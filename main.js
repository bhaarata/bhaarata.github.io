(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, license, repository, author, engines, private, scripts, dependencies, devDependencies, importSort, default */
/***/ (function(module) {

module.exports = {"name":"shapeshifter","version":"1.0.16","license":"Apache-2.0","repository":"https://github.com/alexjlockwood/ShapeShifter","author":"Alex Lockwood <alexjlockwood@gmail.com>","engines":{"node":">=9"},"private":true,"scripts":{"ng":"node --max-old-space-size=8192 ./node_modules/@angular/cli/bin/ng","build":"node --max-old-space-size=8192 ./node_modules/@angular/cli/bin/ng build -c development-beta","start":"npm run build -w","start-beta":"ng serve -c development-beta","build-beta":"node --max-old-space-size=8192 ./node_modules/@angular/cli/bin/ng build -c production-beta","test":"node --max-old-space-size=8192 ./node_modules/@angular/cli/bin/ng test","test-once":"node --max-old-space-size=8192 ./node_modules/@angular/cli/bin/ng test --watch=false --code-coverage --browsers ChromeHeadless","lint":"ng lint","e2e":"ng e2e","deploy":"./scripts/deploy-stable.sh && ./scripts/deploy-beta.sh","deploy-stable":"./scripts/deploy-stable.sh","deploy-beta":"./scripts/deploy-beta.sh","coveralls":"cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","postinstall":"node ./scripts/check-node-version.js","precise-commits":"precise-commits","precommit":"npm run precise-commits"},"dependencies":{"@angular/animations":"^7.0.0","@angular/cdk":"^7.0.0","@angular/common":"^7.0.0","@angular/compiler":"^7.0.0","@angular/core":"^7.0.0","@angular/flex-layout":"^7.0.0-beta.19","@angular/forms":"^7.0.0","@angular/material":"^7.0.0","@angular/platform-browser":"^7.0.0","@angular/platform-browser-dynamic":"^7.0.0","@angular/pwa":"^0.10.2","@angular/router":"^7.0.0","@angular/service-worker":"^7.0.0","@ngrx/store":"^6.1.0","bezier-js":"^2.2.14","bugsnag-angular":"^2.0.1","bugsnag-js":"^4.7.1","core-js":"^2.5.7","element-resize-detector":"^1.1.14","hammerjs":"^2.0.8","jquery":"^3.3.1","jszip":"^3.1.5","local-storage-fallback":"^4.1.1","lodash":"^4.17.10","ngrx-store-logger":"^0.2.2","os-browserify":"^0.3.0","paper":"^0.11.5","polylabel":"^1.0.2","redux-undo":"^1.0.0-beta9-9-7","reselect":"^3.0.1","rxjs":"^6.3.3","stream-browserify":"^2.0.1","svgo":"^1.0.5","tinycolor2":"^1.4.1","tslib":"^1.9.2","zone.js":"^0.8.26"},"devDependencies":{"@angular-devkit/build-angular":"^0.10.2","@angular/cli":"7.0.2","@angular/compiler-cli":"^7.0.0","@angular/language-service":"^7.0.0","@types/hammerjs":"^2.0.35","@types/jasmine":"^2.8.8","@types/jquery":"^3.3.21","@types/lodash":"^4.14.115","@types/node":"10.5.4","@types/polylabel":"^1.0.5","@types/tinycolor2":"^1.4.0","angular-cli-ghpages":"^0.5.2","codelyzer":"^4.3.0","coveralls":"^3.0.1","deep-freeze-strict":"^1.1.1","husky":"^0.14.3","jasmine-core":"^3.1.0","jasmine-jquery":"^2.1.1","jasmine-spec-reporter":"^4.2.1","karma":"^2.0.5","karma-chrome-launcher":"^2.2.0","karma-cli":"~1.0.1","karma-coverage-istanbul-reporter":"^2.0.1","karma-jasmine":"^1.1.2","karma-jasmine-html-reporter":"^1.1.0","karma-verbose-reporter":"0.0.6","node-sass":"^4.10.0","precise-commits":"^1.0.2","prettier":"^1.14.0","protractor":"^5.4.0","redux":"^4.0.0","semver":"^5.5.0","ts-node":"^6.1.0","tslint":"^5.11.0","typescript":"~3.1.3","webdriver-manager":"^12.1.0"},"importSort":{".js, .jsx, .es6, .es":{"parser":"babylon","style":"module"},".ts, .tsx":{"parser":"typescript","style":"module"}}};

/***/ }),

/***/ "./src/$$_lazy_route_resource lazy recursive":
/*!**********************************************************!*\
  !*** ./src/$$_lazy_route_resource lazy namespace object ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = "./src/$$_lazy_route_resource lazy recursive";

/***/ }),

/***/ "./src/app/modules/editor/components/canvas/CanvasLayoutMixin.ts":
/*!***********************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/CanvasLayoutMixin.ts ***!
  \***********************************************************************/
/*! exports provided: CanvasLayoutMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasLayoutMixin", function() { return CanvasLayoutMixin; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);


function CanvasLayoutMixin(Base) {
    if (Base === void 0) { Base = /** @class */ (function () {
        function class_1() {
        }
        return class_1;
    }()); }
    return /** @class */ (function (_super) {
        tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](class_2, _super);
        function class_2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.bounds = { w: 24, h: 24 };
            _this.viewport = { w: 24, h: 24 };
            _this.zoom = 1;
            _this.translation = { tx: 0, ty: 0 };
            return _this;
        }
        Object.defineProperty(class_2.prototype, "cssScale", {
            /**
             * The 'cssScale' represents the number of CSS pixels per SVG viewport pixel.
             */
            get: function () {
                var _a = this.getViewport(), vWidth = _a.w, vHeight = _a.h;
                var _b = this.getBounds(), bWidth = _b.w, bHeight = _b.h;
                var vectorAspectRatio = vWidth / vHeight;
                var containerAspectRatio = bWidth / bHeight;
                if (vectorAspectRatio > containerAspectRatio) {
                    return bWidth / vWidth;
                }
                else {
                    return bHeight / vHeight;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(class_2.prototype, "attrScale", {
            /**
             * The 'attrScale' represents the number of physical pixels per SVG viewport pixel.
             */
            get: function () {
                return this.cssScale * devicePixelRatio;
            },
            enumerable: true,
            configurable: true
        });
        class_2.prototype.getBounds = function () {
            return this.bounds;
        };
        class_2.prototype.getViewport = function () {
            return this.viewport;
        };
        class_2.prototype.getZoom = function () {
            return this.zoom;
        };
        class_2.prototype.getTranslation = function () {
            return this.translation;
        };
        class_2.prototype.setDimensions = function (bounds, viewport) {
            if (!lodash__WEBPACK_IMPORTED_MODULE_1__["isEqual"](this.bounds, bounds) || !lodash__WEBPACK_IMPORTED_MODULE_1__["isEqual"](this.viewport, viewport)) {
                this.bounds = bounds;
                this.viewport = viewport;
                this.onDimensionsChanged(this.bounds, this.viewport);
            }
        };
        class_2.prototype.onDimensionsChanged = function (bounds, viewport) { };
        class_2.prototype.setZoomPan = function (zoom, translation) {
            if (this.zoom !== zoom || !lodash__WEBPACK_IMPORTED_MODULE_1__["isEqual"](this.translation, translation)) {
                this.zoom = zoom;
                this.translation = translation;
                this.onZoomPanChanged(zoom, translation);
            }
        };
        class_2.prototype.onZoomPanChanged = function (zoom, translation) { };
        return class_2;
    }(Base));
}


/***/ }),

/***/ "./src/app/modules/editor/components/canvas/CanvasUtil.ts":
/*!****************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/CanvasUtil.ts ***!
  \****************************************************************/
/*! exports provided: executeCommands */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "executeCommands", function() { return executeCommands; });
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");

/**
 * Executes a series of canvas commands for a given path.
 */
function executeCommands(ctx, commands, transform) {
    ctx.save();
    var a = transform.a, b = transform.b, c = transform.c, d = transform.d, e = transform.e, f = transform.f;
    ctx.transform(a, b, c, d, e, f);
    ctx.beginPath();
    if (commands.length === 1 && commands[0].type !== 'M') {
        ctx.moveTo(commands[0].start.x, commands[0].start.y);
    }
    var previousEndPoint;
    commands.forEach(function (cmd) {
        var start = cmd.start;
        var end = cmd.end;
        if (start && !app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].arePointsEqual(start, previousEndPoint)) {
            // This is to support the case where the list of commands
            // is size fragmented.
            ctx.moveTo(start.x, start.y);
        }
        if (cmd.type === 'M') {
            ctx.moveTo(end.x, end.y);
        }
        else if (cmd.type === 'L') {
            ctx.lineTo(end.x, end.y);
        }
        else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.points[1].x, cmd.points[1].y, cmd.points[2].x, cmd.points[2].y);
        }
        else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.points[1].x, cmd.points[1].y, cmd.points[2].x, cmd.points[2].y, cmd.points[3].x, cmd.points[3].y);
        }
        else if (cmd.type === 'Z') {
            if (app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].arePointsEqual(start, previousEndPoint)) {
                ctx.closePath();
            }
            else {
                // This is to support the case where the list of commands
                // is size fragmented.
                ctx.lineTo(end.x, end.y);
            }
        }
        previousEndPoint = end;
    });
    ctx.restore();
}


/***/ }),

/***/ "./src/app/modules/editor/components/canvas/PairSubPathHelper.ts":
/*!***********************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/PairSubPathHelper.ts ***!
  \***********************************************************************/
/*! exports provided: PairSubPathHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PairSubPathHelper", function() { return PairSubPathHelper; });
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);


// TODO: clean up this class' messy communication w/ the overlay directive
/**
 * Helper class that tracks information during morph subpath mode.
 */
var PairSubPathHelper = /** @class */ (function () {
    function PairSubPathHelper(component) {
        this.component = component;
        this.actionSource = component.actionSource;
        this.actionModeService = component.actionModeService;
    }
    PairSubPathHelper.prototype.onMouseDown = function (mouseDown, isShiftOrMetaPressed) {
        var hitResult = this.performHitTest(mouseDown);
        if (hitResult.isSegmentHit || hitResult.isShapeHit) {
            var hits = hitResult.isShapeHit ? hitResult.shapeHits : hitResult.segmentHits;
            var subIdx = this.findHitSubPath(hits).subIdx;
            this.actionModeService.pairSubPath(subIdx, this.actionSource);
        }
        else if (!isShiftOrMetaPressed) {
            this.actionModeService.setActionMode(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["ActionMode"].Selection);
        }
    };
    PairSubPathHelper.prototype.onMouseMove = function (mouseMove) {
        this.checkForHovers(mouseMove);
        this.component.draw();
    };
    PairSubPathHelper.prototype.onMouseUp = function (mouseUp) {
        this.component.draw();
    };
    PairSubPathHelper.prototype.onMouseLeave = function (mouseLeave) {
        this.component.actionModeService.clearHover();
        this.component.draw();
    };
    PairSubPathHelper.prototype.performHitTest = function (mousePoint) {
        return this.component.performHitTest(mousePoint);
    };
    PairSubPathHelper.prototype.checkForHovers = function (mousePoint) {
        var hitResult = this.performHitTest(mousePoint);
        if (!hitResult.isHit) {
            this.component.actionModeService.clearHover();
        }
        else if (hitResult.isSegmentHit || hitResult.isShapeHit) {
            var hits = hitResult.isShapeHit ? hitResult.shapeHits : hitResult.segmentHits;
            var subIdx = this.findHitSubPath(hits).subIdx;
            this.component.actionModeService.setHover({
                type: app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["HoverType"].SubPath,
                source: this.actionSource,
                subIdx: subIdx,
            });
        }
    };
    PairSubPathHelper.prototype.findHitSubPath = function (hits) {
        var _this = this;
        var infos = hits.map(function (index) {
            var subIdx = index.subIdx;
            return { subIdx: subIdx, subPath: _this.component.activePath.getSubPath(subIdx) };
        });
        var lastSplitIndex = lodash__WEBPACK_IMPORTED_MODULE_1__["findLastIndex"](infos, function (info) { return info.subPath.isSplit(); });
        return infos[lastSplitIndex < 0 ? infos.length - 1 : lastSplitIndex];
    };
    return PairSubPathHelper;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/canvas/SegmentSplitter.ts":
/*!*********************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/SegmentSplitter.ts ***!
  \*********************************************************************/
/*! exports provided: SegmentSplitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SegmentSplitter", function() { return SegmentSplitter; });
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");

// TODO: prefer previous selections over others when performing splits?
// TODO: clean up this class' messy communication w/ the overlay directive
/**
 * Helper class that can be used to split a segment.
 */
var SegmentSplitter = /** @class */ (function () {
    function SegmentSplitter(component) {
        this.component = component;
        this.actionSource = component.actionSource;
        this.actionModeService = component.actionModeService;
    }
    SegmentSplitter.prototype.onMouseDown = function (mouseDown) {
        this.lastKnownMouseLocation = mouseDown;
        this.currProjInfo = this.findProjInfo(mouseDown);
        var activePathLayer = this.component.activePathLayer;
        if (this.currProjInfo) {
            var _a = this.currProjInfo, _b = _a.proj, subIdx = _b.subIdx, cmdIdx = _b.cmdIdx, projection = _b.projection, isEndPt = _a.isEndPt;
            var mode = this.component.actionMode;
            var pathMutator = activePathLayer.pathData.mutate();
            if (mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["ActionMode"].SplitCommands) {
                pathMutator.splitCommand(subIdx, cmdIdx, projection.t);
            }
            else if (mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["ActionMode"].SplitSubPaths) {
                if (!isEndPt) {
                    pathMutator.splitCommand(subIdx, cmdIdx, projection.t);
                }
                pathMutator.splitStrokedSubPath(subIdx, cmdIdx);
            }
            this.component.actionModeService.clearHover();
            this.actionModeService.setSelections([]);
            this.currProjInfo = undefined;
            this.actionModeService.updateActivePathBlock(this.actionSource, pathMutator.build());
            this.component.draw();
            return;
        }
        this.actionModeService.setActionMode(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["ActionMode"].Selection);
    };
    SegmentSplitter.prototype.onMouseMove = function (mouseMove) {
        this.lastKnownMouseLocation = mouseMove;
        this.currProjInfo = this.findProjInfo(mouseMove);
        this.component.draw();
    };
    SegmentSplitter.prototype.onMouseUp = function (mouseUp) {
        this.lastKnownMouseLocation = mouseUp;
        this.component.draw();
    };
    SegmentSplitter.prototype.onMouseLeave = function (mouseLeave) {
        this.lastKnownMouseLocation = mouseLeave;
        this.currProjInfo = undefined;
        this.component.draw();
    };
    SegmentSplitter.prototype.getProjectionOntoPath = function () {
        if (!this.currProjInfo) {
            return undefined;
        }
        return this.currProjInfo.proj;
    };
    SegmentSplitter.prototype.getLastKnownMouseLocation = function () {
        return this.lastKnownMouseLocation;
    };
    SegmentSplitter.prototype.findProjInfo = function (mousePoint) {
        var projInfos = [];
        var hitResult = this.component.performHitTest(mousePoint, { withExtraSegmentPadding: true });
        var isEndPointHit = hitResult.isEndPointHit, isSegmentHit = hitResult.isSegmentHit, endPointHits = hitResult.endPointHits, segmentHits = hitResult.segmentHits;
        if (isEndPointHit) {
            for (var _i = 0, endPointHits_1 = endPointHits; _i < endPointHits_1.length; _i++) {
                var proj = endPointHits_1[_i];
                projInfos.push({ proj: proj, isEndPt: true });
            }
        }
        if (isSegmentHit) {
            for (var _a = 0, segmentHits_1 = segmentHits; _a < segmentHits_1.length; _a++) {
                var proj = segmentHits_1[_a];
                projInfos.push({ proj: proj, isEndPt: false });
            }
        }
        if (!projInfos.length) {
            return undefined;
        }
        projInfos.sort(function (p1, p2) {
            var proj1 = p1.proj, isEndPt1 = p1.isEndPt;
            var proj2 = p2.proj, isEndPt2 = p2.isEndPt;
            if (isEndPt1 !== isEndPt2) {
                return isEndPt1 ? -1 : 1;
            }
            if (proj1.projection.d !== proj2.projection.d) {
                return proj1.projection.d - proj2.projection.d;
            }
            if (proj1.subIdx !== proj2.subIdx) {
                return proj1.subIdx - proj2.subIdx;
            }
            if (proj1.cmdIdx !== proj2.cmdIdx) {
                return proj1.cmdIdx - proj2.cmdIdx;
            }
            return 0;
        });
        return projInfos[0];
    };
    return SegmentSplitter;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/canvas/SelectionHelper.ts":
/*!*********************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/SelectionHelper.ts ***!
  \*********************************************************************/
/*! exports provided: SelectionHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionHelper", function() { return SelectionHelper; });
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);




// TODO: use the 'Dragger' to drag points to different locations
// TODO: clean up this class' messy communication w/ the overlay directive
/**
 * Helper class that tracks information about a user's mouse gesture, allowing
 * for the selection of path points, segments, and shapes.
 */
var SelectionHelper = /** @class */ (function () {
    function SelectionHelper(component) {
        this.component = component;
        this.isDragTriggered_ = false;
        this.actionSource = component.actionSource;
        this.actionModeService = component.actionModeService;
    }
    SelectionHelper.prototype.onMouseDown = function (mouseDown, isShiftOrMetaPressed) {
        this.initialMouseDown = mouseDown;
        this.lastKnownMouseLocation = mouseDown;
        var hitResult = this.performHitTest(mouseDown);
        if (hitResult.isEndPointHit) {
            var _a = this.findHitPoint(hitResult.endPointHits), subIdx = _a.subIdx, cmdIdx = _a.cmdIdx, cmd = _a.cmd;
            if (cmd.isSplitPoint()) {
                // Then a click has occurred on top of a split point.
                // Don't select the point yet because the user might want
                // to drag it to a different location.
                this.currentDraggableSplitIndex = { subIdx: subIdx, cmdIdx: cmdIdx };
            }
            else {
                // Then a click has occurred on top of a non-split point.
            }
            return;
        }
        if (this.component.activePathLayer.isFilled() && hitResult.isSegmentHit) {
            var _b = this.findHitSegment(hitResult.segmentHits), subIdx = _b.subIdx, cmdIdx = _b.cmdIdx, cmd = _b.cmd;
            if (cmd.isSplitSegment()) {
                this.actionModeService.toggleSegmentSelections(this.actionSource, [{ subIdx: subIdx, cmdIdx: cmdIdx }]);
                return;
            }
        }
        if (hitResult.isSegmentHit || hitResult.isShapeHit) {
            var hits = hitResult.isShapeHit ? hitResult.shapeHits : hitResult.segmentHits;
            var subIdx = this.findHitSubPath(hits).subIdx;
            this.actionModeService.toggleSubPathSelection(this.actionSource, subIdx);
        }
        else if (!isShiftOrMetaPressed) {
            // If the mouse down event didn't result in a hit, then
            // clear any existing selections, but only if the user isn't in
            // the middle of selecting multiple points at once.
            this.actionModeService.setSelections([]);
        }
    };
    SelectionHelper.prototype.onMouseMove = function (mouseMove) {
        this.lastKnownMouseLocation = mouseMove;
        if (this.currentDraggableSplitIndex) {
            var distance = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].distance(this.initialMouseDown, mouseMove);
            if (this.component.dragTriggerTouchSlop < distance) {
                this.isDragTriggered_ = true;
            }
        }
        if (this.isDragTriggered_) {
            this.projectionOntoPath = this.calculateProjectionOntoPath(mouseMove, this.currentDraggableSplitIndex.subIdx);
        }
        else {
            this.checkForHovers(mouseMove);
        }
        this.component.draw();
    };
    SelectionHelper.prototype.onMouseUp = function (mouseUp, isShiftOrMetaPressed) {
        this.lastKnownMouseLocation = mouseUp;
        if (this.isDragTriggered_) {
            var projOntoPath = this.projectionOntoPath;
            // TODO: Make this user experience better. There could be other subIdxs that we could use.
            var newSubIdx = projOntoPath.subIdx, newCmdIdx = projOntoPath.cmdIdx;
            var _a = this.currentDraggableSplitIndex, oldSubIdx = _a.subIdx, oldCmdIdx = _a.cmdIdx;
            if (newSubIdx === oldSubIdx) {
                var activeLayer = this.component.activePathLayer;
                var startingPath = activeLayer.pathData;
                var pathMutator = startingPath.mutate();
                // Note that the order is important here, as it preserves the command indices.
                if (newCmdIdx > oldCmdIdx) {
                    pathMutator.splitCommand(newSubIdx, newCmdIdx, projOntoPath.projection.t);
                    pathMutator.unsplitCommand(oldSubIdx, oldCmdIdx);
                }
                else if (newCmdIdx < oldCmdIdx) {
                    pathMutator.unsplitCommand(oldSubIdx, oldCmdIdx);
                    pathMutator.splitCommand(newSubIdx, newCmdIdx, projOntoPath.projection.t);
                }
                else {
                    // Unsplitting will cause the projection t value to change, so recalculate the
                    // projection before the split.
                    // TODO: improve this API somehow... having to set the active layer here is kind of hacky
                    activeLayer.pathData = pathMutator.unsplitCommand(oldSubIdx, oldCmdIdx).build();
                    var tempProjOntoPath = this.calculateProjectionOntoPath(mouseUp);
                    if (oldSubIdx === tempProjOntoPath.subIdx) {
                        pathMutator.splitCommand(tempProjOntoPath.subIdx, tempProjOntoPath.cmdIdx, tempProjOntoPath.projection.t);
                    }
                    else {
                        // If for some reason the projection subIdx changes after the unsplit, we have no
                        // choice but to give up.
                        // TODO: Make this user experience better. There could be other subIdxs that we could use.
                        pathMutator = startingPath.mutate();
                    }
                }
                // Notify the global layer state service about the change and draw.
                // Clear any existing selections and/or hovers as well.
                this.actionModeService.clearHover();
                this.actionModeService.setSelections([]);
                this.reset();
                this.actionModeService.updateActivePathBlock(this.actionSource, pathMutator.build());
            }
        }
        else if (this.currentDraggableSplitIndex) {
            var hitResult = this.performHitTest(mouseUp);
            if (!hitResult.isHit) {
                this.actionModeService.setSelections([]);
            }
            else if (hitResult.isEndPointHit) {
                var _b = this.findHitPoint(hitResult.endPointHits), subIdx = _b.subIdx, cmdIdx = _b.cmdIdx;
                this.actionModeService.togglePointSelection(this.actionSource, subIdx, cmdIdx, isShiftOrMetaPressed);
            }
            else if (hitResult.isSegmentHit || hitResult.isShapeHit) {
                var hits = hitResult.isShapeHit ? hitResult.shapeHits : hitResult.segmentHits;
                var subIdx = this.findHitSubPath(hits).subIdx;
                this.actionModeService.toggleSubPathSelection(this.actionSource, subIdx);
            }
        }
        this.reset();
        this.checkForHovers(mouseUp);
        this.component.draw();
    };
    SelectionHelper.prototype.onMouseLeave = function (mouseLeave) {
        this.lastKnownMouseLocation = mouseLeave;
        this.reset();
        this.component.actionModeService.clearHover();
        this.component.draw();
    };
    SelectionHelper.prototype.performHitTest = function (mousePoint) {
        return this.component.performHitTest(mousePoint);
    };
    SelectionHelper.prototype.reset = function () {
        this.initialMouseDown = undefined;
        this.projectionOntoPath = undefined;
        this.currentDraggableSplitIndex = undefined;
        this.isDragTriggered_ = false;
        this.lastKnownMouseLocation = undefined;
    };
    SelectionHelper.prototype.isDragTriggered = function () {
        return this.isDragTriggered_;
    };
    SelectionHelper.prototype.getDraggableSplitIndex = function () {
        return this.currentDraggableSplitIndex;
    };
    SelectionHelper.prototype.getProjectionOntoPath = function () {
        return this.projectionOntoPath;
    };
    SelectionHelper.prototype.getLastKnownMouseLocation = function () {
        return this.lastKnownMouseLocation;
    };
    SelectionHelper.prototype.checkForHovers = function (mousePoint) {
        if (this.currentDraggableSplitIndex) {
            // Don't broadcast new hover events if a point has been selected.
            return;
        }
        var hitResult = this.performHitTest(mousePoint);
        if (!hitResult.isHit) {
            this.component.actionModeService.clearHover();
            return;
        }
        if (hitResult.isEndPointHit) {
            var _a = this.findHitPoint(hitResult.endPointHits), subIdx = _a.subIdx, cmdIdx = _a.cmdIdx;
            this.component.actionModeService.setHover({
                type: app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["HoverType"].Point,
                source: this.actionSource,
                subIdx: subIdx,
                cmdIdx: cmdIdx,
            });
            return;
        }
        if (hitResult.isSegmentHit) {
            if (this.component.activePathLayer.isFilled()) {
                var _b = this.findHitSegment(hitResult.segmentHits), subIdx = _b.subIdx, cmdIdx = _b.cmdIdx;
                if (this.component.activePath.getCommand(subIdx, cmdIdx).isSplitSegment()) {
                    this.component.actionModeService.setHover({
                        type: app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["HoverType"].Segment,
                        source: this.actionSource,
                        subIdx: subIdx,
                        cmdIdx: cmdIdx,
                    });
                    return;
                }
            }
            else if (this.component.activePathLayer.isStroked()) {
                var subIdx = this.findHitSegment(hitResult.segmentHits).subIdx;
                this.component.actionModeService.setHover({
                    type: app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["HoverType"].SubPath,
                    source: this.actionSource,
                    subIdx: subIdx,
                });
                return;
            }
        }
        if (hitResult.isShapeHit && this.component.activePathLayer.isFilled()) {
            var subIdx = this.findHitSubPath(hitResult.shapeHits).subIdx;
            this.component.actionModeService.setHover({
                type: app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["HoverType"].SubPath,
                source: this.actionSource,
                subIdx: subIdx,
            });
            return;
        }
    };
    SelectionHelper.prototype.findHitSubPath = function (hits) {
        var _this = this;
        var infos = hits.map(function (index) {
            var subIdx = index.subIdx;
            return { subIdx: subIdx, subPath: _this.component.activePath.getSubPath(subIdx) };
        });
        var lastSplitIndex = lodash__WEBPACK_IMPORTED_MODULE_3__["findLastIndex"](infos, function (info) { return info.subPath.isSplit(); });
        return infos[lastSplitIndex < 0 ? infos.length - 1 : lastSplitIndex];
    };
    SelectionHelper.prototype.findHitSegment = function (hits) {
        var _this = this;
        var infos = hits.map(function (index) {
            var subIdx = index.subIdx, cmdIdx = index.cmdIdx;
            return { subIdx: subIdx, cmdIdx: cmdIdx, cmd: _this.component.activePath.getCommand(subIdx, cmdIdx) };
        });
        var lastSplitIndex = lodash__WEBPACK_IMPORTED_MODULE_3__["findLastIndex"](infos, function (info) { return info.cmd.isSplitSegment(); });
        return infos[lastSplitIndex < 0 ? infos.length - 1 : lastSplitIndex];
    };
    SelectionHelper.prototype.findHitPoint = function (hits) {
        var _this = this;
        var infos = hits.map(function (index) {
            var subIdx = index.subIdx, cmdIdx = index.cmdIdx;
            return { subIdx: subIdx, cmdIdx: cmdIdx, cmd: _this.component.activePath.getCommand(subIdx, cmdIdx) };
        });
        var lastSplitIndex = lodash__WEBPACK_IMPORTED_MODULE_3__["findLastIndex"](infos, function (info) { return info.cmd.isSplitPoint(); });
        return infos[lastSplitIndex < 0 ? infos.length - 1 : lastSplitIndex];
    };
    /**
     * Calculates the projection onto the path with the specified path ID.
     * The resulting projection is our way of determining the on-curve point
     * closest to the specified off-curve mouse point.
     */
    SelectionHelper.prototype.calculateProjectionOntoPath = function (mousePoint, restrictToSubIdx) {
        var canvasToLayerMatrix = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["LayerUtil"].getCanvasTransformForLayer(this.component.vectorLayer, this.component.activePathLayer.id).invert();
        if (!canvasToLayerMatrix) {
            // Do nothing if matrix is non-invertible.
            return undefined;
        }
        var transformedMousePoint = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].transformPoint(mousePoint, canvasToLayerMatrix);
        var projInfo = this.component.activePath.project(transformedMousePoint, restrictToSubIdx);
        if (!projInfo) {
            return undefined;
        }
        return {
            subIdx: projInfo.subIdx,
            cmdIdx: projInfo.cmdIdx,
            projection: projInfo.projection,
        };
    };
    return SelectionHelper;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/canvas/ShapeSplitter.ts":
/*!*******************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/ShapeSplitter.ts ***!
  \*******************************************************************/
/*! exports provided: ShapeSplitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeSplitter", function() { return ShapeSplitter; });
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);


// TODO: prefer previous selections over others when performing splits?
// TODO: clean up this class' messy communication w/ the overlay directive
/**
 * Helper class that can be used to split a filled subpath.
 */
var ShapeSplitter = /** @class */ (function () {
    function ShapeSplitter(component) {
        this.component = component;
        this.initProjInfos = [];
        this.finalProjInfos = [];
        this.actionModeService = component.actionModeService;
    }
    ShapeSplitter.prototype.onMouseDown = function (mouseDown) {
        this.initProjInfos = [];
        this.finalProjInfos = [];
        this.lastKnownMouseLocation = mouseDown;
        this.hitResult = this.performHitTest(mouseDown);
        var _a = this.hitResult, isEndPointHit = _a.isEndPointHit, isSegmentHit = _a.isSegmentHit, endPointHits = _a.endPointHits, segmentHits = _a.segmentHits;
        if (isEndPointHit || isSegmentHit) {
            for (var _i = 0, endPointHits_1 = endPointHits; _i < endPointHits_1.length; _i++) {
                var proj = endPointHits_1[_i];
                this.initProjInfos.push({ proj: proj, isEndPt: true });
            }
            for (var _b = 0, segmentHits_1 = segmentHits; _b < segmentHits_1.length; _b++) {
                var proj = segmentHits_1[_b];
                this.initProjInfos.push({ proj: proj, isEndPt: false });
            }
            this.component.draw();
            return;
        }
        this.actionModeService.setActionMode(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["ActionMode"].Selection);
    };
    ShapeSplitter.prototype.onMouseMove = function (mouseMove) {
        this.finalProjInfos = [];
        this.lastKnownMouseLocation = mouseMove;
        this.hitResult = this.performHitTest(mouseMove);
        if (!this.initProjInfos.length) {
            this.component.draw();
            return;
        }
        this.populateFinalProjInfos(mouseMove);
        this.component.draw();
    };
    ShapeSplitter.prototype.onMouseUp = function (mouseUp) {
        this.finalProjInfos = [];
        this.lastKnownMouseLocation = mouseUp;
        if (!this.initProjInfos.length) {
            this.reset();
            this.component.draw();
            return;
        }
        this.populateFinalProjInfos(mouseUp);
        var sortProjInfosFn = function (projInfos) {
            projInfos.sort(function (p1, p2) {
                var proj1 = p1.proj, isEndPt1 = p1.isEndPt;
                var proj2 = p2.proj, isEndPt2 = p2.isEndPt;
                if (isEndPt1 !== isEndPt2) {
                    // Prefer snapping to existing end points first...
                    return isEndPt1 ? -1 : 1;
                }
                if (proj1.projection.d !== proj2.projection.d) {
                    // Then take into account the distance to the new point...
                    return proj1.projection.d - proj2.projection.d;
                }
                if (proj1.subIdx !== proj2.subIdx) {
                    // Then prefer sub paths with higher z-orders...
                    return proj1.subIdx - proj2.subIdx;
                }
                if (proj1.cmdIdx !== proj2.cmdIdx) {
                    // And then finally commands with higher z-orders.
                    return proj1.cmdIdx - proj2.cmdIdx;
                }
                return 0;
            });
        };
        sortProjInfosFn(this.initProjInfos);
        sortProjInfosFn(this.finalProjInfos);
        var initProjInfo;
        var finalProjInfo;
        for (var _i = 0, _a = this.initProjInfos; _i < _a.length; _i++) {
            var p1 = _a[_i];
            for (var _b = 0, _c = this.finalProjInfos; _b < _c.length; _b++) {
                var p2 = _c[_b];
                var _d = p1.proj, subIdx1 = _d.subIdx, cmdIdx1 = _d.cmdIdx;
                var _e = p2.proj, subIdx2 = _e.subIdx, cmdIdx2 = _e.cmdIdx;
                if (subIdx1 === subIdx2) {
                    if (cmdIdx1 === cmdIdx2) {
                        continue;
                    }
                    initProjInfo = p1;
                    finalProjInfo = p2;
                    break;
                }
            }
            if (initProjInfo && finalProjInfo) {
                break;
            }
        }
        if (initProjInfo && finalProjInfo) {
            var activeLayer = this.component.activePathLayer;
            var pathMutator = activeLayer.pathData.mutate();
            var _f = initProjInfo.proj, initSubIdx = _f.subIdx, initCmdIdx = _f.cmdIdx, isInitEndPt = initProjInfo.isEndPt;
            var _g = finalProjInfo.proj, finalSubIdx = _g.subIdx, finalCmdIdx = _g.cmdIdx, isFinalEndPt = finalProjInfo.isEndPt;
            var lastCmdOffset = 0;
            if (!isInitEndPt || !isFinalEndPt) {
                if (initCmdIdx > finalCmdIdx) {
                    if (!isInitEndPt) {
                        pathMutator.splitCommand(initSubIdx, initCmdIdx, initProjInfo.proj.projection.t);
                        if (!isFinalEndPt) {
                            lastCmdOffset++;
                        }
                    }
                    if (!isFinalEndPt) {
                        pathMutator.splitCommand(finalSubIdx, finalCmdIdx, finalProjInfo.proj.projection.t);
                        if (isInitEndPt) {
                            lastCmdOffset++;
                        }
                    }
                }
                else {
                    if (!isFinalEndPt) {
                        pathMutator.splitCommand(finalSubIdx, finalCmdIdx, finalProjInfo.proj.projection.t);
                        if (!isInitEndPt) {
                            lastCmdOffset++;
                        }
                    }
                    if (!isInitEndPt) {
                        pathMutator.splitCommand(initSubIdx, initCmdIdx, initProjInfo.proj.projection.t);
                        if (isFinalEndPt) {
                            lastCmdOffset++;
                        }
                    }
                }
            }
            this.component.actionModeService.clearHover();
            this.actionModeService.setSelections([]);
            this.reset();
            // TODO: some bugs with this path: M 0 20 v -16 h 20 v 2 h -12 v 2 h 12 v 2 h -12 Z
            // TODO: how should we deal with collinear intersections? (i.e. drawing a line across the same line)
            var startingCmdIdx = initCmdIdx > finalCmdIdx ? finalCmdIdx : initCmdIdx;
            var endingCmdIdx = initCmdIdx > finalCmdIdx ? initCmdIdx + lastCmdOffset : finalCmdIdx + lastCmdOffset;
            this.actionModeService.updateActivePathBlock(this.component.actionSource, pathMutator.splitFilledSubPath(initSubIdx, startingCmdIdx, endingCmdIdx).build());
        }
        this.reset();
        this.component.draw();
    };
    ShapeSplitter.prototype.onMouseLeave = function (mouseLeave) {
        this.finalProjInfos = [];
        this.lastKnownMouseLocation = mouseLeave;
        this.hitResult = this.performHitTest(mouseLeave);
        if (!this.initProjInfos.length) {
            return;
        }
        this.reset();
        this.component.draw();
    };
    ShapeSplitter.prototype.populateFinalProjInfos = function (mousePoint) {
        var _a = this.hitResult, isEndPointHit = _a.isEndPointHit, isSegmentHit = _a.isSegmentHit, endPointHits = _a.endPointHits, segmentHits = _a.segmentHits;
        if (isEndPointHit || isSegmentHit) {
            for (var _i = 0, endPointHits_2 = endPointHits; _i < endPointHits_2.length; _i++) {
                var proj = endPointHits_2[_i];
                this.finalProjInfos.push({ proj: proj, isEndPt: true });
            }
            for (var _b = 0, segmentHits_2 = segmentHits; _b < segmentHits_2.length; _b++) {
                var proj = segmentHits_2[_b];
                this.finalProjInfos.push({ proj: proj, isEndPt: false });
            }
            var allowedSubIdxs_1 = new Set(this.initProjInfos.map(function (projInfo) { return projInfo.proj.subIdx; }));
            lodash__WEBPACK_IMPORTED_MODULE_1__["remove"](this.finalProjInfos, function (projInfo) { return !allowedSubIdxs_1.has(projInfo.proj.subIdx); });
        }
    };
    ShapeSplitter.prototype.performHitTest = function (mousePoint) {
        return this.component.performHitTest(mousePoint, { withExtraSegmentPadding: true });
    };
    ShapeSplitter.prototype.reset = function () {
        this.initProjInfos = [];
        this.finalProjInfos = [];
        this.hitResult = undefined;
        this.lastKnownMouseLocation = undefined;
    };
    ShapeSplitter.prototype.getCurrentProjectionOntoPath = function () {
        if (!this.hitResult) {
            return undefined;
        }
        var _a = this.hitResult, isEndPointHit = _a.isEndPointHit, isSegmentHit = _a.isSegmentHit, endPointHits = _a.endPointHits, segmentHits = _a.segmentHits;
        if (isEndPointHit) {
            return lodash__WEBPACK_IMPORTED_MODULE_1__["last"](endPointHits);
        }
        if (isSegmentHit) {
            return lodash__WEBPACK_IMPORTED_MODULE_1__["last"](segmentHits);
        }
        return undefined;
    };
    ShapeSplitter.prototype.getInitialProjectionOntoPath = function () {
        if (!this.initProjInfos.length) {
            return undefined;
        }
        return this.initProjInfos[0].proj;
    };
    ShapeSplitter.prototype.getFinalProjectionOntoPath = function () {
        if (!this.finalProjInfos.length) {
            return undefined;
        }
        return this.finalProjInfos[0].proj;
    };
    ShapeSplitter.prototype.willFinalProjectionOntoPathCreateSplitPoint = function () {
        if (!this.finalProjInfos.length) {
            return true;
        }
        return !this.finalProjInfos[0].isEndPt;
    };
    ShapeSplitter.prototype.getLastKnownMouseLocation = function () {
        return this.lastKnownMouseLocation;
    };
    return ShapeSplitter;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/canvas/canvas.component.html":
/*!************************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/canvas.component.html ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"app-canvas-container\"\n  (click)=\"$event.stopPropagation()\">\n  <canvas appCanvasRuler\n    class=\"canvas-ruler orientation-horizontal\"\n    [orientation]=\"'horizontal'\">\n  </canvas>\n  <canvas appCanvasRuler\n    class=\"canvas-ruler orientation-vertical\"\n    [orientation]=\"'vertical'\">\n  </canvas>\n  <div appCanvasContainer\n    class=\"canvas-container\">\n    <canvas appCanvasLayers\n      *ngIf=\"!this.IS_BETA || (this.isActionMode$ | async) === true\"\n      class=\"rendering-canvas mat-elevation-z4\"\n      [actionSource]=\"this.actionSource\">\n    </canvas>\n    <canvas appCanvasOverlay\n      *ngIf=\"!this.IS_BETA || (this.isActionMode$ | async) === true\"\n      class=\"overlay-canvas\"\n      [actionSource]=\"this.actionSource\">\n    </canvas>\n    <canvas appCanvasPaper\n      *ngIf=\"this.IS_BETA && (this.isActionMode$ | async) === false\"\n      class=\"paper-canvas mat-elevation-z4\"\n      [actionSource]=\"this.actionSource\">\n    </canvas>\n  </div>\n</div>"

/***/ }),

/***/ "./src/app/modules/editor/components/canvas/canvas.component.scss":
/*!************************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/canvas.component.scss ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".app-canvas-container {\n  position: relative; }\n  .app-canvas-container .canvas-ruler {\n    position: absolute;\n    transition: opacity 0.15s ease, visibility 0s linear 0.15s;\n    opacity: 0;\n    visibility: hidden; }\n  .app-canvas-container:hover .canvas-ruler {\n    transition: opacity 0.15s ease;\n    opacity: 1;\n    visibility: visible; }\n  .app-canvas-container .canvas-container {\n    position: relative; }\n  .app-canvas-container .canvas-container canvas.rendering-canvas {\n      position: absolute;\n      z-index: 1; }\n  .app-canvas-container .canvas-container canvas.overlay-canvas {\n      position: absolute;\n      background-color: transparent;\n      z-index: 2; }\n  .app-canvas-container .canvas-container canvas.paper-canvas {\n      position: absolute;\n      background-color: transparent;\n      z-index: 3; }\n  .app-canvas-container .orientation-horizontal {\n    left: -12px;\n    top: -32px;\n    height: 32px; }\n  .app-canvas-container .orientation-vertical {\n    top: -12px;\n    left: -32px;\n    width: 32px; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL2NhbnZhcy9jYW52YXMuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxtQkFBa0IsRUF3Q25CO0VBekNEO0lBR0ksbUJBQWtCO0lBQ2xCLDJEQUEwRDtJQUMxRCxXQUFVO0lBQ1YsbUJBQWtCLEVBQ25CO0VBUEg7SUFTSSwrQkFBOEI7SUFDOUIsV0FBVTtJQUNWLG9CQUFtQixFQUNwQjtFQVpIO0lBY0ksbUJBQWtCLEVBZW5CO0VBN0JIO01BZ0JNLG1CQUFrQjtNQUNsQixXQUFVLEVBQ1g7RUFsQkw7TUFvQk0sbUJBQWtCO01BQ2xCLDhCQUE2QjtNQUM3QixXQUFVLEVBQ1g7RUF2Qkw7TUF5Qk0sbUJBQWtCO01BQ2xCLDhCQUE2QjtNQUM3QixXQUFVLEVBQ1g7RUE1Qkw7SUFnQ0ksWUFBVztJQUNYLFdBSGU7SUFJZixhQUplLEVBS2hCO0VBbkNIO0lBcUNJLFdBQVU7SUFDVixZQVJlO0lBU2YsWUFUZSxFQVVoQiIsImZpbGUiOiJzcmMvYXBwL21vZHVsZXMvZWRpdG9yL2NvbXBvbmVudHMvY2FudmFzL2NhbnZhcy5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi5hcHAtY2FudmFzLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgLmNhbnZhcy1ydWxlciB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xNXMgZWFzZSwgdmlzaWJpbGl0eSAwcyBsaW5lYXIgMC4xNXM7XG4gICAgb3BhY2l0eTogMDtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbiAgJjpob3ZlciAuY2FudmFzLXJ1bGVyIHtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMTVzIGVhc2U7XG4gICAgb3BhY2l0eTogMTtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICB9XG4gIC5jYW52YXMtY29udGFpbmVyIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgY2FudmFzLnJlbmRlcmluZy1jYW52YXMge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgei1pbmRleDogMTtcbiAgICB9XG4gICAgY2FudmFzLm92ZXJsYXktY2FudmFzIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgei1pbmRleDogMjtcbiAgICB9XG4gICAgY2FudmFzLnBhcGVyLWNhbnZhcyB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgIHotaW5kZXg6IDM7XG4gICAgfVxuICB9XG4gICRydWxlcldpZHRoOiAzMnB4O1xuICAub3JpZW50YXRpb24taG9yaXpvbnRhbCB7XG4gICAgbGVmdDogLTEycHg7XG4gICAgdG9wOiAtJHJ1bGVyV2lkdGg7XG4gICAgaGVpZ2h0OiAkcnVsZXJXaWR0aDtcbiAgfVxuICAub3JpZW50YXRpb24tdmVydGljYWwge1xuICAgIHRvcDogLTEycHg7XG4gICAgbGVmdDogLSRydWxlcldpZHRoO1xuICAgIHdpZHRoOiAkcnVsZXJXaWR0aDtcbiAgfVxufVxuIl19 */"

/***/ }),

/***/ "./src/app/modules/editor/components/canvas/canvas.component.ts":
/*!**********************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/canvas.component.ts ***!
  \**********************************************************************/
/*! exports provided: CanvasComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasComponent", function() { return CanvasComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/mixins */ "./src/app/modules/editor/scripts/mixins/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store/actionmode/selectors */ "./src/app/modules/editor/store/actionmode/selectors.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/modules/editor/store/paper/selectors */ "./src/app/modules/editor/store/paper/selectors.ts");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _canvascontainer_directive__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./canvascontainer.directive */ "./src/app/modules/editor/components/canvas/canvascontainer.directive.ts");
/* harmony import */ var _canvaslayers_directive__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./canvaslayers.directive */ "./src/app/modules/editor/components/canvas/canvaslayers.directive.ts");
/* harmony import */ var _CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./CanvasLayoutMixin */ "./src/app/modules/editor/components/canvas/CanvasLayoutMixin.ts");
/* harmony import */ var _canvasoverlay_directive__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./canvasoverlay.directive */ "./src/app/modules/editor/components/canvas/canvasoverlay.directive.ts");
/* harmony import */ var _canvaspaper_directive__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./canvaspaper.directive */ "./src/app/modules/editor/components/canvas/canvaspaper.directive.ts");
/* harmony import */ var _canvasruler_directive__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./canvasruler.directive */ "./src/app/modules/editor/components/canvas/canvasruler.directive.ts");





















// Canvas margin in css pixels.
var CANVAS_MARGIN = 36;
var CanvasComponent = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CanvasComponent, _super);
    function CanvasComponent(elementRef, store, themeService) {
        var _this = _super.call(this) || this;
        _this.store = store;
        _this.themeService = themeService;
        _this.IS_BETA = environments_environment__WEBPACK_IMPORTED_MODULE_10__["environment"].beta;
        _this.$element = jquery__WEBPACK_IMPORTED_MODULE_11__(elementRef.nativeElement);
        return _this;
    }
    CanvasComponent.prototype.ngOnInit = function () {
        this.isActionMode$ = this.store.select(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_7__["isActionMode"]);
    };
    CanvasComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var activeViewport$ = this.store.select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_8__["getVectorLayer"]).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["map"])(function (vl) { return ({ w: vl.width, h: vl.height }); }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["distinctUntilChanged"])(lodash__WEBPACK_IMPORTED_MODULE_12__["isEqual"]));
        this.registerSubscription(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["combineLatest"])(this.canvasBounds$, activeViewport$).subscribe(function (_a) {
            var bounds = _a[0], viewport = _a[1];
            var w = Math.max(1, bounds.w - CANVAS_MARGIN * 2);
            var h = Math.max(1, bounds.h - CANVAS_MARGIN * 2);
            _this.setDimensions({ w: w, h: h }, viewport);
        }));
        this.registerSubscription(this.store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_9__["getZoomPanInfo"]).subscribe(function (info) {
            _this.setZoomPan(info.zoom, info.translation);
        }));
    };
    // @Override
    CanvasComponent.prototype.onDimensionsChanged = function (bounds, viewport) {
        var directives = this.canvasContainer.toArray().concat(this.canvasLayers.toArray(), this.canvasOverlay.toArray(), this.canvasPaper.toArray(), this.canvasRulers.toArray());
        directives.forEach(function (d) { return d.setDimensions(bounds, viewport); });
    };
    // @Override
    CanvasComponent.prototype.onZoomPanChanged = function (zoom, translation) {
        var directives = this.canvasContainer.toArray().concat(this.canvasLayers.toArray(), this.canvasOverlay.toArray(), this.canvasPaper.toArray(), this.canvasRulers.toArray());
        directives.forEach(function (d) { return d.setZoomPan(zoom, translation); });
    };
    CanvasComponent.prototype.onMouseDown = function (event) {
        this.canvasOverlay.forEach(function (c) { return c.onMouseDown(event); });
        this.showRuler(event);
    };
    CanvasComponent.prototype.onMouseMove = function (event) {
        this.canvasOverlay.forEach(function (c) { return c.onMouseMove(event); });
        this.showRuler(event);
    };
    CanvasComponent.prototype.onMouseUp = function (event) {
        this.canvasOverlay.forEach(function (c) { return c.onMouseUp(event); });
        this.showRuler(event);
    };
    CanvasComponent.prototype.onMouseLeave = function (event) {
        this.canvasOverlay.forEach(function (c) { return c.onMouseLeave(event); });
        this.hideRuler();
    };
    CanvasComponent.prototype.showRuler = function (event) {
        var canvasOffset = this.$element.offset();
        var zoom = this.getZoom();
        var _a = this.getTranslation(), tx = _a.tx, ty = _a.ty;
        var point = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["MathUtil"].transformPoint({ x: event.pageX - canvasOffset.left, y: event.pageY - canvasOffset.top }, new app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["Matrix"](zoom, 0, 0, zoom, tx, ty).invert());
        var x = point.x / Math.max(1, this.cssScale);
        var y = point.y / Math.max(1, this.cssScale);
        this.canvasRulers.forEach(function (r) { return r.showMouse({ x: lodash__WEBPACK_IMPORTED_MODULE_12__["round"](x), y: lodash__WEBPACK_IMPORTED_MODULE_12__["round"](y) }); });
    };
    CanvasComponent.prototype.hideRuler = function () {
        this.canvasRulers.forEach(function (r) { return r.hideMouse(); });
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"])(_canvascontainer_directive__WEBPACK_IMPORTED_MODULE_15__["CanvasContainerDirective"]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
    ], CanvasComponent.prototype, "canvasContainer", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"])(_canvaslayers_directive__WEBPACK_IMPORTED_MODULE_16__["CanvasLayersDirective"]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
    ], CanvasComponent.prototype, "canvasLayers", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"])(_canvasoverlay_directive__WEBPACK_IMPORTED_MODULE_18__["CanvasOverlayDirective"]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
    ], CanvasComponent.prototype, "canvasOverlay", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"])(_canvaspaper_directive__WEBPACK_IMPORTED_MODULE_19__["CanvasPaperDirective"]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
    ], CanvasComponent.prototype, "canvasPaper", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"])(_canvasruler_directive__WEBPACK_IMPORTED_MODULE_20__["CanvasRulerDirective"]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
    ], CanvasComponent.prototype, "canvasRulers", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Number)
    ], CanvasComponent.prototype, "actionSource", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", rxjs__WEBPACK_IMPORTED_MODULE_13__["Observable"])
    ], CanvasComponent.prototype, "canvasBounds$", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('mousedown', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [MouseEvent]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], CanvasComponent.prototype, "onMouseDown", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('mousemove', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [MouseEvent]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], CanvasComponent.prototype, "onMouseMove", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('mouseup', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [MouseEvent]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], CanvasComponent.prototype, "onMouseUp", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('mouseleave', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [MouseEvent]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], CanvasComponent.prototype, "onMouseLeave", null);
    CanvasComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-canvas',
            template: __webpack_require__(/*! ./canvas.component.html */ "./src/app/modules/editor/components/canvas/canvas.component.html"),
            styles: [__webpack_require__(/*! ./canvas.component.scss */ "./src/app/modules/editor/components/canvas/canvas.component.scss")],
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
            app_modules_editor_store__WEBPACK_IMPORTED_MODULE_6__["Store"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_5__["ThemeService"]])
    ], CanvasComponent);
    return CanvasComponent;
}(Object(_CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_17__["CanvasLayoutMixin"])(Object(app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_4__["DestroyableMixin"])())));



/***/ }),

/***/ "./src/app/modules/editor/components/canvas/canvascontainer.directive.ts":
/*!*******************************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/canvascontainer.directive.ts ***!
  \*******************************************************************************/
/*! exports provided: CanvasContainerDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasContainerDirective", function() { return CanvasContainerDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CanvasLayoutMixin */ "./src/app/modules/editor/components/canvas/CanvasLayoutMixin.ts");




/**
 * Directive that resizes the canvas container when necessary.
 */
var CanvasContainerDirective = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CanvasContainerDirective, _super);
    function CanvasContainerDirective(elementRef) {
        var _this = _super.call(this) || this;
        _this.element = jquery__WEBPACK_IMPORTED_MODULE_2__(elementRef.nativeElement);
        return _this;
    }
    // @Override
    CanvasContainerDirective.prototype.onDimensionsChanged = function (bounds, viewport) {
        var w = viewport.w, h = viewport.h;
        this.element.attr({ width: w * this.attrScale, height: h * this.attrScale });
        this.element.css({ width: w * this.cssScale, height: h * this.cssScale });
    };
    CanvasContainerDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({ selector: '[appCanvasContainer]' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]])
    ], CanvasContainerDirective);
    return CanvasContainerDirective;
}(Object(_CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_3__["CanvasLayoutMixin"])()));



/***/ }),

/***/ "./src/app/modules/editor/components/canvas/canvaslayers.directive.ts":
/*!****************************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/canvaslayers.directive.ts ***!
  \****************************************************************************/
/*! exports provided: CanvasLayersDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasLayersDirective", function() { return CanvasLayersDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/scripts/mixins */ "./src/app/modules/editor/scripts/mixins/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/modules/editor/store/actionmode/selectors */ "./src/app/modules/editor/store/actionmode/selectors.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./CanvasLayoutMixin */ "./src/app/modules/editor/components/canvas/CanvasLayoutMixin.ts");
/* harmony import */ var _CanvasUtil__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./CanvasUtil */ "./src/app/modules/editor/components/canvas/CanvasUtil.ts");















/**
 * Directive that draws the current vector layer to the canvas.
 */
var CanvasLayersDirective = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CanvasLayersDirective, _super);
    function CanvasLayersDirective(elementRef, playbackService, store) {
        var _this = _super.call(this) || this;
        _this.playbackService = playbackService;
        _this.store = store;
        _this.hiddenLayerIds = new Set();
        _this.$renderingCanvas = jquery__WEBPACK_IMPORTED_MODULE_10__(elementRef.nativeElement);
        _this.$offscreenCanvas = jquery__WEBPACK_IMPORTED_MODULE_10__(document.createElement('canvas'));
        return _this;
    }
    CanvasLayersDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated) {
            // Preview canvas specific setup.
            this.registerSubscription(Object(rxjs__WEBPACK_IMPORTED_MODULE_11__["combineLatest"])(
            // TODO: don't think this is necessary anymore? only need to query playback service now?
            Object(rxjs__WEBPACK_IMPORTED_MODULE_11__["merge"])(this.playbackService.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__["map"])(function (event) { return event.vl; })), this.store.select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_9__["getVectorLayer"])), this.store.select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_9__["getHiddenLayerIds"])).subscribe(function (_a) {
                var vectorLayer = _a[0], hiddenLayerIds = _a[1];
                _this.vectorLayer = vectorLayer;
                _this.hiddenLayerIds = hiddenLayerIds;
                _this.draw();
            }));
        }
        else {
            // Start & end canvas specific setup.
            var actionModeSelector = this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From ? app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_8__["getActionModeStartState"] : app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_8__["getActionModeEndState"];
            this.registerSubscription(this.store.select(actionModeSelector).subscribe(function (_a) {
                var vectorLayer = _a.vectorLayer, hiddenLayerIds = _a.hiddenLayerIds;
                _this.vectorLayer = vectorLayer;
                _this.hiddenLayerIds = hiddenLayerIds;
                _this.draw();
            }));
        }
    };
    Object.defineProperty(CanvasLayersDirective.prototype, "renderingCtx", {
        get: function () {
            return this.$renderingCanvas.get(0).getContext('2d');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasLayersDirective.prototype, "offscreenCtx", {
        get: function () {
            return this.$offscreenCanvas.get(0).getContext('2d');
        },
        enumerable: true,
        configurable: true
    });
    // @Override
    CanvasLayersDirective.prototype.onDimensionsChanged = function (bounds, viewport) {
        var _this = this;
        var _a = this.getViewport(), w = _a.w, h = _a.h;
        [this.$renderingCanvas, this.$offscreenCanvas].forEach(function (canvas) {
            canvas.attr({ width: w * _this.attrScale, height: h * _this.attrScale });
            canvas.css({ width: w * _this.cssScale, height: h * _this.cssScale });
        });
        this.draw();
    };
    CanvasLayersDirective.prototype.draw = function () {
        var _this = this;
        if (!this.vectorLayer) {
            return;
        }
        // Scale the canvas so that everything from this point forward is drawn
        // in terms of the SVG's viewport coordinates.
        var setupCtxWithViewportCoordsFn = function (ctx) {
            ctx.scale(_this.attrScale, _this.attrScale);
            var _a = _this.getViewport(), w = _a.w, h = _a.h;
            ctx.clearRect(0, 0, w, h);
        };
        this.renderingCtx.save();
        setupCtxWithViewportCoordsFn(this.renderingCtx);
        if (this.vectorLayer.canvasColor) {
            this.renderingCtx.fillStyle = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__["ColorUtil"].androidToCssRgbaColor(this.vectorLayer.canvasColor);
            this.renderingCtx.fillRect(0, 0, this.vectorLayer.width, this.vectorLayer.height);
        }
        var currentAlpha = this.vectorLayer ? this.vectorLayer.alpha : 1;
        if (currentAlpha < 1) {
            this.offscreenCtx.save();
            setupCtxWithViewportCoordsFn(this.offscreenCtx);
        }
        // If the canvas is disabled, draw the layer to an offscreen canvas
        // so that we can draw it translucently w/o affecting the rest of
        // the layer's appearance.
        var layerCtx = currentAlpha < 1 ? this.offscreenCtx : this.renderingCtx;
        this.drawLayer(this.vectorLayer, this.vectorLayer, layerCtx);
        if (currentAlpha < 1) {
            this.renderingCtx.save();
            this.renderingCtx.globalAlpha = currentAlpha;
            // Bring the canvas back to its original coordinates before
            // drawing the offscreen canvas contents.
            this.renderingCtx.scale(1 / this.attrScale, 1 / this.attrScale);
            this.renderingCtx.drawImage(this.offscreenCtx.canvas, 0, 0);
            this.renderingCtx.restore();
            this.offscreenCtx.restore();
        }
        this.renderingCtx.restore();
    };
    CanvasLayersDirective.prototype.drawLayer = function (vl, layer, ctx) {
        var _this = this;
        if (this.hiddenLayerIds.has(layer.id)) {
            return;
        }
        if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["ClipPathLayer"]) {
            this.drawClipPathLayer(vl, layer, ctx);
        }
        else if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["PathLayer"]) {
            this.drawPathLayer(vl, layer, ctx);
        }
        else {
            ctx.save();
            layer.children.forEach(function (child) { return _this.drawLayer(vl, child, ctx); });
            ctx.restore();
        }
    };
    CanvasLayersDirective.prototype.drawClipPathLayer = function (vl, layer, ctx) {
        if (!layer.pathData || !layer.pathData.getCommands().length) {
            return;
        }
        var flattenedTransform = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformForLayer(vl, layer.id);
        _CanvasUtil__WEBPACK_IMPORTED_MODULE_14__["executeCommands"](ctx, layer.pathData.getCommands(), flattenedTransform);
        ctx.clip();
    };
    CanvasLayersDirective.prototype.drawPathLayer = function (vl, layer, ctx) {
        if (!layer.pathData || !layer.pathData.getCommands().length) {
            return;
        }
        var layerToCanvasMatrix = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformForLayer(vl, layer.id);
        var canvasToLayerMatrix = layerToCanvasMatrix.invert();
        if (!canvasToLayerMatrix) {
            // Do nothing if matrix is non-invertible.
            return;
        }
        ctx.save();
        _CanvasUtil__WEBPACK_IMPORTED_MODULE_14__["executeCommands"](ctx, layer.pathData.getCommands(), layerToCanvasMatrix);
        var strokeWidthMultiplier = canvasToLayerMatrix.getScaleFactor();
        ctx.strokeStyle = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__["ColorUtil"].androidToCssRgbaColor(layer.strokeColor, layer.strokeAlpha);
        ctx.lineWidth = layer.strokeWidth * strokeWidthMultiplier;
        ctx.fillStyle = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__["ColorUtil"].androidToCssRgbaColor(layer.fillColor, layer.fillAlpha);
        ctx.lineCap = layer.strokeLinecap;
        ctx.lineJoin = layer.strokeLinejoin;
        ctx.miterLimit = layer.strokeMiterLimit;
        if (layer.trimPathStart !== 0 || layer.trimPathEnd !== 1 || layer.trimPathOffset !== 0) {
            var a = canvasToLayerMatrix.a, d = canvasToLayerMatrix.d;
            // Note that we only return the length of the first sub path due to
            // https://code.google.com/p/android/issues/detail?id=172547
            var pathLength = void 0;
            if (Math.abs(a) !== 1 || Math.abs(d) !== 1) {
                // Then recompute the scaled path length.
                pathLength = layer.pathData
                    .mutate()
                    .transform(canvasToLayerMatrix)
                    .build()
                    .getSubPathLength(0);
            }
            else {
                pathLength = layer.pathData.getSubPathLength(0);
            }
            var strokeDashArray = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].toStrokeDashArray(layer.trimPathStart, layer.trimPathEnd, layer.trimPathOffset, pathLength, 0.001);
            var strokeDashOffset = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].toStrokeDashOffset(layer.trimPathStart, layer.trimPathEnd, layer.trimPathOffset, pathLength);
            ctx.setLineDash(strokeDashArray);
            ctx.lineDashOffset = strokeDashOffset;
        }
        else {
            ctx.setLineDash([]);
        }
        if (layer.isStroked() && layer.strokeWidth && layer.trimPathStart !== layer.trimPathEnd) {
            ctx.stroke();
        }
        if (layer.isFilled()) {
            if (layer.fillType === 'evenOdd') {
                // Unlike VectorDrawables, SVGs spell 'evenodd' with a lowercase 'o'.
                ctx.fill('evenodd');
            }
            else {
                ctx.fill();
            }
        }
        ctx.restore();
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Number)
    ], CanvasLayersDirective.prototype, "actionSource", void 0);
    CanvasLayersDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({ selector: '[appCanvasLayers]' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_6__["PlaybackService"],
            app_modules_editor_store__WEBPACK_IMPORTED_MODULE_7__["Store"]])
    ], CanvasLayersDirective);
    return CanvasLayersDirective;
}(Object(_CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_13__["CanvasLayoutMixin"])(Object(app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_5__["DestroyableMixin"])())));



/***/ }),

/***/ "./src/app/modules/editor/components/canvas/canvasoverlay.directive.ts":
/*!*****************************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/canvasoverlay.directive.ts ***!
  \*****************************************************************************/
/*! exports provided: CanvasOverlayDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasOverlayDirective", function() { return CanvasOverlayDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/scripts/mixins */ "./src/app/modules/editor/scripts/mixins/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/modules/editor/store/actionmode/selectors */ "./src/app/modules/editor/store/actionmode/selectors.ts");
/* harmony import */ var app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/modules/editor/store/common/selectors */ "./src/app/modules/editor/store/common/selectors.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./CanvasLayoutMixin */ "./src/app/modules/editor/components/canvas/CanvasLayoutMixin.ts");
/* harmony import */ var _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./CanvasUtil */ "./src/app/modules/editor/components/canvas/CanvasUtil.ts");
/* harmony import */ var _PairSubPathHelper__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./PairSubPathHelper */ "./src/app/modules/editor/components/canvas/PairSubPathHelper.ts");
/* harmony import */ var _SegmentSplitter__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./SegmentSplitter */ "./src/app/modules/editor/components/canvas/SegmentSplitter.ts");
/* harmony import */ var _SelectionHelper__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./SelectionHelper */ "./src/app/modules/editor/components/canvas/SelectionHelper.ts");
/* harmony import */ var _ShapeSplitter__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./ShapeSplitter */ "./src/app/modules/editor/components/canvas/ShapeSplitter.ts");





















// The line width of a highlight in css pixels.
var HIGHLIGHT_LINE_WIDTH = 6;
// The line dash of a highlight in css pixels.
var HIGHLIGHT_LINE_DASH = 12;
// The minimum distance between a point and a path that causes a snap.
var MIN_SNAP_THRESHOLD = 12;
// The distance of a mouse gesture that triggers a drag, in css pixels.
var DRAG_TRIGGER_TOUCH_SLOP = 6;
// The radius of a medium point in css pixels.
var MEDIUM_POINT_RADIUS = 8;
// The radius of a small point in css pixels.
var SMALL_POINT_RADIUS = MEDIUM_POINT_RADIUS / 1.7;
var SPLIT_POINT_RADIUS_FACTOR = 0.8;
var SELECTED_POINT_RADIUS_FACTOR = 1.25;
var POINT_BORDER_FACTOR = 1.075;
var NORMAL_POINT_COLOR = '#2962FF'; // Blue A400
var SPLIT_POINT_COLOR = '#E65100'; // Orange 900
var HIGHLIGHT_COLOR = '#448AFF';
var POINT_BORDER_COLOR = '#000';
var POINT_TEXT_COLOR = '#fff';
var ERROR_COLOR = '#F44336';
/**
 * A directive that draws overlay selections and other content on top
 * of the currently active vector layer.
 */
var CanvasOverlayDirective = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CanvasOverlayDirective, _super);
    function CanvasOverlayDirective(elementRef, store, actionModeService, playbackService, layerTimelineService) {
        var _this = _super.call(this) || this;
        _this.store = store;
        _this.actionModeService = actionModeService;
        _this.playbackService = playbackService;
        _this.layerTimelineService = layerTimelineService;
        // Normal mode variables.
        _this.hiddenLayerIds = new Set();
        _this.selectedLayerIds = new Set();
        _this.selectedBlockLayerIds = new Set();
        _this.$canvas = jquery__WEBPACK_IMPORTED_MODULE_11__(elementRef.nativeElement);
        return _this;
    }
    CanvasOverlayDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated) {
            // Animated canvas specific setup.
            this.registerSubscription(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["combineLatest"])(
            // TODO: don't think this is necessary anymore? only need to query playback service now?
            Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"])(this.playbackService.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["map"])(function (event) { return event.vl; })), this.store.select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_10__["getVectorLayer"])), this.store.select(app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_9__["getCanvasOverlayState"])).subscribe(function (_a) {
                var vectorLayer = _a[0], _b = _a[1], hiddenLayerIds = _b.hiddenLayerIds, selectedLayerIds = _b.selectedLayerIds, isActionMode = _b.isActionMode, selectedBlockLayerIds = _b.selectedBlockLayerIds;
                _this.vectorLayer = vectorLayer;
                _this.hiddenLayerIds = hiddenLayerIds;
                _this.selectedLayerIds = selectedLayerIds;
                _this.isActionMode = isActionMode;
                _this.selectedBlockLayerIds = selectedBlockLayerIds;
                _this.draw();
            }));
        }
        else {
            // From & to canvas specific setup.
            var shapeShifterSelector = this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From ? app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_8__["getActionModeStartState"] : app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_8__["getActionModeEndState"];
            this.registerSubscription(this.store
                .select(shapeShifterSelector)
                .subscribe(function (_a) {
                var vectorLayer = _a.vectorLayer, blockLayerId = _a.blockLayerId, isActionMode = _a.isActionMode, hover = _a.hover, selections = _a.selections, pairedSubPaths = _a.pairedSubPaths, unpairedSubPath = _a.unpairedSubPath, hiddenLayerIds = _a.hiddenLayerIds, selectedLayerIds = _a.selectedLayerIds, subIdxWithError = _a.subIdxWithError;
                _this.vectorLayer = vectorLayer;
                _this.blockLayerId = blockLayerId;
                _this.isActionMode = isActionMode;
                _this.actionHover = hover;
                _this.actionSelections = selections;
                _this.pairedSubPaths = new Set(pairedSubPaths);
                _this.unpairedSubPath = unpairedSubPath;
                _this.hiddenLayerIds = hiddenLayerIds;
                _this.selectedLayerIds = selectedLayerIds;
                _this.subIdxWithError = subIdxWithError;
                _this.draw();
            }));
            this.registerSubscription(this.store.select(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_8__["getActionMode"]).subscribe(function (mode) {
                _this.actionMode = mode;
                var layer = _this.activePathLayer;
                if (_this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitCommands ||
                    (_this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths &&
                        layer &&
                        layer.isStroked() &&
                        !layer.isFilled())) {
                    var subIdxs = new Set();
                    for (var _i = 0, _a = _this.actionSelections; _i < _a.length; _i++) {
                        var s = _a[_i];
                        subIdxs.add(s.subIdx);
                    }
                    _this.segmentSplitter = new _SegmentSplitter__WEBPACK_IMPORTED_MODULE_18__["SegmentSplitter"](_this);
                }
                else {
                    _this.segmentSplitter = undefined;
                }
                _this.selectionHelper =
                    _this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection ? new _SelectionHelper__WEBPACK_IMPORTED_MODULE_19__["SelectionHelper"](_this) : undefined;
                if (_this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].PairSubPaths) {
                    _this.pairSubPathHelper = new _PairSubPathHelper__WEBPACK_IMPORTED_MODULE_17__["PairSubPathHelper"](_this);
                    var selections = _this.actionSelections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].SubPath; });
                    if (selections.length) {
                        var _b = selections[0], source = _b.source, subIdx = _b.subIdx;
                        // TODO: avoid calling this in a subscription (should automatically do this)
                        _this.actionModeService.setUnpairedSubPath({ source: source, subIdx: subIdx });
                    }
                }
                else {
                    _this.pairSubPathHelper = undefined;
                }
                _this.shapeSplitter =
                    _this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths && layer && layer.isFilled()
                        ? new _ShapeSplitter__WEBPACK_IMPORTED_MODULE_20__["ShapeSplitter"](_this)
                        : undefined;
                _this.currentHoverPreviewPath = undefined;
                _this.draw();
            }));
            var updateCurrentHoverFn_1 = function (hover) {
                var previewPath;
                if (_this.vectorLayer && _this.activePath && hover) {
                    // If the user is hovering over the inspector split button, then build
                    // a snapshot of what the path would look like after the action
                    // and display the result.
                    var mutator = _this.activePath.mutate();
                    var type = hover.type, subIdx = hover.subIdx, cmdIdx = hover.cmdIdx;
                    switch (type) {
                        case app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["HoverType"].Split:
                            previewPath = mutator.splitCommandInHalf(subIdx, cmdIdx).build();
                            break;
                        case app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["HoverType"].Unsplit:
                            previewPath = mutator.unsplitCommand(subIdx, cmdIdx).build();
                            break;
                    }
                }
                _this.currentHoverPreviewPath = previewPath;
                _this.draw();
            };
            // TODO: avoid re-executing the draw by combining with the above subscriptions
            this.registerSubscription(this.store.select(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_8__["getActionModeHover"]).subscribe(function (hover) {
                if (!hover) {
                    // Clear the current hover.
                    updateCurrentHoverFn_1(undefined);
                    return;
                }
                if (hover.source !== _this.actionSource && hover.type !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["HoverType"].Point) {
                    updateCurrentHoverFn_1(undefined);
                    return;
                }
                updateCurrentHoverFn_1(hover);
            }));
        }
    };
    Object.defineProperty(CanvasOverlayDirective.prototype, "overlayCtx", {
        get: function () {
            return this.$canvas.get(0).getContext('2d');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "highlightLineWidth", {
        get: function () {
            return HIGHLIGHT_LINE_WIDTH / this.cssScale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "minSnapThreshold", {
        get: function () {
            return MIN_SNAP_THRESHOLD / this.cssScale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "highlightLineDash", {
        get: function () {
            return [HIGHLIGHT_LINE_DASH / this.cssScale, HIGHLIGHT_LINE_DASH / this.cssScale];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "smallPointRadius", {
        get: function () {
            return SMALL_POINT_RADIUS / this.cssScale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "mediumPointRadius", {
        get: function () {
            return MEDIUM_POINT_RADIUS / this.cssScale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "splitPointRadius", {
        get: function () {
            return this.mediumPointRadius * SPLIT_POINT_RADIUS_FACTOR;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "selectedSegmentLineWidth", {
        get: function () {
            return HIGHLIGHT_LINE_WIDTH / this.cssScale / 1.9;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "unselectedSegmentLineWidth", {
        get: function () {
            return HIGHLIGHT_LINE_WIDTH / this.cssScale / 3;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "dragTriggerTouchSlop", {
        get: function () {
            return DRAG_TRIGGER_TOUCH_SLOP / this.cssScale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "activePathLayer", {
        // NOTE: only use this for action mode
        get: function () {
            if (!this.vectorLayer) {
                return undefined;
            }
            return this.vectorLayer.findLayerById(this.blockLayerId);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasOverlayDirective.prototype, "activePath", {
        // NOTE: only use this for action mode
        get: function () {
            var layer = this.activePathLayer;
            if (!layer) {
                return undefined;
            }
            return layer.pathData;
        },
        enumerable: true,
        configurable: true
    });
    // @Override
    CanvasOverlayDirective.prototype.onDimensionsChanged = function () {
        var _a = this.getViewport(), w = _a.w, h = _a.h;
        this.$canvas.attr({ width: w * this.attrScale, height: h * this.attrScale });
        this.$canvas.css({ width: w * this.cssScale, height: h * this.cssScale });
        this.draw();
    };
    CanvasOverlayDirective.prototype.draw = function () {
        var ctx = this.overlayCtx;
        if (this.vectorLayer) {
            var _a = this.getViewport(), w = _a.w, h = _a.h;
            ctx.save();
            ctx.scale(this.attrScale, this.attrScale);
            ctx.clearRect(0, 0, w, h);
            this.drawLayerSelections(ctx, this.vectorLayer);
            this.drawHighlights(ctx);
            ctx.restore();
            // Draw points in terms of physical pixels, not viewport pixels.
            this.drawLabeledPoints(ctx);
            this.drawDraggingPoints(ctx);
            this.drawFloatingPreviewPoint(ctx);
            this.drawFloatingSplitFilledPathPreviewPoints(ctx);
        }
        this.drawPixelGrid(ctx);
    };
    // Recursively draws all layer selections to the canvas.
    CanvasOverlayDirective.prototype.drawLayerSelections = function (ctx, curr) {
        var _this = this;
        if (this.isActionMode) {
            // Don't draw selections for hidden layers or while in action mode.
            return;
        }
        if (this.selectedLayerIds.has(curr.id) || this.selectedBlockLayerIds.has(curr.id)) {
            var root = this.vectorLayer;
            var flattenedTransform = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformForLayer(root, curr.id);
            if (curr instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["ClipPathLayer"]) {
                if (curr.pathData && curr.pathData.getCommands().length) {
                    _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, curr.pathData.getCommands(), flattenedTransform);
                    executeHighlights(ctx, HIGHLIGHT_COLOR, this.highlightLineWidth, this.highlightLineDash);
                    ctx.clip();
                }
            }
            else if (curr instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["PathLayer"]) {
                if (curr.pathData && curr.pathData.getCommands().length) {
                    ctx.save();
                    _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, curr.pathData.getCommands(), flattenedTransform);
                    executeHighlights(ctx, HIGHLIGHT_COLOR, this.highlightLineWidth);
                    ctx.restore();
                }
            }
            else if (curr instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["VectorLayer"] || curr instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["GroupLayer"]) {
                var bounds = curr.bounds;
                if (bounds) {
                    ctx.save();
                    var a = flattenedTransform.a, b = flattenedTransform.b, c = flattenedTransform.c, d = flattenedTransform.d, e = flattenedTransform.e, f = flattenedTransform.f;
                    ctx.transform(a, b, c, d, e, f);
                    ctx.beginPath();
                    ctx.rect(bounds.l, bounds.t, bounds.r - bounds.l, bounds.b - bounds.t);
                    executeHighlights(ctx, HIGHLIGHT_COLOR, this.highlightLineWidth);
                    ctx.restore();
                }
            }
        }
        curr.children.forEach(function (child) { return _this.drawLayerSelections(ctx, child); });
    };
    // Draw any highlighted segments.
    CanvasOverlayDirective.prototype.drawHighlights = function (ctx) {
        var _this = this;
        if (!this.isActionMode || this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated || !this.activePath) {
            return;
        }
        var flattenedTransform = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformForLayer(this.vectorLayer, this.blockLayerId);
        var pathLayer = this.activePathLayer;
        var activePath = pathLayer.pathData;
        var currentHover = this.actionHover;
        if (this.selectionHelper) {
            // Draw any highlighted subpaths. We'll highlight a subpath if a subpath
            // selection or a point selection exists.
            var selectedSubPaths = lodash__WEBPACK_IMPORTED_MODULE_12__(this.actionSelections)
                .filter(function (s) {
                return (s.source === _this.actionSource &&
                    (s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Point || s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].SubPath));
            })
                .map(function (s) { return s.subIdx; })
                .uniq()
                .map(function (subIdx) { return activePath.getSubPath(subIdx); })
                .filter(function (subPath) { return !subPath.isCollapsing(); })
                .value();
            for (var _i = 0, selectedSubPaths_1 = selectedSubPaths; _i < selectedSubPaths_1.length; _i++) {
                var subPath = selectedSubPaths_1[_i];
                // If the subpath has a split segment, highlight it in orange. Otherwise,
                // use the default blue highlight color.
                var isSplitSubPath = subPath.getCommands().some(function (c) { return c.isSplitSegment(); });
                var highlightColor = isSplitSubPath ? SPLIT_POINT_COLOR : HIGHLIGHT_COLOR;
                _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, subPath.getCommands(), flattenedTransform);
                executeHighlights(ctx, highlightColor, this.selectedSegmentLineWidth);
            }
            var segmentSelections = this.actionSelections
                .filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Segment; })
                .filter(function (s) { return s.source === _this.actionSource; })
                .map(function (s) {
                return { subIdx: s.subIdx, cmdIdx: s.cmdIdx };
            });
            var hover = currentHover;
            if (hover && hover.source === this.actionSource && hover.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["HoverType"].Segment) {
                segmentSelections.push({
                    subIdx: hover.subIdx,
                    cmdIdx: hover.cmdIdx,
                });
            }
            var segmentSelectionCmds = segmentSelections
                .map(function (s) { return activePath.getCommand(s.subIdx, s.cmdIdx); })
                .filter(function (cmd) { return cmd.isSplitSegment(); });
            _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, segmentSelectionCmds, flattenedTransform);
            executeHighlights(ctx, SPLIT_POINT_COLOR, this.selectedSegmentLineWidth);
            // Highlight any subpaths with errors.
            if (this.subIdxWithError !== undefined) {
                var cmds = activePath.getSubPath(this.subIdxWithError).getCommands();
                _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, cmds, flattenedTransform);
                executeHighlights(ctx, ERROR_COLOR, this.highlightLineWidth, this.highlightLineDash);
            }
        }
        else if (this.segmentSplitter && this.segmentSplitter.getProjectionOntoPath()) {
            // Highlight the segment as the user hovers over it.
            var _a = this.segmentSplitter.getProjectionOntoPath(), subIdx = _a.subIdx, cmdIdx = _a.cmdIdx, d = _a.projection.d;
            if (d < this.minSnapThreshold) {
                _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, [activePath.getCommand(subIdx, cmdIdx)], flattenedTransform);
                executeHighlights(ctx, SPLIT_POINT_COLOR, this.selectedSegmentLineWidth);
            }
        }
        // Draw any existing split shape segments to the canvas.
        var commands = lodash__WEBPACK_IMPORTED_MODULE_12__(activePath.getSubPaths())
            .filter(function (s) { return !s.isCollapsing(); })
            .flatMap(function (s) { return s.getCommands(); })
            .filter(function (c) { return c.isSplitSegment(); })
            .value();
        _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, commands, flattenedTransform);
        executeHighlights(ctx, SPLIT_POINT_COLOR, this.unselectedSegmentLineWidth);
        if (this.pairSubPathHelper) {
            var currUnpair = this.unpairedSubPath;
            if (currUnpair) {
                // Draw the current unpaired subpath in orange, if it exists.
                var source = currUnpair.source, subIdx = currUnpair.subIdx;
                if (source === this.actionSource) {
                    var subPath = activePath.getSubPath(subIdx);
                    _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, subPath.getCommands(), flattenedTransform);
                    executeHighlights(ctx, SPLIT_POINT_COLOR, this.selectedSegmentLineWidth);
                }
            }
            var pairedSubPaths = this.pairedSubPaths;
            var hasHover = currentHover &&
                currentHover.source === this.actionSource &&
                currentHover.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["HoverType"].SubPath;
            if (hasHover) {
                pairedSubPaths.delete(currentHover.subIdx);
            }
            if (pairedSubPaths.size) {
                // Draw any already paired subpaths in blue.
                var pairedCmds = lodash__WEBPACK_IMPORTED_MODULE_12__["flatMap"](Array.from(pairedSubPaths), function (subIdx) { return activePath.getSubPath(subIdx).getCommands(); });
                _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, pairedCmds, flattenedTransform);
                executeHighlights(ctx, NORMAL_POINT_COLOR, this.selectedSegmentLineWidth);
            }
            if (hasHover) {
                // Highlight the hover in orange, if it exists.
                var hoverCmds = activePath.getSubPath(currentHover.subIdx).getCommands();
                _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, hoverCmds, flattenedTransform);
                executeHighlights(ctx, SPLIT_POINT_COLOR, this.selectedSegmentLineWidth);
            }
        }
        else if (this.shapeSplitter) {
            // If we are splitting a filled subpath, draw the in progress drag segment.
            var proj1 = this.shapeSplitter.getInitialProjectionOntoPath();
            var proj2 = this.shapeSplitter.getFinalProjectionOntoPath();
            if (proj1) {
                // Draw a line from the starting projection to the final projection (or
                // to the last known mouse location, if one doesn't exist).
                var startPoint = applyGroupTransform(proj1.projection, flattenedTransform);
                var endPoint = proj2
                    ? applyGroupTransform(proj2.projection, flattenedTransform)
                    : this.shapeSplitter.getLastKnownMouseLocation();
                ctx.beginPath();
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.lineTo(endPoint.x, endPoint.y);
                executeHighlights(ctx, SPLIT_POINT_COLOR, this.selectedSegmentLineWidth);
            }
            if (!proj1 || proj2) {
                // Highlight the segment as the user hovers over it.
                var projectionOntoPath = this.shapeSplitter.getCurrentProjectionOntoPath();
                if (projectionOntoPath) {
                    var projection = projectionOntoPath.projection;
                    if (projection && projection.d < this.minSnapThreshold) {
                        var subIdx = projectionOntoPath.subIdx, cmdIdx = projectionOntoPath.cmdIdx;
                        _CanvasUtil__WEBPACK_IMPORTED_MODULE_16__["executeCommands"](ctx, [activePath.getCommand(subIdx, cmdIdx)], flattenedTransform);
                        executeHighlights(ctx, SPLIT_POINT_COLOR, this.selectedSegmentLineWidth);
                    }
                }
            }
        }
    };
    // Draw any labeled points.
    CanvasOverlayDirective.prototype.drawLabeledPoints = function (ctx) {
        if (!this.isActionMode || this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated || !this.activePath) {
            return;
        }
        var pathLayer = this.activePathLayer;
        var path = pathLayer.pathData;
        if (this.currentHoverPreviewPath) {
            path = this.currentHoverPreviewPath;
        }
        // Create a list of all path points in their normal order.
        var pointInfos = lodash__WEBPACK_IMPORTED_MODULE_12__(path.getSubPaths())
            .filter(function (s) { return !s.isCollapsing(); })
            .map(function (s, subIdx) {
            return s.getCommands().map(function (cmd, cmdIdx) {
                return { cmd: cmd, subIdx: subIdx, cmdIdx: cmdIdx };
            });
        })
            .flatMap(function (pis) { return pis; })
            .reverse()
            .value();
        var subPathSelections = this.actionSelections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].SubPath; });
        var pointSelections = this.actionSelections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Point; });
        // Remove all selected points from the list.
        var isPointInfoSelectedFn = function (_a) {
            var subIdx = _a.subIdx, cmdIdx = _a.cmdIdx;
            return (subPathSelections.some(function (s) { return s.subIdx === subIdx; }) ||
                pointSelections.some(function (s) { return s.subIdx === subIdx && s.cmdIdx === cmdIdx; }));
        };
        var selectedPointInfos = lodash__WEBPACK_IMPORTED_MODULE_12__["remove"](pointInfos, function (pi) { return isPointInfoSelectedFn(pi); });
        // Remove any subpath points that share the same subIdx as an existing selection.
        // We'll call these 'medium' points (i.e. labeled, but not selected), and we'll
        // always draw selected points on top of medium points, and medium points
        // on top of small points.
        var isPointInfoAtLeastMediumFn = function (_a) {
            var subIdx = _a.subIdx;
            return (subPathSelections.some(function (s) { return s.subIdx === subIdx; }) ||
                pointSelections.some(function (s) { return s.subIdx === subIdx; }));
        };
        pointInfos.push.apply(pointInfos, lodash__WEBPACK_IMPORTED_MODULE_12__["remove"](pointInfos, function (pi) { return isPointInfoAtLeastMediumFn(pi); }));
        pointInfos.push.apply(pointInfos, selectedPointInfos);
        var currentHover = this.actionHover;
        // Remove a hovering point, if one exists.
        var hoveringPointInfos = lodash__WEBPACK_IMPORTED_MODULE_12__["remove"](pointInfos, function (_a) {
            var subIdx = _a.subIdx, cmdIdx = _a.cmdIdx;
            var hover = currentHover;
            return (hover &&
                hover.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["HoverType"].Point &&
                hover.subIdx === subIdx &&
                hover.cmdIdx === cmdIdx);
        });
        // Remove any subpath points that share the same subIdx as an existing hover.
        var isPointInfoHoveringFn = function (_a) {
            var subIdx = _a.subIdx;
            var hover = currentHover;
            return hover && hover.type !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["HoverType"].Segment && hover.subIdx === subIdx;
        };
        // Similar to above, always draw hover points on top of subpath hover points.
        pointInfos.push.apply(pointInfos, lodash__WEBPACK_IMPORTED_MODULE_12__["remove"](pointInfos, function (pi) { return isPointInfoHoveringFn(pi); }));
        pointInfos.push.apply(pointInfos, hoveringPointInfos);
        var draggingIndex = this.selectionHelper && this.selectionHelper.isDragTriggered()
            ? this.selectionHelper.getDraggableSplitIndex()
            : undefined;
        for (var _i = 0, pointInfos_1 = pointInfos; _i < pointInfos_1.length; _i++) {
            var _a = pointInfos_1[_i], cmd = _a.cmd, subIdx = _a.subIdx, cmdIdx = _a.cmdIdx;
            if (draggingIndex && subIdx === draggingIndex.subIdx && cmdIdx === draggingIndex.cmdIdx) {
                // Skip the currently dragged point. We'll draw that next.
                continue;
            }
            var radius = this.smallPointRadius;
            var text = void 0;
            var isHovering = isPointInfoHoveringFn({ cmd: cmd, subIdx: subIdx, cmdIdx: cmdIdx });
            var isAtLeastMedium = isPointInfoAtLeastMediumFn({ cmd: cmd, subIdx: subIdx, cmdIdx: cmdIdx });
            if ((isAtLeastMedium || isHovering) && this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection) {
                radius = this.mediumPointRadius * SELECTED_POINT_RADIUS_FACTOR;
                var isPointEnlargedFn = function (source, sIdx, cIdx) {
                    return pointSelections.some(function (s) {
                        return s.subIdx === sIdx && s.cmdIdx === cIdx && s.source === source;
                    });
                };
                if ((isHovering && cmdIdx === currentHover.cmdIdx) ||
                    isPointEnlargedFn(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From, subIdx, cmdIdx) ||
                    isPointEnlargedFn(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].To, subIdx, cmdIdx)) {
                    radius /= SPLIT_POINT_RADIUS_FACTOR;
                }
                text = (cmdIdx + 1).toString();
            }
            var color = void 0;
            if (cmd.isSplitPoint()) {
                radius *= SPLIT_POINT_RADIUS_FACTOR;
                color = SPLIT_POINT_COLOR;
            }
            else {
                color = NORMAL_POINT_COLOR;
            }
            var flattenedTransform = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformForLayer(this.vectorLayer, this.blockLayerId);
            executeLabeledPoint(ctx, this.attrScale, applyGroupTransform(lodash__WEBPACK_IMPORTED_MODULE_12__["last"](cmd.points), flattenedTransform), radius, color, text);
        }
    };
    // Draw any actively dragged points along the path in selection mode.
    CanvasOverlayDirective.prototype.drawDraggingPoints = function (ctx) {
        if (!this.isActionMode || this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated || !this.activePath) {
            return;
        }
        if (this.actionMode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection ||
            !this.selectionHelper ||
            !this.selectionHelper.isDragTriggered()) {
            return;
        }
        var flattenedTransform = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformForLayer(this.vectorLayer, this.blockLayerId);
        var projection = this.selectionHelper.getProjectionOntoPath().projection;
        var point = projection.d < this.minSnapThreshold
            ? applyGroupTransform(projection, flattenedTransform)
            : this.selectionHelper.getLastKnownMouseLocation();
        executeLabeledPoint(ctx, this.attrScale, point, this.splitPointRadius, SPLIT_POINT_COLOR);
    };
    // Draw a floating point preview over the canvas in split commands mode
    // and split subpaths mode for stroked paths.
    CanvasOverlayDirective.prototype.drawFloatingPreviewPoint = function (ctx) {
        if (!this.isActionMode || this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated || !this.activePath) {
            return;
        }
        var pathLayer = this.activePathLayer;
        if ((this.actionMode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitCommands &&
            this.actionMode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths &&
            !pathLayer.isStroked()) ||
            !this.segmentSplitter ||
            !this.segmentSplitter.getProjectionOntoPath()) {
            return;
        }
        var projection = this.segmentSplitter.getProjectionOntoPath().projection;
        if (projection.d < this.minSnapThreshold) {
            var flattenedTransform = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformForLayer(this.vectorLayer, this.blockLayerId);
            executeLabeledPoint(ctx, this.attrScale, applyGroupTransform(projection, flattenedTransform), this.splitPointRadius, SPLIT_POINT_COLOR);
        }
    };
    // Draw the floating points on top of the drag line in split filled subpath mode.
    CanvasOverlayDirective.prototype.drawFloatingSplitFilledPathPreviewPoints = function (ctx) {
        if (!this.isActionMode || this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated || !this.activePath) {
            return;
        }
        if (this.actionMode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths || !this.shapeSplitter) {
            return;
        }
        var flattenedTransform = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformForLayer(this.vectorLayer, this.blockLayerId);
        var proj1 = this.shapeSplitter.getInitialProjectionOntoPath();
        if (proj1) {
            var proj2 = this.shapeSplitter.getFinalProjectionOntoPath();
            executeLabeledPoint(ctx, this.attrScale, applyGroupTransform(proj1.projection, flattenedTransform), this.splitPointRadius, SPLIT_POINT_COLOR);
            if (this.shapeSplitter.willFinalProjectionOntoPathCreateSplitPoint()) {
                var endPoint = proj2
                    ? applyGroupTransform(proj2.projection, flattenedTransform)
                    : this.shapeSplitter.getLastKnownMouseLocation();
                executeLabeledPoint(ctx, this.attrScale, endPoint, this.splitPointRadius, SPLIT_POINT_COLOR);
            }
        }
        else if (this.shapeSplitter.getCurrentProjectionOntoPath()) {
            var projection = this.shapeSplitter.getCurrentProjectionOntoPath().projection;
            if (projection.d < this.minSnapThreshold) {
                executeLabeledPoint(ctx, this.attrScale, applyGroupTransform(projection, flattenedTransform), this.splitPointRadius, SPLIT_POINT_COLOR);
            }
        }
    };
    // Draws the pixel grid on top of the canvas content.
    CanvasOverlayDirective.prototype.drawPixelGrid = function (ctx) {
        // Note that we draw the pixel grid in terms of physical pixels,
        // not viewport pixels.
        if (this.cssScale > 4) {
            ctx.save();
            ctx.fillStyle = 'rgba(128, 128, 128, .25)';
            var devicePixelRatio_1 = window.devicePixelRatio || 1;
            var viewport = this.getViewport();
            for (var x = 1; x < viewport.w; x++) {
                ctx.fillRect(x * this.attrScale - devicePixelRatio_1 / 2, 0, devicePixelRatio_1, viewport.h * this.attrScale);
            }
            for (var y = 1; y < viewport.h; y++) {
                ctx.fillRect(0, y * this.attrScale - devicePixelRatio_1 / 2, viewport.w * this.attrScale, devicePixelRatio_1);
            }
            ctx.restore();
        }
    };
    // Called by the CanvasComponent.
    CanvasOverlayDirective.prototype.onMouseDown = function (event) {
        var mouseDown = this.mouseEventToViewportCoords(event);
        if (this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated && !this.isActionMode) {
            // Detect layer selections.
            var hitLayer = this.hitTestForLayer(mouseDown);
            var isMetaOrShiftPressed = app_modules_editor_services__WEBPACK_IMPORTED_MODULE_6__["ShortcutService"].isOsDependentModifierKey(event) || event.shiftKey;
            if (hitLayer) {
                this.layerTimelineService.selectLayer(hitLayer.id, !isMetaOrShiftPressed);
            }
            else if (!isMetaOrShiftPressed) {
                this.layerTimelineService.clearSelections();
            }
            return;
        }
        if (this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated) {
            // Don't need to do anything for the animated canvas if we are in action mode.
            return;
        }
        if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection) {
            this.selectionHelper.onMouseDown(mouseDown, event.shiftKey || app_modules_editor_services__WEBPACK_IMPORTED_MODULE_6__["ShortcutService"].isOsDependentModifierKey(event));
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].PairSubPaths) {
            this.pairSubPathHelper.onMouseDown(mouseDown, event.shiftKey || app_modules_editor_services__WEBPACK_IMPORTED_MODULE_6__["ShortcutService"].isOsDependentModifierKey(event));
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitCommands) {
            this.segmentSplitter.onMouseDown(mouseDown);
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths) {
            var pathLayer = this.activePathLayer;
            if (!pathLayer.isFilled() && pathLayer.isStroked()) {
                this.segmentSplitter.onMouseDown(mouseDown);
            }
            else {
                this.shapeSplitter.onMouseDown(mouseDown);
            }
        }
    };
    // Called by the CanvasComponent.
    CanvasOverlayDirective.prototype.onMouseMove = function (event) {
        if (this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated && !this.isActionMode) {
            return;
        }
        var mouseMove = this.mouseEventToViewportCoords(event);
        if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection) {
            this.selectionHelper.onMouseMove(mouseMove);
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].PairSubPaths) {
            this.pairSubPathHelper.onMouseMove(mouseMove);
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitCommands) {
            this.segmentSplitter.onMouseMove(mouseMove);
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths) {
            var pathLayer = this.activePathLayer;
            if (!pathLayer.isFilled() && pathLayer.isStroked()) {
                this.segmentSplitter.onMouseMove(mouseMove);
            }
            else {
                this.shapeSplitter.onMouseMove(mouseMove);
            }
        }
    };
    // Called by the CanvasComponent.
    CanvasOverlayDirective.prototype.onMouseUp = function (event) {
        if (this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated && !this.isActionMode) {
            return;
        }
        var mouseUp = this.mouseEventToViewportCoords(event);
        if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection) {
            this.selectionHelper.onMouseUp(mouseUp, event.shiftKey || app_modules_editor_services__WEBPACK_IMPORTED_MODULE_6__["ShortcutService"].isOsDependentModifierKey(event));
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].PairSubPaths) {
            this.pairSubPathHelper.onMouseUp(mouseUp);
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitCommands) {
            this.segmentSplitter.onMouseUp(mouseUp);
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths) {
            var pathLayer = this.activePathLayer;
            if (!pathLayer.isFilled() && pathLayer.isStroked()) {
                this.segmentSplitter.onMouseUp(mouseUp);
            }
            else {
                this.shapeSplitter.onMouseUp(mouseUp);
            }
        }
    };
    // Called by the CanvasComponent.
    CanvasOverlayDirective.prototype.onMouseLeave = function (event) {
        if (this.actionSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].Animated && !this.isActionMode) {
            return;
        }
        var mouseLeave = this.mouseEventToViewportCoords(event);
        if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection) {
            // TODO: how to handle the case where the mouse leaves and re-enters mid-gesture?
            this.selectionHelper.onMouseLeave(mouseLeave);
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].PairSubPaths) {
            this.pairSubPathHelper.onMouseLeave(mouseLeave);
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitCommands) {
            this.segmentSplitter.onMouseLeave(mouseLeave);
        }
        else if (this.actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths) {
            var pathLayer = this.activePathLayer;
            if (!pathLayer.isFilled() && pathLayer.isStroked()) {
                this.segmentSplitter.onMouseLeave(mouseLeave);
            }
            else {
                this.shapeSplitter.onMouseLeave(mouseLeave);
            }
        }
        this.actionModeService.clearHover();
    };
    CanvasOverlayDirective.prototype.mouseEventToViewportCoords = function (event) {
        var canvasOffset = this.$canvas.offset();
        var x = (event.pageX - canvasOffset.left) / this.cssScale;
        var y = (event.pageY - canvasOffset.top) / this.cssScale;
        return { x: x, y: y };
    };
    CanvasOverlayDirective.prototype.hitTestForLayer = function (point) {
        var _this = this;
        var root = this.vectorLayer;
        if (!root) {
            return undefined;
        }
        var recurseFn = function (layer) {
            if (_this.hiddenLayerIds.has(layer.id)) {
                return undefined;
            }
            // TODO: use a user-defined type check to confirm this layer is an instance of MorphableLayer
            if ((layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["PathLayer"] || layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["ClipPathLayer"]) && layer.pathData) {
                var canvasToLayerMatrix = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformForLayer(root, layer.id).invert();
                if (!canvasToLayerMatrix) {
                    // Do nothing if matrix is non-invertible.
                    return undefined;
                }
                var transformedPoint = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].transformPoint(point, canvasToLayerMatrix);
                var isSegmentInRangeFn = void 0;
                isSegmentInRangeFn = function (distance) {
                    var maxDistance = 0;
                    if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["PathLayer"] && layer.isStroked()) {
                        maxDistance = Math.max(_this.minSnapThreshold, layer.strokeWidth / 2);
                    }
                    return distance <= maxDistance;
                };
                var findShapesInRange = layer.isFilled();
                var hitResult = layer.pathData.hitTest(transformedPoint, {
                    isSegmentInRangeFn: isSegmentInRangeFn,
                    findShapesInRange: findShapesInRange,
                });
                return hitResult.isHit ? layer : undefined;
            }
            // Use 'hitTestLayer || h' and not the other way around because of reverse z-order.
            return layer.children.reduce(function (h, l) { return recurseFn(l) || h; }, undefined);
        };
        return recurseFn(root);
    };
    // NOTE: this should only be used in action mode
    CanvasOverlayDirective.prototype.performHitTest = function (mousePoint, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var flattenedTransform = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformForLayer(this.vectorLayer, this.blockLayerId).invert();
        var transformedMousePoint = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].transformPoint(mousePoint, flattenedTransform);
        var isPointInRangeFn;
        if (!opts.noPoints) {
            isPointInRangeFn = function (distance, cmd) {
                var multiplyFactor = cmd.isSplitPoint() ? SPLIT_POINT_RADIUS_FACTOR : 1;
                return distance <= _this.mediumPointRadius * multiplyFactor;
            };
        }
        var pathLayer = this.vectorLayer.findLayerById(this.blockLayerId);
        if (!pathLayer.pathData) {
            return { isHit: false };
        }
        var isSegmentInRangeFn;
        if (!opts.noSegments) {
            isSegmentInRangeFn = function (distance) {
                var maxDistance = opts.withExtraSegmentPadding ? _this.minSnapThreshold : 0;
                if (pathLayer.isStroked()) {
                    maxDistance = Math.max(maxDistance, pathLayer.strokeWidth / 2);
                }
                return distance <= maxDistance;
            };
        }
        var findShapesInRange = pathLayer.isFilled() && !opts.noShapes;
        var restrictToSubIdx = opts.restrictToSubIdx;
        return pathLayer.pathData.hitTest(transformedMousePoint, {
            isPointInRangeFn: isPointInRangeFn,
            isSegmentInRangeFn: isSegmentInRangeFn,
            findShapesInRange: findShapesInRange,
            restrictToSubIdx: restrictToSubIdx,
        });
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Number)
    ], CanvasOverlayDirective.prototype, "actionSource", void 0);
    CanvasOverlayDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({ selector: '[appCanvasOverlay]' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
            app_modules_editor_store__WEBPACK_IMPORTED_MODULE_7__["Store"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_6__["ActionModeService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_6__["PlaybackService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_6__["LayerTimelineService"]])
    ], CanvasOverlayDirective);
    return CanvasOverlayDirective;
}(Object(_CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_15__["CanvasLayoutMixin"])(Object(app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_5__["DestroyableMixin"])())));

function executeHighlights(ctx, color, lineWidth, lineDash) {
    if (lineDash === void 0) { lineDash = []; }
    ctx.save();
    ctx.setLineDash(lineDash);
    ctx.lineCap = 'round';
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.stroke();
    ctx.restore();
}
// Draws a labeled point with optional text.
function executeLabeledPoint(ctx, attrScale, point, radius, color, text) {
    // Convert the point and the radius to physical pixel coordinates.
    // We do this to avoid fractional font sizes less than 1px, which
    // show up OK on Chrome but not on Firefox or Safari.
    point = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].transformPoint(point, app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__["Matrix"].scaling(attrScale, attrScale));
    radius *= attrScale;
    ctx.save();
    ctx.beginPath();
    ctx.arc(point.x, point.y, radius * POINT_BORDER_FACTOR, 0, 2 * Math.PI, false);
    ctx.fillStyle = POINT_BORDER_COLOR;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI, false);
    ctx.fillStyle = color;
    ctx.fill();
    if (text) {
        ctx.beginPath();
        ctx.fillStyle = POINT_TEXT_COLOR;
        ctx.font = radius + 'px Roboto, Helvetica Neue, sans-serif';
        var width = ctx.measureText(text).width;
        // TODO: is there a better way to get the height?
        var height = ctx.measureText('o').width;
        ctx.fillText(text, point.x - width / 2, point.y + height / 2);
        ctx.fill();
    }
    ctx.restore();
}
// Takes a path point and transforms it so that its coordinates are in terms
// of the VectorLayer's viewport coordinates.
function applyGroupTransform(mousePoint, transform) {
    return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__["MathUtil"].transformPoint(mousePoint, transform);
}


/***/ }),

/***/ "./src/app/modules/editor/components/canvas/canvaspaper.directive.ts":
/*!***************************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/canvaspaper.directive.ts ***!
  \***************************************************************************/
/*! exports provided: CanvasPaperDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasPaperDirective", function() { return CanvasPaperDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/mixins */ "./src/app/modules/editor/scripts/mixins/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/paper */ "./src/app/modules/editor/scripts/paper/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CanvasLayoutMixin */ "./src/app/modules/editor/components/canvas/CanvasLayoutMixin.ts");









var CanvasPaperDirective = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CanvasPaperDirective, _super);
    function CanvasPaperDirective(elementRef, ps, store) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.store = store;
        _this.$canvas = jquery__WEBPACK_IMPORTED_MODULE_7__(elementRef.nativeElement);
        return _this;
    }
    CanvasPaperDirective.prototype.ngAfterViewInit = function () {
        this.paperProject = new app_modules_editor_scripts_paper__WEBPACK_IMPORTED_MODULE_4__["PaperProject"](this.$canvas.get(0), this.ps, this.store);
    };
    CanvasPaperDirective.prototype.ngOnDestroy = function () {
        this.paperProject.remove();
    };
    // @Override
    CanvasPaperDirective.prototype.onDimensionsChanged = function () {
        var _a = this.getViewport(), w = _a.w, h = _a.h;
        var scale = this.cssScale;
        this.$canvas.css({ width: w * scale, height: h * scale });
        this.paperProject.setDimensions(w, h, w * scale, h * scale);
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Number)
    ], CanvasPaperDirective.prototype, "actionSource", void 0);
    CanvasPaperDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({ selector: '[appCanvasPaper]' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_5__["PaperService"],
            app_modules_editor_store__WEBPACK_IMPORTED_MODULE_6__["Store"]])
    ], CanvasPaperDirective);
    return CanvasPaperDirective;
}(Object(_CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_8__["CanvasLayoutMixin"])(Object(app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_3__["DestroyableMixin"])())));



/***/ }),

/***/ "./src/app/modules/editor/components/canvas/canvasruler.directive.ts":
/*!***************************************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/canvasruler.directive.ts ***!
  \***************************************************************************/
/*! exports provided: CanvasRulerDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRulerDirective", function() { return CanvasRulerDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CanvasLayoutMixin */ "./src/app/modules/editor/components/canvas/CanvasLayoutMixin.ts");






// All dimensions are in CSS pixels.
var RULER_SIZE = 32;
var EXTRA_RULER_PADDING = 12;
var GRID_INTERVALS_PX = [1, 2, 4, 8, 16, 24, 48, 100, 100, 250];
var LABEL_OFFSET = 12;
var TICK_SIZE = 6;
var CanvasRulerDirective = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](CanvasRulerDirective, _super);
    function CanvasRulerDirective(elementRef, themeService) {
        var _this = _super.call(this) || this;
        _this.themeService = themeService;
        _this.$canvas = jquery__WEBPACK_IMPORTED_MODULE_4__(elementRef.nativeElement);
        return _this;
    }
    // @Override
    CanvasRulerDirective.prototype.onDimensionsChanged = function () {
        this.draw();
    };
    // @Override
    CanvasRulerDirective.prototype.onZoomPanChanged = function () {
        this.draw();
    };
    CanvasRulerDirective.prototype.hideMouse = function () {
        if (this.vpMousePoint) {
            this.vpMousePoint = undefined;
            this.draw();
        }
    };
    // TODO: need to transform mouse point to account for zoom and translation
    CanvasRulerDirective.prototype.showMouse = function (mousePoint) {
        if (!this.vpMousePoint || !app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].arePointsEqual(this.vpMousePoint, mousePoint)) {
            this.vpMousePoint = mousePoint;
            this.draw();
        }
    };
    CanvasRulerDirective.prototype.draw = function () {
        var isHorizontal = this.orientation === 'horizontal';
        var viewport = this.getViewport();
        var zoom = this.getZoom();
        var cssScale = this.cssScale;
        var width = isHorizontal
            ? viewport.w * cssScale * zoom + EXTRA_RULER_PADDING * 2
            : RULER_SIZE;
        var height = isHorizontal
            ? RULER_SIZE
            : viewport.h * cssScale * zoom + EXTRA_RULER_PADDING * 2;
        this.$canvas.css({ width: width, height: height });
        this.$canvas.attr({ width: width * devicePixelRatio, height: height * devicePixelRatio });
        var ctx = this.$canvas.get(0).getContext('2d');
        ctx.scale(devicePixelRatio, devicePixelRatio);
        var _a = this.getTranslation(), tx = _a.tx, ty = _a.ty;
        ctx.translate(isHorizontal ? tx + EXTRA_RULER_PADDING : 0, isHorizontal ? 0 : ty + EXTRA_RULER_PADDING);
        var widthMinusPadding = width - EXTRA_RULER_PADDING * 2;
        var heightMinusPadding = height - EXTRA_RULER_PADDING * 2;
        var rulerZoom = Math.max(1, isHorizontal ? widthMinusPadding / viewport.w : heightMinusPadding / viewport.h);
        // TODO: change the grid spacing depending on the current zoom?
        // Compute grid spacing (40 = minimum grid spacing in pixels).
        var interval = 0;
        var spacingViewportPx = GRID_INTERVALS_PX[interval];
        while (spacingViewportPx * rulerZoom < 40 || interval >= GRID_INTERVALS_PX.length) {
            interval++;
            spacingViewportPx = GRID_INTERVALS_PX[interval];
        }
        var spacingRulerPx = spacingViewportPx * rulerZoom;
        // Text labels.
        ctx.fillStyle = this.themeService.getDisabledTextColor();
        ctx.font = '10px Roboto, Helvetica Neue, sans-serif';
        if (isHorizontal) {
            ctx.textBaseline = 'alphabetic';
            ctx.textAlign = 'center';
            var minX = -tx;
            var maxX = minX + widthMinusPadding / zoom;
            for (var x = 0, t = 0; app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].round(x) <= app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].round(width - EXTRA_RULER_PADDING * 2); x += spacingRulerPx, t += spacingViewportPx) {
                if (minX <= x && x <= maxX) {
                    ctx.fillText(t.toString(), x, height - LABEL_OFFSET);
                    ctx.fillRect(x - 0.5, height - TICK_SIZE, 1, TICK_SIZE);
                }
            }
        }
        else {
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'right';
            var minY = -ty;
            var maxY = minY + heightMinusPadding / zoom;
            for (var y = 0, t = 0; app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].round(y) <= app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].round(height - EXTRA_RULER_PADDING * 2); y += spacingRulerPx, t += spacingViewportPx) {
                if (minY <= y && y <= maxY) {
                    ctx.fillText(t.toString(), width - LABEL_OFFSET, y);
                    ctx.fillRect(width - TICK_SIZE, y - 0.5, TICK_SIZE, 1);
                }
            }
        }
        if (this.vpMousePoint) {
            var _b = this.vpMousePoint, x = _b.x, y = _b.y;
            ctx.fillStyle = this.themeService.getSecondaryTextColor();
            if (isHorizontal) {
                ctx.fillText(x.toString(), x * rulerZoom, height - LABEL_OFFSET);
            }
            else {
                ctx.fillText(y.toString(), width - LABEL_OFFSET, y * rulerZoom);
            }
        }
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], CanvasRulerDirective.prototype, "orientation", void 0);
    CanvasRulerDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({ selector: '[appCanvasRuler]' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], app_modules_editor_services__WEBPACK_IMPORTED_MODULE_3__["ThemeService"]])
    ], CanvasRulerDirective);
    return CanvasRulerDirective;
}(Object(_CanvasLayoutMixin__WEBPACK_IMPORTED_MODULE_5__["CanvasLayoutMixin"])()));



/***/ }),

/***/ "./src/app/modules/editor/components/canvas/index.ts":
/*!***********************************************************!*\
  !*** ./src/app/modules/editor/components/canvas/index.ts ***!
  \***********************************************************/
/*! exports provided: CanvasComponent, CanvasContainerDirective, CanvasLayersDirective, CanvasOverlayDirective, CanvasRulerDirective, CanvasPaperDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _canvas_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvas.component */ "./src/app/modules/editor/components/canvas/canvas.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasComponent", function() { return _canvas_component__WEBPACK_IMPORTED_MODULE_0__["CanvasComponent"]; });

/* harmony import */ var _canvascontainer_directive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canvascontainer.directive */ "./src/app/modules/editor/components/canvas/canvascontainer.directive.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasContainerDirective", function() { return _canvascontainer_directive__WEBPACK_IMPORTED_MODULE_1__["CanvasContainerDirective"]; });

/* harmony import */ var _canvaslayers_directive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvaslayers.directive */ "./src/app/modules/editor/components/canvas/canvaslayers.directive.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasLayersDirective", function() { return _canvaslayers_directive__WEBPACK_IMPORTED_MODULE_2__["CanvasLayersDirective"]; });

/* harmony import */ var _canvasoverlay_directive__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./canvasoverlay.directive */ "./src/app/modules/editor/components/canvas/canvasoverlay.directive.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasOverlayDirective", function() { return _canvasoverlay_directive__WEBPACK_IMPORTED_MODULE_3__["CanvasOverlayDirective"]; });

/* harmony import */ var _canvasruler_directive__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./canvasruler.directive */ "./src/app/modules/editor/components/canvas/canvasruler.directive.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasRulerDirective", function() { return _canvasruler_directive__WEBPACK_IMPORTED_MODULE_4__["CanvasRulerDirective"]; });

/* harmony import */ var _canvaspaper_directive__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./canvaspaper.directive */ "./src/app/modules/editor/components/canvas/canvaspaper.directive.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CanvasPaperDirective", function() { return _canvaspaper_directive__WEBPACK_IMPORTED_MODULE_5__["CanvasPaperDirective"]; });









/***/ }),

/***/ "./src/app/modules/editor/components/dialogs/confirmdialog.component.scss":
/*!********************************************************************************!*\
  !*** ./src/app/modules/editor/components/dialogs/confirmdialog.component.scss ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "button {\n  text-transform: uppercase; }\n  button:mat-dialog-close {\n    margin-right: 8px; }\n  mat-dialog-actions {\n  min-width: 220px; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL2RpYWxvZ3MvY29uZmlybWRpYWxvZy5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNJLDBCQUF5QixFQUk1QjtFQUxEO0lBR1Esa0JBQWlCLEVBQ3BCO0VBR0w7RUFDSSxpQkFBZ0IsRUFDbkIiLCJmaWxlIjoic3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL2RpYWxvZ3MvY29uZmlybWRpYWxvZy5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbImJ1dHRvbiB7XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICAmOm1hdC1kaWFsb2ctY2xvc2Uge1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbiAgICB9XG59XG5cbm1hdC1kaWFsb2ctYWN0aW9ucyB7XG4gICAgbWluLXdpZHRoOiAyMjBweDtcbn1cbiJdfQ== */"

/***/ }),

/***/ "./src/app/modules/editor/components/dialogs/confirmdialog.component.ts":
/*!******************************************************************************!*\
  !*** ./src/app/modules/editor/components/dialogs/confirmdialog.component.ts ***!
  \******************************************************************************/
/*! exports provided: ConfirmDialogComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConfirmDialogComponent", function() { return ConfirmDialogComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");



var ConfirmDialogComponent = /** @class */ (function () {
    function ConfirmDialogComponent(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
    }
    ConfirmDialogComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-confirmdialog',
            template: "\n  <span matDialogTitle>{{ this.data.title }}</span>\n  <mat-dialog-content>\n    <p>{{ this.data.message }}</p>\n  </mat-dialog-content>\n  <mat-dialog-actions fxLayout=\"row\">\n    <!-- The ordering here matters (it ensures that 'OK' gets focus first). -->\n    <span fxFlex></span>\n    <button fxFlexOrder=\"2\" mat-button (click)=\"dialogRef.close(true)\">OK</button>\n    <button fxFlexOrder=\"1\" mat-button matDialogClose>Cancel</button>\n  </mat-dialog-actions>",
            styles: [__webpack_require__(/*! ./confirmdialog.component.scss */ "./src/app/modules/editor/components/dialogs/confirmdialog.component.scss")],
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__param"](1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"])(_angular_material__WEBPACK_IMPORTED_MODULE_2__["MAT_DIALOG_DATA"])),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_material__WEBPACK_IMPORTED_MODULE_2__["MatDialogRef"], Object])
    ], ConfirmDialogComponent);
    return ConfirmDialogComponent;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/dialogs/demodialog.component.scss":
/*!*****************************************************************************!*\
  !*** ./src/app/modules/editor/components/dialogs/demodialog.component.scss ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "button {\n  text-transform: uppercase; }\n  button:mat-dialog-close {\n    margin-right: 8px; }\n  mat-dialog-actions {\n  min-width: 220px; }\n  .dialog-radio-group {\n  display: inline-flex;\n  flex-direction: column; }\n  .dialog-radio-button {\n  margin-bottom: 16px; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL2RpYWxvZ3MvZGVtb2RpYWxvZy5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNJLDBCQUF5QixFQUk1QjtFQUxEO0lBR1Esa0JBQWlCLEVBQ3BCO0VBR0w7RUFDSSxpQkFBZ0IsRUFDbkI7RUFFRDtFQUNJLHFCQUFvQjtFQUNwQix1QkFBc0IsRUFDekI7RUFFRDtFQUNJLG9CQUFtQixFQUN0QiIsImZpbGUiOiJzcmMvYXBwL21vZHVsZXMvZWRpdG9yL2NvbXBvbmVudHMvZGlhbG9ncy9kZW1vZGlhbG9nLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiYnV0dG9uIHtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgICY6bWF0LWRpYWxvZy1jbG9zZSB7XG4gICAgICAgIG1hcmdpbi1yaWdodDogOHB4O1xuICAgIH1cbn1cblxubWF0LWRpYWxvZy1hY3Rpb25zIHtcbiAgICBtaW4td2lkdGg6IDIyMHB4O1xufVxuXG4uZGlhbG9nLXJhZGlvLWdyb3VwIHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuXG4uZGlhbG9nLXJhZGlvLWJ1dHRvbiB7XG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbn1cbiJdfQ== */"

/***/ }),

/***/ "./src/app/modules/editor/components/dialogs/demodialog.component.ts":
/*!***************************************************************************!*\
  !*** ./src/app/modules/editor/components/dialogs/demodialog.component.ts ***!
  \***************************************************************************/
/*! exports provided: DemoDialogComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DemoDialogComponent", function() { return DemoDialogComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");
/* harmony import */ var app_modules_editor_scripts_demos__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/demos */ "./src/app/modules/editor/scripts/demos/index.ts");




var DemoDialogComponent = /** @class */ (function () {
    function DemoDialogComponent(dialogRef) {
        this.dialogRef = dialogRef;
        this.demoInfos = app_modules_editor_scripts_demos__WEBPACK_IMPORTED_MODULE_3__["DEMO_INFOS"];
        this.selectedDemoInfo = app_modules_editor_scripts_demos__WEBPACK_IMPORTED_MODULE_3__["DEMO_INFOS"][0];
    }
    DemoDialogComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-demodialog',
            template: "\n  <span matDialogTitle>Choose a demo</span>\n  <mat-radio-group class=\"dialog-radio-group\" [(ngModel)]=\"this.selectedDemoInfo\">\n    <mat-radio-button class=\"dialog-radio-button\"\n      *ngFor=\"let demoInfo of this.demoInfos\" [value]=\"demoInfo\">\n      {{ demoInfo.title }}\n    </mat-radio-button>\n  </mat-radio-group>\n  <mat-dialog-actions fxLayout=\"row\">\n    <!-- The ordering here matters (it ensures that 'OK' gets focus first). -->\n    <span fxFlex></span>\n    <button fxFlexOrder=\"2\" mat-button (click)=\"this.dialogRef.close(this.selectedDemoInfo)\">OK</button>\n    <button fxFlexOrder=\"1\" mat-button matDialogClose>Cancel</button>\n  </mat-dialog-actions>",
            styles: [__webpack_require__(/*! ./demodialog.component.scss */ "./src/app/modules/editor/components/dialogs/demodialog.component.scss")],
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_material__WEBPACK_IMPORTED_MODULE_2__["MatDialogRef"]])
    ], DemoDialogComponent);
    return DemoDialogComponent;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/dialogs/dialog.service.ts":
/*!*********************************************************************!*\
  !*** ./src/app/modules/editor/components/dialogs/dialog.service.ts ***!
  \*********************************************************************/
/*! exports provided: DialogService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DialogService", function() { return DialogService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");
/* harmony import */ var app_modules_editor_components_dialogs_confirmdialog_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/components/dialogs/confirmdialog.component */ "./src/app/modules/editor/components/dialogs/confirmdialog.component.ts");
/* harmony import */ var app_modules_editor_components_dialogs_demodialog_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/components/dialogs/demodialog.component */ "./src/app/modules/editor/components/dialogs/demodialog.component.ts");
/* harmony import */ var app_modules_editor_components_dialogs_dropfilesdialog_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/components/dialogs/dropfilesdialog.component */ "./src/app/modules/editor/components/dialogs/dropfilesdialog.component.ts");






var DialogService = /** @class */ (function () {
    function DialogService(dialog) {
        this.dialog = dialog;
    }
    DialogService.prototype.confirm = function (title, message) {
        var config = new _angular_material__WEBPACK_IMPORTED_MODULE_2__["MatDialogConfig"]();
        config.data = { title: title, message: message };
        return this.dialog.open(app_modules_editor_components_dialogs_confirmdialog_component__WEBPACK_IMPORTED_MODULE_3__["ConfirmDialogComponent"], config).afterClosed();
    };
    DialogService.prototype.pickDemo = function () {
        return this.dialog.open(app_modules_editor_components_dialogs_demodialog_component__WEBPACK_IMPORTED_MODULE_4__["DemoDialogComponent"], new _angular_material__WEBPACK_IMPORTED_MODULE_2__["MatDialogConfig"]()).afterClosed();
    };
    DialogService.prototype.dropFiles = function () {
        return this.dialog.open(app_modules_editor_components_dialogs_dropfilesdialog_component__WEBPACK_IMPORTED_MODULE_5__["DropFilesDialogComponent"], new _angular_material__WEBPACK_IMPORTED_MODULE_2__["MatDialogConfig"]()).afterClosed();
    };
    DialogService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_material__WEBPACK_IMPORTED_MODULE_2__["MatDialog"]])
    ], DialogService);
    return DialogService;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/dialogs/dropfilesdialog.component.scss":
/*!**********************************************************************************!*\
  !*** ./src/app/modules/editor/components/dialogs/dropfilesdialog.component.scss ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "button {\n  text-transform: uppercase; }\n  button:mat-dialog-close {\n    margin-right: 8px; }\n  mat-dialog-actions {\n  min-width: 220px; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL2RpYWxvZ3MvZHJvcGZpbGVzZGlhbG9nLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0ksMEJBQXlCLEVBSTVCO0VBTEQ7SUFHUSxrQkFBaUIsRUFDcEI7RUFHTDtFQUNJLGlCQUFnQixFQUNuQiIsImZpbGUiOiJzcmMvYXBwL21vZHVsZXMvZWRpdG9yL2NvbXBvbmVudHMvZGlhbG9ncy9kcm9wZmlsZXNkaWFsb2cuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyJidXR0b24ge1xuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgJjptYXQtZGlhbG9nLWNsb3NlIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA4cHg7XG4gICAgfVxufVxuXG5tYXQtZGlhbG9nLWFjdGlvbnMge1xuICAgIG1pbi13aWR0aDogMjIwcHg7XG59XG4iXX0= */"

/***/ }),

/***/ "./src/app/modules/editor/components/dialogs/dropfilesdialog.component.ts":
/*!********************************************************************************!*\
  !*** ./src/app/modules/editor/components/dialogs/dropfilesdialog.component.ts ***!
  \********************************************************************************/
/*! exports provided: DropFilesAction, DropFilesDialogComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DropFilesAction", function() { return DropFilesAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DropFilesDialogComponent", function() { return DropFilesDialogComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");



var DropFilesAction;
(function (DropFilesAction) {
    DropFilesAction[DropFilesAction["AddToWorkspace"] = 1] = "AddToWorkspace";
    DropFilesAction[DropFilesAction["ResetWorkspace"] = 2] = "ResetWorkspace";
})(DropFilesAction || (DropFilesAction = {}));
var DropFilesDialogComponent = /** @class */ (function () {
    function DropFilesDialogComponent(dialogRef) {
        this.dialogRef = dialogRef;
        this.ADD_TO_WORKSPACE = DropFilesAction.AddToWorkspace;
        this.RESET_WORKSPACE = DropFilesAction.ResetWorkspace;
    }
    DropFilesDialogComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-dropfilesdialog',
            template: "\n  <span matDialogTitle>Start from scratch?</span>\n  <mat-dialog-content>\n    <p>Do you want to start from scratch or add the imported layers to the existing animation?</p>\n  </mat-dialog-content>\n  <mat-dialog-actions fxLayout=\"row\">\n    <!-- The ordering here matters (it ensures that 'OK' gets focus first). -->\n    <span fxFlex></span>\n    <button fxFlexOrder=\"3\" mat-button (click)=\"dialogRef.close(this.ADD_TO_WORKSPACE)\">Add layers</button>\n    <button fxFlexOrder=\"2\" mat-button (click)=\"dialogRef.close(this.RESET_WORKSPACE)\">Start from scratch</button>\n    <button fxFlexOrder=\"1\" mat-button matDialogClose>Cancel</button>\n  </mat-dialog-actions>",
            styles: [__webpack_require__(/*! ./dropfilesdialog.component.scss */ "./src/app/modules/editor/components/dialogs/dropfilesdialog.component.scss")],
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_material__WEBPACK_IMPORTED_MODULE_2__["MatDialogRef"]])
    ], DropFilesDialogComponent);
    return DropFilesDialogComponent;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/dialogs/index.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/components/dialogs/index.ts ***!
  \************************************************************/
/*! exports provided: ConfirmDialogComponent, DemoDialogComponent, DropFilesDialogComponent, DropFilesAction, DialogService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _confirmdialog_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./confirmdialog.component */ "./src/app/modules/editor/components/dialogs/confirmdialog.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConfirmDialogComponent", function() { return _confirmdialog_component__WEBPACK_IMPORTED_MODULE_0__["ConfirmDialogComponent"]; });

/* harmony import */ var _demodialog_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./demodialog.component */ "./src/app/modules/editor/components/dialogs/demodialog.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DemoDialogComponent", function() { return _demodialog_component__WEBPACK_IMPORTED_MODULE_1__["DemoDialogComponent"]; });

/* harmony import */ var _dropfilesdialog_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dropfilesdialog.component */ "./src/app/modules/editor/components/dialogs/dropfilesdialog.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DropFilesDialogComponent", function() { return _dropfilesdialog_component__WEBPACK_IMPORTED_MODULE_2__["DropFilesDialogComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DropFilesAction", function() { return _dropfilesdialog_component__WEBPACK_IMPORTED_MODULE_2__["DropFilesAction"]; });

/* harmony import */ var _dialog_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dialog.service */ "./src/app/modules/editor/components/dialogs/dialog.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DialogService", function() { return _dialog_service__WEBPACK_IMPORTED_MODULE_3__["DialogService"]; });







/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/constants.ts":
/*!**********************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/constants.ts ***!
  \**********************************************************************/
/*! exports provided: TIMELINE_ANIMATION_PADDING */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TIMELINE_ANIMATION_PADDING", function() { return TIMELINE_ANIMATION_PADDING; });
var TIMELINE_ANIMATION_PADDING = 20; // 20px


/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/index.ts":
/*!******************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/index.ts ***!
  \******************************************************************/
/*! exports provided: LayerListTreeComponent, LayerTimelineComponent, LayerTimelineGridDirective, TimelineAnimationRowComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layerlisttree_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layerlisttree.component */ "./src/app/modules/editor/components/layertimeline/layerlisttree.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayerListTreeComponent", function() { return _layerlisttree_component__WEBPACK_IMPORTED_MODULE_0__["LayerListTreeComponent"]; });

/* harmony import */ var _layertimeline_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layertimeline.component */ "./src/app/modules/editor/components/layertimeline/layertimeline.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayerTimelineComponent", function() { return _layertimeline_component__WEBPACK_IMPORTED_MODULE_1__["LayerTimelineComponent"]; });

/* harmony import */ var _layertimelinegrid_directive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layertimelinegrid.directive */ "./src/app/modules/editor/components/layertimeline/layertimelinegrid.directive.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayerTimelineGridDirective", function() { return _layertimelinegrid_directive__WEBPACK_IMPORTED_MODULE_2__["LayerTimelineGridDirective"]; });

/* harmony import */ var _timelineanimationrow_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./timelineanimationrow.component */ "./src/app/modules/editor/components/layertimeline/timelineanimationrow.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineAnimationRowComponent", function() { return _timelineanimationrow_component__WEBPACK_IMPORTED_MODULE_3__["TimelineAnimationRowComponent"]; });







/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/layerlisttree.component.html":
/*!**************************************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/layerlisttree.component.html ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<ng-container *ngIf=\"(this.layerModel$ | async) as model\">\n  <div class=\"slt-layer slt-layer-type-{{ this.layer.type }}\"\n    fxLayout=\"row\"\n    fxLayoutAlign=\"start center\"\n    [ngClass]=\"{\n      'is-selected': model.isSelected,\n      'is-hovered': model.isHovered,\n      'is-disabled': model.isActionMode\n    }\"\n    (click)=\"this.onLayerClick($event, this.layer)\"\n    (dblclick)=\"this.onLayerToggleExpanded($event, this.layer)\"\n    (mousedown)=\"this.onLayerMouseDown($event, this.layer)\">\n    <button mat-icon-button\n      *ngIf=\"model.isExpandable\"\n      (click)=\"this.onLayerToggleExpanded($event, this.layer)\"\n      [disabled]=\"model.isActionMode\"\n      matTooltip=\"{{ model.isExpanded ? 'Collapse layer' : 'Expand layer' }}\"\n      matTooltipPosition=\"right\"\n      matTooltipShowDelay=\"1000\">\n      <mat-icon>{{ model.isExpanded ? 'expand_more' : 'chevron_right' }}</mat-icon>\n    </button>\n    <!-- Add extra 20px margin if the expand/collapse icon isn't being displayed -->\n    <mat-icon svgIcon=\"{{ this.layer.type }}\"\n      [style.margin-left]=\"model.isExpandable ? '0px' : '20px'\">\n    </mat-icon>\n    <span class=\"slt-layer-id-text\"\n      fxFlex>\n      {{ this.layer.name }}\n    </span>\n    <!-- Show overflow options. -->\n    <mat-menu #showOverflowOptionsMenu=\"matMenu\">\n      <button *ngIf=\"model.canBeConvertedToClipPath\"\n        (click)=\"this.onConvertToClipPathClick($event, layer)\"\n        mat-menu-item>\n        Convert to clip path\n      </button>\n      <button *ngIf=\"model.canBeConvertedToPath\"\n        (click)=\"this.onConvertToPathClick($event, layer)\"\n        mat-menu-item>\n        Convert to path\n      </button>\n      <button *ngIf=\"model.canBeFlattened\"\n        (click)=\"this.onFlattenGroupClick($event, layer)\"\n        mat-menu-item>\n        Flatten group\n      </button>\n    </mat-menu>\n    <button mat-icon-button\n      *ngIf=\"model.canBeConvertedToClipPath || model.canBeConvertedToPath || model.canBeFlattened\"\n      class=\"slt-layer-action-button slt-layer-more-actions\"\n      (click)=\"$event.stopPropagation()\"\n      [disabled]=\"model.isActionMode\"\n      [matMenuTriggerFor]=\"showOverflowOptionsMenu\">\n      <mat-icon>more_vert</mat-icon>\n    </button>\n    <!-- Visibility toggle. -->\n    <button mat-icon-button\n      class=\"slt-layer-action-button slt-layer-visibility-toggle\"\n      (click)=\"this.onLayerToggleVisibility($event, this.layer)\"\n      [disabled]=\"model.isActionMode\"\n      matTooltip=\"{{ model.isVisible ? 'Hide layer' : 'Show layer' }}\"\n      matTooltipPosition=\"below\"\n      matTooltipShowDelay=\"1000\"\n      [ngClass]=\"{'is-checked': model.isVisible}\">\n      <mat-icon>{{ model.isVisible ? 'visibility' : 'visibility_off' }}</mat-icon>\n    </button>\n    <!-- Animate layer. -->\n    <mat-menu #addTimelineBlockMenu=\"matMenu\">\n      <button *ngFor=\"let propertyName of model.availablePropertyNames\"\n        (click)=\"this.onAddTimelineBlockClick($event, layer, propertyName)\"\n        mat-menu-item>\n        {{ propertyName }}\n      </button>\n    </mat-menu>\n    <button mat-icon-button\n      *ngIf=\"model.availablePropertyNames.length > 0\"\n      class=\"slt-layer-action-button\"\n      (click)=\"$event.stopPropagation()\"\n      [disabled]=\"model.isActionMode\"\n      matTooltip=\"Animate this layer\"\n      matTooltipPosition=\"below\"\n      matTooltipShowDelay=\"1000\"\n      [matMenuTriggerFor]=\"addTimelineBlockMenu\">\n      <mat-icon svgIcon=\"animationblock\"></mat-icon>\n    </button>\n  </div>\n\n  <!-- List the property names that have been animated. -->\n  <div class=\"slt-properties\"\n    *ngIf=\"model.isExpanded && model.existingPropertyNames.length > 0\">\n    <div class=\"slt-property\"\n      fxLayout=\"row\"\n      fxLayoutAlign=\"start center\"\n      *ngFor=\"let propertyName of model.existingPropertyNames\">\n      <span class=\"slt-property-name\">{{ propertyName }}</span>\n      <button mat-icon-button\n        class=\"slt-property-add-timeline-block-button\"\n        (click)=\"this.onAddTimelineBlockClick($event, layer, propertyName)\"\n        [disabled]=\"model.isActionMode\"\n        matTooltip=\"Add another animation\"\n        matTooltipPosition=\"below\"\n        matTooltipShowDelay=\"1000\">\n        <mat-icon>add</mat-icon>\n      </button>\n    </div>\n  </div>\n\n  <!-- List the layer's children if it is expanded. -->\n  <ul *ngIf=\"model.isExpanded && this.layer.children.length > 0\"\n    class=\"slt-children\">\n    <li *ngFor=\"let child of this.layer.children; trackBy: this.trackLayerFn\"\n      class=\"slt-layer-container\"\n      [attr.data-layer-id]=\"child.id\">\n      <app-layerlisttree [layer]=\"child\"\n        (layerMouseDown)=\"this.onLayerMouseDown($event.event, $event.layer)\"\n        (layerClick)=\"this.onLayerClick($event.event, $event.layer)\"\n        (layerToggleExpanded)=\"this.onLayerToggleExpanded($event.event, $event.layer)\"\n        (layerToggleVisibility)=\"this.onLayerToggleVisibility($event.event, $event.layer)\"\n        (addTimelineBlockClick)=\"this.onAddTimelineBlockClick($event.event, $event.layer, $event.propertyName)\"\n        (convertToClipPathClick)=\"this.onConvertToClipPathClick($event.event, $event.layer)\"\n        (convertToPathClick)=\"this.onConvertToPathClick($event.event, $event.layer)\"\n        (flattenGroupClick)=\"this.onFlattenGroupClick($event.event, $event.layer)\">\n      </app-layerlisttree>\n    </li>\n  </ul>\n</ng-container>"

/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/layerlisttree.component.scss":
/*!**************************************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/layerlisttree.component.scss ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ":host {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none; }\n\nul {\n  margin: 0;\n  padding: 0; }\n\nli {\n  list-style: none; }\n\n.slt-layer {\n  box-sizing: border-box;\n  height: 20px;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  padding: 2px;\n  font-size: 12px;\n  cursor: pointer;\n  outline: none;\n  border-radius: 2px 0 0 2px; }\n\n.slt-layer.is-selected {\n    box-shadow: none; }\n\n.slt-layer.is-disabled {\n    cursor: default; }\n\n.slt-layer span.slt-layer-id-text {\n    flex: 1 1 0;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    margin-left: 4px; }\n\n.slt-layer mat-icon {\n    width: 16px;\n    height: 16px;\n    font-size: 16px; }\n\n.slt-layer button {\n    line-height: 16px;\n    height: 20px;\n    width: 20px;\n    min-height: 20px; }\n\n.slt-layer button[mat-icon-button] mat-icon {\n      line-height: normal;\n      vertical-align: top; }\n\n.slt-layer-type-group,\n.slt-layer-type-vector {\n  font-weight: 500; }\n\n.slt-children {\n  padding: 0;\n  margin: 0 0 0 20px; }\n\n.slt-layer:hover .slt-layer-action-button[disabled].is-checked {\n  opacity: 0; }\n\n.slt-layer:hover .slt-layer-action-button:not([disabled]) {\n  opacity: 1; }\n\n.slt-layer.is-selected .slt-layer-action-button {\n  opacity: 1; }\n\n.slt-layer-expanded-toggle {\n  margin: 0;\n  padding: 2px;\n  height: 20px;\n  width: 20px;\n  line-height: 16px;\n  min-height: 20px;\n  visibility: hidden; }\n\n.slt-layer-expanded-toggle mat-icon {\n    vertical-align: top; }\n\n.slt-layer-expanded-toggle.is-visible {\n    visibility: visible; }\n\n.slt-layer-id {\n  flex: 1 1 0;\n  min-width: 0;\n  overflow: hidden;\n  text-overflow: ellipsis; }\n\n.slt-layer-action-button {\n  margin: 0;\n  padding: 2px;\n  height: 20px;\n  width: 20px;\n  line-height: 16px;\n  min-height: 20px;\n  opacity: 0.2; }\n\n.slt-layer-action-button mat-icon {\n    vertical-align: top; }\n\n.slt-layer-action-button[disabled] {\n    opacity: 0; }\n\nmat-menu {\n  display: flex; }\n\n.slt-layer-visibility-toggle.is-checked {\n  opacity: 0; }\n\n.slt-layer-visibility-toggle:not(.is-checked) {\n  opacity: 0.7; }\n\n.slt-layer-more-actions {\n  opacity: 0; }\n\n.slt-layer-type-group {\n  font-weight: 500; }\n\n.slt-properties {\n  margin-top: 4px;\n  margin-bottom: 4px;\n  margin-left: 40px;\n  margin-right: -2px;\n  padding-right: 2px;\n  border-radius: 2px; }\n\n.slt-property {\n  padding-left: 8px;\n  font-size: 12px; }\n\n.slt-property .slt-property-name {\n    flex: 1 1 0;\n    min-width: 0;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n\n.slt-property button {\n    margin: 2px;\n    padding: 2px;\n    line-height: 16px;\n    height: 20px;\n    width: 20px;\n    min-height: 20px; }\n\n.slt-property button[mat-icon-button] mat-icon {\n      width: 16px;\n      height: 16px;\n      font-size: 16px;\n      line-height: normal;\n      vertical-align: top; }\n\n.slt-layers-list-drag-indicator {\n  position: absolute;\n  height: 2px;\n  left: 0;\n  right: 0;\n  margin-top: -1px;\n  pointer-events: none; }\n\n.slt-layers-list-drag-indicator::before {\n    position: absolute;\n    content: '';\n    left: -4px;\n    top: -3px;\n    height: 8px;\n    width: 8px;\n    border-radius: 50%; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL2xheWVydGltZWxpbmUvbGF5ZXJsaXN0dHJlZS5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLDBCQUFpQjtLQUFqQix1QkFBaUI7TUFBakIsc0JBQWlCO1VBQWpCLGtCQUFpQixFQUNsQjs7QUFFRDtFQUNFLFVBQVM7RUFDVCxXQUFVLEVBQ1g7O0FBRUQ7RUFDRSxpQkFBZ0IsRUFDakI7O0FBRUQ7RUFDRSx1QkFBc0I7RUFDdEIsYUFBWTtFQUNaLGNBQWE7RUFDYixvQkFBbUI7RUFDbkIsb0JBQW1CO0VBQ25CLGFBQVk7RUFDWixnQkFBZTtFQUNmLGdCQUFlO0VBQ2YsY0FBYTtFQUNiLDJCQUEwQixFQStCM0I7O0FBekNEO0lBWUksaUJBQWdCLEVBQ2pCOztBQWJIO0lBZUksZ0JBQWUsRUFDaEI7O0FBaEJIO0lBa0JJLFlBQVc7SUFDWCxhQUFZO0lBQ1osaUJBQWdCO0lBQ2hCLHdCQUF1QjtJQUN2QixpQkFBZ0IsRUFDakI7O0FBdkJIO0lBeUJJLFlBQVc7SUFDWCxhQUFZO0lBQ1osZ0JBQWUsRUFDaEI7O0FBNUJIO0lBOEJJLGtCQUFpQjtJQUNqQixhQUFZO0lBQ1osWUFBVztJQUNYLGlCQUFnQixFQU9qQjs7QUF4Q0g7TUFvQ1Esb0JBQW1CO01BQ25CLG9CQUFtQixFQUNwQjs7QUFLUDs7RUFFRSxpQkFBZ0IsRUFDakI7O0FBRUQ7RUFDRSxXQUFVO0VBQ1YsbUJBQWtCLEVBQ25COztBQWNEO0VBR00sV0FBVSxFQUNYOztBQUpMO0VBTU0sV0FBVSxFQUNYOztBQUlMO0VBRUksV0FBVSxFQUNYOztBQUdIO0VBNUJFLFVBQVM7RUFDVCxhQUFZO0VBQ1osYUFBWTtFQUNaLFlBQVc7RUFDWCxrQkFBaUI7RUFDakIsaUJBQWdCO0VBeUJoQixtQkFBa0IsRUFJbkI7O0FBNUJDO0lBQ0Usb0JBQW1CLEVBQ3BCOztBQW9CSDtJQUlJLG9CQUFtQixFQUNwQjs7QUFHSDtFQUNFLFlBQVc7RUFDWCxhQUFZO0VBQ1osaUJBQWdCO0VBQ2hCLHdCQUF1QixFQUN4Qjs7QUFFRDtFQTNDRSxVQUFTO0VBQ1QsYUFBWTtFQUNaLGFBQVk7RUFDWixZQUFXO0VBQ1gsa0JBQWlCO0VBQ2pCLGlCQUFnQjtFQXdDaEIsYUFBWSxFQUliOztBQTNDQztJQUNFLG9CQUFtQixFQUNwQjs7QUFtQ0g7SUFJSSxXQUFVLEVBQ1g7O0FBR0g7RUFDRSxjQUFhLEVBQ2Q7O0FBRUQ7RUFFSSxXQUFVLEVBQ1g7O0FBSEg7RUFLSSxhQUFZLEVBQ2I7O0FBR0g7RUFDRSxXQUFVLEVBQ1g7O0FBRUQ7RUFDRSxpQkFBZ0IsRUFDakI7O0FBRUQ7RUFDRSxnQkFBZTtFQUNmLG1CQUFrQjtFQUNsQixrQkFBaUI7RUFDakIsbUJBQWtCO0VBQ2xCLG1CQUFrQjtFQUNsQixtQkFBa0IsRUFDbkI7O0FBRUQ7RUFDRSxrQkFBaUI7RUFDakIsZ0JBQWUsRUF3QmhCOztBQTFCRDtJQUlJLFlBQVc7SUFDWCxhQUFZO0lBQ1osaUJBQWdCO0lBQ2hCLHdCQUF1QixFQUN4Qjs7QUFSSDtJQVVJLFlBQVc7SUFDWCxhQUFZO0lBQ1osa0JBQWlCO0lBQ2pCLGFBQVk7SUFDWixZQUFXO0lBQ1gsaUJBQWdCLEVBVWpCOztBQXpCSDtNQWtCUSxZQUFXO01BQ1gsYUFBWTtNQUNaLGdCQUFlO01BQ2Ysb0JBQW1CO01BQ25CLG9CQUFtQixFQUNwQjs7QUFLUDtFQUNFLG1CQUFrQjtFQUNsQixZQUFXO0VBQ1gsUUFBTztFQUNQLFNBQVE7RUFDUixpQkFBZ0I7RUFDaEIscUJBQW9CLEVBVXJCOztBQWhCRDtJQVFJLG1CQUFrQjtJQUNsQixZQUFXO0lBQ1gsV0FBVTtJQUNWLFVBQVM7SUFDVCxZQUFXO0lBQ1gsV0FBVTtJQUNWLG1CQUFrQixFQUNuQiIsImZpbGUiOiJzcmMvYXBwL21vZHVsZXMvZWRpdG9yL2NvbXBvbmVudHMvbGF5ZXJ0aW1lbGluZS9sYXllcmxpc3R0cmVlLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiOmhvc3Qge1xuICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cblxudWwge1xuICBtYXJnaW46IDA7XG4gIHBhZGRpbmc6IDA7XG59XG5cbmxpIHtcbiAgbGlzdC1zdHlsZTogbm9uZTtcbn1cblxuLnNsdC1sYXllciB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIGhlaWdodDogMjBweDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgcGFkZGluZzogMnB4O1xuICBmb250LXNpemU6IDEycHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgb3V0bGluZTogbm9uZTtcbiAgYm9yZGVyLXJhZGl1czogMnB4IDAgMCAycHg7XG4gICYuaXMtc2VsZWN0ZWQge1xuICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gIH1cbiAgJi5pcy1kaXNhYmxlZCB7XG4gICAgY3Vyc29yOiBkZWZhdWx0O1xuICB9XG4gIHNwYW4uc2x0LWxheWVyLWlkLXRleHQge1xuICAgIGZsZXg6IDEgMSAwO1xuICAgIG1pbi13aWR0aDogMDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XG4gIH1cbiAgbWF0LWljb24ge1xuICAgIHdpZHRoOiAxNnB4O1xuICAgIGhlaWdodDogMTZweDtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gIH1cbiAgYnV0dG9uIHtcbiAgICBsaW5lLWhlaWdodDogMTZweDtcbiAgICBoZWlnaHQ6IDIwcHg7XG4gICAgd2lkdGg6IDIwcHg7XG4gICAgbWluLWhlaWdodDogMjBweDtcbiAgICAmW21hdC1pY29uLWJ1dHRvbl0ge1xuICAgICAgbWF0LWljb24ge1xuICAgICAgICBsaW5lLWhlaWdodDogbm9ybWFsO1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4uc2x0LWxheWVyLXR5cGUtZ3JvdXAsXG4uc2x0LWxheWVyLXR5cGUtdmVjdG9yIHtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbn1cblxuLnNsdC1jaGlsZHJlbiB7XG4gIHBhZGRpbmc6IDA7XG4gIG1hcmdpbjogMCAwIDAgMjBweDtcbn1cblxuQG1peGluIGxheWVyLWxpc3QtYnV0dG9uIHtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAycHg7XG4gIGhlaWdodDogMjBweDtcbiAgd2lkdGg6IDIwcHg7XG4gIGxpbmUtaGVpZ2h0OiAxNnB4O1xuICBtaW4taGVpZ2h0OiAyMHB4O1xuICBtYXQtaWNvbiB7XG4gICAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgfVxufVxuXG4uc2x0LWxheWVyOmhvdmVyIHtcbiAgLnNsdC1sYXllci1hY3Rpb24tYnV0dG9uIHtcbiAgICAmW2Rpc2FibGVkXS5pcy1jaGVja2VkIHtcbiAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuICAgICY6bm90KFtkaXNhYmxlZF0pIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgfVxuICB9XG59XG5cbi5zbHQtbGF5ZXIuaXMtc2VsZWN0ZWQge1xuICAuc2x0LWxheWVyLWFjdGlvbi1idXR0b24ge1xuICAgIG9wYWNpdHk6IDE7XG4gIH1cbn1cblxuLnNsdC1sYXllci1leHBhbmRlZC10b2dnbGUge1xuICBAaW5jbHVkZSBsYXllci1saXN0LWJ1dHRvbjtcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICAmLmlzLXZpc2libGUge1xuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gIH1cbn1cblxuLnNsdC1sYXllci1pZCB7XG4gIGZsZXg6IDEgMSAwO1xuICBtaW4td2lkdGg6IDA7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xufVxuXG4uc2x0LWxheWVyLWFjdGlvbi1idXR0b24ge1xuICBAaW5jbHVkZSBsYXllci1saXN0LWJ1dHRvbjtcbiAgb3BhY2l0eTogMC4yO1xuICAmW2Rpc2FibGVkXSB7XG4gICAgb3BhY2l0eTogMDtcbiAgfVxufVxuXG5tYXQtbWVudSB7XG4gIGRpc3BsYXk6IGZsZXg7XG59XG5cbi5zbHQtbGF5ZXItdmlzaWJpbGl0eS10b2dnbGUge1xuICAmLmlzLWNoZWNrZWQge1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cbiAgJjpub3QoLmlzLWNoZWNrZWQpIHtcbiAgICBvcGFjaXR5OiAwLjc7XG4gIH1cbn1cblxuLnNsdC1sYXllci1tb3JlLWFjdGlvbnMge1xuICBvcGFjaXR5OiAwO1xufVxuXG4uc2x0LWxheWVyLXR5cGUtZ3JvdXAge1xuICBmb250LXdlaWdodDogNTAwO1xufVxuXG4uc2x0LXByb3BlcnRpZXMge1xuICBtYXJnaW4tdG9wOiA0cHg7XG4gIG1hcmdpbi1ib3R0b206IDRweDtcbiAgbWFyZ2luLWxlZnQ6IDQwcHg7IC8vIGluZGVudCBieSBib3RoIHRoZSBpY29uICgyMHB4KSBhbmQgZXhwYW5kIHRvZ2dsZSAoMjBweClcbiAgbWFyZ2luLXJpZ2h0OiAtMnB4OyAvLyBoaWRlIGluc2V0IHNoYWRvd1xuICBwYWRkaW5nLXJpZ2h0OiAycHg7IC8vIG9mZnNldCBtYXJnaW5cbiAgYm9yZGVyLXJhZGl1czogMnB4O1xufVxuXG4uc2x0LXByb3BlcnR5IHtcbiAgcGFkZGluZy1sZWZ0OiA4cHg7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgLnNsdC1wcm9wZXJ0eS1uYW1lIHtcbiAgICBmbGV4OiAxIDEgMDtcbiAgICBtaW4td2lkdGg6IDA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgfVxuICBidXR0b24ge1xuICAgIG1hcmdpbjogMnB4O1xuICAgIHBhZGRpbmc6IDJweDtcbiAgICBsaW5lLWhlaWdodDogMTZweDtcbiAgICBoZWlnaHQ6IDIwcHg7XG4gICAgd2lkdGg6IDIwcHg7XG4gICAgbWluLWhlaWdodDogMjBweDtcbiAgICAmW21hdC1pY29uLWJ1dHRvbl0ge1xuICAgICAgbWF0LWljb24ge1xuICAgICAgICB3aWR0aDogMTZweDtcbiAgICAgICAgaGVpZ2h0OiAxNnB4O1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiBub3JtYWw7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi5zbHQtbGF5ZXJzLWxpc3QtZHJhZy1pbmRpY2F0b3Ige1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGhlaWdodDogMnB4O1xuICBsZWZ0OiAwO1xuICByaWdodDogMDtcbiAgbWFyZ2luLXRvcDogLTFweDtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICY6OmJlZm9yZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGNvbnRlbnQ6ICcnO1xuICAgIGxlZnQ6IC00cHg7XG4gICAgdG9wOiAtM3B4O1xuICAgIGhlaWdodDogOHB4O1xuICAgIHdpZHRoOiA4cHg7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICB9XG59XG4iXX0= */"

/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/layerlisttree.component.ts":
/*!************************************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/layerlisttree.component.ts ***!
  \************************************************************************************/
/*! exports provided: LayerListTreeComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerListTreeComponent", function() { return LayerListTreeComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/model/timeline */ "./src/app/modules/editor/model/timeline/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store/common/selectors */ "./src/app/modules/editor/store/common/selectors.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");










var LayerListTreeComponent = /** @class */ (function () {
    function LayerListTreeComponent(store, actionModeService) {
        this.store = store;
        this.actionModeService = actionModeService;
        // MouseEvents from this layer (or children layers further down the tree)
        // are recursively handled by parent components until they reach
        // the LayerTimelineComponent.
        this.layerClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.layerDoubleClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.layerMouseDown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.layerToggleExpanded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.layerToggleVisibility = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.addTimelineBlockClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.convertToClipPathClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.convertToPathClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.flattenGroupClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    LayerListTreeComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.layerModel$ = this.store.select(app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_7__["getLayerListTreeState"]).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["map"])(function (_a) {
            var animation = _a.animation, selectedLayerIds = _a.selectedLayerIds, collapsedLayerIds = _a.collapsedLayerIds, hiddenLayerIds = _a.hiddenLayerIds, hoveredLayerId = _a.hoveredLayerId, isActionMode = _a.isActionMode;
            var isExpandable = _this.isLayerExpandable();
            var availablePropertyNames = Array.from(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__["ModelUtil"].getAvailablePropertyNamesForLayer(_this.layer, animation));
            var getExistingPropertyNamesFn = function (layerId) {
                return lodash__WEBPACK_IMPORTED_MODULE_8__["keys"](app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_4__["ModelUtil"].getOrderedBlocksByPropertyByLayer(animation)[layerId]);
            };
            var existingPropertyNames = getExistingPropertyNamesFn(_this.layer.id);
            var canBeConvertedToPath = _this.layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["ClipPathLayer"];
            // We can't convert a path into a clip path if it has incompatible animation blocks.
            var canBeConvertedToClipPath = _this.layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["PathLayer"] &&
                // TODO: comparing the sets of all animatable properties for each layer type would be more robust
                !animation.blocks.some(function (b) { return !(b instanceof app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_3__["PathAnimationBlock"]); });
            var canBeFlattened = _this.layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["GroupLayer"] &&
                _this.layer.children.length > 0 &&
                // TODO: allow merging groups w/ existing blocks in some cases?
                existingPropertyNames.length === 0 &&
                _this.layer.children.every(function (l) {
                    return (l instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["PathLayer"] ||
                        l instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["ClipPathLayer"] ||
                        // TODO: allow merging groups into groups w/ existing blocks in some cases?
                        getExistingPropertyNamesFn(l.id).length === 0);
                });
            return {
                animation: animation,
                isSelected: selectedLayerIds.has(_this.layer.id),
                isHovered: hoveredLayerId === _this.layer.id,
                isExpandable: isExpandable,
                isExpanded: !collapsedLayerIds.has(_this.layer.id),
                isVisible: !hiddenLayerIds.has(_this.layer.id),
                availablePropertyNames: availablePropertyNames,
                existingPropertyNames: existingPropertyNames,
                isActionMode: isActionMode,
                canBeConvertedToClipPath: canBeConvertedToClipPath,
                canBeConvertedToPath: canBeConvertedToPath,
                canBeFlattened: canBeFlattened,
            };
        }));
    };
    // @Override
    LayerListTreeComponent.prototype.onLayerClick = function (event, layer) {
        event.stopPropagation();
        if (!this.actionModeService.isActionMode()) {
            this.layerClick.emit({ event: event, layer: layer });
        }
    };
    // @Override
    LayerListTreeComponent.prototype.onLayerMouseDown = function (event, layer) {
        if (!this.actionModeService.isActionMode()) {
            this.layerMouseDown.emit({ event: event, layer: layer });
        }
    };
    // @Override
    LayerListTreeComponent.prototype.onLayerToggleExpanded = function (event, layer) {
        event.stopPropagation();
        if (this.isLayerExpandable()) {
            this.layerToggleExpanded.emit({ event: event, layer: layer });
        }
    };
    // @Override
    LayerListTreeComponent.prototype.onLayerToggleVisibility = function (event, layer) {
        event.stopPropagation();
        if (!this.actionModeService.isActionMode()) {
            this.layerToggleVisibility.emit({ event: event, layer: layer });
        }
    };
    // @Override
    LayerListTreeComponent.prototype.onAddTimelineBlockClick = function (event, layer, propertyName) {
        if (!this.actionModeService.isActionMode()) {
            this.addTimelineBlockClick.emit({ event: event, layer: layer, propertyName: propertyName });
        }
    };
    // @Override
    LayerListTreeComponent.prototype.onConvertToClipPathClick = function (event, layer) {
        if (!this.actionModeService.isActionMode()) {
            this.convertToClipPathClick.emit({ event: event, layer: layer });
        }
    };
    // @Override
    LayerListTreeComponent.prototype.onConvertToPathClick = function (event, layer) {
        if (!this.actionModeService.isActionMode()) {
            this.convertToPathClick.emit({ event: event, layer: layer });
        }
    };
    // @Override
    LayerListTreeComponent.prototype.onFlattenGroupClick = function (event, layer) {
        if (!this.actionModeService.isActionMode()) {
            this.flattenGroupClick.emit({ event: event, layer: layer });
        }
    };
    // Used by *ngFor loop.
    LayerListTreeComponent.prototype.trackLayerFn = function (index, layer) {
        return layer.id;
    };
    LayerListTreeComponent.prototype.isLayerExpandable = function () {
        return this.layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["VectorLayer"] || this.layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["GroupLayer"];
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["Layer"])
    ], LayerListTreeComponent.prototype, "layer", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], LayerListTreeComponent.prototype, "layerClick", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], LayerListTreeComponent.prototype, "layerDoubleClick", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], LayerListTreeComponent.prototype, "layerMouseDown", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], LayerListTreeComponent.prototype, "layerToggleExpanded", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], LayerListTreeComponent.prototype, "layerToggleVisibility", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], LayerListTreeComponent.prototype, "addTimelineBlockClick", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], LayerListTreeComponent.prototype, "convertToClipPathClick", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], LayerListTreeComponent.prototype, "convertToPathClick", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], LayerListTreeComponent.prototype, "flattenGroupClick", void 0);
    LayerListTreeComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-layerlisttree',
            template: __webpack_require__(/*! ./layerlisttree.component.html */ "./src/app/modules/editor/components/layertimeline/layerlisttree.component.html"),
            styles: [__webpack_require__(/*! ./layerlisttree.component.scss */ "./src/app/modules/editor/components/layertimeline/layerlisttree.component.scss")],
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_6__["Store"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_5__["ActionModeService"]])
    ], LayerListTreeComponent);
    return LayerListTreeComponent;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/layertimeline.component.html":
/*!**************************************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/layertimeline.component.html ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<ng-container *ngIf=\"(this.layerTimelineModel$ | async) as model\">\n  <div class=\"studio-layer-timeline mat-elevation-z8\"\n    *ngIf=\"(this.themeService.asObservable() | async) as theme\"\n    [class.dark-to-light-base100]=\"!theme.isInitialPageLoad && theme.themeType === 'light'\"\n    [class.light-to-dark-base100]=\"!theme.isInitialPageLoad && theme.themeType === 'dark'\">\n    <app-splitter [edge]=\"'top'\"\n      (split)=\"onTopSplitterChanged()\"\n      [min]=\"200\"\n      [persistId]=\"'layer-timeline'\">\n    </app-splitter>\n\n    <div class=\"slt-layers mat-elevation-z2\"\n      fxLayout=\"column\"\n      [class.dark-to-light-base100]=\"!theme.isInitialPageLoad && theme.themeType === 'light'\"\n      [class.light-to-dark-base100]=\"!theme.isInitialPageLoad && theme.themeType === 'dark'\">\n      <app-splitter [edge]=\"'right'\"\n        [min]=\"200\"\n        [persistId]=\"'layer-list'\">\n      </app-splitter>\n\n      <div class=\"slt-header mat-elevation-z2\"\n        fxLayout=\"row\"\n        fxLayoutAlign=\"start center\">\n\n        <!-- File menu. -->\n        <mat-menu #fileMenu=\"matMenu\">\n          <button mat-menu-item\n            (click)=\"this.onNewWorkspaceClick()\">\n            New\n          </button>\n          <button mat-menu-item\n            (click)=\"this.onLaunchFilePickerClick($event, 'openFileButton')\">\n            Open\n            <input id=\"openFileButton\"\n              type=\"file\"\n              accept=\".shapeshifter\"\n              (click)=\"$event.stopPropagation()\"\n              (change)=\"this.onImportedFilesPicked($event, ($event.target || $event.srcElement).files)\">\n          </button>\n          <button mat-menu-item\n            (click)=\"this.onSaveToFileClick()\">\n            Save\n          </button>\n          <button mat-menu-item\n            (click)=\"this.onLoadDemoClick()\">\n            Demo\n          </button>\n        </mat-menu>\n        <button class=\"slt-layers-menu-group-button\"\n          (click)=\"$event.stopPropagation()\"\n          [matMenuTriggerFor]=\"fileMenu\">\n          File\n        </button>\n\n        <!-- Import menu. -->\n        <mat-menu #importMenu=\"matMenu\">\n          <button mat-menu-item\n            (click)=\"this.onLaunchFilePickerClick($event, 'addPathsFromSvgButton')\">\n            SVG\n            <input multiple\n              id=\"addPathsFromSvgButton\"\n              type=\"file\"\n              accept=\".svg\"\n              (click)=\"$event.stopPropagation()\"\n              (change)=\"this.onImportedFilesPicked($event, ($event.target || $event.srcElement).files)\">\n          </button>\n          <button mat-menu-item\n            (click)=\"this.onLaunchFilePickerClick($event, 'addPathsFromXmlButton')\">\n            Vector Drawable\n            <input multiple\n              id=\"addPathsFromXmlButton\"\n              type=\"file\"\n              accept=\".xml\"\n              (click)=\"$event.stopPropagation()\"\n              (change)=\"this.onImportedFilesPicked($event, ($event.target || $event.srcElement).files)\">\n          </button>\n        </mat-menu>\n        <button class=\"slt-layers-menu-group-button\"\n          (click)=\"$event.stopPropagation()\"\n          [ngClass]=\"{'is-disabled': model.isActionMode}\"\n          [disabled]=\"model.isActionMode\"\n          [matMenuTriggerFor]=\"importMenu\">\n          Import\n        </button>\n\n        <!-- Export menu. -->\n        <mat-menu #exportMenu=\"matMenu\">\n          <button mat-menu-item\n            (click)=\"this.onExportSvgClick()\">\n            SVG\n          </button>\n          <button mat-menu-item\n            (click)=\"this.onExportVectorDrawableClick()\">\n            Vector Drawable\n          </button>\n          <button mat-menu-item\n            (click)=\"this.onExportAnimatedVectorDrawableClick()\">\n            Animated Vector Drawable\n          </button>\n          <button mat-menu-item\n            (click)=\"this.onExportSvgSpritesheetClick()\">\n            SVG spritesheet\n          </button>\n          <!--<button mat-menu-item\n          [disabled]=\"true\"\n          (click)=\"this.onExportCssKeyframesClick()\">\n          CSS keyframes\n        </button>-->\n        </mat-menu>\n        <button class=\"slt-layers-menu-group-button\"\n          (click)=\"$event.stopPropagation()\"\n          [ngClass]=\"{'is-disabled': model.isActionMode}\"\n          [disabled]=\"model.isActionMode\"\n          [matMenuTriggerFor]=\"exportMenu\">\n          Export\n        </button>\n\n        <div fxFlex></div>\n\n        <!-- Add layer menu. -->\n        <mat-menu #addLayerMenu=\"matMenu\">\n          <button mat-menu-item\n            (click)=\"this.onAddPathLayerClick()\">\n            New path\n          </button>\n          <button mat-menu-item\n            (click)=\"this.onAddClipPathLayerClick()\">\n            New clip path\n          </button>\n          <button mat-menu-item\n            (click)=\"this.onAddGroupLayerClick()\">\n            New group layer\n          </button>\n        </mat-menu>\n        <button mat-icon-button\n          (click)=\"$event.stopPropagation()\"\n          matTooltip=\"Add layer\"\n          matTooltipPosition=\"below\"\n          matTooltipShowDelay=\"500\"\n          [disabled]=\"model.isActionMode\"\n          [matMenuTriggerFor]=\"addLayerMenu\">\n          <mat-icon svgIcon=\"addlayer\"></mat-icon>\n        </button>\n      </div>\n\n      <div appScrollGroup=\"timeline\"\n        class=\"slt-layers-list-scroller\"\n        fxFlex>\n        <!-- Layer list. -->\n        <div class=\"slt-layers-list\">\n          <!-- Note the *ngFor loop is intentional here even though there is only\n             ever one layer in the list. We use it because it allows us to recreate\n             the component from scratch when the layer id changes (i.e. when\n             the workspace is reset). -->\n          <app-layerlisttree fxLayout=\"column\"\n            class=\"slt-layer-container\"\n            *ngFor=\"let vectorLayer of [model.vectorLayer]; trackBy: trackLayerFn\"\n            [layer]=\"vectorLayer\"\n            (layerClick)=\"this.onLayerClick($event.event, $event.layer)\"\n            (layerToggleExpanded)=\"this.onLayerToggleExpanded($event.event, $event.layer)\"\n            (layerToggleVisibility)=\"this.onLayerToggleVisibility($event.event, $event.layer)\"\n            (layerMouseDown)=\"this.onLayerMouseDown($event.event, $event.layer)\"\n            (addTimelineBlockClick)=\"this.onAddTimelineBlockClick($event.event, $event.layer, $event.propertyName)\"\n            (convertToClipPathClick)=\"this.onConvertToClipPathClick($event.event, $event.layer)\"\n            (convertToPathClick)=\"this.onConvertToPathClick($event.event, $event.layer)\"\n            (flattenGroupClick)=\"this.onFlattenGroupClick($event.event, $event.layer)\">\n          </app-layerlisttree>\n        </div>\n        <div *ngIf=\"(this.dragIndicatorObservable | async) as dragData\"\n          class=\"slt-layers-list-drag-indicator\"\n          [ngStyle]=\"{\n            'display': dragData.isVisible ? 'block' : 'none',\n            'left': dragData.left + 'px',\n            'top': dragData.top + 'px'\n          }\">\n        </div>\n        <div class=\"slt-layers-empty\"\n          *ngIf=\"model.vectorLayer.children.length === 0 && model.animation.blocks.length === 0\">\n          To get started, drag + drop an SVG file here\n        </div>\n      </div>\n    </div>\n\n    <!-- Animation timeline. -->\n    <div #timeline\n      class=\"slt-timeline\"\n      (mousewheel)=\"this.onWheelEvent($event)\">\n      <div #timelineAnimation\n        *ngIf=\"{ horizZoom: (this.horizZoomObservable | async) } as animationData\"\n        class=\"slt-timeline-animation is-active\"\n        [ngStyle]=\"{'width': (model.animation.duration * animationData.horizZoom + 40) + 'px'}\"\n        fxLayout=\"column\">\n        <div class=\"slt-header mat-elevation-z2\">\n          <div fxLayout=\"row\"\n            fxLayoutAlign=\"start center\">\n            <div class=\"slt-timeline-animation-meta\"\n              [class.is-disabled]=\"model.isActionMode\"\n              [class.is-selected]=\"model.isAnimationSelected\"\n              (click)=\"this.onAnimationHeaderTextClick($event)\">\n              <span class=\"slt-timeline-animation-name\"\n                [class.is-disabled]=\"model.isActionMode\">\n                {{ model.animation.name }}\n              </span>\n              <span class=\"slt-timeline-animation-duration\"\n                [class.is-disabled]=\"model.isActionMode\">\n                {{ model.animation.duration }}ms\n              </span>\n            </div>\n            <button mat-icon-button\n              (click)=\"this.onZoomToFitClick($event)\"\n              matTooltip=\"Zoom to fit ({{ this.shortcutService.getZoomToFitText() }})\"\n              matTooltipPosition=\"below\"\n              matTooltipShowDelay=\"500\">\n              <mat-icon>zoom_out_map</mat-icon>\n            </button>\n          </div>\n          <canvas appLayerTimelineGrid\n            class=\"slt-timeline-header-grid\"\n            [class.dark-to-light-base100]=\"!theme.isInitialPageLoad && theme.themeType === 'light'\"\n            [class.light-to-dark-base100]=\"!theme.isInitialPageLoad && theme.themeType === 'dark'\"\n            [animation]=\"model.animation\"\n            [horizZoom]=\"animationData.horizZoom\"\n            [isHeader]=\"true\"\n            (scrub)=\"this.onTimelineHeaderScrub($event)\">\n          </canvas>\n        </div>\n        <canvas appLayerTimelineGrid\n          class=\"slt-timeline-grid\"\n          [isHeader]=\"false\"\n          [animation]=\"model.animation\"\n          [horizZoom]=\"animationData.horizZoom\">\n        </canvas>\n\n        <div appScrollGroup=\"timeline\"\n          class=\"slt-timeline-animation-scroller\">\n          <div class=\"slt-timeline-animation-rows\">\n            <!-- Note the *ngFor loop is intentional here even though there is only\n               ever one layer in the list. We use it because it allows us to recreate\n               the component from scratch when the layer id changes (i.e. when\n               the workspace is reset). -->\n            <app-timelineanimationrow *ngFor=\"let vl of [model.vectorLayer]; trackBy: trackLayerFn\"\n              [layer]=\"vl\"\n              (timelineBlockMouseDown)=\"this.onTimelineBlockMouseDown($event.event, $event.block)\"\n              (timelineBlockClick)=\"this.onTimelineBlockClick($event.event, $event.block)\"\n              (timelineBlockDoubleClick)=\"this.onTimelineBlockDoubleClick($event.event, $event.block)\">\n            </app-timelineanimationrow>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>"

/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/layertimeline.component.scss":
/*!**************************************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/layertimeline.component.scss ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".studio-layer-timeline {\n  height: 300px;\n  display: flex;\n  flex-direction: row;\n  flex-shrink: 0;\n  overflow: hidden;\n  z-index: 1;\n  position: relative; }\n  .studio-layer-timeline ul {\n    margin: 0;\n    padding: 0; }\n  .studio-layer-timeline li {\n    list-style: none; }\n  .studio-layer-timeline .slt-layers-list {\n    z-index: 2; }\n  .studio-layer-timeline .slt-layer-container {\n    padding-top: 8px; }\n  .studio-layer-timeline .slt-layer {\n    box-sizing: border-box;\n    line-height: 20px;\n    height: 20px; }\n  .studio-layer-timeline .slt-layers {\n    width: 300px;\n    position: relative;\n    z-index: 3;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    flex: 0 0 auto; }\n  .studio-layer-timeline .slt-layers mat-icon {\n      width: 16px;\n      height: 16px;\n      font-size: 16px; }\n  .studio-layer-timeline .slt-layers .slt-layers-list-scroller {\n      position: relative;\n      overflow-x: hidden;\n      overflow-y: auto;\n      -ms-overflow-style: none; }\n  .studio-layer-timeline .slt-layers .slt-layers-list-scroller::-webkit-scrollbar {\n        display: none; }\n  .studio-layer-timeline .slt-layers .slt-layers-list {\n      padding-left: 8px; }\n  .studio-layer-timeline .slt-layers mat-menu {\n      display: flex; }\n  .studio-layer-timeline .slt-layers .slt-header {\n      padding: 0 0 0 4px;\n      overflow: hidden; }\n  .studio-layer-timeline .slt-layers .slt-header .slt-layers-menu-group-button {\n        position: relative;\n        cursor: pointer;\n        border: 0;\n        height: 40px;\n        font-size: 12px;\n        font-weight: 500;\n        line-height: 40px;\n        padding: 0 8px 0 8px;\n        margin: 0;\n        outline: 0;\n        background-color: transparent; }\n  .studio-layer-timeline .slt-layers .slt-header .slt-layers-menu-group-button.is-disabled {\n          cursor: default; }\n  .studio-layer-timeline .slt-layers .slt-header button[mat-icon-button] mat-icon {\n        line-height: 0px; }\n  .studio-layer-timeline .slt-layers .slt-header button[mat-icon-button][disabled] mat-icon {\n        line-height: 0px; }\n  .studio-layer-timeline .slt-layers .slt-layers-list-drag-indicator {\n      position: absolute;\n      height: 2px;\n      left: 0;\n      right: 0;\n      margin-top: -1px;\n      pointer-events: none; }\n  .studio-layer-timeline .slt-layers .slt-layers-list-drag-indicator::before {\n        position: absolute;\n        content: '';\n        left: -4px;\n        top: -3px;\n        height: 8px;\n        width: 8px;\n        border-radius: 50%; }\n  .studio-layer-timeline .slt-layers-empty {\n    padding: 32px;\n    text-align: center;\n    font-size: 14px;\n    line-height: 20px; }\n  .studio-layer-timeline .slt-timeline {\n    overflow-x: auto;\n    overflow-y: hidden;\n    flex: 1;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    cursor: default;\n    display: flex;\n    flex-direction: row;\n    align-items: stretch; }\n  .studio-layer-timeline .slt-timeline .slt-timeline-animation-scroller {\n      position: relative;\n      overflow-x: hidden;\n      overflow-y: auto;\n      -ms-overflow-style: none; }\n  .studio-layer-timeline .slt-timeline .slt-timeline-animation-scroller::-webkit-scrollbar {\n        display: none; }\n  .studio-layer-timeline .slt-timeline .slt-timeline-animation {\n      position: relative;\n      margin-left: 4px;\n      box-sizing: content-box;\n      width: 100px;\n      overflow: hidden;\n      flex: 0 0 auto;\n      opacity: 1; }\n  .studio-layer-timeline .slt-timeline .slt-timeline-animation.is-disabled {\n        opacity: 0.5; }\n  .studio-layer-timeline .slt-timeline .slt-timeline-animation-rows {\n      padding-top: 8px;\n      padding-left: 20px;\n      padding-right: 20px;\n      z-index: 2; }\n  .studio-layer-timeline .slt-timeline .slt-timeline-grid {\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      pointer-events: none;\n      z-index: 1; }\n  .studio-layer-timeline .slt-timeline .slt-header {\n      display: flex;\n      flex-direction: column;\n      margin: 0; }\n  .studio-layer-timeline .slt-timeline .slt-header .slt-timeline-animation-meta {\n        height: 16px;\n        line-height: 16px;\n        margin: 2px -4px;\n        padding: 0 4px;\n        border-radius: 2px;\n        cursor: pointer;\n        outline: 0;\n        align-self: flex-start;\n        display: flex;\n        flex-direction: row; }\n  .studio-layer-timeline .slt-timeline .slt-header .slt-timeline-animation-meta.is-disabled {\n          cursor: default; }\n  .studio-layer-timeline .slt-timeline .slt-header .slt-timeline-animation-name {\n        margin-right: 4px;\n        font-weight: 500; }\n  .studio-layer-timeline .slt-timeline .slt-header .slt-timeline-header-grid {\n        position: absolute;\n        left: 0;\n        top: 50%;\n        width: 100%;\n        height: 50%;\n        z-index: 1;\n        cursor: pointer; }\n  .studio-layer-timeline .slt-timeline .slt-header mat-icon {\n        width: 13px;\n        height: 13px;\n        font-size: 13px; }\n  .studio-layer-timeline .slt-timeline .slt-header button {\n        line-height: 16px;\n        height: 16px;\n        width: 16px;\n        min-height: 16px;\n        padding-left: 1.5px;\n        padding-right: 1.5px;\n        padding-top: 1px;\n        padding-bottom: 1px;\n        margin-left: 4px; }\n  .studio-layer-timeline .slt-timeline .slt-header button[mat-icon-button] mat-icon {\n          line-height: normal;\n          vertical-align: top; }\n  .studio-layer-timeline .slt-header {\n    position: relative;\n    flex: 0 0 auto;\n    height: 40px;\n    box-sizing: border-box;\n    width: 100%;\n    font-size: 12px;\n    line-height: 40px;\n    padding: 0 16px;\n    z-index: 2; }\n  button[mat-menu-item] input[type='file'] {\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  opacity: 0;\n  cursor: pointer;\n  width: 0.1px;\n  height: 0.1px; }\n  button[mat-menu-item] ::-webkit-file-upload-button {\n  cursor: pointer; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL2xheWVydGltZWxpbmUvbGF5ZXJ0aW1lbGluZS5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGNBQWE7RUFDYixjQUFhO0VBQ2Isb0JBQW1CO0VBQ25CLGVBQWM7RUFDZCxpQkFBZ0I7RUFDaEIsV0FBVTtFQUNWLG1CQUFrQixFQXVObkI7RUE5TkQ7SUFXSSxVQUFTO0lBQ1QsV0FBVSxFQUNYO0VBYkg7SUFlSSxpQkFBZ0IsRUFDakI7RUFoQkg7SUFrQkksV0FBVSxFQUNYO0VBbkJIO0lBcUJJLGlCQUFnQixFQUNqQjtFQXRCSDtJQXdCSSx1QkFBc0I7SUFDdEIsa0JBQWlCO0lBQ2pCLGFBQVksRUFDYjtFQTNCSDtJQTZCSSxhQUFZO0lBQ1osbUJBQWtCO0lBQ2xCLFdBQVU7SUFDViwwQkFBaUI7T0FBakIsdUJBQWlCO1FBQWpCLHNCQUFpQjtZQUFqQixrQkFBaUI7SUFDakIsZUFBYyxFQXNFZjtFQXZHSDtNQW1DTSxZQUFXO01BQ1gsYUFBWTtNQUNaLGdCQUFlLEVBQ2hCO0VBdENMO01Bd0NNLG1CQUFrQjtNQUNsQixtQkFBa0I7TUFDbEIsaUJBQWdCO01BQ2hCLHlCQUF3QixFQUl6QjtFQS9DTDtRQTZDUSxjQUFhLEVBQ2Q7RUE5Q1A7TUFpRE0sa0JBQWlCLEVBQ2xCO0VBbERMO01Bb0RNLGNBQWEsRUFDZDtFQXJETDtNQXVETSxtQkFBa0I7TUFDbEIsaUJBQWdCLEVBNkJqQjtFQXJGTDtRQTBEUSxtQkFBa0I7UUFDbEIsZ0JBQWU7UUFDZixVQUFTO1FBQ1QsYUFyRGE7UUFzRGIsZ0JBQWU7UUFDZixpQkFBZ0I7UUFDaEIsa0JBeERhO1FBeURiLHFCQUFvQjtRQUNwQixVQUFTO1FBQ1QsV0FBVTtRQUNWLDhCQUE2QixFQUk5QjtFQXhFUDtVQXNFVSxnQkFBZSxFQUNoQjtFQXZFVDtRQTRFWSxpQkFBZ0IsRUFDakI7RUE3RVg7UUFpRlksaUJBQWdCLEVBQ2pCO0VBbEZYO01BdUZNLG1CQUFrQjtNQUNsQixZQUFXO01BQ1gsUUFBTztNQUNQLFNBQVE7TUFDUixpQkFBZ0I7TUFDaEIscUJBQW9CLEVBVXJCO0VBdEdMO1FBOEZRLG1CQUFrQjtRQUNsQixZQUFXO1FBQ1gsV0FBVTtRQUNWLFVBQVM7UUFDVCxZQUFXO1FBQ1gsV0FBVTtRQUNWLG1CQUFrQixFQUNuQjtFQXJHUDtJQXlHSSxjQUFhO0lBQ2IsbUJBQWtCO0lBQ2xCLGdCQUFlO0lBQ2Ysa0JBQWlCLEVBQ2xCO0VBN0dIO0lBK0dJLGlCQUFnQjtJQUNoQixtQkFBa0I7SUFDbEIsUUFBTztJQUNQLDBCQUFpQjtPQUFqQix1QkFBaUI7UUFBakIsc0JBQWlCO1lBQWpCLGtCQUFpQjtJQUNqQixnQkFBZTtJQUNmLGNBQWE7SUFDYixvQkFBbUI7SUFDbkIscUJBQW9CLEVBNEZyQjtFQWxOSDtNQXdITSxtQkFBa0I7TUFDbEIsbUJBQWtCO01BQ2xCLGlCQUFnQjtNQUNoQix5QkFBd0IsRUFJekI7RUEvSEw7UUE2SFEsY0FBYSxFQUNkO0VBOUhQO01BaUlNLG1CQUFrQjtNQUNsQixpQkFBZ0I7TUFDaEIsd0JBQXVCO01BQ3ZCLGFBQVk7TUFDWixpQkFBZ0I7TUFDaEIsZUFBYztNQUNkLFdBQVUsRUFJWDtFQTNJTDtRQXlJUSxhQUFZLEVBQ2I7RUExSVA7TUE2SU0saUJBQWdCO01BQ2hCLG1CQXJJMkI7TUFzSTNCLG9CQXRJMkI7TUF1STNCLFdBQVUsRUFDWDtFQWpKTDtNQW1KTSxtQkFBa0I7TUFDbEIsUUFBTztNQUNQLE9BQU07TUFDTixZQUFXO01BQ1gsYUFBWTtNQUNaLHFCQUFvQjtNQUNwQixXQUFVLEVBQ1g7RUExSkw7TUE0Sk0sY0FBYTtNQUNiLHVCQUFzQjtNQUN0QixVQUFTLEVBbURWO0VBak5MO1FBZ0tRLGFBQStCO1FBQy9CLGtCQUFvQztRQUNwQyxpQkFBZ0I7UUFDaEIsZUFBYztRQUNkLG1CQUFrQjtRQUNsQixnQkFBZTtRQUNmLFdBQVU7UUFDVix1QkFBc0I7UUFDdEIsY0FBYTtRQUNiLG9CQUFtQixFQUlwQjtFQTdLUDtVQTJLVSxnQkFBZSxFQUNoQjtFQTVLVDtRQStLUSxrQkFBaUI7UUFDakIsaUJBQWdCLEVBQ2pCO0VBakxQO1FBbUxRLG1CQUFrQjtRQUNsQixRQUFPO1FBQ1AsU0FBUTtRQUNSLFlBQVc7UUFDWCxZQUFXO1FBQ1gsV0FBVTtRQUNWLGdCQUFlLEVBQ2hCO0VBMUxQO1FBNExRLFlBQVc7UUFDWCxhQUFZO1FBQ1osZ0JBQWUsRUFDaEI7RUEvTFA7UUFpTVEsa0JBQWlCO1FBQ2pCLGFBQVk7UUFDWixZQUFXO1FBQ1gsaUJBQWdCO1FBQ2hCLG9CQUFtQjtRQUNuQixxQkFBb0I7UUFDcEIsaUJBQWdCO1FBQ2hCLG9CQUFtQjtRQUNuQixpQkFBZ0IsRUFPakI7RUFoTlA7VUE0TVksb0JBQW1CO1VBQ25CLG9CQUFtQixFQUNwQjtFQTlNWDtJQW9OSSxtQkFBa0I7SUFDbEIsZUFBYztJQUNkLGFBOU1pQjtJQStNakIsdUJBQXNCO0lBQ3RCLFlBQVc7SUFDWCxnQkFBZTtJQUNmLGtCQWxOaUI7SUFtTmpCLGdCQUFlO0lBQ2YsV0FBVSxFQUNYO0VBR0g7RUFHTSxtQkFBa0I7RUFDbEIsUUFBTztFQUNQLE9BQU07RUFDTixTQUFRO0VBQ1IsVUFBUztFQUNULFdBQVU7RUFDVixnQkFBZTtFQUNmLGFBQVk7RUFDWixjQUFhLEVBQ2Q7RUFaTDtFQWNNLGdCQUFlLEVBQ2hCIiwiZmlsZSI6InNyYy9hcHAvbW9kdWxlcy9lZGl0b3IvY29tcG9uZW50cy9sYXllcnRpbWVsaW5lL2xheWVydGltZWxpbmUuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuc3R1ZGlvLWxheWVyLXRpbWVsaW5lIHtcbiAgaGVpZ2h0OiAzMDBweDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgZmxleC1zaHJpbms6IDA7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHotaW5kZXg6IDE7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgJGhlYWRlckhlaWdodDogNDBweDtcbiAgJHRpbWVsaW5lQW5pbWF0aW9uUGFkZGluZzogMjBweDtcbiAgdWwge1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG4gIGxpIHtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICB9XG4gIC5zbHQtbGF5ZXJzLWxpc3Qge1xuICAgIHotaW5kZXg6IDI7XG4gIH1cbiAgLnNsdC1sYXllci1jb250YWluZXIge1xuICAgIHBhZGRpbmctdG9wOiA4cHg7XG4gIH1cbiAgLnNsdC1sYXllciB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgICBoZWlnaHQ6IDIwcHg7XG4gIH1cbiAgLnNsdC1sYXllcnMge1xuICAgIHdpZHRoOiAzMDBweDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgei1pbmRleDogMztcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICBmbGV4OiAwIDAgYXV0bztcbiAgICBtYXQtaWNvbiB7XG4gICAgICB3aWR0aDogMTZweDtcbiAgICAgIGhlaWdodDogMTZweDtcbiAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICB9XG4gICAgLnNsdC1sYXllcnMtbGlzdC1zY3JvbGxlciB7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICBvdmVyZmxvdy14OiBoaWRkZW47XG4gICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lO1xuICAgICAgJjo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgfVxuICAgIH1cbiAgICAuc2x0LWxheWVycy1saXN0IHtcbiAgICAgIHBhZGRpbmctbGVmdDogOHB4O1xuICAgIH1cbiAgICBtYXQtbWVudSB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgIH1cbiAgICAuc2x0LWhlYWRlciB7XG4gICAgICBwYWRkaW5nOiAwIDAgMCA0cHg7XG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgLnNsdC1sYXllcnMtbWVudS1ncm91cC1idXR0b24ge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgYm9yZGVyOiAwO1xuICAgICAgICBoZWlnaHQ6ICRoZWFkZXJIZWlnaHQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICAgICAgbGluZS1oZWlnaHQ6ICRoZWFkZXJIZWlnaHQ7XG4gICAgICAgIHBhZGRpbmc6IDAgOHB4IDAgOHB4O1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIG91dGxpbmU6IDA7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICAmLmlzLWRpc2FibGVkIHtcbiAgICAgICAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1dHRvbiB7XG4gICAgICAgICZbbWF0LWljb24tYnV0dG9uXSB7XG4gICAgICAgICAgbWF0LWljb24ge1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDBweDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJlttYXQtaWNvbi1idXR0b25dW2Rpc2FibGVkXSB7XG4gICAgICAgICAgbWF0LWljb24ge1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDBweDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLnNsdC1sYXllcnMtbGlzdC1kcmFnLWluZGljYXRvciB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBoZWlnaHQ6IDJweDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICByaWdodDogMDtcbiAgICAgIG1hcmdpbi10b3A6IC0xcHg7XG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICY6OmJlZm9yZSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgY29udGVudDogJyc7XG4gICAgICAgIGxlZnQ6IC00cHg7XG4gICAgICAgIHRvcDogLTNweDtcbiAgICAgICAgaGVpZ2h0OiA4cHg7XG4gICAgICAgIHdpZHRoOiA4cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLnNsdC1sYXllcnMtZW1wdHkge1xuICAgIHBhZGRpbmc6IDMycHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgfVxuICAuc2x0LXRpbWVsaW5lIHtcbiAgICBvdmVyZmxvdy14OiBhdXRvO1xuICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcbiAgICBmbGV4OiAxO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIGN1cnNvcjogZGVmYXVsdDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAgLnNsdC10aW1lbGluZS1hbmltYXRpb24tc2Nyb2xsZXIge1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAgIC1tcy1vdmVyZmxvdy1zdHlsZTogbm9uZTtcbiAgICAgICY6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLnNsdC10aW1lbGluZS1hbmltYXRpb24ge1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgbWFyZ2luLWxlZnQ6IDRweDtcbiAgICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICAgICAgd2lkdGg6IDEwMHB4O1xuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIGZsZXg6IDAgMCBhdXRvO1xuICAgICAgb3BhY2l0eTogMTtcbiAgICAgICYuaXMtZGlzYWJsZWQge1xuICAgICAgICBvcGFjaXR5OiAwLjU7XG4gICAgICB9XG4gICAgfVxuICAgIC5zbHQtdGltZWxpbmUtYW5pbWF0aW9uLXJvd3Mge1xuICAgICAgcGFkZGluZy10b3A6IDhweDtcbiAgICAgIHBhZGRpbmctbGVmdDogJHRpbWVsaW5lQW5pbWF0aW9uUGFkZGluZztcbiAgICAgIHBhZGRpbmctcmlnaHQ6ICR0aW1lbGluZUFuaW1hdGlvblBhZGRpbmc7XG4gICAgICB6LWluZGV4OiAyO1xuICAgIH1cbiAgICAuc2x0LXRpbWVsaW5lLWdyaWQge1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgbGVmdDogMDtcbiAgICAgIHRvcDogMDtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB6LWluZGV4OiAxO1xuICAgIH1cbiAgICAuc2x0LWhlYWRlciB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIG1hcmdpbjogMDtcbiAgICAgIC5zbHQtdGltZWxpbmUtYW5pbWF0aW9uLW1ldGEge1xuICAgICAgICBoZWlnaHQ6ICRoZWFkZXJIZWlnaHQgLyAyIC0gNHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogJGhlYWRlckhlaWdodCAvIDIgLSA0cHg7XG4gICAgICAgIG1hcmdpbjogMnB4IC00cHg7XG4gICAgICAgIHBhZGRpbmc6IDAgNHB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgb3V0bGluZTogMDtcbiAgICAgICAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgJi5pcy1kaXNhYmxlZCB7XG4gICAgICAgICAgY3Vyc29yOiBkZWZhdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAuc2x0LXRpbWVsaW5lLWFuaW1hdGlvbi1uYW1lIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgICB9XG4gICAgICAuc2x0LXRpbWVsaW5lLWhlYWRlci1ncmlkIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogNTAlO1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICB9XG4gICAgICBtYXQtaWNvbiB7XG4gICAgICAgIHdpZHRoOiAxM3B4O1xuICAgICAgICBoZWlnaHQ6IDEzcHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgIH1cbiAgICAgIGJ1dHRvbiB7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxNnB4O1xuICAgICAgICBoZWlnaHQ6IDE2cHg7XG4gICAgICAgIHdpZHRoOiAxNnB4O1xuICAgICAgICBtaW4taGVpZ2h0OiAxNnB4O1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDEuNXB4O1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiAxLjVweDtcbiAgICAgICAgcGFkZGluZy10b3A6IDFweDtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDFweDtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDRweDtcbiAgICAgICAgJlttYXQtaWNvbi1idXR0b25dIHtcbiAgICAgICAgICBtYXQtaWNvbiB7XG4gICAgICAgICAgICBsaW5lLWhlaWdodDogbm9ybWFsO1xuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLnNsdC1oZWFkZXIge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBmbGV4OiAwIDAgYXV0bztcbiAgICBoZWlnaHQ6ICRoZWFkZXJIZWlnaHQ7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgbGluZS1oZWlnaHQ6ICRoZWFkZXJIZWlnaHQ7XG4gICAgcGFkZGluZzogMCAxNnB4O1xuICAgIHotaW5kZXg6IDI7XG4gIH1cbn1cblxuYnV0dG9uIHtcbiAgJlttYXQtbWVudS1pdGVtXSB7XG4gICAgaW5wdXRbdHlwZT0nZmlsZSddIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICB0b3A6IDA7XG4gICAgICByaWdodDogMDtcbiAgICAgIGJvdHRvbTogMDtcbiAgICAgIG9wYWNpdHk6IDA7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICB3aWR0aDogMC4xcHg7XG4gICAgICBoZWlnaHQ6IDAuMXB4O1xuICAgIH1cbiAgICA6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB9XG4gIH1cbn1cbiJdfQ== */"

/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/layertimeline.component.ts":
/*!************************************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/layertimeline.component.ts ***!
  \************************************************************************************/
/*! exports provided: LayerTimelineComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerTimelineComponent", function() { return LayerTimelineComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/components/dialogs */ "./src/app/modules/editor/components/dialogs/index.ts");
/* harmony import */ var app_modules_editor_components_project__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/components/project */ "./src/app/modules/editor/components/project/index.ts");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_dragger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/scripts/dragger */ "./src/app/modules/editor/scripts/dragger/index.ts");
/* harmony import */ var app_modules_editor_scripts_intervals__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/modules/editor/scripts/intervals */ "./src/app/modules/editor/scripts/intervals/index.ts");
/* harmony import */ var app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/modules/editor/scripts/mixins */ "./src/app/modules/editor/scripts/mixins/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_services_shortcut_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/modules/editor/services/shortcut.service */ "./src/app/modules/editor/services/shortcut.service.ts");
/* harmony import */ var app_modules_editor_services_snackbar_service__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/modules/editor/services/snackbar.service */ "./src/app/modules/editor/services/snackbar.service.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/modules/editor/store/batch/actions */ "./src/app/modules/editor/store/batch/actions.ts");
/* harmony import */ var app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/modules/editor/store/common/selectors */ "./src/app/modules/editor/store/common/selectors.ts");
/* harmony import */ var app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! app/modules/editor/store/layers/actions */ "./src/app/modules/editor/store/layers/actions.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_reset_actions__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! app/modules/editor/store/reset/actions */ "./src/app/modules/editor/store/reset/actions.ts");
/* harmony import */ var app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! app/modules/editor/store/timeline/selectors */ "./src/app/modules/editor/store/timeline/selectors.ts");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./constants */ "./src/app/modules/editor/components/layertimeline/constants.ts");
/* harmony import */ var _layertimelinegrid_directive__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./layertimelinegrid.directive */ "./src/app/modules/editor/components/layertimeline/layertimelinegrid.directive.ts");



























var IS_DEV_BUILD = !environments_environment__WEBPACK_IMPORTED_MODULE_20__["environment"].production;
// Distance in pixels from a snap point before snapping to the point.
var SNAP_PIXELS = 10;
var LAYER_INDENT_PIXELS = 20;
var MIN_BLOCK_DURATION = 10;
var MAX_ZOOM = 10;
var MIN_ZOOM = 0.01;
var DEFAULT_HORIZ_ZOOM = 2; // 1ms = 2px.
var MouseActions;
(function (MouseActions) {
    // We are dragging a block to a different location on the timeline.
    MouseActions[MouseActions["Moving"] = 1] = "Moving";
    // Scales all selected blocks w/o altering their initial positions.
    MouseActions[MouseActions["ScalingUniformStart"] = 2] = "ScalingUniformStart";
    MouseActions[MouseActions["ScalingUniformEnd"] = 3] = "ScalingUniformEnd";
    // Scales all blocks and also translates their initial positions.
    MouseActions[MouseActions["ScalingTogetherStart"] = 4] = "ScalingTogetherStart";
    MouseActions[MouseActions["ScalingTogetherEnd"] = 5] = "ScalingTogetherEnd";
})(MouseActions || (MouseActions = {}));
var LayerTimelineComponent = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](LayerTimelineComponent, _super);
    function LayerTimelineComponent(fileImportService, fileExportService, snackBarService, playbackService, store, dialogService, projectService, actionModeService, shortcutService, layerTimelineService, themeService) {
        var _this = _super.call(this) || this;
        _this.fileImportService = fileImportService;
        _this.fileExportService = fileExportService;
        _this.snackBarService = snackBarService;
        _this.playbackService = playbackService;
        _this.store = store;
        _this.dialogService = dialogService;
        _this.projectService = projectService;
        _this.actionModeService = actionModeService;
        _this.shortcutService = shortcutService;
        _this.layerTimelineService = layerTimelineService;
        _this.themeService = themeService;
        _this.dragIndicatorSubject = new rxjs__WEBPACK_IMPORTED_MODULE_23__["BehaviorSubject"]({
            isVisible: false,
            left: 0,
            top: 0,
        });
        _this.dragIndicatorObservable = _this.dragIndicatorSubject.asObservable();
        _this.horizZoomSubject = new rxjs__WEBPACK_IMPORTED_MODULE_23__["BehaviorSubject"](DEFAULT_HORIZ_ZOOM);
        _this.horizZoomObservable = _this.horizZoomSubject.asObservable();
        _this.currentTime_ = 0;
        _this.shouldSuppressRebuildSnapTimes = false;
        _this.performZoomRAF = undefined;
        _this.endZoomTimeout = undefined;
        return _this;
    }
    LayerTimelineComponent.prototype.ngOnInit = function () {
        var _this = this;
        var currActionMode;
        this.layerTimelineModel$ = this.store.select(app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_15__["getLayerTimelineState"]).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_24__["map"])(function (_a) {
            var animation = _a.animation, vectorLayer = _a.vectorLayer, isAnimationSelected = _a.isAnimationSelected, selectedBlockIds = _a.selectedBlockIds, isBeingReset = _a.isBeingReset, isActionMode = _a.isActionMode, actionMode = _a.actionMode, singleSelectedPathBlock = _a.singleSelectedPathBlock;
            _this.animation = animation;
            _this.rebuildSnapTimes();
            _this.vectorLayer = vectorLayer;
            _this.selectedBlockIds = selectedBlockIds;
            if (isBeingReset) {
                // TODO: store the 'zoom' info in the store to avoid using this isBeingReset flag
                _this.autoZoomToAnimation();
            }
            if (currActionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_4__["ActionMode"].None && actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_4__["ActionMode"].Selection) {
                // Move the current time to the beginning of the selected block when
                // entering action mode.
                _this.playbackService.setCurrentTime(singleSelectedPathBlock.startTime);
            }
            currActionMode = actionMode;
            return {
                animation: animation,
                vectorLayer: vectorLayer,
                isAnimationSelected: isAnimationSelected,
                isActionMode: isActionMode,
            };
        }));
        this.registerSubscription(this.shortcutService.asObservable().subscribe(function (shortcut) {
            if (shortcut === app_modules_editor_services_shortcut_service__WEBPACK_IMPORTED_MODULE_11__["Shortcut"].ZoomToFit) {
                _this.autoZoomToAnimation();
            }
        }));
    };
    LayerTimelineComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.$timeline = jquery__WEBPACK_IMPORTED_MODULE_21__(this.timelineRef.nativeElement);
        this.registerSubscription(this.playbackService.asObservable().subscribe(function (event) {
            // TODO: make this reactive/avoid storing current time locally
            _this.currentTime = event.currentTime;
        }));
        setTimeout(function () { return _this.autoZoomToAnimation(); });
    };
    Object.defineProperty(LayerTimelineComponent.prototype, "horizZoom", {
        get: function () {
            return this.horizZoomSubject.getValue();
        },
        set: function (horizZoom) {
            this.horizZoomSubject.next(horizZoom);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerTimelineComponent.prototype, "currentTime", {
        get: function () {
            return this.currentTime_;
        },
        set: function (currentTime) {
            this.currentTime_ = currentTime;
            this.timelineDirectives.forEach(function (dir) { return (dir.currentTime = currentTime); });
        },
        enumerable: true,
        configurable: true
    });
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onNewWorkspaceClick = function () {
        var _this = this;
        var resetWorkspaceFn = function () {
            ga('send', 'event', 'File', 'New');
            _this.store.dispatch(new app_modules_editor_store_reset_actions__WEBPACK_IMPORTED_MODULE_18__["ResetWorkspace"]());
        };
        this.store
            .select(app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_15__["isWorkspaceDirty"])
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_24__["first"])())
            .subscribe(function (isDirty) {
            if (isDirty && !IS_DEV_BUILD) {
                _this.dialogService
                    .confirm('Start over?', "You'll lose any unsaved changes.")
                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_24__["filter"])(function (result) { return result; }))
                    .subscribe(resetWorkspaceFn);
            }
            else {
                resetWorkspaceFn();
            }
        });
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onSaveToFileClick = function () {
        ga('send', 'event', 'File', 'Save');
        this.fileExportService.exportJSON();
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onLoadDemoClick = function () {
        var _this = this;
        ga('send', 'event', 'File', 'Demo');
        this.dialogService
            .pickDemo()
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_24__["filter"])(function (demoInfo) { return !!demoInfo; }))
            .subscribe(function (selectedDemoInfo) {
            ga('send', 'event', 'Demos', 'Demo selected', selectedDemoInfo.title);
            _this.projectService
                .getProject("demos/" + selectedDemoInfo.id + ".shapeshifter")
                .then(function (_a) {
                var vectorLayer = _a.vectorLayer, animation = _a.animation, hiddenLayerIds = _a.hiddenLayerIds;
                _this.store.dispatch(new app_modules_editor_store_reset_actions__WEBPACK_IMPORTED_MODULE_18__["ResetWorkspace"](vectorLayer, animation, hiddenLayerIds));
            })
                .catch(function (error) {
                var msg = 'serviceWorker' in navigator && navigator.serviceWorker.controller
                    ? 'Demo not available offline'
                    : "Couldn't fetch demo";
                _this.snackBarService.show(msg, 'Dismiss', app_modules_editor_services_snackbar_service__WEBPACK_IMPORTED_MODULE_12__["Duration"].Long);
                return Promise.reject(error.message || error);
            });
        });
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onExportSvgClick = function () {
        ga('send', 'event', 'Export', 'SVG');
        this.fileExportService.exportSvg();
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onExportVectorDrawableClick = function () {
        ga('send', 'event', 'Export', 'Vector Drawable');
        this.fileExportService.exportVectorDrawable();
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onExportAnimatedVectorDrawableClick = function () {
        ga('send', 'event', 'Export', 'Animated Vector Drawable');
        this.fileExportService.exportAnimatedVectorDrawable();
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onExportSvgSpritesheetClick = function () {
        ga('send', 'event', 'Export', 'SVG Spritesheet');
        this.fileExportService.exportSvgSpritesheet();
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onExportCssKeyframesClick = function () {
        // TODO: implement this feature
        ga('send', 'event', 'Export', 'CSS Keyframes');
        this.fileExportService.exportCssKeyframes();
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onAnimationHeaderTextClick = function (event) {
        // Stop propagation to ensure that animationTimelineClick() isn't called.
        event.stopPropagation();
        if (!this.actionModeService.isActionMode()) {
            var isSelected = !app_modules_editor_services_shortcut_service__WEBPACK_IMPORTED_MODULE_11__["ShortcutService"].isOsDependentModifierKey(event) && !event.shiftKey;
            this.layerTimelineService.selectAnimation(isSelected);
        }
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onTimelineHeaderScrub = function (event) {
        var time = event.time;
        if (!event.disableSnap) {
            time = this.snapTime(time, false);
        }
        this.currentTime = time;
        this.playbackService.setCurrentTime(time);
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onAddPathLayerClick = function () {
        var _this = this;
        this.store
            .select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_17__["getVectorLayer"])
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_24__["first"])())
            .subscribe(function (vl) {
            var layer = new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["PathLayer"]({
                name: app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].getUniqueLayerName([vl], 'path'),
                children: [],
                pathData: undefined,
            });
            _this.layerTimelineService.addLayer(layer);
        });
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onAddClipPathLayerClick = function () {
        var _this = this;
        this.store
            .select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_17__["getVectorLayer"])
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_24__["first"])())
            .subscribe(function (vl) {
            var layer = new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["ClipPathLayer"]({
                name: app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].getUniqueLayerName([vl], 'mask'),
                children: [],
                pathData: undefined,
            });
            _this.layerTimelineService.addLayer(layer);
        });
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onAddGroupLayerClick = function () {
        var _this = this;
        this.store
            .select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_17__["getVectorLayer"])
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_24__["first"])())
            .subscribe(function (vl) {
            var name = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].getUniqueLayerName([vl], 'group');
            var layer = new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["GroupLayer"]({ name: name, children: [] });
            _this.layerTimelineService.addLayer(layer);
        });
    };
    // @Override TimelineAnimationRowCallbacks
    LayerTimelineComponent.prototype.onTimelineBlockMouseDown = function (mouseDownEvent, dragBlock) {
        var _this = this;
        var animation = this.animation;
        // TODO: this JQuery 'class' stuff may not work with view encapsulation enabled
        var $target = jquery__WEBPACK_IMPORTED_MODULE_21__(mouseDownEvent.target);
        // Some geometry and hit-testing basics.
        var animRect = jquery__WEBPACK_IMPORTED_MODULE_21__(mouseDownEvent.target)
            .parents('.slt-property')
            .get(0)
            .getBoundingClientRect();
        var xToTimeFn = function (x) { return ((x - animRect.left) / animRect.width) * animation.duration; };
        var downTime = xToTimeFn(mouseDownEvent.clientX);
        // Determine the action based on where the user clicked and the modifier keys.
        var metaKey = app_modules_editor_services_shortcut_service__WEBPACK_IMPORTED_MODULE_11__["ShortcutService"].isOsDependentModifierKey(mouseDownEvent);
        var action = MouseActions.Moving;
        if ($target.hasClass('slt-timeline-block-edge-end')) {
            action =
                mouseDownEvent.shiftKey || metaKey
                    ? MouseActions.ScalingTogetherEnd
                    : MouseActions.ScalingUniformEnd;
        }
        else if ($target.hasClass('slt-timeline-block-edge-start')) {
            action =
                mouseDownEvent.shiftKey || metaKey
                    ? MouseActions.ScalingTogetherStart
                    : MouseActions.ScalingUniformStart;
        }
        // Start up a cache of info for each selected block, calculating the left and right
        // bounds for each selected block, based on adjacent non-dragging blocks.
        var blocksByPropertyByLayer = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_6__["ModelUtil"].getOrderedBlocksByPropertyByLayer(animation);
        // Either drag all selected blocks or just the mousedown block.
        var draggingBlocks = this.selectedBlockIds.has(dragBlock.id)
            ? animation.blocks.filter(function (b) { return _this.selectedBlockIds.has(b.id); })
            : [dragBlock];
        var stagnantBlocks = animation.blocks.filter(function (block) {
            return (draggingBlocks.every(function (b) { return block.id !== b.id; }) &&
                draggingBlocks.some(function (_a) {
                    var layerId = _a.layerId, propertyName = _a.propertyName;
                    return block.layerId === layerId && block.propertyName === propertyName;
                }));
        });
        var intervalTree = new app_modules_editor_scripts_intervals__WEBPACK_IMPORTED_MODULE_8__["IntervalTree"]();
        stagnantBlocks.forEach(function (b) {
            var id = b.id, layerId = b.layerId, propertyName = b.propertyName, startTime = b.startTime, endTime = b.endTime;
            intervalTree.insert(Math.min(startTime, animation.duration), Math.max(0, endTime), {
                blockId: id,
                layerId: layerId,
                propertyName: propertyName,
                startTime: startTime,
                endTime: endTime,
            });
        });
        var blockInfos = draggingBlocks.map(function (block) {
            var blockNeighbors = blocksByPropertyByLayer[block.layerId][block.propertyName];
            var indexIntoNeighbors = lodash__WEBPACK_IMPORTED_MODULE_22__["findIndex"](blockNeighbors, function (b) { return block.id === b.id; });
            // By default the block is only bound by the animation duration.
            var startBound = 0;
            var endBound = animation.duration;
            // For each block find the left-most non-selected block and use that as
            // the start bound.
            if (indexIntoNeighbors > 0) {
                for (var i = indexIntoNeighbors - 1; i >= 0; i--) {
                    var neighbor = blockNeighbors[i];
                    if (!draggingBlocks.includes(neighbor) || action === MouseActions.ScalingUniformStart) {
                        // Only be bound by neighbors not being dragged
                        // except when uniformly changing just start time.
                        startBound = neighbor.endTime;
                        break;
                    }
                }
            }
            // For each block find the right-most non-selected block and use that as
            // the end bound.
            if (indexIntoNeighbors < blockNeighbors.length - 1) {
                for (var i = indexIntoNeighbors + 1; i < blockNeighbors.length; i++) {
                    var neighbor = blockNeighbors[i];
                    if (!draggingBlocks.includes(neighbor) || action === MouseActions.ScalingUniformEnd) {
                        // Only be bound by neighbors not being dragged
                        // except when uniformly changing just end time.
                        endBound = neighbor.startTime;
                        break;
                    }
                }
            }
            return {
                block: block,
                startBound: startBound,
                endBound: endBound,
                downStartTime: block.startTime,
                downEndTime: block.endTime,
            };
        });
        var dragBlockDownStartTime = dragBlock.startTime;
        var dragBlockDownEndTime = dragBlock.endTime;
        var minStartTime;
        var maxEndTime;
        if (action === MouseActions.ScalingTogetherStart ||
            action === MouseActions.ScalingTogetherEnd) {
            minStartTime = blockInfos.reduce(function (t, info) { return Math.min(t, info.block.startTime); }, Infinity);
            maxEndTime = blockInfos.reduce(function (t, info) { return Math.max(t, info.block.endTime); }, 0);
            // Avoid divide by zero.
            maxEndTime = Math.max(maxEndTime, minStartTime + MIN_BLOCK_DURATION);
        }
        var isOverlappingBlockFn = function (info, low, high) {
            var _a = info.block, layerId = _a.layerId, propertyName = _a.propertyName;
            return intervalTree.intersectsWith(low, high, function (d) { return d.layerId === layerId && d.propertyName === propertyName; });
        };
        // tslint:disable-next-line: no-unused-expression
        new app_modules_editor_scripts_dragger__WEBPACK_IMPORTED_MODULE_7__["Dragger"]({
            direction: 'horizontal',
            downX: mouseDownEvent.clientX,
            downY: mouseDownEvent.clientY,
            draggingCursor: action === MouseActions.Moving ? 'grabbing' : 'ew-resize',
            onBeginDragFn: function () {
                _this.shouldSuppressRebuildSnapTimes = true;
            },
            onDropFn: function () {
                return setTimeout(function () {
                    _this.shouldSuppressRebuildSnapTimes = false;
                    _this.rebuildSnapTimes();
                }, 0);
            },
            onDragFn: function (event) {
                // Calculate the 'time delta' (the number of milliseconds the user has moved
                // since the gesture began).
                var timeDelta = Math.round(xToTimeFn(event.clientX) - downTime);
                var allowSnap = !event.shiftKey && !app_modules_editor_services_shortcut_service__WEBPACK_IMPORTED_MODULE_11__["ShortcutService"].isOsDependentModifierKey(event);
                var replacementBlocks = [];
                switch (action) {
                    case MouseActions.Moving: {
                        blockInfos.forEach(function (info) {
                            // Snap time delta.
                            if (allowSnap && info.block.id === dragBlock.id) {
                                var newStartTime = info.downStartTime + timeDelta;
                                var newStartTimeSnapDelta = _this.snapTime(newStartTime) - newStartTime;
                                var newEndTime = info.downEndTime + timeDelta;
                                var newEndTimeSnapDelta = _this.snapTime(newEndTime) - newEndTime;
                                if (newStartTimeSnapDelta) {
                                    if (newEndTimeSnapDelta) {
                                        timeDelta += Math.min(newStartTimeSnapDelta, newEndTimeSnapDelta);
                                    }
                                    else {
                                        timeDelta += newStartTimeSnapDelta;
                                    }
                                }
                                else if (newEndTimeSnapDelta) {
                                    timeDelta += newEndTimeSnapDelta;
                                }
                            }
                            // Clamp time delta to ensure it remains within the duration's bounds.
                            var min = -info.downStartTime;
                            var max = animation.duration - info.downEndTime;
                            timeDelta = lodash__WEBPACK_IMPORTED_MODULE_22__["clamp"](timeDelta, min, max);
                        });
                        var deltas = lodash__WEBPACK_IMPORTED_MODULE_22__(blockInfos)
                            .filter(function (info) {
                            // For each block, check if it overlaps with any of the stagnant blocks.
                            var low = info.downStartTime + timeDelta;
                            var end = info.downEndTime + timeDelta;
                            return isOverlappingBlockFn(info, low, end);
                        })
                            .flatMap(function (info) {
                            var _a = info.block, id = _a.id, layerId = _a.layerId, propertyName = _a.propertyName;
                            var neighbors = blocksByPropertyByLayer[layerId][propertyName].filter(function (ngh) { return id !== ngh.id; });
                            return lodash__WEBPACK_IMPORTED_MODULE_22__["flatMap"](neighbors, function (ngh) {
                                return [ngh.startTime - info.downEndTime, ngh.endTime - info.downStartTime];
                            });
                        })
                            .sort(function (a, b) { return Math.abs(a - timeDelta) - Math.abs(b - timeDelta); })
                            .value();
                        var deltaIndex = lodash__WEBPACK_IMPORTED_MODULE_22__["findIndex"](deltas, function (delta) {
                            return blockInfos.every(function (info) {
                                var low = info.downStartTime + delta;
                                var high = info.downEndTime + delta;
                                if (low < 0 || high > animation.duration) {
                                    return false;
                                }
                                return !isOverlappingBlockFn(info, low, high);
                            });
                        });
                        if (deltaIndex >= 0) {
                            timeDelta = deltas[deltaIndex];
                        }
                        blockInfos.forEach(function (info) {
                            var blockDuration = info.block.endTime - info.block.startTime;
                            var block = info.block.clone();
                            block.startTime = info.downStartTime + timeDelta;
                            block.endTime = block.startTime + blockDuration;
                            replacementBlocks.push(block);
                        });
                        break;
                    }
                    case MouseActions.ScalingUniformStart: {
                        blockInfos.forEach(function (info) {
                            // Snap time delta.
                            if (allowSnap && info.block.id === dragBlock.id) {
                                var newStartTime = info.downStartTime + timeDelta;
                                var newStartTimeSnapDelta = _this.snapTime(newStartTime) - newStartTime;
                                if (newStartTimeSnapDelta) {
                                    timeDelta += newStartTimeSnapDelta;
                                }
                            }
                            // Clamp time delta.
                            var min = info.startBound - info.downStartTime;
                            var max = info.block.endTime - MIN_BLOCK_DURATION - info.downStartTime;
                            timeDelta = lodash__WEBPACK_IMPORTED_MODULE_22__["clamp"](timeDelta, min, max);
                        });
                        blockInfos.forEach(function (info) {
                            var block = info.block.clone();
                            block.startTime = info.downStartTime + timeDelta;
                            replacementBlocks.push(block);
                        });
                        break;
                    }
                    case MouseActions.ScalingUniformEnd: {
                        blockInfos.forEach(function (info) {
                            // Snap time delta.
                            if (allowSnap && info.block === dragBlock) {
                                var newEndTime = info.downEndTime + timeDelta;
                                var newEndTimeSnapDelta = _this.snapTime(newEndTime) - newEndTime;
                                if (newEndTimeSnapDelta) {
                                    timeDelta += newEndTimeSnapDelta;
                                }
                            }
                            // Clamp time delta.
                            var min = info.block.startTime + MIN_BLOCK_DURATION - info.downEndTime;
                            var max = info.endBound - info.downEndTime;
                            timeDelta = lodash__WEBPACK_IMPORTED_MODULE_22__["clamp"](timeDelta, min, max);
                        });
                        blockInfos.forEach(function (info) {
                            var block = info.block.clone();
                            block.endTime = info.downEndTime + timeDelta;
                            replacementBlocks.push(block);
                        });
                        break;
                    }
                    case MouseActions.ScalingTogetherStart: {
                        var scale_1 = (dragBlockDownStartTime + timeDelta - maxEndTime) /
                            (dragBlockDownStartTime - maxEndTime);
                        scale_1 = Math.min(scale_1, maxEndTime / (maxEndTime - minStartTime));
                        var cancel_1 = false;
                        blockInfos.forEach(function (info) {
                            info.newStartTime = maxEndTime - (maxEndTime - info.downStartTime) * scale_1;
                            info.newEndTime = Math.max(maxEndTime - (maxEndTime - info.downEndTime) * scale_1, info.newStartTime + MIN_BLOCK_DURATION);
                            if (info.newStartTime < info.startBound || info.newEndTime > info.endBound) {
                                cancel_1 = true;
                            }
                        });
                        if (!cancel_1) {
                            blockInfos.forEach(function (info) {
                                var block = info.block.clone();
                                block.startTime = info.newStartTime;
                                block.endTime = info.newEndTime;
                                replacementBlocks.push(block);
                            });
                        }
                        break;
                    }
                    case MouseActions.ScalingTogetherEnd: {
                        var scale_2 = (dragBlockDownEndTime + timeDelta - minStartTime) /
                            (dragBlockDownEndTime - minStartTime);
                        scale_2 = Math.min(scale_2, (animation.duration - minStartTime) / (maxEndTime - minStartTime));
                        var cancel_2 = false;
                        blockInfos.forEach(function (info) {
                            info.newStartTime = minStartTime + (info.downStartTime - minStartTime) * scale_2;
                            info.newEndTime = Math.max(minStartTime + (info.downEndTime - minStartTime) * scale_2, info.newStartTime + MIN_BLOCK_DURATION);
                            if (info.newStartTime < info.startBound || info.newEndTime > info.endBound) {
                                cancel_2 = true;
                            }
                        });
                        if (!cancel_2) {
                            blockInfos.forEach(function (info) {
                                var block = info.block.clone();
                                block.startTime = info.newStartTime;
                                block.endTime = info.newEndTime;
                                replacementBlocks.push(block);
                            });
                        }
                        break;
                    }
                }
                _this.store
                    .select(app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_19__["getAnimation"])
                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_24__["first"])())
                    .subscribe(function (anim) {
                    var blocks = replacementBlocks.filter(function (replacementBlock) {
                        // Note that existingBlock may not be found if changes were made to the animation
                        // (i.e. a block was deleted during a drag).
                        var existingBlock = lodash__WEBPACK_IMPORTED_MODULE_22__["find"](anim.blocks, function (b) { return replacementBlock.id === b.id; });
                        return (existingBlock &&
                            (replacementBlock.startTime !== existingBlock.startTime ||
                                replacementBlock.endTime !== existingBlock.endTime));
                    });
                    _this.layerTimelineService.updateBlocks(blocks);
                });
            },
        });
    };
    /**
     * Builds a cache of snap times for all available animations.
     */
    LayerTimelineComponent.prototype.rebuildSnapTimes = function () {
        if (this.shouldSuppressRebuildSnapTimes) {
            return;
        }
        this.snapTimes = new Map();
        var snapTimesSet = new Set();
        snapTimesSet.add(0);
        snapTimesSet.add(this.animation.duration);
        this.animation.blocks.forEach(function (block) {
            snapTimesSet.add(block.startTime);
            snapTimesSet.add(block.endTime);
        });
        this.snapTimes.set(this.animation.id, Array.from(snapTimesSet));
    };
    /**
     * Returns a new time, possibly snapped to animation boundaries
     */
    LayerTimelineComponent.prototype.snapTime = function (time, includeActiveTime) {
        if (includeActiveTime === void 0) { includeActiveTime = true; }
        var animation = this.animation;
        var snapTimes = this.snapTimes.get(animation.id);
        var snapDelta = SNAP_PIXELS / this.horizZoom;
        var reducerFn = function (best, snapTime) {
            var dist = Math.abs(time - snapTime);
            return dist < snapDelta && dist < Math.abs(time - best) ? snapTime : best;
        };
        var bestSnapTime = snapTimes.reduce(reducerFn, Infinity);
        if (includeActiveTime) {
            bestSnapTime = reducerFn(bestSnapTime, this.currentTime);
        }
        return isFinite(bestSnapTime) ? bestSnapTime : time;
    };
    // @Override TimelineAnimationRowCallbacks
    LayerTimelineComponent.prototype.onTimelineBlockClick = function (event, block) {
        var clearExisting = !app_modules_editor_services_shortcut_service__WEBPACK_IMPORTED_MODULE_11__["ShortcutService"].isOsDependentModifierKey(event) && !event.shiftKey;
        this.layerTimelineService.selectBlock(block.id, clearExisting);
    };
    // @Override TimelineAnimationRowCallbacks
    LayerTimelineComponent.prototype.onTimelineBlockDoubleClick = function (event, block) {
        this.playbackService.setCurrentTime(block.startTime);
    };
    // @Override LayerListTreeComponentCallbacks
    LayerTimelineComponent.prototype.onAddTimelineBlockClick = function (event, layer, propertyName) {
        var clonedValue = layer.inspectableProperties
            .get(propertyName)
            .cloneValue(layer[propertyName]);
        this.layerTimelineService.addBlocks([
            {
                layerId: layer.id,
                propertyName: propertyName,
                fromValue: clonedValue,
                toValue: clonedValue,
                currentTime: this.currentTime,
            },
        ]);
    };
    // @Override LayerListTreeComponentCallbacks
    LayerTimelineComponent.prototype.onConvertToClipPathClick = function (event, layer) {
        var clipPathLayer = new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["ClipPathLayer"](layer);
        clipPathLayer.id = lodash__WEBPACK_IMPORTED_MODULE_22__["uniqueId"]();
        this.layerTimelineService.swapLayers(layer.id, clipPathLayer);
    };
    // @Override LayerListTreeComponentCallbacks
    LayerTimelineComponent.prototype.onConvertToPathClick = function (event, layer) {
        var pathLayer = new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["PathLayer"](layer);
        pathLayer.id = lodash__WEBPACK_IMPORTED_MODULE_22__["uniqueId"]();
        this.layerTimelineService.swapLayers(layer.id, pathLayer);
    };
    // @Override LayerListTreeComponentCallbacks
    LayerTimelineComponent.prototype.onFlattenGroupClick = function (event, layer) {
        this.layerTimelineService.flattenGroupLayer(layer.id);
    };
    // @Override LayerListTreeComponentCallbacks
    LayerTimelineComponent.prototype.onLayerClick = function (event, clickedLayer) {
        var isMeta = app_modules_editor_services_shortcut_service__WEBPACK_IMPORTED_MODULE_11__["ShortcutService"].isOsDependentModifierKey(event);
        var isShift = event.shiftKey;
        if (!isMeta && !isShift) {
            // Clear the existing selections.
            this.layerTimelineService.selectLayer(clickedLayer.id, true);
            return;
        }
        if (isMeta && !isShift) {
            // Add the single layer to the existing selections, toggling the
            // layer if it is already selected.
            this.layerTimelineService.selectLayer(clickedLayer.id, false);
            return;
        }
        if (isMeta && isShift) {
            // Add the single layer to the existing selections.
            var layerIds = this.layerTimelineService.getSelectedLayerIds();
            layerIds.add(clickedLayer.id);
            this.layerTimelineService.setSelectedLayers(layerIds);
            return;
        }
        // Batch add layers to the existing selections.
        var vectorLayer = this.vectorLayer;
        var topDownSortedLayers = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].runPreorderTraversal(vectorLayer);
        var clickedLayerIndex = lodash__WEBPACK_IMPORTED_MODULE_22__["findIndex"](topDownSortedLayers, function (l) { return l.id === clickedLayer.id; });
        var selectedLayerIds = this.layerTimelineService.getSelectedLayerIds();
        // TODO: re-implement this behavior to match the behavior of Sketch
        // TODO will need to store most recently selected layer ID in order to implement this behavior
        var _a = (function () {
            // Find the first selected layer before clickedLayerIndex.
            var beforeLayerIndex = lodash__WEBPACK_IMPORTED_MODULE_22__["findLastIndex"](topDownSortedLayers, function (l) { return selectedLayerIds.has(l.id); }, clickedLayerIndex);
            if (beforeLayerIndex >= 0) {
                // Batch select [beforeLayerIndex, clickedLayerIndex].
                return { startIndex: beforeLayerIndex, endIndex: clickedLayerIndex };
            }
            // Find the first selected layer after clickedLayerIndex.
            var afterLayerIndex = lodash__WEBPACK_IMPORTED_MODULE_22__["findIndex"](topDownSortedLayers, function (l) { return selectedLayerIds.has(l.id); }, clickedLayerIndex);
            if (afterLayerIndex >= 0) {
                // Batch select [clickedLayerIndex, afterLayerIndex].
                return { startIndex: clickedLayerIndex, endIndex: afterLayerIndex };
            }
            // Batch select [0, clickedLayerIndex].
            return { startIndex: 0, endIndex: clickedLayerIndex };
        })(), startIndex = _a.startIndex, endIndex = _a.endIndex;
        for (var i = startIndex; i <= endIndex; i++) {
            selectedLayerIds.add(topDownSortedLayers[i].id);
        }
        this.layerTimelineService.setSelectedLayers(selectedLayerIds);
    };
    // @Override LayerListTreeComponentCallbacks
    LayerTimelineComponent.prototype.onLayerToggleExpanded = function (event, layer) {
        var recursive = app_modules_editor_services_shortcut_service__WEBPACK_IMPORTED_MODULE_11__["ShortcutService"].isOsDependentModifierKey(event) || event.shiftKey;
        this.layerTimelineService.toggleExpandedLayer(layer.id, recursive);
    };
    // @Override LayerListTreeComponentCallbacks
    LayerTimelineComponent.prototype.onLayerToggleVisibility = function (event, layer) {
        this.layerTimelineService.toggleVisibleLayer(layer.id);
    };
    // @Override LayerListTreeComponentCallbacks
    LayerTimelineComponent.prototype.onLayerMouseDown = function (mouseDownEvent, mouseDownDragLayer) {
        var _this = this;
        var $layersList = jquery__WEBPACK_IMPORTED_MODULE_21__(mouseDownEvent.target).parents('.slt-layers-list');
        var $scroller = jquery__WEBPACK_IMPORTED_MODULE_21__(mouseDownEvent.target).parents('.slt-layers-list-scroller');
        var orderedLayerInfos = [];
        var scrollerRect;
        var targetLayerInfo;
        var targetEdge;
        var dragLayers = (function (lts) {
            var selectedLayerIds = lts.getSelectedLayerIds();
            // Don't drag any other selected layers if the drag layer isn't selected itself.
            // At the end of the drag, we will select the drag layer and deselect the others.
            var dragLayerIdSet = selectedLayerIds.has(mouseDownDragLayer.id)
                ? selectedLayerIds
                : new Set([mouseDownDragLayer.id]);
            var topDownSortedLayers = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].runPreorderTraversal(lts.getVectorLayer());
            return topDownSortedLayers.filter(function (l) { return dragLayerIdSet.has(l.id); });
        })(this.layerTimelineService);
        // tslint:disable-next-line: no-unused-expression
        new app_modules_editor_scripts_dragger__WEBPACK_IMPORTED_MODULE_7__["Dragger"]({
            direction: 'both',
            downX: mouseDownEvent.clientX,
            downY: mouseDownEvent.clientY,
            onBeginDragFn: function () {
                // Build up a list of all layers ordered by Y position.
                orderedLayerInfos = [];
                scrollerRect = $scroller.get(0).getBoundingClientRect();
                var scrollTop = $scroller.scrollTop();
                $layersList.find('.slt-layer-container').each(function (__, element) {
                    // toString() is necessary because JQuery converts the ID into a number.
                    var layerId = (jquery__WEBPACK_IMPORTED_MODULE_21__(element).data('layer-id') || '').toString();
                    if (!layerId) {
                        // The root layer doesn't have an ID set.
                        return;
                    }
                    var rect = element.getBoundingClientRect();
                    rect = {
                        left: rect.left,
                        top: rect.top + scrollTop - scrollerRect.top,
                        bottom: rect.bottom + scrollTop - scrollerRect.top,
                        height: rect.height,
                        right: rect.right,
                        width: rect.width,
                    };
                    var layer = _this.vectorLayer.findLayerById(layerId);
                    orderedLayerInfos.push({ layer: layer, element: element, localRect: rect });
                    // Add a fake target for empty groups.
                    if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["GroupLayer"] && !layer.children.length) {
                        var left = rect.left + LAYER_INDENT_PIXELS;
                        var top_1 = rect.bottom;
                        rect = tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, rect, { left: left, top: top_1 });
                        orderedLayerInfos.push({
                            layer: layer,
                            element: element,
                            localRect: rect,
                            moveIntoEmptyLayerGroup: true,
                        });
                    }
                });
                orderedLayerInfos.sort(function (a, b) { return a.localRect.top - b.localRect.top; });
                _this.updateDragIndicator({ isVisible: true, left: 0, top: 0 });
            },
            onDragFn: function (event) {
                var localEventY = event.clientY - scrollerRect.top + $scroller.scrollTop();
                // Find the target layer and edge (top or bottom).
                targetLayerInfo = undefined;
                var minDistance = Infinity;
                var minDistanceIndent = Infinity; // Tie break to most indented layer.
                for (var _i = 0, orderedLayerInfos_1 = orderedLayerInfos; _i < orderedLayerInfos_1.length; _i++) {
                    var layerInfo = orderedLayerInfos_1[_i];
                    // Skip if mouse to the left of this layer.
                    if (event.clientX < layerInfo.localRect.left) {
                        continue;
                    }
                    for (var _a = 0, _b = ['top', 'bottom']; _a < _b.length; _a++) {
                        var edge = _b[_a];
                        // Test distance to top edge.
                        var distance = Math.abs(localEventY - layerInfo.localRect[edge]);
                        var indent = layerInfo.localRect.left;
                        if (distance <= minDistance) {
                            if (distance !== minDistance || indent > minDistanceIndent) {
                                minDistance = distance;
                                minDistanceIndent = indent;
                                targetLayerInfo = layerInfo;
                                targetEdge = edge;
                            }
                        }
                    }
                }
                // Disallow dragging a layer into itself or its children.
                if (targetLayerInfo) {
                    var layer_1 = targetLayerInfo.layer;
                    while (layer_1) {
                        if (lodash__WEBPACK_IMPORTED_MODULE_22__["find"](dragLayers, function (l) { return l.id === layer_1.id; })) {
                            targetLayerInfo = undefined;
                            break;
                        }
                        layer_1 = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].findParent(_this.vectorLayer, layer_1.id);
                    }
                }
                if (targetLayerInfo && targetEdge === 'bottom') {
                    var nextSibling = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].findNextSibling(_this.vectorLayer, targetLayerInfo.layer.id);
                    if (nextSibling && nextSibling.id === mouseDownDragLayer.id) {
                        targetLayerInfo = undefined;
                    }
                }
                var dragIndicatorInfo = { isVisible: !!targetLayerInfo };
                if (targetLayerInfo) {
                    dragIndicatorInfo.left = targetLayerInfo.localRect.left;
                    dragIndicatorInfo.top = targetLayerInfo.localRect[targetEdge];
                }
                _this.updateDragIndicator(dragIndicatorInfo);
            },
            onDropFn: function () {
                _this.updateDragIndicator({ isVisible: false });
                if (!targetLayerInfo) {
                    return;
                }
                var dragLayerIds = dragLayers.map(function (l) { return l.id; });
                var addDragLayersFn = function (vl, parent, startingIndex) {
                    if (startingIndex === void 0) { startingIndex = parent.children.length; }
                    var layersToAdd = dragLayers.map(function (l) {
                        var otherDragLayerIds = dragLayerIds.filter(function (id) { return id !== l.id; });
                        return app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].removeLayers.apply(app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"], [l].concat(otherDragLayerIds));
                    });
                    return app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].addLayers.apply(app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"], [vl, parent.id, startingIndex].concat(layersToAdd));
                };
                var removeDragLayersFn = function (vl) { return app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].removeLayers.apply(app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"], [vl].concat(dragLayerIds)); };
                var initialVl = _this.vectorLayer;
                var replacementVl;
                if (targetLayerInfo.moveIntoEmptyLayerGroup) {
                    // Moving into an empty layer group.
                    replacementVl = addDragLayersFn(removeDragLayersFn(initialVl), targetLayerInfo.layer);
                }
                else if (app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].findParent(initialVl, targetLayerInfo.layer.id)) {
                    // Moving next to another layer.
                    var tempVl = removeDragLayersFn(initialVl);
                    var parent_1 = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_5__["LayerUtil"].findParent(tempVl, targetLayerInfo.layer.id);
                    var index = lodash__WEBPACK_IMPORTED_MODULE_22__["findIndex"](parent_1.children, function (l) { return l.id === targetLayerInfo.layer.id; });
                    if (index >= 0) {
                        replacementVl = addDragLayersFn(tempVl, parent_1, index + (targetEdge === 'top' ? 0 : 1));
                    }
                }
                if (replacementVl) {
                    _this.store.dispatch(new app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_14__["BatchAction"](new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_16__["SetVectorLayer"](replacementVl), new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_16__["SetSelectedLayers"](new Set(dragLayerIds))));
                }
            },
        });
    };
    LayerTimelineComponent.prototype.updateDragIndicator = function (info) {
        var curr = this.dragIndicatorSubject.getValue();
        this.dragIndicatorSubject.next(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, curr, info));
    };
    /**
     * Handles ctrl + mouse wheel event for zooming into and out of the timeline.
     */
    LayerTimelineComponent.prototype.onWheelEvent = function (event) {
        var _this = this;
        var startZoomFn = function () {
            _this.$zoomStartActiveAnimation = jquery__WEBPACK_IMPORTED_MODULE_21__(_this.timelineAnimationRef.nativeElement);
            _this.zoomStartTimeCursorPos =
                _this.$zoomStartActiveAnimation.position().left +
                    _this.currentTime * _this.horizZoom +
                    _constants__WEBPACK_IMPORTED_MODULE_25__["TIMELINE_ANIMATION_PADDING"];
        };
        var performZoomFn = function () {
            _this.horizZoom = _this.targetHorizZoom;
            // Set the scroll offset such that the time cursor remains at zoomStartTimeCursorPos
            if (_this.$zoomStartActiveAnimation) {
                var newScrollLeft = _this.$zoomStartActiveAnimation.position().left +
                    _this.$timeline.scrollLeft() +
                    _this.currentTime * _this.horizZoom +
                    _constants__WEBPACK_IMPORTED_MODULE_25__["TIMELINE_ANIMATION_PADDING"] -
                    _this.zoomStartTimeCursorPos;
                _this.$timeline.scrollLeft(newScrollLeft);
            }
        };
        var endZoomFn = function () {
            _this.zoomStartTimeCursorPos = 0;
            _this.$zoomStartActiveAnimation = undefined;
            _this.endZoomTimeout = undefined;
            _this.targetHorizZoom = 0;
        };
        // chrome+mac trackpad pinch-zoom = ctrlKey
        if (app_modules_editor_services_shortcut_service__WEBPACK_IMPORTED_MODULE_11__["ShortcutService"].isOsDependentModifierKey(event) || event.ctrlKey) {
            if (!this.targetHorizZoom) {
                // Multiple changes can happen to targetHorizZoom before the
                // actual zoom level is updated (see performZoom_).
                this.targetHorizZoom = this.horizZoom;
            }
            event.preventDefault();
            this.targetHorizZoom *= Math.pow(1.01, -event.deltaY);
            this.targetHorizZoom = lodash__WEBPACK_IMPORTED_MODULE_22__["clamp"](this.targetHorizZoom, MIN_ZOOM, MAX_ZOOM);
            if (this.targetHorizZoom !== this.horizZoom) {
                // Zoom has changed.
                if (this.performZoomRAF) {
                    window.cancelAnimationFrame(this.performZoomRAF);
                }
                this.performZoomRAF = window.requestAnimationFrame(function () { return performZoomFn(); });
                if (this.endZoomTimeout) {
                    window.clearTimeout(this.endZoomTimeout);
                }
                else {
                    startZoomFn();
                }
                this.endZoomTimeout = window.setTimeout(function () { return endZoomFn(); }, 100);
            }
            return false;
        }
        return undefined;
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onZoomToFitClick = function (event) {
        event.stopPropagation();
        this.autoZoomToAnimation();
    };
    /**
     * Zooms the timeline to fit the first animation.
     */
    LayerTimelineComponent.prototype.autoZoomToAnimation = function () {
        // Shave off 48 pixels for safety.
        this.horizZoom = (this.$timeline.width() - 48) / this.animation.duration;
    };
    // Proxies a button click to the <input> tag that opens the file picker.
    // We clear the element's value to make it possible to import the same file
    // more than once.
    LayerTimelineComponent.prototype.onLaunchFilePickerClick = function (event, sourceElementId) {
        jquery__WEBPACK_IMPORTED_MODULE_21__("#" + sourceElementId)
            .val('')
            .trigger('click');
    };
    // Called from the LayerTimelineComponent template.
    LayerTimelineComponent.prototype.onImportedFilesPicked = function (event, fileList) {
        // TODO: determine if calling stopPropogation() is needed?
        event.stopPropagation();
        this.fileImportService.import(fileList);
    };
    LayerTimelineComponent.prototype.onTopSplitterChanged = function () {
        if (this.timelineDirectives) {
            this.timelineDirectives.forEach(function (d) { return d.redraw(); });
        }
    };
    // Used by *ngFor loop.
    LayerTimelineComponent.prototype.trackLayerFn = function (index, layer) {
        return layer.id;
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('timeline'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"])
    ], LayerTimelineComponent.prototype, "timelineRef", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"])('timelineAnimation'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"])
    ], LayerTimelineComponent.prototype, "timelineAnimationRef", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"])(_layertimelinegrid_directive__WEBPACK_IMPORTED_MODULE_26__["LayerTimelineGridDirective"]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"])
    ], LayerTimelineComponent.prototype, "timelineDirectives", void 0);
    LayerTimelineComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-layertimeline',
            template: __webpack_require__(/*! ./layertimeline.component.html */ "./src/app/modules/editor/components/layertimeline/layertimeline.component.html"),
            styles: [__webpack_require__(/*! ./layertimeline.component.scss */ "./src/app/modules/editor/components/layertimeline/layertimeline.component.scss")],
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_services__WEBPACK_IMPORTED_MODULE_10__["FileImportService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_10__["FileExportService"],
            app_modules_editor_services_snackbar_service__WEBPACK_IMPORTED_MODULE_12__["SnackBarService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_10__["PlaybackService"],
            app_modules_editor_store__WEBPACK_IMPORTED_MODULE_13__["Store"],
            app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_2__["DialogService"],
            app_modules_editor_components_project__WEBPACK_IMPORTED_MODULE_3__["ProjectService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_10__["ActionModeService"],
            app_modules_editor_services_shortcut_service__WEBPACK_IMPORTED_MODULE_11__["ShortcutService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_10__["LayerTimelineService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_10__["ThemeService"]])
    ], LayerTimelineComponent);
    return LayerTimelineComponent;
}(Object(app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_9__["DestroyableMixin"])()));



/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/layertimelinegrid.directive.ts":
/*!****************************************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/layertimelinegrid.directive.ts ***!
  \****************************************************************************************/
/*! exports provided: LayerTimelineGridDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerTimelineGridDirective", function() { return LayerTimelineGridDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/timeline */ "./src/app/modules/editor/model/timeline/index.ts");
/* harmony import */ var app_modules_editor_scripts_dragger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/dragger */ "./src/app/modules/editor/scripts/dragger/index.ts");
/* harmony import */ var app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/mixins */ "./src/app/modules/editor/scripts/mixins/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./constants */ "./src/app/modules/editor/components/layertimeline/constants.ts");










var HEADER_HEIGHT = 40;
var GRID_INTERVALS_MS = [10, 25, 50, 100, 250, 500, 1000, 2500, 5000, 10000, 30000, 60000];
var LayerTimelineGridDirective = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](LayerTimelineGridDirective, _super);
    function LayerTimelineGridDirective(elementRef, themeService) {
        var _this = _super.call(this) || this;
        _this.themeService = themeService;
        _this.scrub = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        _this.canvas = elementRef.nativeElement;
        _this.$canvas = jquery__WEBPACK_IMPORTED_MODULE_6__(_this.canvas);
        return _this;
    }
    LayerTimelineGridDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.registerSubscription(this.themeService
            .asObservable()
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["filter"])(function (t) { return !t.isInitialPageLoad; }))
            .subscribe(function (t) { return _this.redraw(); }));
    };
    Object.defineProperty(LayerTimelineGridDirective.prototype, "horizZoom", {
        get: function () {
            return this.horizZoom_;
        },
        set: function (horizZoom) {
            if (this.horizZoom_ !== horizZoom) {
                this.horizZoom_ = horizZoom;
                this.redraw();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerTimelineGridDirective.prototype, "currentTime", {
        get: function () {
            return this.currentTime_;
        },
        set: function (currentTime) {
            if (this.currentTime_ !== currentTime) {
                this.currentTime_ = currentTime;
                this.redraw();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LayerTimelineGridDirective.prototype, "animation", {
        get: function () {
            return this.animation_;
        },
        set: function (animation) {
            this.animation_ = animation;
            this.redraw();
        },
        enumerable: true,
        configurable: true
    });
    LayerTimelineGridDirective.prototype.onMouseDown = function (event) {
        var _this = this;
        this.handleScrubEvent(event.clientX, app_modules_editor_services__WEBPACK_IMPORTED_MODULE_5__["ShortcutService"].isOsDependentModifierKey(event));
        // tslint:disable-next-line: no-unused-expression
        new app_modules_editor_scripts_dragger__WEBPACK_IMPORTED_MODULE_3__["Dragger"]({
            direction: 'horizontal',
            downX: event.clientX,
            downY: event.clientY,
            shouldSkipSlopCheck: true,
            onDragFn: function (e) { return _this.handleScrubEvent(e.clientX, app_modules_editor_services__WEBPACK_IMPORTED_MODULE_5__["ShortcutService"].isOsDependentModifierKey(e)); },
        });
        event.preventDefault();
        return false;
    };
    LayerTimelineGridDirective.prototype.handleScrubEvent = function (clientX, disableSnap) {
        var x = clientX - this.$canvas.offset().left;
        var time = ((x - _constants__WEBPACK_IMPORTED_MODULE_9__["TIMELINE_ANIMATION_PADDING"]) / (this.$canvas.width() - _constants__WEBPACK_IMPORTED_MODULE_9__["TIMELINE_ANIMATION_PADDING"] * 2)) *
            this.animation.duration;
        time = lodash__WEBPACK_IMPORTED_MODULE_7__["clamp"](time, 0, this.animation.duration);
        this.scrub.emit({ time: time, disableSnap: disableSnap });
    };
    LayerTimelineGridDirective.prototype.redraw = function () {
        if (!this.$canvas.is(':visible')) {
            return;
        }
        var width = this.$canvas.width();
        var height = this.$canvas.height();
        this.$canvas.attr('width', width * window.devicePixelRatio);
        this.$canvas.attr('height', height * window.devicePixelRatio);
        var ctx = this.canvas.getContext('2d');
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        ctx.translate(_constants__WEBPACK_IMPORTED_MODULE_9__["TIMELINE_ANIMATION_PADDING"], 0);
        // Compute grid spacing (40 = minimum grid spacing in pixels).
        var interval = 0;
        var spacingMs = GRID_INTERVALS_MS[interval];
        while (spacingMs * this.horizZoom < 40 || interval >= GRID_INTERVALS_MS.length) {
            interval++;
            spacingMs = GRID_INTERVALS_MS[interval];
        }
        var spacingPx = spacingMs * this.horizZoom;
        if (this.isHeader) {
            // Text labels.
            ctx.fillStyle = this.themeService.getSecondaryTextColor();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '10px Roboto';
            for (var x = 0, t = 0; round(x) <= round(width); x += spacingPx, t += spacingMs) {
                ctx.fillText(t / 1000 + "s", x, height / 2);
            }
            ctx.fillStyle = 'rgba(244, 67, 54, .7)';
            ctx.beginPath();
            ctx.arc(this.currentTime * this.horizZoom, height / 2, 4, 0, 2 * Math.PI, false);
            ctx.fill();
            ctx.closePath();
            ctx.fillRect(this.currentTime * this.horizZoom - 1, height / 2 + 4, 2, height);
        }
        else {
            // Grid lines.
            ctx.fillStyle = this.themeService.getDividerTextColor();
            for (var x = spacingPx; round(x) < round(width - _constants__WEBPACK_IMPORTED_MODULE_9__["TIMELINE_ANIMATION_PADDING"] * 2); x += spacingPx) {
                ctx.fillRect(x - 0.5, HEADER_HEIGHT, 1, height - HEADER_HEIGHT);
            }
            ctx.fillStyle = 'rgba(244, 67, 54, .7)';
            ctx.fillRect(this.currentTime * this.horizZoom - 1, HEADER_HEIGHT, 2, height - HEADER_HEIGHT);
        }
    };
    LayerTimelineGridDirective.prototype.onClick = function (event) {
        // This ensures that click events originating on top of the
        // host element aren't triggered in the component.
        event.stopPropagation();
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Boolean)
    ], LayerTimelineGridDirective.prototype, "isHeader", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], LayerTimelineGridDirective.prototype, "scrub", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Number),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Number])
    ], LayerTimelineGridDirective.prototype, "horizZoom", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_2__["Animation"]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_2__["Animation"]])
    ], LayerTimelineGridDirective.prototype, "animation", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('mousedown', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [MouseEvent]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], LayerTimelineGridDirective.prototype, "onMouseDown", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('click', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [MouseEvent]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], LayerTimelineGridDirective.prototype, "onClick", null);
    LayerTimelineGridDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({ selector: '[appLayerTimelineGrid]' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"], app_modules_editor_services__WEBPACK_IMPORTED_MODULE_5__["ThemeService"]])
    ], LayerTimelineGridDirective);
    return LayerTimelineGridDirective;
}(Object(app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_4__["DestroyableMixin"])()));

function round(n) {
    return lodash__WEBPACK_IMPORTED_MODULE_7__["round"](n, 8);
}


/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/timelineanimationrow.component.html":
/*!*********************************************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/timelineanimationrow.component.html ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"slt-layer-row\"></div>\n\n<ng-container *ngIf=\"(this.animationRowModel$ | async) as model\">\n  <div class=\"slt-properties\"\n    *ngIf=\"model.isExpanded\"\n    [ngClass]=\"{'slt-properties-empty': !model.blocksByPropertyNameValues.length}\">\n    <div class=\"slt-property\"\n      *ngFor=\"let blocks of model.blocksByPropertyNameValues\">\n      <div class=\"slt-timeline-block\"\n        *ngFor=\"let block of blocks\"\n        (dblclick)=\"this.onTimelineBlockDoubleClick($event, block, this.layer)\"\n        (click)=\"this.onTimelineBlockClick($event, block, this.layer)\"\n        (mousedown)=\"this.onTimelineBlockMouseDown($event, block, this.layer)\"\n        tabindex=\"-1\"\n        [ngStyle]=\"{\n          'left': (100 * block.startTime / model.animation.duration) + '%',\n          'width': (100 * (block.endTime - block.startTime) / model.animation.duration) + '%'\n        }\"\n        [ngClass]=\"{\n          'is-disabled': model.isActionMode,\n          'is-selected': block.isAnimatable() && model.selectedBlockIds.has(block.id),\n          'has-error': !block.isAnimatable() && !model.selectedBlockIds.has(block.id),\n          'is-selected-with-error': !block.isAnimatable() && model.selectedBlockIds.has(block.id)\n        }\">\n        <div class=\"slt-timeline-block-edge slt-timeline-block-edge-start\"></div>\n        <div class=\"slt-timeline-block-edge slt-timeline-block-edge-end\"></div>\n      </div>\n    </div>\n  </div>\n\n  <ul class=\"slt-children-row\"\n    *ngIf=\"layer.children.length > 0 && model.isExpanded\">\n    <li *ngFor=\"let child of layer.children; trackBy: trackLayerFn\">\n      <app-timelineanimationrow [layer]=\"child\"\n        (timelineBlockMouseDown)=\"this.onTimelineBlockMouseDown($event.event, $event.block, $event.layer)\"\n        (timelineBlockClick)=\"this.onTimelineBlockClick($event.event, $event.block, $event.layer)\"\n        (timelineBlockDoubleClick)=\"this.onTimelineBlockDoubleClick($event.event, $event.block, $event.layer)\">\n      </app-timelineanimationrow>\n    </li>\n  </ul>\n</ng-container>\n"

/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/timelineanimationrow.component.scss":
/*!*********************************************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/timelineanimationrow.component.scss ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "ul {\n  margin: 0;\n  padding: 0; }\n\nli {\n  list-style: none; }\n\n.slt-layer-row {\n  box-sizing: border-box;\n  line-height: 20px;\n  height: 20px; }\n\n.slt-children-row {\n  padding: 0;\n  margin: 0 0 0 0px; }\n\n.slt-properties {\n  margin: 4px 0;\n  border-radius: 2px; }\n\n.slt-properties .slt-property {\n    position: relative;\n    line-height: 24px;\n    height: 24px; }\n\n.slt-properties .slt-property .slt-timeline-block {\n      position: absolute;\n      height: 12px;\n      border-radius: 6px;\n      top: 50%;\n      transform: translate(0, -50%);\n      outline: 0;\n      cursor: pointer; }\n\n.slt-properties .slt-property .slt-timeline-block .slt-timeline-block-edge {\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        width: 6px;\n        cursor: ew-resize; }\n\n.slt-properties .slt-property .slt-timeline-block .slt-timeline-block-edge-start {\n        left: 0; }\n\n.slt-properties .slt-property .slt-timeline-block .slt-timeline-block-edge-end {\n        right: 0; }\n\n.slt-properties .slt-property .slt-timeline-block.is-disabled {\n        cursor: default; }\n\n.slt-properties-empty {\n  display: none; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL2xheWVydGltZWxpbmUvdGltZWxpbmVhbmltYXRpb25yb3cuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0E7RUFDSSxVQUFTO0VBQ1QsV0FBVSxFQUNiOztBQUVEO0VBQ0ksaUJBQWdCLEVBQ25COztBQUVEO0VBQ0ksdUJBQXNCO0VBQ3RCLGtCQUFpQjtFQUNqQixhQUFZLEVBQ2Y7O0FBRUQ7RUFDSSxXQUFVO0VBQ1Ysa0JBQWlCLEVBQ3BCOztBQUVEO0VBQ0ksY0FBYTtFQUNiLG1CQUFrQixFQStCckI7O0FBakNEO0lBSVEsbUJBQWtCO0lBQ2xCLGtCQUFpQjtJQUNqQixhQUFZLEVBMEJmOztBQWhDTDtNQVFZLG1CQUFrQjtNQUNsQixhQUFZO01BQ1osbUJBQWtCO01BQ2xCLFNBQVE7TUFDUiw4QkFBNkI7TUFDN0IsV0FBVTtNQUNWLGdCQUFlLEVBaUJsQjs7QUEvQlQ7UUFnQmdCLG1CQUFrQjtRQUNsQixPQUFNO1FBQ04sVUFBUztRQUNULFdBQVU7UUFDVixrQkFBaUIsRUFDcEI7O0FBckJiO1FBdUJnQixRQUFPLEVBQ1Y7O0FBeEJiO1FBMEJnQixTQUFRLEVBQ1g7O0FBM0JiO1FBNkJnQixnQkFBZSxFQUNsQjs7QUFLYjtFQUNJLGNBQWEsRUFDaEIiLCJmaWxlIjoic3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL2xheWVydGltZWxpbmUvdGltZWxpbmVhbmltYXRpb25yb3cuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIkdGltZWxpbmVBbmltYXRpb25QYWRkaW5nOiAyMHB4O1xudWwge1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xufVxuXG5saSB7XG4gICAgbGlzdC1zdHlsZTogbm9uZTtcbn1cblxuLnNsdC1sYXllci1yb3cge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gICAgaGVpZ2h0OiAyMHB4O1xufVxuXG4uc2x0LWNoaWxkcmVuLXJvdyB7XG4gICAgcGFkZGluZzogMDtcbiAgICBtYXJnaW46IDAgMCAwIDBweDtcbn1cblxuLnNsdC1wcm9wZXJ0aWVzIHtcbiAgICBtYXJnaW46IDRweCAwO1xuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAuc2x0LXByb3BlcnR5IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBsaW5lLWhlaWdodDogMjRweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICAuc2x0LXRpbWVsaW5lLWJsb2NrIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgIGhlaWdodDogMTJweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICAgICAgICAgIHRvcDogNTAlO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgLTUwJSk7XG4gICAgICAgICAgICBvdXRsaW5lOiAwO1xuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgLnNsdC10aW1lbGluZS1ibG9jay1lZGdlIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgdG9wOiAwO1xuICAgICAgICAgICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgICAgICAgICB3aWR0aDogNnB4O1xuICAgICAgICAgICAgICAgIGN1cnNvcjogZXctcmVzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLnNsdC10aW1lbGluZS1ibG9jay1lZGdlLXN0YXJ0IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLnNsdC10aW1lbGluZS1ibG9jay1lZGdlLWVuZCB7XG4gICAgICAgICAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAmLmlzLWRpc2FibGVkIHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi5zbHQtcHJvcGVydGllcy1lbXB0eSB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cbiJdfQ== */"

/***/ }),

/***/ "./src/app/modules/editor/components/layertimeline/timelineanimationrow.component.ts":
/*!*******************************************************************************************!*\
  !*** ./src/app/modules/editor/components/layertimeline/timelineanimationrow.component.ts ***!
  \*******************************************************************************************/
/*! exports provided: TimelineAnimationRowComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineAnimationRowComponent", function() { return TimelineAnimationRowComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store/common/selectors */ "./src/app/modules/editor/store/common/selectors.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");









var TimelineAnimationRowComponent = /** @class */ (function () {
    function TimelineAnimationRowComponent(store, actionModeService) {
        this.store = store;
        this.actionModeService = actionModeService;
        // MouseEvents from this layer (or children layers further down the tree)
        // are recursively handled by parent components until they reach
        // the LayerTimelineComponent.
        this.timelineBlockClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.timelineBlockMouseDown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.timelineBlockDoubleClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    TimelineAnimationRowComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.animationRowModel$ = this.store.select(app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_6__["getTimelineAnimationRowState"]).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["map"])(function (_a) {
            var animation = _a.animation, collapsedLayerIds = _a.collapsedLayerIds, selectedBlockIds = _a.selectedBlockIds, isActionMode = _a.isActionMode;
            // Returns a list of animation block lists. Each animation block list corresponds to
            // a property name displayed in the layer list tree.
            var blocksByPropertyNameValues = lodash__WEBPACK_IMPORTED_MODULE_7__["values"](app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["ModelUtil"].getOrderedBlocksByPropertyByLayer(animation)[_this.layer.id]);
            return {
                animation: animation,
                blocksByPropertyNameValues: blocksByPropertyNameValues,
                isExpanded: !collapsedLayerIds.has(_this.layer.id),
                selectedBlockIds: selectedBlockIds,
                isActionMode: isActionMode,
            };
        }));
    };
    // @Override Callbacks
    TimelineAnimationRowComponent.prototype.onTimelineBlockClick = function (event, block) {
        event.stopPropagation();
        if (!this.actionModeService.isActionMode()) {
            this.timelineBlockClick.emit({ event: event, block: block });
        }
    };
    // @Override Callbacks
    TimelineAnimationRowComponent.prototype.onTimelineBlockDoubleClick = function (event, block) {
        event.stopPropagation();
        if (!this.actionModeService.isActionMode()) {
            this.timelineBlockDoubleClick.emit({ event: event, block: block });
        }
    };
    // @Override Callbacks
    TimelineAnimationRowComponent.prototype.onTimelineBlockMouseDown = function (event, block) {
        if (!this.actionModeService.isActionMode()) {
            this.timelineBlockMouseDown.emit({ event: event, block: block });
        }
    };
    // Used by *ngFor loop.
    TimelineAnimationRowComponent.prototype.trackLayerFn = function (index, layer) {
        return layer.id;
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["Layer"])
    ], TimelineAnimationRowComponent.prototype, "layer", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], TimelineAnimationRowComponent.prototype, "timelineBlockClick", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], TimelineAnimationRowComponent.prototype, "timelineBlockMouseDown", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], TimelineAnimationRowComponent.prototype, "timelineBlockDoubleClick", void 0);
    TimelineAnimationRowComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-timelineanimationrow',
            template: __webpack_require__(/*! ./timelineanimationrow.component.html */ "./src/app/modules/editor/components/layertimeline/timelineanimationrow.component.html"),
            styles: [__webpack_require__(/*! ./timelineanimationrow.component.scss */ "./src/app/modules/editor/components/layertimeline/timelineanimationrow.component.scss")],
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_5__["Store"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_4__["ActionModeService"]])
    ], TimelineAnimationRowComponent);
    return TimelineAnimationRowComponent;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/playback/index.ts":
/*!*************************************************************!*\
  !*** ./src/app/modules/editor/components/playback/index.ts ***!
  \*************************************************************/
/*! exports provided: PlaybackComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _playback_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./playback.component */ "./src/app/modules/editor/components/playback/playback.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlaybackComponent", function() { return _playback_component__WEBPACK_IMPORTED_MODULE_0__["PlaybackComponent"]; });




/***/ }),

/***/ "./src/app/modules/editor/components/playback/playback.component.html":
/*!****************************************************************************!*\
  !*** ./src/app/modules/editor/components/playback/playback.component.html ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div *ngIf=\"(this.playbackModel$ | async) as model\"\n  class=\"playback\"\n  fxLayout=\"row\"\n  fxLayoutAlign=\"center center\">\n  <span fxFlex></span>\n  <button class=\"slow-motion-button\"\n    mat-icon-button\n    matTooltip=\"Slow motion (S)\"\n    matTooltipPosition=\"below\"\n    matTooltipShowDelay=\"500\"\n    (click)=\"this.isSlowMotionClick($event)\">\n    <mat-icon [class.activated]=\"model.isSlowMotion\">slow_motion_video</mat-icon>\n  </button>\n  <button mat-icon-button\n    matTooltip=\"Rewind (Left)\"\n    matTooltipPosition=\"below\"\n    matTooltipShowDelay=\"500\"\n    (click)=\"this.rewindClick($event)\">\n    <mat-icon>skip_previous</mat-icon>\n  </button>\n  <button mat-mini-fab\n    matTooltip=\"{{ (model.isPlaying) ? 'Pause' : 'Play' }} (Spacebar)\"\n    matTooltipPosition=\"below\"\n    matTooltipShowDelay=\"500\"\n    (click)=\"this.playPauseButtonClick($event)\">\n    <div\n      class=\"play-pause-icon\"\n      [ngClass]=\"{\n        'can-animate': true,\n        'is-playing': model.isPlaying\n      }\">\n    </div>\n  </button>\n  <button mat-icon-button\n    matTooltip=\"Fast forward (Right)\"\n    matTooltipPosition=\"below\"\n    matTooltipShowDelay=\"500\"\n    (click)=\"this.fastForwardClick($event)\">\n    <mat-icon>skip_next</mat-icon>\n  </button>\n  <button class=\"repeating-button\"\n    mat-icon-button\n    matTooltip=\"Repeat (R)\"\n    matTooltipPosition=\"below\"\n    matTooltipShowDelay=\"500\"\n    (click)=\"this.isRepeatingClick($event)\">\n    <mat-icon [class.activated]=\"model.isRepeating\">repeat</mat-icon>\n  </button>\n  <span fxFlex></span>\n</div>\n"

/***/ }),

/***/ "./src/app/modules/editor/components/playback/playback.component.scss":
/*!****************************************************************************!*\
  !*** ./src/app/modules/editor/components/playback/playback.component.scss ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".playback button {\n  margin: 0px 3px; }\n\n.playback .play-pause-icon {\n  position: absolute;\n  overflow: hidden;\n  left: 50%;\n  top: 50%;\n  width: 24px;\n  height: 24px;\n  transform: translate(-50%, -50%); }\n\n.playback .play-pause-icon::after {\n    content: '';\n    display: block;\n    pointer-events: none;\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 504px;\n    height: 24px;\n    background-size: 504px 24px;\n    background-position: 0% 0%;\n    background-image: url(/assets/icons/pauseplay-white.png);\n    transform: translateX(-480px);\n    -webkit-animation-duration: 0.35s;\n            animation-duration: 0.35s;\n    -webkit-animation-timing-function: steps(20);\n            animation-timing-function: steps(20); }\n\n.playback .play-pause-icon.can-animate::after {\n    -webkit-animation-name: pauseplay;\n            animation-name: pauseplay; }\n\n.playback .play-pause-icon.can-animate.is-playing::after {\n    background-image: url(/assets/icons/playpause-white.png);\n    -webkit-animation-name: playpause;\n            animation-name: playpause; }\n\n@-webkit-keyframes playpause {\n  from {\n    transform: translateX(0); }\n  to {\n    transform: translateX(-480px); } }\n\n@keyframes playpause {\n  from {\n    transform: translateX(0); }\n  to {\n    transform: translateX(-480px); } }\n\n@-webkit-keyframes pauseplay {\n  from {\n    transform: translateX(0); }\n  to {\n    transform: translateX(-480px); } }\n\n@keyframes pauseplay {\n  from {\n    transform: translateX(0); }\n  to {\n    transform: translateX(-480px); } }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL3BsYXliYWNrL3BsYXliYWNrLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBRVEsZ0JBQWUsRUFDbEI7O0FBSEw7RUFNUSxtQkFBa0I7RUFDbEIsaUJBQWdCO0VBQ2hCLFVBQVM7RUFDVCxTQUFRO0VBQ1IsWUFBVztFQUNYLGFBQVk7RUFDWixpQ0FBZ0MsRUF3Q25DOztBQXBETDtJQWNZLFlBQVc7SUFDWCxlQUFjO0lBQ2QscUJBQW9CO0lBQ3BCLG1CQUFrQjtJQUNsQixRQUFPO0lBQ1AsT0FBTTtJQUNOLGFBQW1DO0lBQ25DLGFBQVk7SUFDWiw0QkFBa0Q7SUFDbEQsMkJBQTBCO0lBQzFCLHlEQUF3RDtJQUN4RCw4QkFBd0Q7SUFDeEQsa0NBQW1EO1lBQW5ELDBCQUFtRDtJQUNuRCw2Q0FBeUQ7WUFBekQscUNBQXlELEVBQzVEOztBQTVCVDtJQThCWSxrQ0FBeUI7WUFBekIsMEJBQXlCLEVBQzVCOztBQS9CVDtJQWlDWSx5REFBd0Q7SUFDeEQsa0NBQXlCO1lBQXpCLDBCQUF5QixFQUM1Qjs7QUFDRDtFQUNJO0lBQ0kseUJBQXdCLEVBQUE7RUFFNUI7SUFDSSw4QkFBd0QsRUFBQSxFQUFBOztBQUxoRTtFQUNJO0lBQ0kseUJBQXdCLEVBQUE7RUFFNUI7SUFDSSw4QkFBd0QsRUFBQSxFQUFBOztBQUdoRTtFQUNJO0lBQ0kseUJBQXdCLEVBQUE7RUFFNUI7SUFDSSw4QkFBd0QsRUFBQSxFQUFBOztBQUxoRTtFQUNJO0lBQ0kseUJBQXdCLEVBQUE7RUFFNUI7SUFDSSw4QkFBd0QsRUFBQSxFQUFBIiwiZmlsZSI6InNyYy9hcHAvbW9kdWxlcy9lZGl0b3IvY29tcG9uZW50cy9wbGF5YmFjay9wbGF5YmFjay5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi5wbGF5YmFjayB7XG4gICAgYnV0dG9uIHtcbiAgICAgICAgbWFyZ2luOiAwcHggM3B4O1xuICAgIH1cbiAgICAucGxheS1wYXVzZS1pY29uIHtcbiAgICAgICAgJG51bUFuaW1hdGlvbkZyYW1lczogMjE7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgbGVmdDogNTAlO1xuICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgd2lkdGg6IDI0cHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgICY6OmFmdGVyIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgICB0b3A6IDA7XG4gICAgICAgICAgICB3aWR0aDogKCRudW1BbmltYXRpb25GcmFtZXMgKiAyNHB4KTtcbiAgICAgICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgICAgIGJhY2tncm91bmQtc2l6ZTogKCRudW1BbmltYXRpb25GcmFtZXMgKiAyNHB4KSAyNHB4O1xuICAgICAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMCUgMCU7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoL2Fzc2V0cy9pY29ucy9wYXVzZXBsYXktd2hpdGUucG5nKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgoJG51bUFuaW1hdGlvbkZyYW1lcyAtIDEpICogLTI0cHgpO1xuICAgICAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAoMXMgKiAkbnVtQW5pbWF0aW9uRnJhbWVzIC8gNjApO1xuICAgICAgICAgICAgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogc3RlcHMoJG51bUFuaW1hdGlvbkZyYW1lcyAtIDEpO1xuICAgICAgICB9XG4gICAgICAgICYuY2FuLWFuaW1hdGU6OmFmdGVyIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbi1uYW1lOiBwYXVzZXBsYXk7XG4gICAgICAgIH1cbiAgICAgICAgJi5jYW4tYW5pbWF0ZS5pcy1wbGF5aW5nOjphZnRlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoL2Fzc2V0cy9pY29ucy9wbGF5cGF1c2Utd2hpdGUucG5nKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbi1uYW1lOiBwbGF5cGF1c2U7XG4gICAgICAgIH1cbiAgICAgICAgQGtleWZyYW1lcyBwbGF5cGF1c2Uge1xuICAgICAgICAgICAgZnJvbSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG8ge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgoJG51bUFuaW1hdGlvbkZyYW1lcyAtIDEpICogLTI0cHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEBrZXlmcmFtZXMgcGF1c2VwbGF5IHtcbiAgICAgICAgICAgIGZyb20ge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoKCRudW1BbmltYXRpb25GcmFtZXMgLSAxKSAqIC0yNHB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ== */"

/***/ }),

/***/ "./src/app/modules/editor/components/playback/playback.component.ts":
/*!**************************************************************************!*\
  !*** ./src/app/modules/editor/components/playback/playback.component.ts ***!
  \**************************************************************************/
/*! exports provided: PlaybackComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaybackComponent", function() { return PlaybackComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/store/playback/selectors */ "./src/app/modules/editor/store/playback/selectors.ts");





var PlaybackComponent = /** @class */ (function () {
    function PlaybackComponent(store, playbackService) {
        this.store = store;
        this.playbackService = playbackService;
    }
    PlaybackComponent.prototype.ngOnInit = function () {
        this.playbackModel$ = this.store.select(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_4__["getPlaybackState"]);
    };
    PlaybackComponent.prototype.isSlowMotionClick = function (event) {
        event.stopPropagation();
        this.playbackService.toggleIsSlowMotion();
    };
    PlaybackComponent.prototype.rewindClick = function (event) {
        event.stopPropagation();
        this.playbackService.rewind();
    };
    PlaybackComponent.prototype.playPauseButtonClick = function (event) {
        event.stopPropagation();
        this.playbackService.toggleIsPlaying();
    };
    PlaybackComponent.prototype.fastForwardClick = function (event) {
        event.stopPropagation();
        this.playbackService.fastForward();
    };
    PlaybackComponent.prototype.isRepeatingClick = function (event) {
        event.stopPropagation();
        this.playbackService.toggleIsRepeating();
    };
    PlaybackComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-playback',
            template: __webpack_require__(/*! ./playback.component.html */ "./src/app/modules/editor/components/playback/playback.component.html"),
            styles: [__webpack_require__(/*! ./playback.component.scss */ "./src/app/modules/editor/components/playback/playback.component.scss")],
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_3__["Store"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_2__["PlaybackService"]])
    ], PlaybackComponent);
    return PlaybackComponent;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/project/index.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/components/project/index.ts ***!
  \************************************************************/
/*! exports provided: ProjectService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _project_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./project.service */ "./src/app/modules/editor/components/project/project.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ProjectService", function() { return _project_service__WEBPACK_IMPORTED_MODULE_0__["ProjectService"]; });




/***/ }),

/***/ "./src/app/modules/editor/components/project/project.service.ts":
/*!**********************************************************************!*\
  !*** ./src/app/modules/editor/components/project/project.service.ts ***!
  \**********************************************************************/
/*! exports provided: ProjectService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProjectService", function() { return ProjectService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm5/http.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_services_fileexport_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/services/fileexport.service */ "./src/app/modules/editor/services/fileexport.service.ts");





var ProjectService = /** @class */ (function () {
    function ProjectService(http) {
        this.http = http;
    }
    /**
     * Fetches a shape shifter project via HTTP.
     * @param url the URL of the shape shifter project
     */
    ProjectService.prototype.getProject = function (url) {
        return this.http
            .get(url)
            .toPromise()
            .then(function (response) {
            var jsonObj = response;
            var _a = app_modules_editor_services_fileexport_service__WEBPACK_IMPORTED_MODULE_4__["FileExportService"].fromJSON(jsonObj), vectorLayer = _a.vectorLayer, animation = _a.animation, hiddenLayerIds = _a.hiddenLayerIds;
            return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["ModelUtil"].regenerateModelIds(vectorLayer, animation, hiddenLayerIds);
        });
    };
    ProjectService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_1__["HttpClient"]])
    ], ProjectService);
    return ProjectService;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/propertyinput/InspectedProperty.ts":
/*!******************************************************************************!*\
  !*** ./src/app/modules/editor/components/propertyinput/InspectedProperty.ts ***!
  \******************************************************************************/
/*! exports provided: InspectedProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InspectedProperty", function() { return InspectedProperty; });
/**
 * Stores information about an inspected property.
 * V is the property value type (number, string, or path).
 */
var InspectedProperty = /** @class */ (function () {
    function InspectedProperty(
    // The model object being inspected (a layer, animation, or animation block).
    model, 
    // The model object's inspected property.
    property, 
    // The model object's inspected property name.
    propertyName, 
    // The in-memory entered value map.
    enteredValueMap, 
    // Stores the model's entered value for the given property name in the application store.
    setValueFn, 
    // Returns the value associated with this model's property name.
    getValueFn, 
    // Provides an opportunity to edit the value before it is set.
    transformEditedValueFn, 
    // Returns whether or not this property name is editable.
    isEditable) {
        if (getValueFn === void 0) { getValueFn = function () { return model[propertyName]; }; }
        if (transformEditedValueFn === void 0) { transformEditedValueFn = function (enteredValue) { return enteredValue; }; }
        if (isEditable === void 0) { isEditable = function () { return true; }; }
        this.property = property;
        this.propertyName = propertyName;
        this.enteredValueMap = enteredValueMap;
        this.setValueFn = setValueFn;
        this.getValueFn = getValueFn;
        this.transformEditedValueFn = transformEditedValueFn;
        this.isEditable = isEditable;
        this.typeName = this.property.getTypeName();
    }
    Object.defineProperty(InspectedProperty.prototype, "value", {
        get: function () {
            return this.getValueFn();
        },
        set: function (value) {
            this.setValueFn(value);
        },
        enumerable: true,
        configurable: true
    });
    InspectedProperty.prototype.getDisplayValue = function () {
        return this.property.displayValueForValue(this.value);
    };
    Object.defineProperty(InspectedProperty.prototype, "editableValue", {
        get: function () {
            var enteredValue = this.getEnteredValue();
            return enteredValue === undefined
                ? this.property.getEditableValue(this, 'value')
                : enteredValue;
        },
        set: function (enteredValue) {
            this.setEnteredValue(enteredValue);
            enteredValue = this.transformEditedValueFn(enteredValue);
            this.property.setEditableValue(this, 'value', enteredValue);
        },
        enumerable: true,
        configurable: true
    });
    InspectedProperty.prototype.resolveEnteredValue = function () {
        this.setEnteredValue(undefined);
    };
    InspectedProperty.prototype.getEnteredValue = function () {
        if (this.enteredValueMap.has(this.propertyName)) {
            return this.enteredValueMap.get(this.propertyName);
        }
        return undefined;
    };
    InspectedProperty.prototype.setEnteredValue = function (value) {
        if (value === undefined) {
            this.enteredValueMap.delete(this.propertyName);
        }
        else {
            this.enteredValueMap.set(this.propertyName, value);
        }
    };
    return InspectedProperty;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/propertyinput/index.ts":
/*!******************************************************************!*\
  !*** ./src/app/modules/editor/components/propertyinput/index.ts ***!
  \******************************************************************/
/*! exports provided: PropertyInputComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _propertyinput_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./propertyinput.component */ "./src/app/modules/editor/components/propertyinput/propertyinput.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PropertyInputComponent", function() { return _propertyinput_component__WEBPACK_IMPORTED_MODULE_0__["PropertyInputComponent"]; });




/***/ }),

/***/ "./src/app/modules/editor/components/propertyinput/propertyinput.component.html":
/*!**************************************************************************************!*\
  !*** ./src/app/modules/editor/components/propertyinput/propertyinput.component.html ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class=\"property-input mat-elevation-z4\"\n  *ngIf=\"(this.themeState$ | async) as theme\"\n  [class.dark-to-light-base200]=\"theme.prevThemeType === 'dark' && theme.currThemeType === 'light'\"\n  [class.light-to-dark-base200]=\"theme.prevThemeType === 'light' && theme.currThemeType === 'dark'\"\n  fxLayout=\"column\"\n  fxFlex>\n  <app-splitter [persistId]=\"'property-inspector'\"\n    [edge]=\"'left'\"\n    [min]=\"200\">\n  </app-splitter>\n  <ng-container *ngIf=\"(this.propertyInputModel$ | async) as model\">\n    <!-- No models selected. -->\n    <div *ngIf=\"model.numSelections === 0\"\n      class=\"spi-empty\"\n      fxFlex>\n      Select something to edit its properties\n    </div>\n    <!-- At least one model selected. -->\n    <div *ngIf=\"model.numSelections > 0\"\n      fxLayout=\"column\"\n      fxFlex>\n      <div class=\"spi-header mat-elevation-z2\"\n        [class.dark-to-light-base]=\"theme.prevThemeType === 'dark' && theme.currThemeType === 'light'\"\n        [class.light-to-dark-base]=\"theme.prevThemeType === 'light' && theme.currThemeType === 'dark'\"\n        fxLayoutAlign=\"center center\"\n        fxFlex=\"none\">\n        <mat-icon class=\"spi-selection-icon\"\n          svgIcon=\"{{model.icon}}\">\n        </mat-icon>\n        <div class=\"spi-selection-description-container\"\n          fxLayout=\"column\"\n          fxFlex>\n          <span class=\"spi-selection-description\">{{ model.description }}</span>\n          <span class=\"spi-selection-sub-description\">{{ model.subDescription }}</span>\n        </div>\n        <mat-menu #addTimelineBlockMenu=\"matMenu\">\n          <button mat-menu-item\n            *ngFor=\"let propertyName of model.availablePropertyNames\"\n            (click)=\"this.onAnimateLayerClick(model.model, propertyName)\">\n            {{ propertyName }}\n          </button>\n        </mat-menu>\n        <button mat-icon-button\n          class=\"spi-secondary-icon\"\n          *ngIf=\"this.shouldShowAnimateLayerButton(model)\"\n          matTooltip=\"Animate this layer\"\n          matTooltipPosition=\"left\"\n          matTooltipShowDelay=\"500\"\n          [matMenuTriggerFor]=\"addTimelineBlockMenu\">\n          <mat-icon svgIcon=\"animationblock\"></mat-icon>\n        </button>\n        <button mat-icon-button\n          class=\"spi-secondary-icon\"\n          [disabled]=\"this.shouldDisableStartActionModeButton(model)\"\n          *ngIf=\"this.shouldShowStartActionModeButton(model)\"\n          (click)=\"this.onStartActionModeClick()\"\n          matTooltip=\"Edit path morphing animation\"\n          matTooltipPosition=\"left\"\n          matTooltipShowDelay=\"500\">\n          <mat-icon>edit</mat-icon>\n        </button>\n      </div>\n      <div class=\"spi-body\"\n        fxLayout=\"column\"\n        fxFlex>\n        <div class=\"spi-empty\"\n          *ngIf=\"!model.inspectedProperties.length\"\n          fxFlex>\n          No shared properties to view or edit\n        </div>\n        <div class=\"spi-property\"\n          *ngFor=\"let ip of model.inspectedProperties; trackBy: trackInspectedPropertyFn\">\n          <div class=\"spi-property-name\">{{ ip.propertyName }}</div>\n          <div class=\"spi-property-value\"\n            fxLayout=\"row\">\n            <div *ngIf=\"ip.typeName === 'ColorProperty'\"\n              class=\"spi-property-color-preview\"\n              [style.background-color]=\"this.androidToCssColor(ip.value)\">\n            </div>\n            <span *ngIf=\"!ip.isEditable()\"\n              class=\"spi-property-value-static\"\n              fxFlex>\n              <!-- Only show text if the property isn't inspectable. -->\n              {{ ip.getDisplayValue() }}\n            </span>\n            <div *ngIf=\"ip.isEditable()\"\n              class=\"spi-property-value-editor\"\n              fxLayout=\"column\"\n              fxFlex>\n              <input (keydown)=\"this.onValueEditorKeyDown($event, ip)\"\n                [ngClass]=\"{\n                  'has-input-error': ip.typeName === 'PathProperty' && this.shouldShowInvalidPathAnimationBlockMsg(model)\n                }\"\n                (blur)=\"ip.resolveEnteredValue()\"\n                name=\"{{ip.propertyName}}\"\n                [(ngModel)]=\"ip.editableValue\"\n                *ngIf=\"ip.typeName === 'NameProperty'\n                || ip.typeName === 'PathProperty'\n                || ip.typeName === 'ColorProperty'\n                || ip.typeName === 'NumberProperty'\n                || ip.typeName === 'FractionProperty'\">\n              <ng-container *ngIf=\"ip.typeName === 'EnumProperty'\">\n                <mat-menu #enumMenu=\"matMenu\">\n                  <button mat-menu-item\n                    *ngFor=\"let option of ip.property.options; trackBy: trackEnumOptionFn\"\n                    (click)=\"ip.value = option.value;\">\n                  {{ option.label }}\n                </button>\n                </mat-menu>\n                <button class=\"spi-property-value-menu-target\"\n                  [matMenuTriggerFor]=\"enumMenu\">\n                  <span class=\"spi-property-value-menu-current-value\">\n                    {{ ip.getDisplayValue() }}\n                  </span>\n                </button>\n              </ng-container>\n            </div>\n          </div>\n        </div>\n        <div *ngIf=\"this.shouldShowInvalidPathAnimationBlockMsg(model)\"\n          class=\"alert alert-danger\"\n          fxLayout=\"row\">\n          <span class=\"paths-incompatible-text\"\n            [innerHTML]=\"\n            (this.isPathBlockFromValueEmpty(model.model) && !this.isPathBlockToValueEmpty(model.model))\n              ? '<i>fromValue</i> must not be empty'\n              : (!this.isPathBlockFromValueEmpty(model.model) && this.isPathBlockToValueEmpty(model.model))\n                ? '<i>toValue</i> must not be empty'\n                : (this.isPathBlockFromValueEmpty(model.model) && this.isPathBlockToValueEmpty(model.model))\n                  ? '<i>fromValue</i> and <i>toValue</i> must not be empty'\n                  : 'Paths are incompatible. <i>Auto fix</i> or click the <i>edit path morphing animation</i> button above.'\">\n          </span>\n          <button mat-icon-button\n            class=\"auto-fix-button\"\n            *ngIf=\"!this.isPathBlockFromValueEmpty(model.model) && !this.isPathBlockToValueEmpty(model.model)\"\n            (click)=\"this.onAutoFixPathsClick(model)\"\n            matTooltip=\"Auto fix\"\n            matTooltipPosition=\"below\"\n            matTooltipShowDelay=\"500\">\n            <mat-icon svgIcon=\"autofix\"></mat-icon>\n          </button>\n        </div>\n      </div>\n    </div>\n  </ng-container>\n</div>\n"

/***/ }),

/***/ "./src/app/modules/editor/components/propertyinput/propertyinput.component.scss":
/*!**************************************************************************************!*\
  !*** ./src/app/modules/editor/components/propertyinput/propertyinput.component.scss ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".material-icons {\n  font-weight: normal;\n  font-style: normal;\n  font-size: 24px;\n  display: inline-block;\n  width: 1em;\n  height: 1em;\n  line-height: 1;\n  text-transform: none;\n  letter-spacing: normal;\n  word-wrap: normal;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: 'liga';\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  font-family: 'Material Icons'; }\n\n.property-input {\n  width: 320px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  cursor: default;\n  position: relative; }\n\n.spi-header {\n  z-index: 1;\n  display: flex;\n  flex-direction: row;\n  padding: 16px; }\n\n.spi-header .spi-selection-icon {\n    margin-right: 12px;\n    width: 32px;\n    height: 32px; }\n\n.spi-header .spi-selection-description-container {\n    padding: 4px 0; }\n\n.spi-header .spi-selection-description {\n    font-weight: 500;\n    font-size: 20px;\n    line-height: 24px; }\n\n.spi-header .spi-selection-sub-description {\n    font-size: 14px;\n    line-height: 20px; }\n\n.spi-header .spi-selection-sub-description:empty {\n      display: none; }\n\n.spi-body {\n  overflow-y: auto;\n  padding: 8px 0; }\n\n.spi-body .spi-property {\n    display: flex;\n    flex-direction: row;\n    padding: 4px 16px;\n    min-height: 24px; }\n\n.spi-body .spi-property-name {\n    font-size: 14px;\n    line-height: 24px;\n    flex: 1 1 0; }\n\n.spi-body .spi-property-value {\n    flex: 2 1 0;\n    min-width: 0;\n    font-size: 14px;\n    line-height: 24px; }\n\n.spi-body .spi-property-value-static,\n  .spi-body .spi-property-value-editor input,\n  .spi-body .spi-property-value-menu-target {\n    border: 0;\n    border-radius: 2px;\n    font-size: 14px;\n    line-height: 20px;\n    height: 24px;\n    box-sizing: border-box;\n    padding: 2px 6px;\n    outline: 0; }\n\n.spi-body .spi-property-value-static {\n    overflow-x: scroll;\n    white-space: nowrap;\n    overflow-y: hidden;\n    -ms-overflow-style: none;\n    -webkit-user-select: all;\n       -moz-user-select: all;\n        -ms-user-select: all;\n            user-select: all;\n    cursor: text; }\n\n.spi-body .spi-property-value-static::-webkit-scrollbar {\n      display: none; }\n\n.spi-body .spi-property-value-menu-target {\n    border: 0;\n    text-align: left;\n    position: relative;\n    padding-right: 24px; }\n\n.spi-body .spi-property-value-menu-target::after {\n      font-weight: normal;\n      font-style: normal;\n      font-size: 24px;\n      display: inline-block;\n      width: 1em;\n      height: 1em;\n      line-height: 1;\n      text-transform: none;\n      letter-spacing: normal;\n      word-wrap: normal;\n      -webkit-font-smoothing: antialiased;\n      text-rendering: optimizeLegibility;\n      -moz-osx-font-smoothing: grayscale;\n      font-feature-settings: 'liga';\n      -webkit-user-select: none;\n         -moz-user-select: none;\n          -ms-user-select: none;\n              user-select: none;\n      font-family: 'Material Icons';\n      content: 'arrow_drop_down';\n      position: absolute;\n      font-size: 24px;\n      right: 0;\n      top: 50%;\n      transform: translate(0, -50%); }\n\n.spi-body .spi-property-value-menu-current-value {\n    display: block;\n    width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap; }\n\n.spi-body .spi-property-color-preview {\n    width: 16px;\n    height: 16px;\n    min-width: 16px;\n    min-height: 16px;\n    margin: 4px 8px 4px 4px;\n    border-radius: 50%; }\n\n.spi-empty {\n  padding: 32px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  font-size: 14px;\n  line-height: 20px; }\n\n.launch-shape-shifter-button {\n  min-height: 72px;\n  text-transform: uppercase; }\n\n.alert {\n  padding: 16px;\n  margin-top: 6px;\n  margin-left: 16px;\n  margin-right: 16px;\n  margin-bottom: 16px;\n  border: 1px solid transparent;\n  border-radius: 4px; }\n\n.auto-fix-button {\n  margin-left: 8px; }\n\n.paths-incompatible-text {\n  font-size: 14px;\n  line-height: 20px; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9zdHlsZXMvbWF0ZXJpYWwtaWNvbnMuc2NzcyIsIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL3Byb3BlcnR5aW5wdXQvcHJvcGVydHlpbnB1dC5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF5QkE7RUF4Qkksb0JBQW1CO0VBQ25CLG1CQUFrQjtFQUNsQixnQkFBZTtFQUNmLHNCQUFxQjtFQUNyQixXQUFVO0VBQ1YsWUFBVztFQUNYLGVBQWM7RUFDZCxxQkFBb0I7RUFDcEIsdUJBQXNCO0VBQ3RCLGtCQUFpQjtFQUNqQixvQ0FBbUM7RUFDbkMsbUNBQWtDO0VBQ2xDLG1DQUFrQztFQUdsQyw4QkFBNkI7RUFDN0IsMEJBQWlCO0tBQWpCLHVCQUFpQjtNQUFqQixzQkFBaUI7VUFBakIsa0JBQWlCO0VBS2pCLDhCQUE2QixFQUtoQzs7QUN6QkQ7RUFDSSxhQUFZO0VBQ1osMEJBQWlCO0tBQWpCLHVCQUFpQjtNQUFqQixzQkFBaUI7VUFBakIsa0JBQWlCO0VBQ2pCLGdCQUFlO0VBQ2YsbUJBQWtCLEVBQ3JCOztBQUVEO0VBQ0ksV0FBVTtFQUNWLGNBQWE7RUFDYixvQkFBbUI7RUFDbkIsY0FBYSxFQXFCaEI7O0FBekJEO0lBTVEsbUJBQWtCO0lBQ2xCLFlBQVc7SUFDWCxhQUFZLEVBQ2Y7O0FBVEw7SUFXUSxlQUE0QixFQUMvQjs7QUFaTDtJQWNRLGlCQUFnQjtJQUNoQixnQkFBZTtJQUNmLGtCQUFpQixFQUNwQjs7QUFqQkw7SUFtQlEsZ0JBQWU7SUFDZixrQkFBaUIsRUFJcEI7O0FBeEJMO01Bc0JZLGNBQWEsRUFDaEI7O0FBSVQ7RUFDSSxpQkFBZ0I7RUFDaEIsZUFBYyxFQXVFakI7O0FBekVEO0lBSVEsY0FBYTtJQUNiLG9CQUFtQjtJQUNuQixrQkFBaUI7SUFDakIsaUJBQWdCLEVBQ25COztBQVJMO0lBVVEsZ0JBQWU7SUFDZixrQkFBaUI7SUFDakIsWUFBVyxFQUNkOztBQWJMO0lBZVEsWUFBVztJQUNYLGFBQVk7SUFDWixnQkFBZTtJQUNmLGtCQUFpQixFQUNwQjs7QUFuQkw7OztJQXVCUSxVQUFTO0lBQ1QsbUJBQWtCO0lBQ2xCLGdCQUFlO0lBQ2Ysa0JBQWlCO0lBQ2pCLGFBQVk7SUFDWix1QkFBc0I7SUFDdEIsaUJBQWdCO0lBQ2hCLFdBQVUsRUFDYjs7QUEvQkw7SUFpQ1EsbUJBQWtCO0lBQ2xCLG9CQUFtQjtJQUNuQixtQkFBa0I7SUFDbEIseUJBQXdCO0lBSXhCLHlCQUFnQjtPQUFoQixzQkFBZ0I7UUFBaEIscUJBQWdCO1lBQWhCLGlCQUFnQjtJQUNoQixhQUFZLEVBQ2Y7O0FBMUNMO01Bc0NZLGNBQWEsRUFDaEI7O0FBdkNUO0lBNENRLFVBQVM7SUFDVCxpQkFBZ0I7SUFDaEIsbUJBQWtCO0lBQ2xCLG9CQUFtQixFQVV0Qjs7QUF6REw7TURuQ0ksb0JBQW1CO01BQ25CLG1CQUFrQjtNQUNsQixnQkFBZTtNQUNmLHNCQUFxQjtNQUNyQixXQUFVO01BQ1YsWUFBVztNQUNYLGVBQWM7TUFDZCxxQkFBb0I7TUFDcEIsdUJBQXNCO01BQ3RCLGtCQUFpQjtNQUNqQixvQ0FBbUM7TUFDbkMsbUNBQWtDO01BQ2xDLG1DQUFrQztNQUdsQyw4QkFBNkI7TUFDN0IsMEJBQWlCO1NBQWpCLHVCQUFpQjtVQUFqQixzQkFBaUI7Y0FBakIsa0JBQWlCO01BS2pCLDhCQUE2QjtNQ2dFckIsMkJBQTBCO01BQzFCLG1CQUFrQjtNQUNsQixnQkFBZTtNQUNmLFNBQVE7TUFDUixTQUFRO01BQ1IsOEJBQTZCLEVBQ2hDOztBQXhEVDtJQTJEUSxlQUFjO0lBQ2QsWUFBVztJQUNYLGlCQUFnQjtJQUNoQix3QkFBdUI7SUFDdkIsb0JBQW1CLEVBQ3RCOztBQWhFTDtJQWtFUSxZQUFXO0lBQ1gsYUFBWTtJQUNaLGdCQUFlO0lBQ2YsaUJBQWdCO0lBQ2hCLHdCQUF1QjtJQUN2QixtQkFBa0IsRUFDckI7O0FBR0w7RUFDSSxjQUFhO0VBQ2IsY0FBYTtFQUNiLG9CQUFtQjtFQUNuQix3QkFBdUI7RUFDdkIsbUJBQWtCO0VBQ2xCLGdCQUFlO0VBQ2Ysa0JBQWlCLEVBQ3BCOztBQUVEO0VBQ0ksaUJBQWdCO0VBQ2hCLDBCQUF5QixFQUM1Qjs7QUFFRDtFQUNJLGNBQWE7RUFDYixnQkFBZTtFQUNmLGtCQUFpQjtFQUNqQixtQkFBa0I7RUFDbEIsb0JBQW1CO0VBQ25CLDhCQUE2QjtFQUM3QixtQkFBa0IsRUFDckI7O0FBRUQ7RUFDSSxpQkFBZ0IsRUFDbkI7O0FBRUQ7RUFDSSxnQkFBZTtFQUNmLGtCQUFpQixFQUNwQiIsImZpbGUiOiJzcmMvYXBwL21vZHVsZXMvZWRpdG9yL2NvbXBvbmVudHMvcHJvcGVydHlpbnB1dC9wcm9wZXJ0eWlucHV0LmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiQG1peGluIHVzZS1pY29uLWZvbnQge1xuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xuICAgIGZvbnQtc2l6ZTogMjRweDsgLy8gUHJlZmVycmVkIGljb24gc2l6ZVxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB3aWR0aDogMWVtO1xuICAgIGhlaWdodDogMWVtO1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgIHRleHQtdHJhbnNmb3JtOiBub25lO1xuICAgIGxldHRlci1zcGFjaW5nOiBub3JtYWw7XG4gICAgd29yZC13cmFwOiBub3JtYWw7IC8vIFN1cHBvcnQgZm9yIGFsbCBXZWJLaXQgYnJvd3NlcnMuXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7IC8vIFN1cHBvcnQgZm9yIFNhZmFyaSBhbmQgQ2hyb21lLlxuICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7IC8vIFN1cHBvcnQgZm9yIEZpcmVmb3guXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTsgLy8gU3VwcG9ydCBmb3IgSUUuXG4gICAgLXdlYmtpdC1mb250LWZlYXR1cmUtc2V0dGluZ3M6ICdsaWdhJztcbiAgICAtbW96LWZvbnQtZmVhdHVyZS1zZXR0aW5nczogJ2xpZ2EnO1xuICAgIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogJ2xpZ2EnOyAvLyBDdXN0b20gYWRkZWQgZm9yIEdNUFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xufVxuXG5AbWl4aW4gbWF0ZXJpYWwtaWNvbnMge1xuICAgIEBpbmNsdWRlIHVzZS1pY29uLWZvbnQ7XG4gICAgZm9udC1mYW1pbHk6ICdNYXRlcmlhbCBJY29ucyc7XG59XG5cbi5tYXRlcmlhbC1pY29ucyB7XG4gICAgQGluY2x1ZGUgbWF0ZXJpYWwtaWNvbnM7XG59XG4iLCJAaW1wb3J0ICcuLi8uLi9zdHlsZXMvbWF0ZXJpYWwtaWNvbnMnO1xuXG4ucHJvcGVydHktaW5wdXQge1xuICAgIHdpZHRoOiAzMjBweDtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uc3BpLWhlYWRlciB7XG4gICAgei1pbmRleDogMTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgcGFkZGluZzogMTZweDtcbiAgICAuc3BpLXNlbGVjdGlvbi1pY29uIHtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAxMnB4O1xuICAgICAgICB3aWR0aDogMzJweDtcbiAgICAgICAgaGVpZ2h0OiAzMnB4O1xuICAgIH1cbiAgICAuc3BpLXNlbGVjdGlvbi1kZXNjcmlwdGlvbi1jb250YWluZXIge1xuICAgICAgICBwYWRkaW5nOiAoMzJweCAtIDI0cHgpIC8gMiAwO1xuICAgIH1cbiAgICAuc3BpLXNlbGVjdGlvbi1kZXNjcmlwdGlvbiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDI0cHg7XG4gICAgfVxuICAgIC5zcGktc2VsZWN0aW9uLXN1Yi1kZXNjcmlwdGlvbiB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gICAgICAgICY6ZW1wdHkge1xuICAgICAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLnNwaS1ib2R5IHtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIHBhZGRpbmc6IDhweCAwO1xuICAgIC5zcGktcHJvcGVydHkge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgICBwYWRkaW5nOiA0cHggMTZweDtcbiAgICAgICAgbWluLWhlaWdodDogMjRweDtcbiAgICB9XG4gICAgLnNwaS1wcm9wZXJ0eS1uYW1lIHtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBsaW5lLWhlaWdodDogMjRweDtcbiAgICAgICAgZmxleDogMSAxIDA7XG4gICAgfVxuICAgIC5zcGktcHJvcGVydHktdmFsdWUge1xuICAgICAgICBmbGV4OiAyIDEgMDtcbiAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyNHB4O1xuICAgIH1cbiAgICAuc3BpLXByb3BlcnR5LXZhbHVlLXN0YXRpYyxcbiAgICAuc3BpLXByb3BlcnR5LXZhbHVlLWVkaXRvciBpbnB1dCxcbiAgICAuc3BpLXByb3BlcnR5LXZhbHVlLW1lbnUtdGFyZ2V0IHtcbiAgICAgICAgYm9yZGVyOiAwO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gICAgICAgIGhlaWdodDogMjRweDtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgcGFkZGluZzogMnB4IDZweDtcbiAgICAgICAgb3V0bGluZTogMDtcbiAgICB9XG4gICAgLnNwaS1wcm9wZXJ0eS12YWx1ZS1zdGF0aWMge1xuICAgICAgICBvdmVyZmxvdy14OiBzY3JvbGw7XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcbiAgICAgICAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lO1xuICAgICAgICAmOjotd2Via2l0LXNjcm9sbGJhciB7XG4gICAgICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICB9XG4gICAgICAgIHVzZXItc2VsZWN0OiBhbGw7XG4gICAgICAgIGN1cnNvcjogdGV4dDtcbiAgICB9XG4gICAgLnNwaS1wcm9wZXJ0eS12YWx1ZS1tZW51LXRhcmdldCB7XG4gICAgICAgIGJvcmRlcjogMDtcbiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiAyNHB4O1xuICAgICAgICAmOjphZnRlciB7XG4gICAgICAgICAgICBAaW5jbHVkZSBtYXRlcmlhbC1pY29ucztcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdhcnJvd19kcm9wX2Rvd24nO1xuICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgICAgZm9udC1zaXplOiAyNHB4O1xuICAgICAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIC01MCUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC5zcGktcHJvcGVydHktdmFsdWUtbWVudS1jdXJyZW50LXZhbHVlIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICB9XG4gICAgLnNwaS1wcm9wZXJ0eS1jb2xvci1wcmV2aWV3IHtcbiAgICAgICAgd2lkdGg6IDE2cHg7XG4gICAgICAgIGhlaWdodDogMTZweDtcbiAgICAgICAgbWluLXdpZHRoOiAxNnB4O1xuICAgICAgICBtaW4taGVpZ2h0OiAxNnB4O1xuICAgICAgICBtYXJnaW46IDRweCA4cHggNHB4IDRweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIH1cbn1cblxuLnNwaS1lbXB0eSB7XG4gICAgcGFkZGluZzogMzJweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBsaW5lLWhlaWdodDogMjBweDtcbn1cblxuLmxhdW5jaC1zaGFwZS1zaGlmdGVyLWJ1dHRvbiB7XG4gICAgbWluLWhlaWdodDogNzJweDtcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xufVxuXG4uYWxlcnQge1xuICAgIHBhZGRpbmc6IDE2cHg7XG4gICAgbWFyZ2luLXRvcDogNnB4O1xuICAgIG1hcmdpbi1sZWZ0OiAxNnB4O1xuICAgIG1hcmdpbi1yaWdodDogMTZweDtcbiAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbn1cblxuLmF1dG8tZml4LWJ1dHRvbiB7XG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcbn1cblxuLnBhdGhzLWluY29tcGF0aWJsZS10ZXh0IHtcbiAgICBmb250LXNpemU6IDE0cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG59XG4iXX0= */"

/***/ }),

/***/ "./src/app/modules/editor/components/propertyinput/propertyinput.component.ts":
/*!************************************************************************************!*\
  !*** ./src/app/modules/editor/components/propertyinput/propertyinput.component.ts ***!
  \************************************************************************************/
/*! exports provided: PropertyInputComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyInputComponent", function() { return PropertyInputComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/model/properties */ "./src/app/modules/editor/model/properties/index.ts");
/* harmony import */ var app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/model/timeline */ "./src/app/modules/editor/model/timeline/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/modules/editor/store/common/selectors */ "./src/app/modules/editor/store/common/selectors.ts");
/* harmony import */ var app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/modules/editor/store/timeline/actions */ "./src/app/modules/editor/store/timeline/actions.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _InspectedProperty__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./InspectedProperty */ "./src/app/modules/editor/components/propertyinput/InspectedProperty.ts");
















// TODO: when you enter a 'start time' larger than 'end time', transform 'end time' correctly
var PropertyInputComponent = /** @class */ (function () {
    function PropertyInputComponent(store, actionModeService, playbackService, layerTimelineService, themeService) {
        this.store = store;
        this.actionModeService = actionModeService;
        this.playbackService = playbackService;
        this.layerTimelineService = layerTimelineService;
        this.themeService = themeService;
        // Map used to track user state that has been entered into textfields
        // but may not have been saved in the store.
        this.enteredValueMap = new Map();
    }
    PropertyInputComponent.prototype.ngOnInit = function () {
        var _this = this;
        var prevThemeType;
        var currThemeType = this.themeService.getThemeType().themeType;
        this.propertyInputModel$ = this.store.select(app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_9__["getPropertyInputState"]).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["map"])(function (_a) {
            var animation = _a.animation, isAnimationSelected = _a.isAnimationSelected, selectedBlockIds = _a.selectedBlockIds, vectorLayer = _a.vectorLayer, selectedLayerIds = _a.selectedLayerIds;
            prevThemeType = currThemeType = _this.themeService.getThemeType().themeType;
            if (selectedLayerIds.size) {
                return _this.buildInspectedLayerProperties(vectorLayer, selectedLayerIds, animation);
            }
            else if (selectedBlockIds.size) {
                return _this.buildInspectedBlockProperties(vectorLayer, animation, selectedBlockIds);
            }
            else if (isAnimationSelected) {
                return _this.buildInspectedAnimationProperties(animation);
            }
            else {
                return {
                    numSelections: 0,
                    inspectedProperties: [],
                    availablePropertyNames: [],
                };
            }
        }));
        this.themeState$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["combineLatest"])(this.propertyInputModel$, this.themeService.asObservable()).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["map"])(function (_a) {
            var unused = _a[0], themeType = _a[1].themeType;
            prevThemeType = currThemeType;
            currThemeType = _this.themeService.getThemeType().themeType;
            return { prevThemeType: prevThemeType, currThemeType: currThemeType };
        }));
    };
    PropertyInputComponent.prototype.shouldShowStartActionModeButton = function (pim) {
        return pim.numSelections === 1 && pim.model instanceof app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_5__["PathAnimationBlock"];
    };
    PropertyInputComponent.prototype.shouldDisableStartActionModeButton = function (pim) {
        if (!this.shouldShowStartActionModeButton(pim)) {
            return false;
        }
        var _a = pim.model, fromValue = _a.fromValue, toValue = _a.toValue;
        return !fromValue || !fromValue.getPathString() || !toValue || !toValue.getPathString();
    };
    PropertyInputComponent.prototype.onAutoFixPathsClick = function (pim) {
        this.actionModeService.autoFix();
    };
    PropertyInputComponent.prototype.onStartActionModeClick = function () {
        ga('send', 'event', 'Action mode', 'Started');
        this.actionModeService.setActionMode(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection);
    };
    PropertyInputComponent.prototype.shouldShowAnimateLayerButton = function (pim) {
        return (pim.availablePropertyNames.length > 0 &&
            pim.numSelections === 1 &&
            (pim.model instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["VectorLayer"] ||
                pim.model instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["GroupLayer"] ||
                pim.model instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["ClipPathLayer"] ||
                pim.model instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["PathLayer"]));
    };
    PropertyInputComponent.prototype.onAnimateLayerClick = function (layer, propertyName) {
        var clonedValue = layer.inspectableProperties
            .get(propertyName)
            .cloneValue(layer[propertyName]);
        var currentTime = this.playbackService.getCurrentTime();
        this.layerTimelineService.addBlocks([
            {
                layerId: layer.id,
                propertyName: propertyName,
                fromValue: clonedValue,
                toValue: clonedValue,
                currentTime: currentTime,
            },
        ]);
    };
    PropertyInputComponent.prototype.shouldShowInvalidPathAnimationBlockMsg = function (pim) {
        return (pim.numSelections === 1 &&
            pim.model instanceof app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_5__["PathAnimationBlock"] &&
            !pim.model.isAnimatable());
    };
    PropertyInputComponent.prototype.isPathBlockFromValueEmpty = function (block) {
        return !block.fromValue || !block.fromValue.getPathString();
    };
    PropertyInputComponent.prototype.isPathBlockToValueEmpty = function (block) {
        return !block.toValue || !block.toValue.getPathString();
    };
    PropertyInputComponent.prototype.onValueEditorKeyDown = function (event, ip) {
        switch (event.keyCode) {
            // Up/down arrow buttons.
            case 38:
            case 40:
                ip.resolveEnteredValue();
                var $target_1 = jquery__WEBPACK_IMPORTED_MODULE_11__(event.target);
                var numberValue = Number($target_1.val());
                if (isNaN(numberValue)) {
                    break;
                }
                var delta = event.keyCode === 38 ? 1 : -1;
                if (ip.property instanceof app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_4__["FractionProperty"]) {
                    delta *= 0.1;
                }
                if (event.shiftKey) {
                    // TODO: make this more obvious somehow
                    delta *= 10;
                }
                else if (app_modules_editor_services__WEBPACK_IMPORTED_MODULE_7__["ShortcutService"].isOsDependentModifierKey(event)) {
                    // TODO: make this more obvious somehow
                    delta /= 10;
                }
                ip.property.setEditableValue(ip, 'value', Number((numberValue + delta).toFixed(6)));
                setTimeout(function () { return $target_1.get(0).select(); }, 0);
                return false;
        }
        return undefined;
    };
    PropertyInputComponent.prototype.buildInspectedLayerProperties = function (vl, selectedLayerIds, animation) {
        var _this = this;
        var numSelections = selectedLayerIds.size;
        var selectedLayers = Array.from(selectedLayerIds).map(function (id) { return vl.findLayerById(id); });
        if (numSelections > 1) {
            return {
                numSelections: numSelections,
                icon: 'collection',
                description: numSelections + " layers",
                // TODO: implement batch editting
                inspectedProperties: [],
                availablePropertyNames: [],
            };
        }
        // Edit a single layer.
        var enteredValueMap = this.enteredValueMap;
        var layer = selectedLayers[0];
        var icon = layer.type;
        var description = layer.name;
        var inspectedProperties = [];
        layer.inspectableProperties.forEach(function (property, propertyName) {
            inspectedProperties.push(new _InspectedProperty__WEBPACK_IMPORTED_MODULE_15__["InspectedProperty"](layer, property, propertyName, enteredValueMap, function (value) {
                // TODO: avoid dispatching the action if the properties are equal
                var clonedLayer = layer.clone();
                clonedLayer[propertyName] = value;
                _this.layerTimelineService.updateLayer(clonedLayer);
            }, 
            // TODO: return the 'rendered' value if an animation is ongoing? (see AIA)
            undefined, function (enteredValue) {
                if (property instanceof app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_4__["NameProperty"]) {
                    return app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getUniqueLayerName([vl], app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_4__["NameProperty"].sanitize(enteredValue));
                }
                return enteredValue;
            }, 
            // TODO: copy AIA conditions to determine whether this should be editable
            undefined));
        });
        var availablePropertyNames = Array.from(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_6__["ModelUtil"].getAvailablePropertyNamesForLayer(layer, animation));
        return {
            model: layer,
            numSelections: numSelections,
            inspectedProperties: inspectedProperties,
            icon: icon,
            description: description,
            availablePropertyNames: availablePropertyNames,
        };
    };
    PropertyInputComponent.prototype.buildInspectedBlockProperties = function (vl, animation, selectedBlockIds) {
        var _this = this;
        var numSelections = selectedBlockIds.size;
        var selectedBlocks = Array.from(selectedBlockIds).map(function (id) {
            return lodash__WEBPACK_IMPORTED_MODULE_12__["find"](animation.blocks, function (b) { return b.id === id; });
        });
        if (numSelections > 1) {
            return {
                numSelections: numSelections,
                icon: 'collection',
                // TODO: implement batch editting
                description: numSelections + " property animations",
                inspectedProperties: [],
                availablePropertyNames: [],
            };
        }
        var enteredValueMap = this.enteredValueMap;
        var block = selectedBlocks[0];
        var icon = 'animationblock';
        var description = block.propertyName;
        var blockLayer = vl.findLayerById(block.layerId);
        var subDescription = "for '" + blockLayer.name + "'";
        var inspectedProperties = [];
        block.inspectableProperties.forEach(function (property, propertyName) {
            inspectedProperties.push(new _InspectedProperty__WEBPACK_IMPORTED_MODULE_15__["InspectedProperty"](block, property, propertyName, enteredValueMap, function (value) {
                // TODO: avoid dispatching the action if the properties are equal
                var clonedBlock = block.clone();
                clonedBlock[propertyName] = value;
                _this.layerTimelineService.updateBlocks([clonedBlock]);
            }));
        });
        return {
            model: block,
            numSelections: numSelections,
            inspectedProperties: inspectedProperties,
            icon: icon,
            description: description,
            subDescription: subDescription,
            availablePropertyNames: [],
        };
    };
    PropertyInputComponent.prototype.buildInspectedAnimationProperties = function (animation) {
        var store = this.store;
        var enteredValueMap = this.enteredValueMap;
        var icon = 'animation';
        var description = animation.name;
        var inspectedProperties = [];
        animation.inspectableProperties.forEach(function (property, propertyName) {
            inspectedProperties.push(new _InspectedProperty__WEBPACK_IMPORTED_MODULE_15__["InspectedProperty"](animation, property, propertyName, enteredValueMap, function (value) {
                // TODO: avoid dispatching the action if the properties are equal
                var clonedAnimation = animation.clone();
                clonedAnimation[propertyName] = value;
                store.dispatch(new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SetAnimation"](clonedAnimation));
            }, undefined, undefined, undefined));
        });
        return {
            model: animation,
            numSelections: 1,
            inspectedProperties: inspectedProperties,
            icon: icon,
            description: description,
            availablePropertyNames: [],
        };
    };
    // Called from the HTML template.
    PropertyInputComponent.prototype.androidToCssColor = function (color) {
        return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_6__["ColorUtil"].androidToCssHexColor(color);
    };
    PropertyInputComponent.prototype.trackInspectedPropertyFn = function (index, ip) {
        return ip.propertyName;
    };
    PropertyInputComponent.prototype.trackEnumOptionFn = function (index, option) {
        return option.value;
    };
    PropertyInputComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-propertyinput',
            template: __webpack_require__(/*! ./propertyinput.component.html */ "./src/app/modules/editor/components/propertyinput/propertyinput.component.html"),
            styles: [__webpack_require__(/*! ./propertyinput.component.scss */ "./src/app/modules/editor/components/propertyinput/propertyinput.component.scss")],
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_8__["Store"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_7__["ActionModeService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_7__["PlaybackService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_7__["LayerTimelineService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_7__["ThemeService"]])
    ], PropertyInputComponent);
    return PropertyInputComponent;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/root/droptarget.directive.ts":
/*!************************************************************************!*\
  !*** ./src/app/modules/editor/components/root/droptarget.directive.ts ***!
  \************************************************************************/
/*! exports provided: DropTargetDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DropTargetDirective", function() { return DropTargetDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);



var DragState;
(function (DragState) {
    DragState[DragState["None"] = 0] = "None";
    DragState[DragState["Dragging"] = 1] = "Dragging";
    DragState[DragState["Loading"] = 2] = "Loading";
})(DragState || (DragState = {}));
var DropTargetDirective = /** @class */ (function () {
    function DropTargetDirective(elementRef) {
        this.elementRef = elementRef;
        this.onDropFiles = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.dragState = DragState.None;
    }
    DropTargetDirective.prototype.ngOnInit = function () {
        this.element = jquery__WEBPACK_IMPORTED_MODULE_2__(this.elementRef.nativeElement);
        this.element.addClass('file-drop-target');
    };
    DropTargetDirective.prototype.onDragEnter = function (event) {
        event.preventDefault();
        this.setDragging(true);
        return false;
    };
    DropTargetDirective.prototype.onDragOver = function (event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
        return false;
    };
    DropTargetDirective.prototype.onDragLeave = function (event) {
        event.preventDefault();
        this.setDragging(false);
        return false;
    };
    DropTargetDirective.prototype.onDrop = function (event) {
        this.setDragState(DragState.None);
        this.onDropFiles.emit(event.dataTransfer.files);
        return false;
    };
    DropTargetDirective.prototype.setDragState = function (state) {
        this.dragState = state;
        this.element.toggleClass('is-dragging-over', this.dragState === DragState.Dragging);
        this.element.toggleClass('is-loading', this.dragState === DragState.Loading);
    };
    // Set up drag event listeners, with debouncing because dragging over/out
    // of each child triggers these events on the element.
    DropTargetDirective.prototype.setDragging = function (isDragging) {
        var _this = this;
        if (isDragging) {
            // When moving from child to child, dragenter is sent before dragleave
            // on previous child.
            window.setTimeout(function () {
                if (_this.notDraggingTimeoutId) {
                    window.clearTimeout(_this.notDraggingTimeoutId);
                    _this.notDraggingTimeoutId = undefined;
                }
                _this.setDragState(DragState.Dragging);
            }, 0);
        }
        else {
            if (this.notDraggingTimeoutId) {
                window.clearTimeout(this.notDraggingTimeoutId);
            }
            this.notDraggingTimeoutId = window.setTimeout(function () { return _this.setDragState(DragState.None); }, 100);
        }
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], DropTargetDirective.prototype, "onDropFiles", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('dragenter', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Event]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], DropTargetDirective.prototype, "onDragEnter", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('dragover', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Event]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], DropTargetDirective.prototype, "onDragOver", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('dragleave', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Event]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], DropTargetDirective.prototype, "onDragLeave", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('drop', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Event]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], DropTargetDirective.prototype, "onDrop", null);
    DropTargetDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
            selector: '[appDropTarget]',
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]])
    ], DropTargetDirective);
    return DropTargetDirective;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/root/root.component.html":
/*!********************************************************************!*\
  !*** ./src/app/modules/editor/components/root/root.component.html ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div>\n  <app-splashscreen fxLayoutAlign=\"center center\"\n    *ngIf=\"this.isMobile()\">\n  </app-splashscreen>\n\n  <!-- Disable drag start events by default. -->\n  <div *ngIf=\"!this.isMobile()\"\n    appDropTarget\n    (onDropFiles)=\"onDropFiles($event)\"\n    class=\"app-container\"\n    fxLayout=\"column\"\n    ondragstart=\"return false;\"\n    (click)=\"this.onClick($event)\"\n    fxFlex>\n    <!-- Toolbar. -->\n    <div class=\"toolbar-container\">\n      <app-toolbar></app-toolbar>\n    </div>\n    <div fxLayout=\"row\"\n      fxFlex>\n      <!-- Tool Panel -->\n      <app-toolpanel *ngIf=\"this.IS_BETA\"\n        fxLayout=\"column\">\n      </app-toolpanel>\n      <div class=\"display-container\"\n        *ngIf=\"(this.themeService.asObservable() | async) as theme\"\n        [class.dark-to-light-base300]=\"!theme.isInitialPageLoad && theme.themeType === 'light'\"\n        [class.light-to-dark-base300]=\"!theme.isInitialPageLoad && theme.themeType === 'dark'\"\n        fxLayout=\"column\"\n        fxFlex>\n        <!-- Canvas -->\n        <div #displayContainer\n          fxLayout=\"row\"\n          fxLayoutAlign=\"center center\"\n          fxFlex\n          [ngClass]=\"this.cursorClassName$ | async\">\n          <app-canvas class=\"start\"\n            *ngIf=\"this.isActionMode$ | async\"\n            [actionSource]=\"ACTION_SOURCE_FROM\"\n            [canvasBounds$]=\"this.canvasBounds$\">\n          </app-canvas>\n          <app-canvas [canvasBounds$]=\"this.canvasBounds$\"\n            [actionSource]=\"ACTION_SOURCE_ANIMATED\">\n          </app-canvas>\n          <app-canvas class=\"end\"\n            *ngIf=\"this.isActionMode$ | async\"\n            [actionSource]=\"ACTION_SOURCE_TO\"\n            [canvasBounds$]=\"this.canvasBounds$\">\n          </app-canvas>\n        </div>\n        <!-- Playback controls. -->\n        <app-playback></app-playback>\n      </div>\n      <!-- Property input panel. -->\n      <app-propertyinput *ngIf=\"(this.isActionMode$ | async) === false\"\n        fxLayout=\"column\"\n        (click)=\"$event.stopPropagation()\">\n      </app-propertyinput>\n    </div>\n    <!-- Layer list & animation timeline. -->\n    <app-layertimeline></app-layertimeline>\n  </div>\n</div>"

/***/ }),

/***/ "./src/app/modules/editor/components/root/root.component.scss":
/*!********************************************************************!*\
  !*** ./src/app/modules/editor/components/root/root.component.scss ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ":host,\n.app-container {\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none; }\n\napp-canvas.start {\n  margin-right: 48px; }\n\napp-canvas.end {\n  margin-left: 48px; }\n\ndiv.toolbar-container {\n  position: relative;\n  z-index: 1; }\n\n.file-drop-target.is-dragging-over::after {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  z-index: 9999;\n  -webkit-animation: pulsate-color 0.66s ease 0s infinite;\n          animation: pulsate-color 0.66s ease 0s infinite;\n  pointer-events: none;\n  transform: translateZ(0); }\n\n@-webkit-keyframes pulsate-color {\n  0% {\n    opacity: 0.5; }\n  50% {\n    opacity: 1; }\n  100% {\n    opacity: 0.5; } }\n\n@keyframes pulsate-color {\n  0% {\n    opacity: 0.5; }\n  50% {\n    opacity: 1; }\n  100% {\n    opacity: 0.5; } }\n\ndiv.display-container {\n  box-sizing: border-box;\n  padding-bottom: 16px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none; }\n\napp-toolpanel {\n  background-color: white; }\n\n.cursor-default {\n  cursor: default; }\n\n.cursor-pointer {\n  cursor: pointer; }\n\n.cursor-resize0 {\n  cursor: ns-resize; }\n\n.cursor-resize45 {\n  cursor: nesw-resize; }\n\n.cursor-resize90 {\n  cursor: ew-resize; }\n\n.cursor-resize135 {\n  cursor: nwse-resize; }\n\n.cursor-zoom-in {\n  cursor: zoom-in; }\n\n.cursor-zoom-out {\n  cursor: zoom-out; }\n\n.cursor-grab {\n  cursor: -webkit-grab;\n  cursor: grab; }\n\n.cursor-grabbing {\n  cursor: -webkit-grabbing;\n  cursor: grabbing; }\n\n.cursor-point-select {\n  cursor: url(/assets/cursor/point-select.png) 3 3, auto; }\n\n.cursor-crosshair {\n  cursor: url(/assets/cursor/crosshair.png) 10 10, auto; }\n\n.cursor-pen {\n  cursor: url(/assets/cursor/pen.png) 6 0, auto; }\n\n.cursor-pen-add {\n  cursor: url(/assets/cursor/pen-add.png) 6 0, auto; }\n\n.cursor-pen-close {\n  cursor: url(/assets/cursor/pen-close.png) 6 0, auto; }\n\n.cursor-pencil {\n  cursor: url(/assets/cursor/pencil.png) 0 18, auto; }\n\n.cursor-rotate0 {\n  cursor: url(/assets/cursor/rotate-top.png) 11 11, auto; }\n\n.cursor-rotate45 {\n  cursor: url(/assets/cursor/rotate-top-right.png) 10 11, auto; }\n\n.cursor-rotate90 {\n  cursor: url(/assets/cursor/rotate-right.png) 10 12, auto; }\n\n.cursor-rotate135 {\n  cursor: url(/assets/cursor/rotate-bottom-right.png) 11 11, auto; }\n\n.cursor-rotate180 {\n  cursor: url(/assets/cursor/rotate-bottom.png) 11 10, auto; }\n\n.cursor-rotate225 {\n  cursor: url(/assets/cursor/rotate-bottom-left.png) 11 10, auto; }\n\n.cursor-rotate270 {\n  cursor: url(/assets/cursor/rotate-left.png) 11 12, auto; }\n\n.cursor-rotate315 {\n  cursor: url(/assets/cursor/rotate-top-left.png) 10 10, auto; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL3Jvb3Qvcm9vdC5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7RUFFRSxtQkFBa0I7RUFDbEIsUUFBTztFQUNQLE9BQU07RUFDTixTQUFRO0VBQ1IsVUFBUztFQUNULDBCQUFpQjtLQUFqQix1QkFBaUI7TUFBakIsc0JBQWlCO1VBQWpCLGtCQUFpQixFQUNsQjs7QUFFRDtFQUNFLG1CQUFrQixFQUNuQjs7QUFFRDtFQUNFLGtCQUFpQixFQUNsQjs7QUFFRDtFQUNFLG1CQUFrQjtFQUNsQixXQUFVLEVBQ1g7O0FBRUQ7RUFFSSxZQUFXO0VBQ1gsbUJBQWtCO0VBQ2xCLFFBQU87RUFDUCxPQUFNO0VBQ04sU0FBUTtFQUNSLFVBQVM7RUFDVCxjQUFhO0VBQ2Isd0RBQStDO1VBQS9DLGdEQUErQztFQUMvQyxxQkFBb0I7RUFDcEIseUJBQXdCLEVBQ3pCOztBQUNEO0VBQ0U7SUFDRSxhQUFZLEVBQUE7RUFFZDtJQUNFLFdBQVUsRUFBQTtFQUVaO0lBQ0UsYUFBWSxFQUFBLEVBQUE7O0FBUmhCO0VBQ0U7SUFDRSxhQUFZLEVBQUE7RUFFZDtJQUNFLFdBQVUsRUFBQTtFQUVaO0lBQ0UsYUFBWSxFQUFBLEVBQUE7O0FBS2xCO0VBQ0UsdUJBQXNCO0VBQ3RCLHFCQUFvQjtFQUNwQiwwQkFBaUI7S0FBakIsdUJBQWlCO01BQWpCLHNCQUFpQjtVQUFqQixrQkFBaUIsRUFDbEI7O0FBRUQ7RUFFRSx3QkFBdUIsRUFDeEI7O0FBRUQ7RUFDRSxnQkFBZSxFQUNoQjs7QUFFRDtFQUNFLGdCQUFlLEVBQ2hCOztBQUVEO0VBQ0Usa0JBQWlCLEVBQ2xCOztBQUVEO0VBQ0Usb0JBQW1CLEVBQ3BCOztBQUVEO0VBQ0Usa0JBQWlCLEVBQ2xCOztBQUVEO0VBQ0Usb0JBQW1CLEVBQ3BCOztBQUVEO0VBQ0UsZ0JBQWUsRUFDaEI7O0FBRUQ7RUFDRSxpQkFBZ0IsRUFDakI7O0FBRUQ7RUFDRSxxQkFBWTtFQUFaLGFBQVksRUFDYjs7QUFFRDtFQUNFLHlCQUFnQjtFQUFoQixpQkFBZ0IsRUFDakI7O0FBRUQ7RUFDRSx1REFBc0QsRUFDdkQ7O0FBRUQ7RUFDRSxzREFBcUQsRUFDdEQ7O0FBRUQ7RUFDRSw4Q0FBNkMsRUFDOUM7O0FBRUQ7RUFDRSxrREFBaUQsRUFDbEQ7O0FBRUQ7RUFDRSxvREFBbUQsRUFDcEQ7O0FBRUQ7RUFDRSxrREFBaUQsRUFDbEQ7O0FBRUQ7RUFDRSx1REFBc0QsRUFDdkQ7O0FBRUQ7RUFDRSw2REFBNEQsRUFDN0Q7O0FBRUQ7RUFDRSx5REFBd0QsRUFDekQ7O0FBRUQ7RUFDRSxnRUFBK0QsRUFDaEU7O0FBRUQ7RUFDRSwwREFBeUQsRUFDMUQ7O0FBRUQ7RUFDRSwrREFBOEQsRUFDL0Q7O0FBRUQ7RUFDRSx3REFBdUQsRUFDeEQ7O0FBRUQ7RUFDRSw0REFBMkQsRUFDNUQiLCJmaWxlIjoic3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL3Jvb3Qvcm9vdC5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIjpob3N0LFxuLmFwcC1jb250YWluZXIge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGxlZnQ6IDA7XG4gIHRvcDogMDtcbiAgcmlnaHQ6IDA7XG4gIGJvdHRvbTogMDtcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XG59XG5cbmFwcC1jYW52YXMuc3RhcnQge1xuICBtYXJnaW4tcmlnaHQ6IDQ4cHg7XG59XG5cbmFwcC1jYW52YXMuZW5kIHtcbiAgbWFyZ2luLWxlZnQ6IDQ4cHg7XG59XG5cbmRpdi50b29sYmFyLWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgei1pbmRleDogMTtcbn1cblxuLmZpbGUtZHJvcC10YXJnZXQge1xuICAmLmlzLWRyYWdnaW5nLW92ZXI6OmFmdGVyIHtcbiAgICBjb250ZW50OiAnJztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICB0b3A6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIHotaW5kZXg6IDk5OTk7XG4gICAgYW5pbWF0aW9uOiBwdWxzYXRlLWNvbG9yIDAuNjZzIGVhc2UgMHMgaW5maW5pdGU7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICB9XG4gIEBrZXlmcmFtZXMgcHVsc2F0ZS1jb2xvciB7XG4gICAgMCUge1xuICAgICAgb3BhY2l0eTogMC41O1xuICAgIH1cbiAgICA1MCUge1xuICAgICAgb3BhY2l0eTogMTtcbiAgICB9XG4gICAgMTAwJSB7XG4gICAgICBvcGFjaXR5OiAwLjU7XG4gICAgfVxuICB9XG59XG5cbmRpdi5kaXNwbGF5LWNvbnRhaW5lciB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIHBhZGRpbmctYm90dG9tOiAxNnB4O1xuICB1c2VyLXNlbGVjdDogbm9uZTtcbn1cblxuYXBwLXRvb2xwYW5lbCB7XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb2xvciB0aGVtZSBkZXBlbmRlbnRcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG59XG5cbi5jdXJzb3ItZGVmYXVsdCB7XG4gIGN1cnNvcjogZGVmYXVsdDtcbn1cblxuLmN1cnNvci1wb2ludGVyIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4uY3Vyc29yLXJlc2l6ZTAge1xuICBjdXJzb3I6IG5zLXJlc2l6ZTtcbn1cblxuLmN1cnNvci1yZXNpemU0NSB7XG4gIGN1cnNvcjogbmVzdy1yZXNpemU7XG59XG5cbi5jdXJzb3ItcmVzaXplOTAge1xuICBjdXJzb3I6IGV3LXJlc2l6ZTtcbn1cblxuLmN1cnNvci1yZXNpemUxMzUge1xuICBjdXJzb3I6IG53c2UtcmVzaXplO1xufVxuXG4uY3Vyc29yLXpvb20taW4ge1xuICBjdXJzb3I6IHpvb20taW47XG59XG5cbi5jdXJzb3Item9vbS1vdXQge1xuICBjdXJzb3I6IHpvb20tb3V0O1xufVxuXG4uY3Vyc29yLWdyYWIge1xuICBjdXJzb3I6IGdyYWI7XG59XG5cbi5jdXJzb3ItZ3JhYmJpbmcge1xuICBjdXJzb3I6IGdyYWJiaW5nO1xufVxuXG4uY3Vyc29yLXBvaW50LXNlbGVjdCB7XG4gIGN1cnNvcjogdXJsKC9hc3NldHMvY3Vyc29yL3BvaW50LXNlbGVjdC5wbmcpIDMgMywgYXV0bztcbn1cblxuLmN1cnNvci1jcm9zc2hhaXIge1xuICBjdXJzb3I6IHVybCgvYXNzZXRzL2N1cnNvci9jcm9zc2hhaXIucG5nKSAxMCAxMCwgYXV0bztcbn1cblxuLmN1cnNvci1wZW4ge1xuICBjdXJzb3I6IHVybCgvYXNzZXRzL2N1cnNvci9wZW4ucG5nKSA2IDAsIGF1dG87XG59XG5cbi5jdXJzb3ItcGVuLWFkZCB7XG4gIGN1cnNvcjogdXJsKC9hc3NldHMvY3Vyc29yL3Blbi1hZGQucG5nKSA2IDAsIGF1dG87XG59XG5cbi5jdXJzb3ItcGVuLWNsb3NlIHtcbiAgY3Vyc29yOiB1cmwoL2Fzc2V0cy9jdXJzb3IvcGVuLWNsb3NlLnBuZykgNiAwLCBhdXRvO1xufVxuXG4uY3Vyc29yLXBlbmNpbCB7XG4gIGN1cnNvcjogdXJsKC9hc3NldHMvY3Vyc29yL3BlbmNpbC5wbmcpIDAgMTgsIGF1dG87XG59XG5cbi5jdXJzb3Itcm90YXRlMCB7XG4gIGN1cnNvcjogdXJsKC9hc3NldHMvY3Vyc29yL3JvdGF0ZS10b3AucG5nKSAxMSAxMSwgYXV0bztcbn1cblxuLmN1cnNvci1yb3RhdGU0NSB7XG4gIGN1cnNvcjogdXJsKC9hc3NldHMvY3Vyc29yL3JvdGF0ZS10b3AtcmlnaHQucG5nKSAxMCAxMSwgYXV0bztcbn1cblxuLmN1cnNvci1yb3RhdGU5MCB7XG4gIGN1cnNvcjogdXJsKC9hc3NldHMvY3Vyc29yL3JvdGF0ZS1yaWdodC5wbmcpIDEwIDEyLCBhdXRvO1xufVxuXG4uY3Vyc29yLXJvdGF0ZTEzNSB7XG4gIGN1cnNvcjogdXJsKC9hc3NldHMvY3Vyc29yL3JvdGF0ZS1ib3R0b20tcmlnaHQucG5nKSAxMSAxMSwgYXV0bztcbn1cblxuLmN1cnNvci1yb3RhdGUxODAge1xuICBjdXJzb3I6IHVybCgvYXNzZXRzL2N1cnNvci9yb3RhdGUtYm90dG9tLnBuZykgMTEgMTAsIGF1dG87XG59XG5cbi5jdXJzb3Itcm90YXRlMjI1IHtcbiAgY3Vyc29yOiB1cmwoL2Fzc2V0cy9jdXJzb3Ivcm90YXRlLWJvdHRvbS1sZWZ0LnBuZykgMTEgMTAsIGF1dG87XG59XG5cbi5jdXJzb3Itcm90YXRlMjcwIHtcbiAgY3Vyc29yOiB1cmwoL2Fzc2V0cy9jdXJzb3Ivcm90YXRlLWxlZnQucG5nKSAxMSAxMiwgYXV0bztcbn1cblxuLmN1cnNvci1yb3RhdGUzMTUge1xuICBjdXJzb3I6IHVybCgvYXNzZXRzL2N1cnNvci9yb3RhdGUtdG9wLWxlZnQucG5nKSAxMCAxMCwgYXV0bztcbn1cbiJdfQ== */"

/***/ }),

/***/ "./src/app/modules/editor/components/root/root.component.ts":
/*!******************************************************************!*\
  !*** ./src/app/modules/editor/components/root/root.component.ts ***!
  \******************************************************************/
/*! exports provided: RootComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RootComponent", function() { return RootComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm5/overlay.es5.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/components/dialogs */ "./src/app/modules/editor/components/dialogs/index.ts");
/* harmony import */ var app_modules_editor_components_project__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/components/project */ "./src/app/modules/editor/components/project/index.ts");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_scripts_bugsnag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/scripts/bugsnag */ "./src/app/modules/editor/scripts/bugsnag/index.ts");
/* harmony import */ var app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/modules/editor/scripts/mixins */ "./src/app/modules/editor/scripts/mixins/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_services_snackbar_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/modules/editor/services/snackbar.service */ "./src/app/modules/editor/services/snackbar.service.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/modules/editor/store/actionmode/selectors */ "./src/app/modules/editor/store/actionmode/selectors.ts");
/* harmony import */ var app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/modules/editor/store/common/selectors */ "./src/app/modules/editor/store/common/selectors.ts");
/* harmony import */ var app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/modules/editor/store/paper/selectors */ "./src/app/modules/editor/store/paper/selectors.ts");
/* harmony import */ var app_modules_editor_store_reset_actions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/modules/editor/store/reset/actions */ "./src/app/modules/editor/store/reset/actions.ts");
/* harmony import */ var element_resize_detector__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! element-resize-detector */ "./node_modules/element-resize-detector/src/element-resize-detector.js");
/* harmony import */ var element_resize_detector__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(element_resize_detector__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");





















var IS_DEV_BUILD = !environments_environment__WEBPACK_IMPORTED_MODULE_17__["environment"].production;
var ELEMENT_RESIZE_DETECTOR = element_resize_detector__WEBPACK_IMPORTED_MODULE_16__({ strategy: 'scroll' });
var STORAGE_KEY_FIRST_TIME_USER = 'storage_key_first_time_user';
var RootComponent = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RootComponent, _super);
    function RootComponent(snackBarService, fileImportService, store, actionModeService, shortcutService, demoService, dialogService, clipboardService, layerTimelineService, themeService, overlayContainer) {
        var _this = _super.call(this) || this;
        _this.snackBarService = snackBarService;
        _this.fileImportService = fileImportService;
        _this.store = store;
        _this.actionModeService = actionModeService;
        _this.shortcutService = shortcutService;
        _this.demoService = demoService;
        _this.dialogService = dialogService;
        _this.clipboardService = clipboardService;
        _this.layerTimelineService = layerTimelineService;
        _this.themeService = themeService;
        _this.overlayContainer = overlayContainer;
        _this.ACTION_SOURCE_FROM = app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_5__["ActionSource"].From;
        _this.ACTION_SOURCE_ANIMATED = app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_5__["ActionSource"].Animated;
        _this.ACTION_SOURCE_TO = app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_5__["ActionSource"].To;
        _this.IS_BETA = environments_environment__WEBPACK_IMPORTED_MODULE_17__["environment"].beta;
        _this.displayBoundsSubject = new rxjs__WEBPACK_IMPORTED_MODULE_19__["BehaviorSubject"]({ w: 1, h: 1 });
        return _this;
    }
    RootComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.shortcutService.init();
        this.clipboardService.init();
        this.registerSubscription(this.themeService.asObservable().subscribe(function (t) {
            var isDark = t.themeType === 'dark';
            _this.isDarkThemeHostBinding = isDark;
            var classList = _this.overlayContainer.getContainerElement().classList;
            if (isDark) {
                classList.add('ss-dark-theme');
            }
            else {
                classList.remove('ss-dark-theme');
            }
        }));
        jquery__WEBPACK_IMPORTED_MODULE_18__(window).on('beforeunload', function (event) {
            var isDirty;
            _this.store
                .select(app_modules_editor_store_common_selectors__WEBPACK_IMPORTED_MODULE_13__["isWorkspaceDirty"])
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__["first"])())
                .subscribe(function (dirty) { return (isDirty = dirty); });
            if (isDirty && !IS_DEV_BUILD) {
                return "You've made changes but haven't saved. Are you sure you want to navigate away?";
            }
            return undefined;
        });
        var displaySize$ = this.displayBoundsSubject.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__["distinctUntilChanged"])(function (s1, s2) {
            return s1.w === s2.w && s1.h === s2.h;
        }));
        this.isActionMode$ = this.store
            .select(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_12__["getActionMode"])
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__["map"])(function (mode) { return mode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_5__["ActionMode"].None; }));
        this.canvasBounds$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_19__["combineLatest"])(displaySize$, this.isActionMode$).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__["map"])(function (_a) {
            var _b = _a[0], w = _b.w, h = _b.h, shouldShowThreeCanvases = _a[1];
            return { w: w / (shouldShowThreeCanvases ? 3 : 1), h: h };
        }));
        this.cursorClassName$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_19__["combineLatest"])(this.store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_14__["getCursorType"]), this.store.select(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_12__["getActionMode"]), this.store.select(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_12__["getActionModeHover"])).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__["map"])(function (_a) {
            var cursorType = _a[0], mode = _a[1], hover = _a[2];
            if (mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_5__["ActionMode"].SplitCommands || mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_5__["ActionMode"].SplitSubPaths) {
                return app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_6__["CursorType"].Pen;
            }
            else if (hover) {
                return app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_6__["CursorType"].Pointer;
            }
            return cursorType || app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_6__["CursorType"].Default;
        }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__["map"])(function (cursorType) { return "cursor-" + cursorType; }));
    };
    RootComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (!this.isMobile()) {
            this.$displayContainer = jquery__WEBPACK_IMPORTED_MODULE_18__(this.displayContainerRef.nativeElement);
            ELEMENT_RESIZE_DETECTOR.listenTo(this.$displayContainer.get(0), function () {
                var w = _this.$displayContainer.width();
                var h = _this.$displayContainer.height();
                _this.displayBoundsSubject.next({ w: w, h: h });
            });
        }
        if ('serviceWorker' in navigator) {
            var isFirstTimeUser = window.localStorage.getItem(STORAGE_KEY_FIRST_TIME_USER);
            if (!isFirstTimeUser) {
                window.localStorage.setItem(STORAGE_KEY_FIRST_TIME_USER, 'true');
                setTimeout(function () {
                    _this.snackBarService.show('Ready to work offline', 'Dismiss', app_modules_editor_services_snackbar_service__WEBPACK_IMPORTED_MODULE_10__["Duration"].Long);
                });
            }
        }
        var projectUrl = getUrlParameter('project');
        if (projectUrl) {
            this.demoService
                .getProject(projectUrl)
                .then(function (_a) {
                var vectorLayer = _a.vectorLayer, animation = _a.animation, hiddenLayerIds = _a.hiddenLayerIds;
                _this.store.dispatch(new app_modules_editor_store_reset_actions__WEBPACK_IMPORTED_MODULE_15__["ResetWorkspace"](vectorLayer, animation, hiddenLayerIds));
            })
                .catch(function (e) {
                _this.snackBarService.show("There was a problem loading the Shape Shifter project", 'Dismiss', app_modules_editor_services_snackbar_service__WEBPACK_IMPORTED_MODULE_10__["Duration"].Long);
            });
        }
    };
    RootComponent.prototype.ngOnDestroy = function () {
        _super.prototype.ngOnDestroy.call(this);
        if (!this.isMobile()) {
            ELEMENT_RESIZE_DETECTOR.removeAllListeners(this.$displayContainer.get(0));
        }
        this.shortcutService.destroy();
        this.clipboardService.destroy();
        jquery__WEBPACK_IMPORTED_MODULE_18__(window).unbind('beforeunload');
    };
    // Called by the DropTargetDirective.
    RootComponent.prototype.onDropFiles = function (fileList) {
        var _this = this;
        if (this.actionModeService.isActionMode()) {
            // TODO: make action mode automatically exit when layers/blocks are added in other parts of the app
            app_modules_editor_scripts_bugsnag__WEBPACK_IMPORTED_MODULE_7__["bugsnagClient"].notify('Attempt to import files while in action mode', {
                severity: 'warning',
            });
            return;
        }
        if (!fileList || !fileList.length) {
            return;
        }
        var files = [];
        // tslint:disable-next-line: prefer-for-of
        for (var i = 0; i < fileList.length; i++) {
            files.push(fileList[i]);
        }
        var type = files[0].type;
        if (!files.every(function (file) { return file.type === type; })) {
            // TODO: handle attempts to import different types of files better
            return;
        }
        if (type === 'application/json' || files[0].name.match(/\.shapeshifter$/)) {
            // TODO: Show a dialog here as well?
            this.fileImportService.import(fileList, true /* resetWorkspace */);
            return;
        }
        this.dialogService.dropFiles().subscribe(function (action) {
            if (action === app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_3__["DropFilesAction"].AddToWorkspace) {
                _this.fileImportService.import(fileList);
            }
            else if (action === app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_3__["DropFilesAction"].ResetWorkspace) {
                _this.fileImportService.import(fileList, true /* resetWorkspace */);
            }
        });
    };
    RootComponent.prototype.onClick = function (event) {
        var actionMode = this.actionModeService.getActionMode();
        if (actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_5__["ActionMode"].None) {
            this.layerTimelineService.clearSelections();
        }
        else if (actionMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_5__["ActionMode"].Selection) {
            this.actionModeService.setSelections([]);
        }
        else {
            this.actionModeService.setActionMode(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_5__["ActionMode"].Selection);
        }
    };
    RootComponent.prototype.isMobile = function () {
        return window.navigator.userAgent.includes('Mobile');
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["HostBinding"])('class.ss-dark-theme'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Boolean)
    ], RootComponent.prototype, "isDarkThemeHostBinding", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"])('displayContainer'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"])
    ], RootComponent.prototype, "displayContainerRef", void 0);
    RootComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"])({
            selector: 'app-root',
            template: __webpack_require__(/*! ./root.component.html */ "./src/app/modules/editor/components/root/root.component.html"),
            styles: [__webpack_require__(/*! ./root.component.scss */ "./src/app/modules/editor/components/root/root.component.scss")],
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectionStrategy"].OnPush,
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_services_snackbar_service__WEBPACK_IMPORTED_MODULE_10__["SnackBarService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_9__["FileImportService"],
            app_modules_editor_store__WEBPACK_IMPORTED_MODULE_11__["Store"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_9__["ActionModeService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_9__["ShortcutService"],
            app_modules_editor_components_project__WEBPACK_IMPORTED_MODULE_4__["ProjectService"],
            app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_3__["DialogService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_9__["ClipboardService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_9__["LayerTimelineService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_9__["ThemeService"],
            _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_1__["OverlayContainer"]])
    ], RootComponent);
    return RootComponent;
}(Object(app_modules_editor_scripts_mixins__WEBPACK_IMPORTED_MODULE_8__["DestroyableMixin"])()));

function getUrlParameter(name) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    var results = regex.exec(location.search);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
}


/***/ }),

/***/ "./src/app/modules/editor/components/scrollgroup/scrollgroup.directive.ts":
/*!********************************************************************************!*\
  !*** ./src/app/modules/editor/components/scrollgroup/scrollgroup.directive.ts ***!
  \********************************************************************************/
/*! exports provided: ScrollGroupDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollGroupDirective", function() { return ScrollGroupDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);



var GROUPS = new Map();
var ScrollGroupDirective = /** @class */ (function () {
    function ScrollGroupDirective(elementRef) {
        this.element = jquery__WEBPACK_IMPORTED_MODULE_2__(elementRef.nativeElement);
        GROUPS.set(this.scrollGroup, GROUPS.get(this.scrollGroup) || []);
        GROUPS.get(this.scrollGroup).push(this.element);
    }
    ScrollGroupDirective.prototype.ngOnDestroy = function () {
        GROUPS.get(this.scrollGroup).splice(GROUPS.get(this.scrollGroup).indexOf(this.element), 1);
    };
    ScrollGroupDirective.prototype.onScrollEvent = function (event) {
        var _this = this;
        var scrollTop = this.element.scrollTop();
        GROUPS.get(this.scrollGroup).forEach(function (e) {
            if (_this.element !== e) {
                e.scrollTop(scrollTop);
            }
        });
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], ScrollGroupDirective.prototype, "scrollGroup", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('scroll', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [MouseEvent]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], ScrollGroupDirective.prototype, "onScrollEvent", null);
    ScrollGroupDirective = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
            selector: '[appScrollGroup]',
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]])
    ], ScrollGroupDirective);
    return ScrollGroupDirective;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/splashscreen/splashscreen.component.html":
/*!************************************************************************************!*\
  !*** ./src/app/modules/editor/components/splashscreen/splashscreen.component.html ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div fxLayout=\"column\"\n  fxLayoutAlign=\"center center\">\n\n  <mat-icon class=\"splashscreen-logo\"\n    svgIcon=\"shapeshifter\">\n  </mat-icon>\n\n  <div class=\"splashscreen-text\">Shape Shifter is an icon animation tool designed for desktop browsers</div>\n\n</div>\n"

/***/ }),

/***/ "./src/app/modules/editor/components/splashscreen/splashscreen.component.scss":
/*!************************************************************************************!*\
  !*** ./src/app/modules/editor/components/splashscreen/splashscreen.component.scss ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "/* Theme for the ripple elements.*/\n/* stylelint-disable material/no-prefixes */\n/* stylelint-enable */\n:host {\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  background-color: #e0e0e0; }\n.splashscreen-logo {\n  width: 144px;\n  height: 144px;\n  margin-bottom: 16px; }\n.splashscreen-text {\n  font-size: 18px;\n  line-height: 22px;\n  padding-left: 16px;\n  padding-right: 16px;\n  padding-bottom: 16px;\n  text-align: center; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL21hdGVyaWFsL190aGVtaW5nLnNjc3MiLCIvaG9tZS91YnVudHUvU2hhcGVTaGlmdGVyL3NyYy9hcHAvbW9kdWxlcy9lZGl0b3IvY29tcG9uZW50cy9zcGxhc2hzY3JlZW4vc3BsYXNoc2NyZWVuLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXkxQ0EsbUNBQW1DO0FBb2hEbkMsNENBQTRDO0FBd0M1QyxzQkFBc0I7QUNwNUZ0QjtFQUNJLG1CQUFrQjtFQUNsQixRQUFPO0VBQ1AsT0FBTTtFQUNOLFNBQVE7RUFDUixVQUFTO0VBQ1QsMEJBQWlCO0tBQWpCLHVCQUFpQjtNQUFqQixzQkFBaUI7VUFBakIsa0JBQWlCO0VBQ2pCLDBCRHFrQ1UsRUNwa0NiO0FBRUQ7RUFDSSxhQUFZO0VBQ1osY0FBYTtFQUNiLG9CQUFtQixFQUN0QjtBQUVEO0VBQ0ksZ0JBQWU7RUFDZixrQkFBaUI7RUFDakIsbUJBQWtCO0VBQ2xCLG9CQUFtQjtFQUNuQixxQkFBb0I7RUFDcEIsbUJBQWtCLEVBQ3JCIiwiZmlsZSI6InNyYy9hcHAvbW9kdWxlcy9lZGl0b3IvY29tcG9uZW50cy9zcGxhc2hzY3JlZW4vc3BsYXNoc2NyZWVuLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0IGFsbCB0aGUgdGhlbWluZyBmdW5jdGlvbmFsaXR5LlxuLy8gV2UgY2FuIHVzZSByZWxhdGl2ZSBpbXBvcnRzIGZvciBpbXBvcnRzIGZyb20gdGhlIGNkayBiZWNhdXNlIHdlIGJ1bmRsZSBldmVyeXRoaW5nXG4vLyB1cCBpbnRvIGEgc2luZ2xlIGZsYXQgc2NzcyBmaWxlIGZvciBtYXRlcmlhbC5cbi8vIFdlIHdhbnQgb3ZlcmxheXMgdG8gYWx3YXlzIGFwcGVhciBvdmVyIHVzZXIgY29udGVudCwgc28gc2V0IGEgYmFzZWxpbmVcbi8vIHZlcnkgaGlnaCB6LWluZGV4IGZvciB0aGUgb3ZlcmxheSBjb250YWluZXIsIHdoaWNoIGlzIHdoZXJlIHdlIGNyZWF0ZSB0aGUgbmV3XG4vLyBzdGFja2luZyBjb250ZXh0IGZvciBhbGwgb3ZlcmxheXMuXG4kY2RrLXotaW5kZXgtb3ZlcmxheS1jb250YWluZXI6IDEwMDA7XG4kY2RrLXotaW5kZXgtb3ZlcmxheTogMTAwMDtcbiRjZGstei1pbmRleC1vdmVybGF5LWJhY2tkcm9wOiAxMDAwO1xuXG4vLyBCYWNrZ3JvdW5kIGNvbG9yIGZvciBhbGwgb2YgdGhlIGJhY2tkcm9wc1xuJGNkay1vdmVybGF5LWRhcmstYmFja2Ryb3AtYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjMyKTtcblxuLy8gRGVmYXVsdCBiYWNrZHJvcCBhbmltYXRpb24gaXMgYmFzZWQgb24gdGhlIE1hdGVyaWFsIERlc2lnbiBzd2lmdC1lYXNlLW91dC5cbiRiYWNrZHJvcC1hbmltYXRpb24tZHVyYXRpb246IDQwMG1zICFkZWZhdWx0O1xuJGJhY2tkcm9wLWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpICFkZWZhdWx0O1xuXG5cbkBtaXhpbiBjZGstb3ZlcmxheSgpIHtcbiAgLmNkay1vdmVybGF5LWNvbnRhaW5lciwgLmNkay1nbG9iYWwtb3ZlcmxheS13cmFwcGVyIHtcbiAgICAvLyBEaXNhYmxlIGV2ZW50cyBmcm9tIGJlaW5nIGNhcHR1cmVkIG9uIHRoZSBvdmVybGF5IGNvbnRhaW5lci5cbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcblxuICAgIC8vIFRoZSBjb250YWluZXIgc2hvdWxkIGJlIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydC5cbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IDEwMCU7XG4gIH1cblxuICAvLyBUaGUgb3ZlcmxheS1jb250YWluZXIgaXMgYW4gaW52aXNpYmxlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgYWxsIGluZGl2aWR1YWwgb3ZlcmxheXMuXG4gIC5jZGstb3ZlcmxheS1jb250YWluZXIge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB6LWluZGV4OiAkY2RrLXotaW5kZXgtb3ZlcmxheS1jb250YWluZXI7XG5cbiAgICAmOmVtcHR5IHtcbiAgICAgIC8vIEhpZGUgdGhlIGVsZW1lbnQgd2hlbiBpdCBkb2Vzbid0IGhhdmUgYW55IGNoaWxkIG5vZGVzLiBUaGlzIGRvZXNuJ3RcbiAgICAgIC8vIGluY2x1ZGUgb3ZlcmxheXMgdGhhdCBoYXZlIGJlZW4gZGV0YWNoZWQsIHJhdGhlciB0aGFuIGRpc3Bvc2VkLlxuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gIH1cblxuICAvLyBXZSB1c2UgYW4gZXh0cmEgd3JhcHBlciBlbGVtZW50IGluIG9yZGVyIHRvIHVzZSBtYWtlIHRoZSBvdmVybGF5IGl0c2VsZiBhIGZsZXggaXRlbS5cbiAgLy8gVGhpcyBtYWtlcyBjZW50ZXJpbmcgdGhlIG92ZXJsYXkgZWFzeSB3aXRob3V0IHJ1bm5pbmcgaW50byB0aGUgc3VicGl4ZWwgcmVuZGVyaW5nXG4gIC8vIHByb2JsZW1zIHRpZWQgdG8gdXNpbmcgYHRyYW5zZm9ybWAgYW5kIHdpdGhvdXQgaW50ZXJmZXJpbmcgd2l0aCB0aGUgb3RoZXIgcG9zaXRpb25cbiAgLy8gc3RyYXRlZ2llcy5cbiAgLmNkay1nbG9iYWwtb3ZlcmxheS13cmFwcGVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB6LWluZGV4OiAkY2RrLXotaW5kZXgtb3ZlcmxheTtcbiAgfVxuXG4gIC8vIEEgc2luZ2xlIG92ZXJsYXkgcGFuZS5cbiAgLmNkay1vdmVybGF5LXBhbmUge1xuICAgIC8vIE5vdGU6IGl0J3MgaW1wb3J0YW50IGZvciB0aGlzIG9uZSB0byBzdGFydCBvZmYgYGFic29sdXRlYCxcbiAgICAvLyBpbiBvcmRlciBmb3IgdXMgdG8gYmUgYWJsZSB0byBtZWFzdXJlIGl0IGNvcnJlY3RseS5cbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB6LWluZGV4OiAkY2RrLXotaW5kZXgtb3ZlcmxheTtcblxuICAgIC8vIEZvciBjb25uZWN0ZWQtcG9zaXRpb24gb3ZlcmxheXMsIHdlIHNldCBgZGlzcGxheTogZmxleGAgaW5cbiAgICAvLyBvcmRlciB0byBmb3JjZSBgbWF4LXdpZHRoYCBhbmQgYG1heC1oZWlnaHRgIHRvIHRha2UgZWZmZWN0LlxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIG1heC1oZWlnaHQ6IDEwMCU7XG4gIH1cblxuICAuY2RrLW92ZXJsYXktYmFja2Ryb3Age1xuICAgIC8vIFRPRE8oamVsYm91cm4pOiByZXVzZSBzaWRlbmF2IGZ1bGxzY3JlZW4gbWl4aW4uXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gICAgbGVmdDogMDtcbiAgICByaWdodDogMDtcblxuICAgIHotaW5kZXg6ICRjZGstei1pbmRleC1vdmVybGF5LWJhY2tkcm9wO1xuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAkYmFja2Ryb3AtYW5pbWF0aW9uLWR1cmF0aW9uICRiYWNrZHJvcC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uO1xuICAgIG9wYWNpdHk6IDA7XG5cbiAgICAmLmNkay1vdmVybGF5LWJhY2tkcm9wLXNob3dpbmcge1xuICAgICAgb3BhY2l0eTogMTtcblxuICAgICAgLy8gSW4gaGlnaCBjb250cmFzdCBtb2RlIHRoZSByZ2JhIGJhY2tncm91bmQgd2lsbCBiZWNvbWUgc29saWQgc28gd2UgbmVlZCB0byBmYWxsIGJhY2tcbiAgICAgIC8vIHRvIG1ha2luZyBpdCBvcGFxdWUgdXNpbmcgYG9wYWNpdHlgLiBOb3RlIHRoYXQgd2UgY2FuJ3QgdXNlIHRoZSBgY2RrLWhpZ2gtY29udHJhc3RgXG4gICAgICAvLyBtaXhpbiwgYmVjYXVzZSB3ZSBjYW4ndCBub3JtYWxpemUgdGhlIGltcG9ydCBwYXRoIHRvIHRoZSBfYTExeS5zY3NzIGJvdGggZm9yIHRoZVxuICAgICAgLy8gc291cmNlIGFuZCB3aGVuIHRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZC4gU2VlICMxMDkwOC5cbiAgICAgIEBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDogYWN0aXZlKSB7XG4gICAgICAgIG9wYWNpdHk6IDAuNjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAuY2RrLW92ZXJsYXktZGFyay1iYWNrZHJvcCB7XG4gICAgYmFja2dyb3VuZDogJGNkay1vdmVybGF5LWRhcmstYmFja2Ryb3AtYmFja2dyb3VuZDtcbiAgfVxuXG4gIC5jZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCB7XG4gICAgLy8gTm90ZTogYXMgb2YgRmlyZWZveCA1NywgaGF2aW5nIHRoZSBiYWNrZHJvcCBiZSBgYmFja2dyb3VuZDogbm9uZWAgd2lsbCBwcmV2ZW50IGl0IGZyb21cbiAgICAvLyBjYXB0dXJpbmcgdGhlIHVzZXIncyBtb3VzZSBzY3JvbGwgZXZlbnRzLiBTaW5jZSB3ZSBhbHNvIGNhbid0IHVzZSBzb21ldGhpbmcgbGlrZVxuICAgIC8vIGByZ2JhKDAsIDAsIDAsIDApYCwgd2Ugd29yayBhcm91bmQgdGhlIGluY29uc2lzdGVuY3kgYnkgbm90IHNldHRpbmcgdGhlIGJhY2tncm91bmQgYXRcbiAgICAvLyBhbGwgYW5kIHVzaW5nIGBvcGFjaXR5YCB0byBtYWtlIHRoZSBlbGVtZW50IHRyYW5zcGFyZW50LlxuICAgICYsICYuY2RrLW92ZXJsYXktYmFja2Ryb3Atc2hvd2luZyB7XG4gICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIE92ZXJsYXkgcGFyZW50IGVsZW1lbnQgdXNlZCB3aXRoIHRoZSBjb25uZWN0ZWQgcG9zaXRpb24gc3RyYXRlZ3kuIFVzZWQgdG8gY29uc3RyYWluIHRoZVxuICAvLyBvdmVybGF5IGVsZW1lbnQncyBzaXplIHRvIGZpdCB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuICAuY2RrLW92ZXJsYXktY29ubmVjdGVkLXBvc2l0aW9uLWJvdW5kaW5nLWJveCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6ICRjZGstei1pbmRleC1vdmVybGF5O1xuXG4gICAgLy8gV2UgdXNlIGBkaXNwbGF5OiBmbGV4YCBvbiB0aGlzIGVsZW1lbnQgZXhjbHVzaXZlbHkgZm9yIGNlbnRlcmluZyBjb25uZWN0ZWQgb3ZlcmxheXMuXG4gICAgLy8gV2hlbiAqbm90KiBjZW50ZXJpbmcsIGEgdG9wL2xlZnQvYm90dG9tL3JpZ2h0IHdpbGwgYmUgc2V0IHdoaWNoIG92ZXJyaWRlcyB0aGUgbm9ybWFsXG4gICAgLy8gZmxleCBsYXlvdXQuXG4gICAgZGlzcGxheTogZmxleDtcblxuICAgIC8vIFdlIHVzZSB0aGUgYGNvbHVtbmAgZGlyZWN0aW9uIGhlcmUgdG8gYXZvaWQgc29tZSBmbGV4Ym94IGlzc3VlcyBpbiBFZGdlXG4gICAgLy8gd2hlbiB1c2luZyB0aGUgXCJncm93IGFmdGVyIG9wZW5cIiBvcHRpb25zLlxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cbiAgICAvLyBBZGQgc29tZSBkaW1lbnNpb25zIHNvIHRoZSBlbGVtZW50IGhhcyBhbiBgaW5uZXJUZXh0YCB3aGljaCBzb21lIHBlb3BsZSBkZXBlbmQgb24gaW4gdGVzdHMuXG4gICAgbWluLXdpZHRoOiAxcHg7XG4gICAgbWluLWhlaWdodDogMXB4O1xuICB9XG5cbiAgLy8gVXNlZCB3aGVuIGRpc2FibGluZyBnbG9iYWwgc2Nyb2xsaW5nLlxuICAuY2RrLWdsb2JhbC1zY3JvbGxibG9jayB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuXG4gICAgLy8gTmVjZXNzYXJ5IGZvciB0aGUgY29udGVudCBub3QgdG8gbG9zZSBpdHMgd2lkdGguIE5vdGUgdGhhdCB3ZSdyZSB1c2luZyAxMDAlLCBpbnN0ZWFkIG9mXG4gICAgLy8gMTAwdncsIGJlY2F1c2UgMTAwdncgaW5jbHVkZXMgdGhlIHdpZHRoIHBsdXMgdGhlIHNjcm9sbGJhciwgd2hlcmVhcyAxMDAlIGlzIHRoZSB3aWR0aFxuICAgIC8vIHRoYXQgdGhlIGVsZW1lbnQgaGFkIGJlZm9yZSB3ZSBtYWRlIGl0IGBmaXhlZGAuXG4gICAgd2lkdGg6IDEwMCU7XG5cbiAgICAvLyBOb3RlOiB0aGlzIHdpbGwgYWx3YXlzIGFkZCBhIHNjcm9sbGJhciB0byB3aGF0ZXZlciBlbGVtZW50IGl0IGlzIG9uLCB3aGljaCBjYW5cbiAgICAvLyBwb3RlbnRpYWxseSByZXN1bHQgaW4gZG91YmxlIHNjcm9sbGJhcnMuIEl0IHNob3VsZG4ndCBiZSBhbiBpc3N1ZSwgYmVjYXVzZSB3ZSB3b24ndFxuICAgIC8vIGJsb2NrIHNjcm9sbGluZyBvbiBhIHBhZ2UgdGhhdCBkb2Vzbid0IGhhdmUgYSBzY3JvbGxiYXIgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcbiAgfVxufVxuXG5AbWl4aW4gY2RrLWExMXkge1xuICAuY2RrLXZpc3VhbGx5LWhpZGRlbiB7XG4gICAgYm9yZGVyOiAwO1xuICAgIGNsaXA6IHJlY3QoMCAwIDAgMCk7XG4gICAgaGVpZ2h0OiAxcHg7XG4gICAgbWFyZ2luOiAtMXB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcGFkZGluZzogMDtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDFweDtcblxuICAgIC8vIEF2b2lkIGJyb3dzZXJzIHJlbmRlcmluZyB0aGUgZm9jdXMgcmluZyBpbiBzb21lIGNhc2VzLlxuICAgIG91dGxpbmU6IDA7XG5cbiAgICAvLyBBdm9pZCBzb21lIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyIHdpbGwgc3RpbGwgcmVuZGVyIHRoZSBuYXRpdmUgY29udHJvbHMgKHNlZSAjOTA0OSkuXG4gICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcbiAgfVxufVxuXG4vLyBBcHBsaWVzIHN0eWxlcyBmb3IgdXNlcnMgaW4gaGlnaCBjb250cmFzdCBtb2RlLiBOb3RlIHRoYXQgdGhpcyBvbmx5IGFwcGxpZXNcbi8vIHRvIE1pY3Jvc29mdCBicm93c2Vycy4gQ2hyb21lIGNhbiBiZSBpbmNsdWRlZCBieSBjaGVja2luZyBmb3IgdGhlIGBodG1sW2hjXWBcbi8vIGF0dHJpYnV0ZSwgaG93ZXZlciBDaHJvbWUgaGFuZGxlcyBoaWdoIGNvbnRyYXN0IGRpZmZlcmVudGx5LlxuLy9cbi8vIEBwYXJhbSB0YXJnZXQgV2hpY2gga2luZCBvZiBoaWdoIGNvbnRyYXN0IHNldHRpbmcgdG8gdGFyZ2V0LiBEZWZhdWx0cyB0byBgYWN0aXZlYCwgY2FuIGJlXG4vLyAgICBgd2hpdGUtb24tYmxhY2tgIG9yIGBibGFjay1vbi13aGl0ZWAuXG5AbWl4aW4gY2RrLWhpZ2gtY29udHJhc3QoJHRhcmdldDogYWN0aXZlKSB7XG4gIEBtZWRpYSAoLW1zLWhpZ2gtY29udHJhc3Q6ICR0YXJnZXQpIHtcbiAgICBAY29udGVudDtcbiAgfVxufVxuXG4vLyBDb3JlIHN0eWxlcyB0aGF0IGVuYWJsZSBtb25pdG9yaW5nIGF1dG9maWxsIHN0YXRlIG9mIHRleHQgZmllbGRzLlxuQG1peGluIGNkay10ZXh0LWZpZWxkIHtcbiAgLy8gS2V5ZnJhbWVzIHRoYXQgYXBwbHkgbm8gc3R5bGVzLCBidXQgYWxsb3cgdXMgdG8gbW9uaXRvciB3aGVuIGFuIHRleHQgZmllbGQgYmVjb21lcyBhdXRvZmlsbGVkXG4gIC8vIGJ5IHdhdGNoaW5nIGZvciB0aGUgYW5pbWF0aW9uIGV2ZW50cyB0aGF0IGFyZSBmaXJlZCB3aGVuIHRoZXkgc3RhcnQuIE5vdGU6IHRoZSAvKiEqLyBjb21tZW50IGlzXG4gIC8vIG5lZWRlZCB0byBwcmV2ZW50IExpYlNhc3MgZnJvbSBzdHJpcHBpbmcgdGhlIGtleWZyYW1lcyBvdXQuXG4gIC8vIEJhc2VkIG9uOiBodHRwczovL21lZGl1bS5jb20vQGJydW5uL2RldGVjdGluZy1hdXRvZmlsbGVkLWZpZWxkcy1pbi1qYXZhc2NyaXB0LWFlZDU5OGQyNWRhN1xuICBAa2V5ZnJhbWVzIGNkay10ZXh0LWZpZWxkLWF1dG9maWxsLXN0YXJ0IHsvKiEqL31cbiAgQGtleWZyYW1lcyBjZGstdGV4dC1maWVsZC1hdXRvZmlsbC1lbmQgey8qISovfVxuXG4gIC5jZGstdGV4dC1maWVsZC1hdXRvZmlsbC1tb25pdG9yZWQ6LXdlYmtpdC1hdXRvZmlsbCB7XG4gICAgYW5pbWF0aW9uLW5hbWU6IGNkay10ZXh0LWZpZWxkLWF1dG9maWxsLXN0YXJ0O1xuICB9XG5cbiAgLmNkay10ZXh0LWZpZWxkLWF1dG9maWxsLW1vbml0b3JlZDpub3QoOi13ZWJraXQtYXV0b2ZpbGwpIHtcbiAgICBhbmltYXRpb24tbmFtZTogY2RrLXRleHQtZmllbGQtYXV0b2ZpbGwtZW5kO1xuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSByZXNpemUgaGFuZGxlIG9uIGF1dG9zaXppbmcgdGV4dGFyZWFzLCBiZWNhdXNlIHdoYXRldmVyIGhlaWdodFxuICAvLyB0aGUgdXNlciByZXNpemVkIHRvIHdpbGwgYmUgb3ZlcndyaXR0ZW4gb25jZSB0aGV5IHN0YXJ0IHR5cGluZyBhZ2Fpbi5cbiAgdGV4dGFyZWEuY2RrLXRleHRhcmVhLWF1dG9zaXplIHtcbiAgICByZXNpemU6IG5vbmU7XG4gIH1cblxuICAvLyBUaGlzIGNsYXNzIGlzIHRlbXBvcmFyaWx5IGFwcGxpZWQgdG8gdGhlIHRleHRhcmVhIHdoZW4gaXQgaXMgYmVpbmcgbWVhc3VyZWQuIEl0IGlzIGltbWVkaWF0ZWx5XG4gIC8vIHJlbW92ZWQgd2hlbiBtZWFzdXJpbmcgaXMgY29tcGxldGUuIFdlIHVzZSBgIWltcG9ydGFudGAgcnVsZXMgaGVyZSB0byBtYWtlIHN1cmUgdXNlci1zcGVjaWZpZWRcbiAgLy8gcnVsZXMgZG8gbm90IGludGVyZmVyZSB3aXRoIHRoZSBtZWFzdXJlbWVudC5cbiAgdGV4dGFyZWEuY2RrLXRleHRhcmVhLWF1dG9zaXplLW1lYXN1cmluZyB7XG4gICAgaGVpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbiAhaW1wb3J0YW50O1xuICAgIC8vIEhhdmluZyAycHggdG9wIGFuZCBib3R0b20gcGFkZGluZyBzZWVtcyB0byBmaXggYSBidWcgd2hlcmUgQ2hyb21lIGdldHMgYW4gaW5jb3JyZWN0XG4gICAgLy8gbWVhc3VyZW1lbnQuIFdlIGp1c3QgaGF2ZSB0byBhY2NvdW50IGZvciBpdCBsYXRlciBhbmQgc3VidHJhY3QgaXQgb2ZmIHRoZSBmaW5hbCByZXN1bHQuXG4gICAgcGFkZGluZzogMnB4IDAgIWltcG9ydGFudDtcbiAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveCAhaW1wb3J0YW50O1xuICB9XG59XG5cbi8vIFVzZWQgdG8gZ2VuZXJhdGUgVUlEcyBmb3Iga2V5ZnJhbWVzIHVzZWQgdG8gY2hhbmdlIHRoZSB0ZXh0IGZpZWxkIGF1dG9maWxsIHN0eWxlcy5cbiRjZGstdGV4dC1maWVsZC1hdXRvZmlsbC1jb2xvci1mcmFtZS1jb3VudDogMDtcblxuLy8gTWl4aW4gdXNlZCB0byBhcHBseSBjdXN0b20gYmFja2dyb3VuZCBhbmQgZm9yZWdyb3VuZCBjb2xvcnMgdG8gYW4gYXV0b2ZpbGxlZCB0ZXh0IGZpZWxkLlxuLy8gQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI3ODE1NDkvXG4vLyByZW1vdmluZy1pbnB1dC1iYWNrZ3JvdW5kLWNvbG91ci1mb3ItY2hyb21lLWF1dG9jb21wbGV0ZSNhbnN3ZXItMzc0MzIyNjBcbkBtaXhpbiBjZGstdGV4dC1maWVsZC1hdXRvZmlsbC1jb2xvcigkYmFja2dyb3VuZCwgJGZvcmVncm91bmQ6JycpIHtcbiAgQGtleWZyYW1lcyBjZGstdGV4dC1maWVsZC1hdXRvZmlsbC1jb2xvci0jeyRjZGstdGV4dC1maWVsZC1hdXRvZmlsbC1jb2xvci1mcmFtZS1jb3VudH0ge1xuICAgIHRvIHtcbiAgICAgIGJhY2tncm91bmQ6ICRiYWNrZ3JvdW5kO1xuICAgICAgQGlmICRmb3JlZ3JvdW5kICE9ICcnIHsgY29sb3I6ICRmb3JlZ3JvdW5kOyB9XG4gICAgfVxuICB9XG5cbiAgJjotd2Via2l0LWF1dG9maWxsIHtcbiAgICBhbmltYXRpb24tbmFtZTogY2RrLXRleHQtZmllbGQtYXV0b2ZpbGwtY29sb3ItI3skY2RrLXRleHQtZmllbGQtYXV0b2ZpbGwtY29sb3ItZnJhbWUtY291bnR9O1xuICAgIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XG4gIH1cblxuICAmLmNkay10ZXh0LWZpZWxkLWF1dG9maWxsLW1vbml0b3JlZDotd2Via2l0LWF1dG9maWxsIHtcbiAgICBhbmltYXRpb24tbmFtZTogY2RrLXRleHQtZmllbGQtYXV0b2ZpbGwtc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGNkay10ZXh0LWZpZWxkLWF1dG9maWxsLWNvbG9yLSN7JGNkay10ZXh0LWZpZWxkLWF1dG9maWxsLWNvbG9yLWZyYW1lLWNvdW50fTtcbiAgfVxuXG4gICRjZGstdGV4dC1maWVsZC1hdXRvZmlsbC1jb2xvci1mcmFtZS1jb3VudDpcbiAgICAgICRjZGstdGV4dC1maWVsZC1hdXRvZmlsbC1jb2xvci1mcmFtZS1jb3VudCArIDEgIWdsb2JhbDtcbn1cblxuXG4vLyBDb3JlIHN0eWxlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGFwcGx5IG1hdGVyaWFsIGRlc2lnbiB0cmVhdG1lbnRzIHRvIGFueSBlbGVtZW50LlxuLy8gTWVkaWEgcXVlcmllc1xuLy8gVE9ETyhqb3NlcGhwZXJyb3R0KTogQ2hhbmdlICRtYXQteHNtYWxsIGFuZCAkbWF0LXNtYWxsIHVzYWdlcyB0byByZWx5IG9uIEJyZWFrcG9pbnRPYnNlcnZlcixcbiRtYXQteHNtYWxsOiAnbWF4LXdpZHRoOiA1OTlweCc7XG4kbWF0LXNtYWxsOiAnbWF4LXdpZHRoOiA5NTlweCc7XG5cbi8vIFRPRE86IFJldmlzaXQgYWxsIHotaW5kaWNlcyBiZWZvcmUgYmV0YVxuLy8gei1pbmRleCBtYXN0ZXIgbGlzdFxuXG4kei1pbmRleC1mYWI6IDIwICFkZWZhdWx0O1xuJHotaW5kZXgtZHJhd2VyOiAxMDAgIWRlZmF1bHQ7XG5cbi8vIEdsb2JhbCBjb25zdGFudHNcbiRwaTogMy4xNDE1OTI2NTtcblxuLy8gUGFkZGluZyBiZXR3ZWVuIGlucHV0IHRvZ2dsZXMgYW5kIHRoZWlyIGxhYmVsc1xuJG1hdC10b2dnbGUtcGFkZGluZzogOHB4ICFkZWZhdWx0O1xuLy8gV2lkdGggYW5kIGhlaWdodCBvZiBpbnB1dCB0b2dnbGVzXG4kbWF0LXRvZ2dsZS1zaXplOiAyMHB4ICFkZWZhdWx0O1xuXG4vLyBFYXNpbmcgQ3VydmVzXG4vLyBUT0RPKGplbGJvdXJuKTogYWxsIG9mIHRoZXNlIG5lZWQgdG8gYmUgcmV2aXNpdGVkXG5cbi8vIFRoZSBkZWZhdWx0IGFuaW1hdGlvbiBjdXJ2ZXMgdXNlZCBieSBtYXRlcmlhbCBkZXNpZ24uXG4kbWF0LWxpbmVhci1vdXQtc2xvdy1pbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLCAwLCAwLjIsIDAuMSkgIWRlZmF1bHQ7XG4kbWF0LWZhc3Qtb3V0LXNsb3ctaW4tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpICFkZWZhdWx0O1xuJG1hdC1mYXN0LW91dC1saW5lYXItaW4tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAxLCAxKSAhZGVmYXVsdDtcblxuJGVhc2UtaW4tb3V0LWN1cnZlLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSkgIWRlZmF1bHQ7XG5cbiRzd2lmdC1lYXNlLW91dC1kdXJhdGlvbjogNDAwbXMgIWRlZmF1bHQ7XG4kc3dpZnQtZWFzZS1vdXQtdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKSAhZGVmYXVsdDtcbiRzd2lmdC1lYXNlLW91dDogYWxsICRzd2lmdC1lYXNlLW91dC1kdXJhdGlvbiAkc3dpZnQtZWFzZS1vdXQtdGltaW5nLWZ1bmN0aW9uICFkZWZhdWx0O1xuXG4kc3dpZnQtZWFzZS1pbi1kdXJhdGlvbjogMzAwbXMgIWRlZmF1bHQ7XG4kc3dpZnQtZWFzZS1pbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjU1LCAwLCAwLjU1LCAwLjIpICFkZWZhdWx0O1xuJHN3aWZ0LWVhc2UtaW46IGFsbCAkc3dpZnQtZWFzZS1pbi1kdXJhdGlvbiAkc3dpZnQtZWFzZS1pbi10aW1pbmctZnVuY3Rpb24gIWRlZmF1bHQ7XG5cbiRzd2lmdC1lYXNlLWluLW91dC1kdXJhdGlvbjogNTAwbXMgIWRlZmF1bHQ7XG4kc3dpZnQtZWFzZS1pbi1vdXQtdGltaW5nLWZ1bmN0aW9uOiAkZWFzZS1pbi1vdXQtY3VydmUtZnVuY3Rpb24gIWRlZmF1bHQ7XG4kc3dpZnQtZWFzZS1pbi1vdXQ6IGFsbCAkc3dpZnQtZWFzZS1pbi1vdXQtZHVyYXRpb24gJHN3aWZ0LWVhc2UtaW4tb3V0LXRpbWluZy1mdW5jdGlvbiAhZGVmYXVsdDtcblxuJHN3aWZ0LWxpbmVhci1kdXJhdGlvbjogODBtcyAhZGVmYXVsdDtcbiRzd2lmdC1saW5lYXItdGltaW5nLWZ1bmN0aW9uOiBsaW5lYXIgIWRlZmF1bHQ7XG4kc3dpZnQtbGluZWFyOiBhbGwgJHN3aWZ0LWxpbmVhci1kdXJhdGlvbiAkc3dpZnQtbGluZWFyLXRpbWluZy1mdW5jdGlvbiAhZGVmYXVsdDtcblxuXG5cbi8vIEEgY29sbGVjdGlvbiBvZiBtaXhpbnMgYW5kIENTUyBjbGFzc2VzIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXBwbHkgZWxldmF0aW9uIHRvIGEgbWF0ZXJpYWxcbi8vIGVsZW1lbnQuXG4vLyBTZWU6IGh0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL2Vudmlyb25tZW50L2VsZXZhdGlvbi5odG1sXG4vLyBFeGFtcGxlczpcbi8vXG4vL1xuLy8gLm1hdC1mb28ge1xuLy8gICBAaW5jbHVkZSAkbWF0LWVsZXZhdGlvbigyKTtcbi8vXG4vLyAgICY6YWN0aXZlIHtcbi8vICAgICBAaW5jbHVkZSAkbWF0LWVsZXZhdGlvbig4KTtcbi8vICAgfVxuLy8gfVxuLy9cbi8vIDxkaXYgaWQ9XCJleHRlcm5hbC1jYXJkXCIgY2xhc3M9XCJtYXQtZWxldmF0aW9uLXoyXCI+PHA+U29tZSBjb250ZW50PC9wPjwvZGl2PlxuLy9cbi8vIEZvciBhbiBleHBsYW5hdGlvbiBvZiB0aGUgZGVzaWduIGJlaGluZCBob3cgZWxldmF0aW9uIGlzIGltcGxlbWVudGVkLCBzZWUgdGhlIGRlc2lnbiBkb2MgYXRcbi8vIGh0dHBzOi8vZ29vLmdsL0txMGs5Wi5cblxuLy8gQ29sb3JzIGZvciB1bWJyYSwgcGVudW1icmEsIGFuZCBhbWJpZW50IHNoYWRvd3MuIEFzIGRlc2NyaWJlZCBpbiB0aGUgZGVzaWduIGRvYywgZWFjaCBlbGV2YXRpb25cbi8vIGxldmVsIGlzIGNyZWF0ZWQgdXNpbmcgYSBzZXQgb2YgMyBzaGFkb3cgdmFsdWVzLCBvbmUgZm9yIHVtYnJhICh0aGUgc2hhZG93IHJlcHJlc2VudGluZyB0aGVcbi8vIHNwYWNlIGNvbXBsZXRlbHkgb2JzY3VyZWQgYnkgYW4gb2JqZWN0IHJlbGF0aXZlIHRvIGl0cyBsaWdodCBzb3VyY2UpLCBvbmUgZm9yIHBlbnVtYnJhICh0aGVcbi8vIHNwYWNlIHBhcnRpYWxseSBvYnNjdXJlZCBieSBhbiBvYmplY3QpLCBhbmQgb25lIGZvciBhbWJpZW50ICh0aGUgc3BhY2Ugd2hpY2ggY29udGFpbnMgdGhlIG9iamVjdFxuLy8gaXRzZWxmKS4gRm9yIGEgZnVydGhlciBleHBsYW5hdGlvbiBvZiB0aGVzZSB0ZXJtcyBhbmQgdGhlaXIgbWVhbmluZ3MsIHNlZVxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW1icmEsX3BlbnVtYnJhX2FuZF9hbnR1bWJyYS5cblxuLy8gTWFwcyBmb3IgdGhlIGRpZmZlcmVudCBzaGFkb3cgc2V0cyBhbmQgdGhlaXIgdmFsdWVzIHdpdGhpbiBlYWNoIHotc3BhY2UuIFRoZXNlIHZhbHVlcyB3ZXJlXG4vLyBjcmVhdGVkIGJ5IHRha2luZyBhIGZldyByZWZlcmVuY2Ugc2hhZG93IHNldHMgY3JlYXRlZCBieSBHb29nbGUncyBEZXNpZ25lcnMgYW5kIGludGVycG9sYXRpbmdcbi8vIGFsbCBvZiB0aGUgdmFsdWVzIGJldHdlZW4gdGhlbS5cblxuQGZ1bmN0aW9uIF9nZXQtdW1icmEtbWFwKCRjb2xvciwgJG9wYWNpdHkpIHtcbiAgJHNoYWRvdy1jb2xvcjogaWYodHlwZS1vZigkY29sb3IpID09IGNvbG9yLCByZ2JhKCRjb2xvciwgJG9wYWNpdHkgKiAwLjIpLCAkY29sb3IpO1xuXG4gIEByZXR1cm4gKFxuICAgIDA6ICcwcHggMHB4IDBweCAwcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTogJzBweCAycHggMXB4IC0xcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMjogJzBweCAzcHggMXB4IC0ycHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMzogJzBweCAzcHggM3B4IC0ycHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgNDogJzBweCAycHggNHB4IC0xcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgNTogJzBweCAzcHggNXB4IC0xcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgNjogJzBweCAzcHggNXB4IC0xcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgNzogJzBweCA0cHggNXB4IC0ycHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgODogJzBweCA1cHggNXB4IC0zcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgOTogJzBweCA1cHggNnB4IC0zcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTA6ICcwcHggNnB4IDZweCAtM3B4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDExOiAnMHB4IDZweCA3cHggLTRweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAxMjogJzBweCA3cHggOHB4IC00cHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTM6ICcwcHggN3B4IDhweCAtNHB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDE0OiAnMHB4IDdweCA5cHggLTRweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAxNTogJzBweCA4cHggOXB4IC01cHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTY6ICcwcHggOHB4IDEwcHggLTVweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAxNzogJzBweCA4cHggMTFweCAtNXB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDE4OiAnMHB4IDlweCAxMXB4IC01cHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTk6ICcwcHggOXB4IDEycHggLTZweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAyMDogJzBweCAxMHB4IDEzcHggLTZweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAyMTogJzBweCAxMHB4IDEzcHggLTZweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAyMjogJzBweCAxMHB4IDE0cHggLTZweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAyMzogJzBweCAxMXB4IDE0cHggLTdweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAyNDogJzBweCAxMXB4IDE1cHggLTdweCAjeyRzaGFkb3ctY29sb3J9J1xuICApO1xufVxuXG5AZnVuY3Rpb24gX2dldC1wZW51bWJyYS1tYXAoJGNvbG9yLCAkb3BhY2l0eSkge1xuICAkc2hhZG93LWNvbG9yOiBpZih0eXBlLW9mKCRjb2xvcikgPT0gY29sb3IsIHJnYmEoJGNvbG9yLCAkb3BhY2l0eSAqIDAuMTQpLCAkY29sb3IpO1xuXG4gIEByZXR1cm4gKFxuICAgIDA6ICcwcHggMHB4IDBweCAwcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTogJzBweCAxcHggMXB4IDBweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAyOiAnMHB4IDJweCAycHggMHB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDM6ICcwcHggM3B4IDRweCAwcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgNDogJzBweCA0cHggNXB4IDBweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICA1OiAnMHB4IDVweCA4cHggMHB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDY6ICcwcHggNnB4IDEwcHggMHB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDc6ICcwcHggN3B4IDEwcHggMXB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDg6ICcwcHggOHB4IDEwcHggMXB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDk6ICcwcHggOXB4IDEycHggMXB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDEwOiAnMHB4IDEwcHggMTRweCAxcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTE6ICcwcHggMTFweCAxNXB4IDFweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAxMjogJzBweCAxMnB4IDE3cHggMnB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDEzOiAnMHB4IDEzcHggMTlweCAycHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTQ6ICcwcHggMTRweCAyMXB4IDJweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAxNTogJzBweCAxNXB4IDIycHggMnB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDE2OiAnMHB4IDE2cHggMjRweCAycHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTc6ICcwcHggMTdweCAyNnB4IDJweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAxODogJzBweCAxOHB4IDI4cHggMnB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDE5OiAnMHB4IDE5cHggMjlweCAycHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMjA6ICcwcHggMjBweCAzMXB4IDNweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAyMTogJzBweCAyMXB4IDMzcHggM3B4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDIyOiAnMHB4IDIycHggMzVweCAzcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMjM6ICcwcHggMjNweCAzNnB4IDNweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAyNDogJzBweCAyNHB4IDM4cHggM3B4ICN7JHNoYWRvdy1jb2xvcn0nXG4gICk7XG59XG5cbkBmdW5jdGlvbiBfZ2V0LWFtYmllbnQtbWFwKCRjb2xvciwgJG9wYWNpdHkpIHtcbiAgJHNoYWRvdy1jb2xvcjogaWYodHlwZS1vZigkY29sb3IpID09IGNvbG9yLCByZ2JhKCRjb2xvciwgJG9wYWNpdHkgKiAwLjEyKSwgJGNvbG9yKTtcblxuICBAcmV0dXJuIChcbiAgICAwOiAnMHB4IDBweCAwcHggMHB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDE6ICcwcHggMXB4IDNweCAwcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMjogJzBweCAxcHggNXB4IDBweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAzOiAnMHB4IDFweCA4cHggMHB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDQ6ICcwcHggMXB4IDEwcHggMHB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDU6ICcwcHggMXB4IDE0cHggMHB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDY6ICcwcHggMXB4IDE4cHggMHB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDc6ICcwcHggMnB4IDE2cHggMXB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDg6ICcwcHggM3B4IDE0cHggMnB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDk6ICcwcHggM3B4IDE2cHggMnB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDEwOiAnMHB4IDRweCAxOHB4IDNweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAxMTogJzBweCA0cHggMjBweCAzcHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTI6ICcwcHggNXB4IDIycHggNHB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDEzOiAnMHB4IDVweCAyNHB4IDRweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAxNDogJzBweCA1cHggMjZweCA0cHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTU6ICcwcHggNnB4IDI4cHggNXB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDE2OiAnMHB4IDZweCAzMHB4IDVweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAxNzogJzBweCA2cHggMzJweCA1cHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMTg6ICcwcHggN3B4IDM0cHggNnB4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDE5OiAnMHB4IDdweCAzNnB4IDZweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAyMDogJzBweCA4cHggMzhweCA3cHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMjE6ICcwcHggOHB4IDQwcHggN3B4ICN7JHNoYWRvdy1jb2xvcn0nLFxuICAgIDIyOiAnMHB4IDhweCA0MnB4IDdweCAjeyRzaGFkb3ctY29sb3J9JyxcbiAgICAyMzogJzBweCA5cHggNDRweCA4cHggI3skc2hhZG93LWNvbG9yfScsXG4gICAgMjQ6ICcwcHggOXB4IDQ2cHggOHB4ICN7JHNoYWRvdy1jb2xvcn0nXG4gICk7XG59XG5cbi8vIFRoZSBkZWZhdWx0IGR1cmF0aW9uIHZhbHVlIGZvciBlbGV2YXRpb24gdHJhbnNpdGlvbnMuXG4kbWF0LWVsZXZhdGlvbi10cmFuc2l0aW9uLWR1cmF0aW9uOiAyODBtcyAhZGVmYXVsdDtcblxuLy8gVGhlIGRlZmF1bHQgZWFzaW5nIHZhbHVlIGZvciBlbGV2YXRpb24gdHJhbnNpdGlvbnMuXG4kbWF0LWVsZXZhdGlvbi10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogJG1hdC1mYXN0LW91dC1zbG93LWluLXRpbWluZy1mdW5jdGlvbjtcblxuLy8gVGhlIGRlZmF1bHQgY29sb3IgZm9yIGVsZXZhdGlvbiBzaGFkb3dzLlxuJG1hdC1lbGV2YXRpb24tY29sb3I6IGJsYWNrICFkZWZhdWx0O1xuXG4vLyBUaGUgZGVmYXVsdCBvcGFjaXR5IHNjYWxpbmcgdmFsdWUgZm9yIGVsZXZhdGlvbiBzaGFkb3dzLlxuJG1hdC1lbGV2YXRpb24tb3BhY2l0eTogMSAhZGVmYXVsdDtcblxuLy8gUHJlZml4IGZvciBlbGV2YXRpb24tcmVsYXRlZCBzZWxlY3RvcnMuXG4kX21hdC1lbGV2YXRpb24tcHJlZml4OiAnbWF0LWVsZXZhdGlvbi16JztcblxuLy8gQXBwbGllcyB0aGUgY29ycmVjdCBjc3MgcnVsZXMgdG8gYW4gZWxlbWVudCB0byBnaXZlIGl0IHRoZSBlbGV2YXRpb24gc3BlY2lmaWVkIGJ5ICR6VmFsdWUuXG4vLyBUaGUgJHpWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjQuXG5AbWl4aW4gbWF0LWVsZXZhdGlvbigkelZhbHVlLCAkY29sb3I6ICRtYXQtZWxldmF0aW9uLWNvbG9yLCAkb3BhY2l0eTogJG1hdC1lbGV2YXRpb24tb3BhY2l0eSkge1xuICBAaWYgdHlwZS1vZigkelZhbHVlKSAhPSBudW1iZXIgb3Igbm90IHVuaXRsZXNzKCR6VmFsdWUpIHtcbiAgICBAZXJyb3IgJyR6VmFsdWUgbXVzdCBiZSBhIHVuaXRsZXNzIG51bWJlcic7XG4gIH1cbiAgQGlmICR6VmFsdWUgPCAwIG9yICR6VmFsdWUgPiAyNCB7XG4gICAgQGVycm9yICckelZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNCc7XG4gIH1cblxuICBib3gtc2hhZG93OiAje21hcC1nZXQoX2dldC11bWJyYS1tYXAoJGNvbG9yLCAkb3BhY2l0eSksICR6VmFsdWUpfSxcbiAgICAgICAgICAgICAgI3ttYXAtZ2V0KF9nZXQtcGVudW1icmEtbWFwKCRjb2xvciwgJG9wYWNpdHkpLCAkelZhbHVlKX0sXG4gICAgICAgICAgICAgICN7bWFwLWdldChfZ2V0LWFtYmllbnQtbWFwKCRjb2xvciwgJG9wYWNpdHkpLCAkelZhbHVlKX07XG59XG5cbkBtaXhpbiBfbWF0LXRoZW1lLWVsZXZhdGlvbigkelZhbHVlLCAkdGhlbWUsICRvcGFjaXR5OiAkbWF0LWVsZXZhdGlvbi1vcGFjaXR5KSB7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG4gICRlbGV2YXRpb24tY29sb3I6IG1hcC1nZXQoJGZvcmVncm91bmQsIGVsZXZhdGlvbik7XG4gICRlbGV2YXRpb24tY29sb3Itb3ItZGVmYXVsdDogaWYoJGVsZXZhdGlvbi1jb2xvciA9PSBudWxsLCAkbWF0LWVsZXZhdGlvbi1jb2xvciwgJGVsZXZhdGlvbi1jb2xvcik7XG5cbiAgQGluY2x1ZGUgbWF0LWVsZXZhdGlvbigkelZhbHVlLCAkZWxldmF0aW9uLWNvbG9yLW9yLWRlZmF1bHQsICRvcGFjaXR5KTtcbn1cblxuLy8gQXBwbGllcyB0aGUgZWxldmF0aW9uIHRvIGFuIGVsZW1lbnQgaW4gYSBtYW5uZXIgdGhhdCBhbGxvd3Ncbi8vIGNvbnN1bWVycyB0byBvdmVycmlkZSBpdCB2aWEgdGhlIE1hdGVyaWFsIGVsZXZhdGlvbiBjbGFzc2VzLlxuQG1peGluIG1hdC1vdmVycmlkYWJsZS1lbGV2YXRpb24oXG4gICAgJHpWYWx1ZSxcbiAgICAkY29sb3I6ICRtYXQtZWxldmF0aW9uLWNvbG9yLFxuICAgICRvcGFjaXR5OiAkbWF0LWVsZXZhdGlvbi1vcGFjaXR5KSB7XG4gICY6bm90KFtjbGFzcyo9JyN7JF9tYXQtZWxldmF0aW9uLXByZWZpeH0nXSkge1xuICAgIEBpbmNsdWRlIG1hdC1lbGV2YXRpb24oJHpWYWx1ZSwgJGNvbG9yLCAkb3BhY2l0eSk7XG4gIH1cbn1cblxuQG1peGluIF9tYXQtdGhlbWUtb3ZlcnJpZGFibGUtZWxldmF0aW9uKCR6VmFsdWUsICR0aGVtZSwgJG9wYWNpdHk6ICRtYXQtZWxldmF0aW9uLW9wYWNpdHkpIHtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcbiAgJGVsZXZhdGlvbi1jb2xvcjogbWFwLWdldCgkZm9yZWdyb3VuZCwgZWxldmF0aW9uKTtcbiAgJGVsZXZhdGlvbi1jb2xvci1vci1kZWZhdWx0OiBpZigkZWxldmF0aW9uLWNvbG9yID09IG51bGwsICRtYXQtZWxldmF0aW9uLWNvbG9yLCAkZWxldmF0aW9uLWNvbG9yKTtcblxuICBAaW5jbHVkZSBtYXQtb3ZlcnJpZGFibGUtZWxldmF0aW9uKCR6VmFsdWUsICRlbGV2YXRpb24tY29sb3Itb3ItZGVmYXVsdCwgJG9wYWNpdHkpO1xufVxuXG4vLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgYXMgdGhlIHZhbHVlIGZvciBhIHRyYW5zaXRpb24gcHJvcGVydHkgZm9yIGVsZXZhdGlvbi5cbi8vIENhbGxpbmcgdGhpcyBmdW5jdGlvbiBkaXJlY3RseSBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSBhIGNvbXBvbmVudCBuZWVkcyB0byB0cmFuc2l0aW9uXG4vLyBtb3JlIHRoYW4gb25lIHByb3BlcnR5LlxuLy9cbi8vIC5mb28ge1xuLy8gICB0cmFuc2l0aW9uOiBtYXQtZWxldmF0aW9uLXRyYW5zaXRpb24tcHJvcGVydHktdmFsdWUoKSwgb3BhY2l0eSAxMDBtcyBlYXNlO1xuLy8gfVxuQGZ1bmN0aW9uIG1hdC1lbGV2YXRpb24tdHJhbnNpdGlvbi1wcm9wZXJ0eS12YWx1ZShcbiAgICAkZHVyYXRpb246ICRtYXQtZWxldmF0aW9uLXRyYW5zaXRpb24tZHVyYXRpb24sXG4gICAgJGVhc2luZzogJG1hdC1lbGV2YXRpb24tdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24pIHtcbiAgQHJldHVybiBib3gtc2hhZG93ICN7JGR1cmF0aW9ufSAjeyRlYXNpbmd9O1xufVxuXG4vLyBBcHBsaWVzIHRoZSBjb3JyZWN0IGNzcyBydWxlcyBuZWVkZWQgdG8gaGF2ZSBhbiBlbGVtZW50IHRyYW5zaXRpb24gYmV0d2VlbiBlbGV2YXRpb25zLlxuLy8gVGhpcyBtaXhpbiBzaG91bGQgYmUgYXBwbGllZCB0byBlbGVtZW50cyB3aG9zZSBlbGV2YXRpb24gdmFsdWVzIHdpbGwgY2hhbmdlIGRlcGVuZGluZyBvbiB0aGVpclxuLy8gY29udGV4dCAoZS5nLiB3aGVuIGFjdGl2ZSBvciBkaXNhYmxlZCkuXG4vL1xuLy8gTk9URSh0cmF2aXNrYXVmbWFuKTogQm90aCB0aGlzIG1peGluIGFuZCB0aGUgYWJvdmUgZnVuY3Rpb24gdXNlIGRlZmF1bHQgcGFyYW1ldGVycyBzbyB0aGV5IGNhblxuLy8gYmUgdXNlZCBpbiB0aGUgc2FtZSB3YXkgYnkgY2xpZW50cy5cbkBtaXhpbiBtYXQtZWxldmF0aW9uLXRyYW5zaXRpb24oXG4gICAgJGR1cmF0aW9uOiAkbWF0LWVsZXZhdGlvbi10cmFuc2l0aW9uLWR1cmF0aW9uLFxuICAgICRlYXNpbmc6ICRtYXQtZWxldmF0aW9uLXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uKSB7XG4gIHRyYW5zaXRpb246IG1hdC1lbGV2YXRpb24tdHJhbnNpdGlvbi1wcm9wZXJ0eS12YWx1ZSgkZHVyYXRpb24sICRlYXNpbmcpO1xufVxuXG4vLyBDb2xvciBwYWxldHRlcyBmcm9tIHRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYy5cbi8vIFNlZSBodHRwczovL21hdGVyaWFsLmlvL2Rlc2lnbi9jb2xvci9cbi8vXG4vLyBDb250cmFzdCBjb2xvcnMgYXJlIGhhcmQtY29kZWQgYmVjYXVzZSBpdCBpcyB0b28gZGlmZmljdWx0IChwcm9iYWJseSBpbXBvc3NpYmxlKSB0b1xuLy8gY2FsY3VsYXRlIHRoZW0uIFRoZXNlIGNvbnRyYXN0IGNvbG9ycyBhcmUgcHVsbGVkIGZyb20gdGhlIHB1YmxpYyBNYXRlcmlhbCBEZXNpZ24gc3BlYyBzd2F0Y2hlcy5cbi8vIFdoaWxlIHRoZSBjb250cmFzdCBjb2xvcnMgaW4gdGhlIHNwZWMgYXJlIG5vdCBwcmVzY3JpcHRpdmUsIHdlIHVzZSB0aGVtIGZvciBjb252ZW5pZW5jZS5cblxuXG4vLyBAZGVwcmVjYXRlZCByZW5hbWVkIHRvICRkYXJrLXByaW1hcnktdGV4dC5cbi8vIEBicmVha2luZy1jaGFuZ2UgOC4wLjBcbiRibGFjay04Ny1vcGFjaXR5OiByZ2JhKGJsYWNrLCAwLjg3KTtcbi8vIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8gJGxpZ2h0LXByaW1hcnktdGV4dC5cbi8vIEBicmVha2luZy1jaGFuZ2UgOC4wLjBcbiR3aGl0ZS04Ny1vcGFjaXR5OiByZ2JhKHdoaXRlLCAwLjg3KTtcbi8vIEBkZXByZWNhdGVkIHVzZSAkZGFyay1bc2Vjb25kYXJ5LXRleHQsZGlzYWJsZWQtdGV4dCxkaXZpZGVycyxmb2N1c2VkXSBpbnN0ZWFkLlxuLy8gQGJyZWFraW5nLWNoYW5nZSA4LjAuMFxuJGJsYWNrLTEyLW9wYWNpdHk6IHJnYmEoYmxhY2ssIDAuMTIpO1xuLy8gQGRlcHJlY2F0ZWQgdXNlICRsaWdodC1bc2Vjb25kYXJ5LXRleHQsZGlzYWJsZWQtdGV4dCxkaXZpZGVycyxmb2N1c2VkXSBpbnN0ZWFkLlxuLy8gQGJyZWFraW5nLWNoYW5nZSA4LjAuMFxuJHdoaXRlLTEyLW9wYWNpdHk6IHJnYmEod2hpdGUsIDAuMTIpO1xuLy8gQGRlcHJlY2F0ZWQgdXNlICRkYXJrLVtzZWNvbmRhcnktdGV4dCxkaXNhYmxlZC10ZXh0LGRpdmlkZXJzLGZvY3VzZWRdIGluc3RlYWQuXG4vLyBAYnJlYWtpbmctY2hhbmdlIDguMC4wXG4kYmxhY2stNi1vcGFjaXR5OiByZ2JhKGJsYWNrLCAwLjA2KTtcbi8vIEBkZXByZWNhdGVkIHVzZSAkbGlnaHQtW3NlY29uZGFyeS10ZXh0LGRpc2FibGVkLXRleHQsZGl2aWRlcnMsZm9jdXNlZF0gaW5zdGVhZC5cbi8vIEBicmVha2luZy1jaGFuZ2UgOC4wLjBcbiR3aGl0ZS02LW9wYWNpdHk6IHJnYmEod2hpdGUsIDAuMDYpO1xuXG4kZGFyay1wcmltYXJ5LXRleHQ6IHJnYmEoYmxhY2ssIDAuODcpO1xuJGRhcmstc2Vjb25kYXJ5LXRleHQ6IHJnYmEoYmxhY2ssIDAuNTQpO1xuJGRhcmstZGlzYWJsZWQtdGV4dDogcmdiYShibGFjaywgMC4zOCk7XG4kZGFyay1kaXZpZGVyczogcmdiYShibGFjaywgMC4xMik7XG4kZGFyay1mb2N1c2VkOiByZ2JhKGJsYWNrLCAwLjEyKTtcbiRsaWdodC1wcmltYXJ5LXRleHQ6IHdoaXRlO1xuJGxpZ2h0LXNlY29uZGFyeS10ZXh0OiByZ2JhKHdoaXRlLCAwLjcpO1xuJGxpZ2h0LWRpc2FibGVkLXRleHQ6IHJnYmEod2hpdGUsIDAuNSk7XG4kbGlnaHQtZGl2aWRlcnM6IHJnYmEod2hpdGUsIDAuMTIpO1xuJGxpZ2h0LWZvY3VzZWQ6IHJnYmEod2hpdGUsIDAuMTIpO1xuXG4kbWF0LXJlZDogKFxuICA1MDogI2ZmZWJlZSxcbiAgMTAwOiAjZmZjZGQyLFxuICAyMDA6ICNlZjlhOWEsXG4gIDMwMDogI2U1NzM3MyxcbiAgNDAwOiAjZWY1MzUwLFxuICA1MDA6ICNmNDQzMzYsXG4gIDYwMDogI2U1MzkzNSxcbiAgNzAwOiAjZDMyZjJmLFxuICA4MDA6ICNjNjI4MjgsXG4gIDkwMDogI2I3MWMxYyxcbiAgQTEwMDogI2ZmOGE4MCxcbiAgQTIwMDogI2ZmNTI1MixcbiAgQTQwMDogI2ZmMTc0NCxcbiAgQTcwMDogI2Q1MDAwMCxcbiAgY29udHJhc3Q6IChcbiAgICA1MDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDEwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDIwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDMwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDQwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDUwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA2MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNzAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDgwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA5MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTEwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEEyMDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTQwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICBBNzAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICApXG4pO1xuXG4kbWF0LXBpbms6IChcbiAgNTA6ICNmY2U0ZWMsXG4gIDEwMDogI2Y4YmJkMCxcbiAgMjAwOiAjZjQ4ZmIxLFxuICAzMDA6ICNmMDYyOTIsXG4gIDQwMDogI2VjNDA3YSxcbiAgNTAwOiAjZTkxZTYzLFxuICA2MDA6ICNkODFiNjAsXG4gIDcwMDogI2MyMTg1YixcbiAgODAwOiAjYWQxNDU3LFxuICA5MDA6ICM4ODBlNGYsXG4gIEExMDA6ICNmZjgwYWIsXG4gIEEyMDA6ICNmZjQwODEsXG4gIEE0MDA6ICNmNTAwNTcsXG4gIEE3MDA6ICNjNTExNjIsXG4gIGNvbnRyYXN0OiAoXG4gICAgNTA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAxMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAzMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA0MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA1MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNjAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA4MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgOTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIEExMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBMjAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIEE0MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgKVxuKTtcblxuJG1hdC1wdXJwbGU6IChcbiAgNTA6ICNmM2U1ZjUsXG4gIDEwMDogI2UxYmVlNyxcbiAgMjAwOiAjY2U5M2Q4LFxuICAzMDA6ICNiYTY4YzgsXG4gIDQwMDogI2FiNDdiYyxcbiAgNTAwOiAjOWMyN2IwLFxuICA2MDA6ICM4ZTI0YWEsXG4gIDcwMDogIzdiMWZhMixcbiAgODAwOiAjNmExYjlhLFxuICA5MDA6ICM0YTE0OGMsXG4gIEExMDA6ICNlYTgwZmMsXG4gIEEyMDA6ICNlMDQwZmIsXG4gIEE0MDA6ICNkNTAwZjksXG4gIEE3MDA6ICNhYTAwZmYsXG4gIGNvbnRyYXN0OiAoXG4gICAgNTA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAxMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAzMDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNDAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDUwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA2MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNzAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDgwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA5MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTEwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEEyMDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTQwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICBBNzAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICApXG4pO1xuXG4kbWF0LWRlZXAtcHVycGxlOiAoXG4gIDUwOiAjZWRlN2Y2LFxuICAxMDA6ICNkMWM0ZTksXG4gIDIwMDogI2IzOWRkYixcbiAgMzAwOiAjOTU3NWNkLFxuICA0MDA6ICM3ZTU3YzIsXG4gIDUwMDogIzY3M2FiNyxcbiAgNjAwOiAjNWUzNWIxLFxuICA3MDA6ICM1MTJkYTgsXG4gIDgwMDogIzQ1MjdhMCxcbiAgOTAwOiAjMzExYjkyLFxuICBBMTAwOiAjYjM4OGZmLFxuICBBMjAwOiAjN2M0ZGZmLFxuICBBNDAwOiAjNjUxZmZmLFxuICBBNzAwOiAjNjIwMGVhLFxuICBjb250cmFzdDogKFxuICAgIDUwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMzAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDQwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA1MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNjAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA4MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgOTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIEExMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBMjAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIEE0MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgKVxuKTtcblxuJG1hdC1pbmRpZ286IChcbiAgNTA6ICNlOGVhZjYsXG4gIDEwMDogI2M1Y2FlOSxcbiAgMjAwOiAjOWZhOGRhLFxuICAzMDA6ICM3OTg2Y2IsXG4gIDQwMDogIzVjNmJjMCxcbiAgNTAwOiAjM2Y1MWI1LFxuICA2MDA6ICMzOTQ5YWIsXG4gIDcwMDogIzMwM2Y5ZixcbiAgODAwOiAjMjgzNTkzLFxuICA5MDA6ICMxYTIzN2UsXG4gIEExMDA6ICM4YzllZmYsXG4gIEEyMDA6ICM1MzZkZmUsXG4gIEE0MDA6ICMzZDVhZmUsXG4gIEE3MDA6ICMzMDRmZmUsXG4gIGNvbnRyYXN0OiAoXG4gICAgNTA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAxMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAzMDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNDAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDUwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA2MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNzAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDgwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA5MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTEwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEEyMDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTQwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICBBNzAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICApXG4pO1xuXG4kbWF0LWJsdWU6IChcbiAgNTA6ICNlM2YyZmQsXG4gIDEwMDogI2JiZGVmYixcbiAgMjAwOiAjOTBjYWY5LFxuICAzMDA6ICM2NGI1ZjYsXG4gIDQwMDogIzQyYTVmNSxcbiAgNTAwOiAjMjE5NmYzLFxuICA2MDA6ICMxZTg4ZTUsXG4gIDcwMDogIzE5NzZkMixcbiAgODAwOiAjMTU2NWMwLFxuICA5MDA6ICMwZDQ3YTEsXG4gIEExMDA6ICM4MmIxZmYsXG4gIEEyMDA6ICM0NDhhZmYsXG4gIEE0MDA6ICMyOTc5ZmYsXG4gIEE3MDA6ICMyOTYyZmYsXG4gIGNvbnRyYXN0OiAoXG4gICAgNTA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAxMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAzMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA0MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA1MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNjAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA4MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgOTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIEExMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBMjAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIEE0MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgKVxuKTtcblxuJG1hdC1saWdodC1ibHVlOiAoXG4gIDUwOiAjZTFmNWZlLFxuICAxMDA6ICNiM2U1ZmMsXG4gIDIwMDogIzgxZDRmYSxcbiAgMzAwOiAjNGZjM2Y3LFxuICA0MDA6ICMyOWI2ZjYsXG4gIDUwMDogIzAzYTlmNCxcbiAgNjAwOiAjMDM5YmU1LFxuICA3MDA6ICMwMjg4ZDEsXG4gIDgwMDogIzAyNzdiZCxcbiAgOTAwOiAjMDE1NzliLFxuICBBMTAwOiAjODBkOGZmLFxuICBBMjAwOiAjNDBjNGZmLFxuICBBNDAwOiAjMDBiMGZmLFxuICBBNzAwOiAjMDA5MWVhLFxuICBjb250cmFzdDogKFxuICAgIDUwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMzAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNDAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDYwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA3MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgODAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDkwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICBBMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTIwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEE0MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBNzAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICApXG4pO1xuXG4kbWF0LWN5YW46IChcbiAgNTA6ICNlMGY3ZmEsXG4gIDEwMDogI2IyZWJmMixcbiAgMjAwOiAjODBkZWVhLFxuICAzMDA6ICM0ZGQwZTEsXG4gIDQwMDogIzI2YzZkYSxcbiAgNTAwOiAjMDBiY2Q0LFxuICA2MDA6ICMwMGFjYzEsXG4gIDcwMDogIzAwOTdhNyxcbiAgODAwOiAjMDA4MzhmLFxuICA5MDA6ICMwMDYwNjQsXG4gIEExMDA6ICM4NGZmZmYsXG4gIEEyMDA6ICMxOGZmZmYsXG4gIEE0MDA6ICMwMGU1ZmYsXG4gIEE3MDA6ICMwMGI4ZDQsXG4gIGNvbnRyYXN0OiAoXG4gICAgNTA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAxMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAzMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA0MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA1MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNjAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA4MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgOTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIEExMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTQwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEE3MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgKVxuKTtcblxuJG1hdC10ZWFsOiAoXG4gIDUwOiAjZTBmMmYxLFxuICAxMDA6ICNiMmRmZGIsXG4gIDIwMDogIzgwY2JjNCxcbiAgMzAwOiAjNGRiNmFjLFxuICA0MDA6ICMyNmE2OWEsXG4gIDUwMDogIzAwOTY4OCxcbiAgNjAwOiAjMDA4OTdiLFxuICA3MDA6ICMwMDc5NmIsXG4gIDgwMDogIzAwNjk1YyxcbiAgOTAwOiAjMDA0ZDQwLFxuICBBMTAwOiAjYTdmZmViLFxuICBBMjAwOiAjNjRmZmRhLFxuICBBNDAwOiAjMWRlOWI2LFxuICBBNzAwOiAjMDBiZmE1LFxuICBjb250cmFzdDogKFxuICAgIDUwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMzAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNDAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDYwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA3MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgODAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDkwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICBBMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTIwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEE0MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBNzAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gIClcbik7XG5cbiRtYXQtZ3JlZW46IChcbiAgNTA6ICNlOGY1ZTksXG4gIDEwMDogI2M4ZTZjOSxcbiAgMjAwOiAjYTVkNmE3LFxuICAzMDA6ICM4MWM3ODQsXG4gIDQwMDogIzY2YmI2YSxcbiAgNTAwOiAjNGNhZjUwLFxuICA2MDA6ICM0M2EwNDcsXG4gIDcwMDogIzM4OGUzYyxcbiAgODAwOiAjMmU3ZDMyLFxuICA5MDA6ICMxYjVlMjAsXG4gIEExMDA6ICNiOWY2Y2EsXG4gIEEyMDA6ICM2OWYwYWUsXG4gIEE0MDA6ICMwMGU2NzYsXG4gIEE3MDA6ICMwMGM4NTMsXG4gIGNvbnRyYXN0OiAoXG4gICAgNTA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAxMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAzMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA0MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA1MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA2MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNzAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDgwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA5MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTEwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEEyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBNDAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTcwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICApXG4pO1xuXG4kbWF0LWxpZ2h0LWdyZWVuOiAoXG4gIDUwOiAjZjFmOGU5LFxuICAxMDA6ICNkY2VkYzgsXG4gIDIwMDogI2M1ZTFhNSxcbiAgMzAwOiAjYWVkNTgxLFxuICA0MDA6ICM5Y2NjNjUsXG4gIDUwMDogIzhiYzM0YSxcbiAgNjAwOiAjN2NiMzQyLFxuICA3MDA6ICM2ODlmMzgsXG4gIDgwMDogIzU1OGIyZixcbiAgOTAwOiAjMzM2OTFlLFxuICBBMTAwOiAjY2NmZjkwLFxuICBBMjAwOiAjYjJmZjU5LFxuICBBNDAwOiAjNzZmZjAzLFxuICBBNzAwOiAjNjRkZDE3LFxuICBjb250cmFzdDogKFxuICAgIDUwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMzAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNDAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNzAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDgwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA5MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTEwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEEyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBNDAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTcwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICApXG4pO1xuXG4kbWF0LWxpbWU6IChcbiAgNTA6ICNmOWZiZTcsXG4gIDEwMDogI2YwZjRjMyxcbiAgMjAwOiAjZTZlZTljLFxuICAzMDA6ICNkY2U3NzUsXG4gIDQwMDogI2Q0ZTE1NyxcbiAgNTAwOiAjY2RkYzM5LFxuICA2MDA6ICNjMGNhMzMsXG4gIDcwMDogI2FmYjQyYixcbiAgODAwOiAjOWU5ZDI0LFxuICA5MDA6ICM4Mjc3MTcsXG4gIEExMDA6ICNmNGZmODEsXG4gIEEyMDA6ICNlZWZmNDEsXG4gIEE0MDA6ICNjNmZmMDAsXG4gIEE3MDA6ICNhZWVhMDAsXG4gIGNvbnRyYXN0OiAoXG4gICAgNTA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAxMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAzMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA0MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA1MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA2MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA3MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA4MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA5MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTEwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEEyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBNDAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTcwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICApXG4pO1xuXG4kbWF0LXllbGxvdzogKFxuICA1MDogI2ZmZmRlNyxcbiAgMTAwOiAjZmZmOWM0LFxuICAyMDA6ICNmZmY1OWQsXG4gIDMwMDogI2ZmZjE3NixcbiAgNDAwOiAjZmZlZTU4LFxuICA1MDA6ICNmZmViM2IsXG4gIDYwMDogI2ZkZDgzNSxcbiAgNzAwOiAjZmJjMDJkLFxuICA4MDA6ICNmOWE4MjUsXG4gIDkwMDogI2Y1N2YxNyxcbiAgQTEwMDogI2ZmZmY4ZCxcbiAgQTIwMDogI2ZmZmYwMCxcbiAgQTQwMDogI2ZmZWEwMCxcbiAgQTcwMDogI2ZmZDYwMCxcbiAgY29udHJhc3Q6IChcbiAgICA1MDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDEwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDIwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDMwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDQwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDUwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDYwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDcwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDgwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDkwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEExMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTQwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEE3MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgKVxuKTtcblxuJG1hdC1hbWJlcjogKFxuICA1MDogI2ZmZjhlMSxcbiAgMTAwOiAjZmZlY2IzLFxuICAyMDA6ICNmZmUwODIsXG4gIDMwMDogI2ZmZDU0ZixcbiAgNDAwOiAjZmZjYTI4LFxuICA1MDA6ICNmZmMxMDcsXG4gIDYwMDogI2ZmYjMwMCxcbiAgNzAwOiAjZmZhMDAwLFxuICA4MDA6ICNmZjhmMDAsXG4gIDkwMDogI2ZmNmYwMCxcbiAgQTEwMDogI2ZmZTU3ZixcbiAgQTIwMDogI2ZmZDc0MCxcbiAgQTQwMDogI2ZmYzQwMCxcbiAgQTcwMDogI2ZmYWIwMCxcbiAgY29udHJhc3Q6IChcbiAgICA1MDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDEwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDIwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDMwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDQwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDUwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDYwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDcwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDgwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDkwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEExMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTQwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEE3MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgKVxuKTtcblxuJG1hdC1vcmFuZ2U6IChcbiAgNTA6ICNmZmYzZTAsXG4gIDEwMDogI2ZmZTBiMixcbiAgMjAwOiAjZmZjYzgwLFxuICAzMDA6ICNmZmI3NGQsXG4gIDQwMDogI2ZmYTcyNixcbiAgNTAwOiAjZmY5ODAwLFxuICA2MDA6ICNmYjhjMDAsXG4gIDcwMDogI2Y1N2MwMCxcbiAgODAwOiAjZWY2YzAwLFxuICA5MDA6ICNlNjUxMDAsXG4gIEExMDA6ICNmZmQxODAsXG4gIEEyMDA6ICNmZmFiNDAsXG4gIEE0MDA6ICNmZjkxMDAsXG4gIEE3MDA6ICNmZjZkMDAsXG4gIGNvbnRyYXN0OiAoXG4gICAgNTA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAxMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAzMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA0MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA1MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA2MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA3MDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA4MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgOTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIEExMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTQwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEE3MDA6IGJsYWNrLFxuICApXG4pO1xuXG4kbWF0LWRlZXAtb3JhbmdlOiAoXG4gIDUwOiAjZmJlOWU3LFxuICAxMDA6ICNmZmNjYmMsXG4gIDIwMDogI2ZmYWI5MSxcbiAgMzAwOiAjZmY4YTY1LFxuICA0MDA6ICNmZjcwNDMsXG4gIDUwMDogI2ZmNTcyMixcbiAgNjAwOiAjZjQ1MTFlLFxuICA3MDA6ICNlNjRhMTksXG4gIDgwMDogI2Q4NDMxNSxcbiAgOTAwOiAjYmYzNjBjLFxuICBBMTAwOiAjZmY5ZTgwLFxuICBBMjAwOiAjZmY2ZTQwLFxuICBBNDAwOiAjZmYzZDAwLFxuICBBNzAwOiAjZGQyYzAwLFxuICBjb250cmFzdDogKFxuICAgIDUwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMzAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNDAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDYwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA3MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgODAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDkwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICBBMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTIwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEE0MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgKVxuKTtcblxuJG1hdC1icm93bjogKFxuICA1MDogI2VmZWJlOSxcbiAgMTAwOiAjZDdjY2M4LFxuICAyMDA6ICNiY2FhYTQsXG4gIDMwMDogI2ExODg3ZixcbiAgNDAwOiAjOGQ2ZTYzLFxuICA1MDA6ICM3OTU1NDgsXG4gIDYwMDogIzZkNGM0MSxcbiAgNzAwOiAjNWQ0MDM3LFxuICA4MDA6ICM0ZTM0MmUsXG4gIDkwMDogIzNlMjcyMyxcbiAgQTEwMDogI2Q3Y2NjOCxcbiAgQTIwMDogI2JjYWFhNCxcbiAgQTQwMDogIzhkNmU2MyxcbiAgQTcwMDogIzVkNDAzNyxcbiAgY29udHJhc3Q6IChcbiAgICA1MDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDEwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDIwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIDMwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA0MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDYwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA3MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgODAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDkwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICBBMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTIwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEE0MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgKVxuKTtcblxuJG1hdC1ncmV5OiAoXG4gIDUwOiAjZmFmYWZhLFxuICAxMDA6ICNmNWY1ZjUsXG4gIDIwMDogI2VlZWVlZSxcbiAgMzAwOiAjZTBlMGUwLFxuICA0MDA6ICNiZGJkYmQsXG4gIDUwMDogIzllOWU5ZSxcbiAgNjAwOiAjNzU3NTc1LFxuICA3MDA6ICM2MTYxNjEsXG4gIDgwMDogIzQyNDI0MixcbiAgOTAwOiAjMjEyMTIxLFxuICBBMTAwOiAjZmZmZmZmLFxuICBBMjAwOiAjZWVlZWVlLFxuICBBNDAwOiAjYmRiZGJkLFxuICBBNzAwOiAjNjE2MTYxLFxuICBjb250cmFzdDogKFxuICAgIDUwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgMzAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNDAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgNjAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA4MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgOTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIEExMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICBBMjAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTQwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEE3MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gIClcbik7XG5cbi8vIEFsaWFzIGZvciBhbHRlcm5hdGUgc3BlbGxpbmcuXG4kbWF0LWdyYXk6ICRtYXQtZ3JleTtcblxuJG1hdC1ibHVlLWdyZXk6IChcbiAgNTA6ICNlY2VmZjEsXG4gIDEwMDogI2NmZDhkYyxcbiAgMjAwOiAjYjBiZWM1LFxuICAzMDA6ICM5MGE0YWUsXG4gIDQwMDogIzc4OTA5YyxcbiAgNTAwOiAjNjA3ZDhiLFxuICA2MDA6ICM1NDZlN2EsXG4gIDcwMDogIzQ1NWE2NCxcbiAgODAwOiAjMzc0NzRmLFxuICA5MDA6ICMyNjMyMzgsXG4gIEExMDA6ICNjZmQ4ZGMsXG4gIEEyMDA6ICNiMGJlYzUsXG4gIEE0MDA6ICM3ODkwOWMsXG4gIEE3MDA6ICM0NTVhNjQsXG4gIGNvbnRyYXN0OiAoXG4gICAgNTA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAxMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAyMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICAzMDA6ICRkYXJrLXByaW1hcnktdGV4dCxcbiAgICA0MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgNTAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDYwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICA3MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgODAwOiAkbGlnaHQtcHJpbWFyeS10ZXh0LFxuICAgIDkwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgICBBMTAwOiAkZGFyay1wcmltYXJ5LXRleHQsXG4gICAgQTIwMDogJGRhcmstcHJpbWFyeS10ZXh0LFxuICAgIEE0MDA6ICRsaWdodC1wcmltYXJ5LXRleHQsXG4gICAgQTcwMDogJGxpZ2h0LXByaW1hcnktdGV4dCxcbiAgKVxuKTtcblxuLy8gQWxpYXMgZm9yIGFsdGVybmF0ZSBzcGVsbGluZy5cbiRtYXQtYmx1ZS1ncmF5OiAkbWF0LWJsdWUtZ3JleTtcblxuXG4vLyBCYWNrZ3JvdW5kIHBhbGV0dGUgZm9yIGxpZ2h0IHRoZW1lcy5cbiRtYXQtbGlnaHQtdGhlbWUtYmFja2dyb3VuZDogKFxuICBzdGF0dXMtYmFyOiBtYXBfZ2V0KCRtYXQtZ3JleSwgMzAwKSxcbiAgYXBwLWJhcjogICAgbWFwX2dldCgkbWF0LWdyZXksIDEwMCksXG4gIGJhY2tncm91bmQ6IG1hcF9nZXQoJG1hdC1ncmV5LCA1MCksXG4gIGhvdmVyOiAgICAgIHJnYmEoYmxhY2ssIDAuMDQpLCAvLyBUT0RPKGthcmEpOiBjaGVjayBzdHlsZSB3aXRoIE1hdGVyaWFsIERlc2lnbiBVWFxuICBjYXJkOiAgICAgICB3aGl0ZSxcbiAgZGlhbG9nOiAgICAgd2hpdGUsXG4gIGRpc2FibGVkLWJ1dHRvbjogcmdiYShibGFjaywgMC4xMiksXG4gIHJhaXNlZC1idXR0b246IHdoaXRlLFxuICBmb2N1c2VkLWJ1dHRvbjogJGRhcmstZm9jdXNlZCxcbiAgc2VsZWN0ZWQtYnV0dG9uOiBtYXBfZ2V0KCRtYXQtZ3JleSwgMzAwKSxcbiAgc2VsZWN0ZWQtZGlzYWJsZWQtYnV0dG9uOiBtYXBfZ2V0KCRtYXQtZ3JleSwgNDAwKSxcbiAgZGlzYWJsZWQtYnV0dG9uLXRvZ2dsZTogbWFwX2dldCgkbWF0LWdyZXksIDIwMCksXG4gIHVuc2VsZWN0ZWQtY2hpcDogbWFwX2dldCgkbWF0LWdyZXksIDMwMCksXG4gIGRpc2FibGVkLWxpc3Qtb3B0aW9uOiBtYXBfZ2V0KCRtYXQtZ3JleSwgMjAwKSxcbik7XG5cbi8vIEJhY2tncm91bmQgcGFsZXR0ZSBmb3IgZGFyayB0aGVtZXMuXG4kbWF0LWRhcmstdGhlbWUtYmFja2dyb3VuZDogKFxuICBzdGF0dXMtYmFyOiBibGFjayxcbiAgYXBwLWJhcjogICAgbWFwX2dldCgkbWF0LWdyZXksIDkwMCksXG4gIGJhY2tncm91bmQ6ICMzMDMwMzAsXG4gIGhvdmVyOiAgICAgIHJnYmEod2hpdGUsIDAuMDQpLCAvLyBUT0RPKGthcmEpOiBjaGVjayBzdHlsZSB3aXRoIE1hdGVyaWFsIERlc2lnbiBVWFxuICBjYXJkOiAgICAgICBtYXBfZ2V0KCRtYXQtZ3JleSwgODAwKSxcbiAgZGlhbG9nOiAgICAgbWFwX2dldCgkbWF0LWdyZXksIDgwMCksXG4gIGRpc2FibGVkLWJ1dHRvbjogcmdiYSh3aGl0ZSwgMC4xMiksXG4gIHJhaXNlZC1idXR0b246IG1hcC1nZXQoJG1hdC1ncmV5LCA4MDApLFxuICBmb2N1c2VkLWJ1dHRvbjogJGxpZ2h0LWZvY3VzZWQsXG4gIHNlbGVjdGVkLWJ1dHRvbjogbWFwX2dldCgkbWF0LWdyZXksIDkwMCksXG4gIHNlbGVjdGVkLWRpc2FibGVkLWJ1dHRvbjogbWFwX2dldCgkbWF0LWdyZXksIDgwMCksXG4gIGRpc2FibGVkLWJ1dHRvbi10b2dnbGU6IGJsYWNrLFxuICB1bnNlbGVjdGVkLWNoaXA6IG1hcF9nZXQoJG1hdC1ncmV5LCA3MDApLFxuICBkaXNhYmxlZC1saXN0LW9wdGlvbjogYmxhY2ssXG4pO1xuXG4vLyBGb3JlZ3JvdW5kIHBhbGV0dGUgZm9yIGxpZ2h0IHRoZW1lcy5cbiRtYXQtbGlnaHQtdGhlbWUtZm9yZWdyb3VuZDogKFxuICBiYXNlOiAgICAgICAgICAgICAgYmxhY2ssXG4gIGRpdmlkZXI6ICAgICAgICAgICAkZGFyay1kaXZpZGVycyxcbiAgZGl2aWRlcnM6ICAgICAgICAgICRkYXJrLWRpdmlkZXJzLFxuICBkaXNhYmxlZDogICAgICAgICAgJGRhcmstZGlzYWJsZWQtdGV4dCxcbiAgZGlzYWJsZWQtYnV0dG9uOiAgIHJnYmEoYmxhY2ssIDAuMjYpLFxuICBkaXNhYmxlZC10ZXh0OiAgICAgJGRhcmstZGlzYWJsZWQtdGV4dCxcbiAgZWxldmF0aW9uOiAgICAgICAgIGJsYWNrLFxuICBoaW50LXRleHQ6ICAgICAgICAgJGRhcmstZGlzYWJsZWQtdGV4dCxcbiAgc2Vjb25kYXJ5LXRleHQ6ICAgICRkYXJrLXNlY29uZGFyeS10ZXh0LFxuICBpY29uOiAgICAgICAgICAgICAgcmdiYShibGFjaywgMC41NCksXG4gIGljb25zOiAgICAgICAgICAgICByZ2JhKGJsYWNrLCAwLjU0KSxcbiAgdGV4dDogICAgICAgICAgICAgIHJnYmEoYmxhY2ssIDAuODcpLFxuICBzbGlkZXItbWluOiAgICAgICAgcmdiYShibGFjaywgMC44NyksXG4gIHNsaWRlci1vZmY6ICAgICAgICByZ2JhKGJsYWNrLCAwLjI2KSxcbiAgc2xpZGVyLW9mZi1hY3RpdmU6IHJnYmEoYmxhY2ssIDAuMzgpLFxuKTtcblxuLy8gRm9yZWdyb3VuZCBwYWxldHRlIGZvciBkYXJrIHRoZW1lcy5cbiRtYXQtZGFyay10aGVtZS1mb3JlZ3JvdW5kOiAoXG4gIGJhc2U6ICAgICAgICAgICAgICB3aGl0ZSxcbiAgZGl2aWRlcjogICAgICAgICAgICRsaWdodC1kaXZpZGVycyxcbiAgZGl2aWRlcnM6ICAgICAgICAgICRsaWdodC1kaXZpZGVycyxcbiAgZGlzYWJsZWQ6ICAgICAgICAgICRsaWdodC1kaXNhYmxlZC10ZXh0LFxuICBkaXNhYmxlZC1idXR0b246ICAgcmdiYSh3aGl0ZSwgMC4zKSxcbiAgZGlzYWJsZWQtdGV4dDogICAgICRsaWdodC1kaXNhYmxlZC10ZXh0LFxuICBlbGV2YXRpb246ICAgICAgICAgYmxhY2ssXG4gIGhpbnQtdGV4dDogICAgICAgICAkbGlnaHQtZGlzYWJsZWQtdGV4dCxcbiAgc2Vjb25kYXJ5LXRleHQ6ICAgICRsaWdodC1zZWNvbmRhcnktdGV4dCxcbiAgaWNvbjogICAgICAgICAgICAgIHdoaXRlLFxuICBpY29uczogICAgICAgICAgICAgd2hpdGUsXG4gIHRleHQ6ICAgICAgICAgICAgICB3aGl0ZSxcbiAgc2xpZGVyLW1pbjogICAgICAgIHdoaXRlLFxuICBzbGlkZXItb2ZmOiAgICAgICAgcmdiYSh3aGl0ZSwgMC4zKSxcbiAgc2xpZGVyLW9mZi1hY3RpdmU6IHJnYmEod2hpdGUsIDAuMyksXG4pO1xuXG5cblxuLy8gRm9yIGEgZ2l2ZW4gaHVlIGluIGEgcGFsZXR0ZSwgcmV0dXJuIHRoZSBjb250cmFzdCBjb2xvciBmcm9tIHRoZSBtYXAgb2YgY29udHJhc3QgcGFsZXR0ZXMuXG4vLyBAcGFyYW0gJGNvbG9yLW1hcFxuLy8gQHBhcmFtICRodWVcbkBmdW5jdGlvbiBtYXQtY29udHJhc3QoJHBhbGV0dGUsICRodWUpIHtcbiAgQHJldHVybiBtYXAtZ2V0KG1hcC1nZXQoJHBhbGV0dGUsIGNvbnRyYXN0KSwgJGh1ZSk7XG59XG5cblxuLy8gQ3JlYXRlcyBhIG1hcCBvZiBodWVzIHRvIGNvbG9ycyBmb3IgYSB0aGVtZS4gVGhpcyBpcyB1c2VkIHRvIGRlZmluZSBhIHRoZW1lIHBhbGV0dGUgaW4gdGVybXNcbi8vIG9mIHRoZSBNYXRlcmlhbCBEZXNpZ24gaHVlcy5cbi8vIEBwYXJhbSAkY29sb3ItbWFwXG4vLyBAcGFyYW0gJHByaW1hcnlcbi8vIEBwYXJhbSAkbGlnaHRlclxuQGZ1bmN0aW9uIG1hdC1wYWxldHRlKCRiYXNlLXBhbGV0dGUsICRkZWZhdWx0OiA1MDAsICRsaWdodGVyOiAxMDAsICRkYXJrZXI6IDcwMCkge1xuICAkcmVzdWx0OiBtYXBfbWVyZ2UoJGJhc2UtcGFsZXR0ZSwgKFxuICAgIGRlZmF1bHQ6IG1hcC1nZXQoJGJhc2UtcGFsZXR0ZSwgJGRlZmF1bHQpLFxuICAgIGxpZ2h0ZXI6IG1hcC1nZXQoJGJhc2UtcGFsZXR0ZSwgJGxpZ2h0ZXIpLFxuICAgIGRhcmtlcjogbWFwLWdldCgkYmFzZS1wYWxldHRlLCAkZGFya2VyKSxcblxuICAgIGRlZmF1bHQtY29udHJhc3Q6IG1hdC1jb250cmFzdCgkYmFzZS1wYWxldHRlLCAkZGVmYXVsdCksXG4gICAgbGlnaHRlci1jb250cmFzdDogbWF0LWNvbnRyYXN0KCRiYXNlLXBhbGV0dGUsICRsaWdodGVyKSxcbiAgICBkYXJrZXItY29udHJhc3Q6IG1hdC1jb250cmFzdCgkYmFzZS1wYWxldHRlLCAkZGFya2VyKVxuICApKTtcblxuICAvLyBGb3IgZWFjaCBodWUgaW4gdGhlIHBhbGV0dGUsIGFkZCBhIFwiLWNvbnRyYXN0XCIgY29sb3IgdG8gdGhlIG1hcC5cbiAgQGVhY2ggJGh1ZSwgJGNvbG9yIGluICRiYXNlLXBhbGV0dGUge1xuICAgICRyZXN1bHQ6IG1hcF9tZXJnZSgkcmVzdWx0LCAoXG4gICAgICAnI3skaHVlfS1jb250cmFzdCc6IG1hdC1jb250cmFzdCgkYmFzZS1wYWxldHRlLCAkaHVlKVxuICAgICkpO1xuICB9XG5cbiAgQHJldHVybiAkcmVzdWx0O1xufVxuXG5cbi8vIEdldHMgYSBjb2xvciBmcm9tIGEgdGhlbWUgcGFsZXR0ZSAodGhlIG91dHB1dCBvZiBtYXQtcGFsZXR0ZSkuXG4vLyBUaGUgaHVlIGNhbiBiZSBvbmUgb2YgdGhlIHN0YW5kYXJkIHZhbHVlcyAoNTAwLCBBNDAwLCBldGMuKSwgb25lIG9mIHRoZSB0aHJlZSBwcmVjb25maWd1cmVkXG4vLyBodWVzIChkZWZhdWx0LCBsaWdodGVyLCBkYXJrZXIpLCBvciBhbnkgb2YgdGhlIGFmb3JlbWVudGlvbmVkIHByZWZpeGVkIHdpdGggXCItY29udHJhc3RcIi5cbi8vXG4vLyBAcGFyYW0gJGNvbG9yLW1hcCBUaGUgdGhlbWUgcGFsZXR0ZSAob3V0cHV0IG9mIG1hdC1wYWxldHRlKS5cbi8vIEBwYXJhbSAkaHVlIFRoZSBodWUgZnJvbSB0aGUgcGFsZXR0ZSB0byB1c2UuIElmIHRoaXMgaXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGl0IHdpbGxcbi8vICAgICBiZSB0cmVhdGVkIGFzIG9wYWNpdHkuXG4vLyBAcGFyYW0gJG9wYWNpdHkgVGhlIGFscGhhIGNoYW5uZWwgdmFsdWUgZm9yIHRoZSBjb2xvci5cbkBmdW5jdGlvbiBtYXQtY29sb3IoJHBhbGV0dGUsICRodWU6IGRlZmF1bHQsICRvcGFjaXR5OiBudWxsKSB7XG4gIC8vIElmIGh1ZUtleSBpcyBhIG51bWJlciBiZXR3ZWVuIHplcm8gYW5kIG9uZSwgdGhlbiBpdCBhY3R1YWxseSBjb250YWlucyBhblxuICAvLyBvcGFjaXR5IHZhbHVlLCBzbyByZWNhbGwgdGhpcyBmdW5jdGlvbiB3aXRoIHRoZSBkZWZhdWx0IGh1ZSBhbmQgdGhhdCBnaXZlbiBvcGFjaXR5LlxuICBAaWYgdHlwZS1vZigkaHVlKSA9PSBudW1iZXIgYW5kICRodWUgPj0gMCBhbmQgJGh1ZSA8PSAxIHtcbiAgICBAcmV0dXJuIG1hdC1jb2xvcigkcGFsZXR0ZSwgZGVmYXVsdCwgJGh1ZSk7XG4gIH1cblxuICAkY29sb3I6IG1hcC1nZXQoJHBhbGV0dGUsICRodWUpO1xuXG4gIEBpZiAodHlwZS1vZigkY29sb3IpICE9IGNvbG9yKSB7XG4gICAgLy8gSWYgdGhlICRjb2xvciByZXNvbHZlZCB0byBzb21ldGhpbmcgZGlmZmVyZW50IGZyb20gYSBjb2xvciAoZS5nLiBhIENTUyB2YXJpYWJsZSksXG4gICAgLy8gd2UgY2FuJ3QgYXBwbHkgdGhlIG9wYWNpdHkgYW55d2F5IHNvIHdlIHJldHVybiB0aGUgdmFsdWUgYXMgaXMsIG90aGVyd2lzZSBTYXNzIGNhblxuICAgIC8vIHRocm93IGFuIGVycm9yIG9yIG91dHB1dCBzb21ldGhpbmcgaW52YWxpZC5cbiAgICBAcmV0dXJuICRjb2xvcjtcbiAgfVxuXG4gIEByZXR1cm4gcmdiYSgkY29sb3IsIGlmKCRvcGFjaXR5ID09IG51bGwsIG9wYWNpdHkoJGNvbG9yKSwgJG9wYWNpdHkpKTtcbn1cblxuXG4vLyBDcmVhdGVzIGEgY29udGFpbmVyIG9iamVjdCBmb3IgYSBsaWdodCB0aGVtZSB0byBiZSBnaXZlbiB0byBpbmRpdmlkdWFsIGNvbXBvbmVudCB0aGVtZSBtaXhpbnMuXG5AZnVuY3Rpb24gbWF0LWxpZ2h0LXRoZW1lKCRwcmltYXJ5LCAkYWNjZW50LCAkd2FybjogbWF0LXBhbGV0dGUoJG1hdC1yZWQpKSB7XG4gIEByZXR1cm4gKFxuICAgIHByaW1hcnk6ICRwcmltYXJ5LFxuICAgIGFjY2VudDogJGFjY2VudCxcbiAgICB3YXJuOiAkd2FybixcbiAgICBpcy1kYXJrOiBmYWxzZSxcbiAgICBmb3JlZ3JvdW5kOiAkbWF0LWxpZ2h0LXRoZW1lLWZvcmVncm91bmQsXG4gICAgYmFja2dyb3VuZDogJG1hdC1saWdodC10aGVtZS1iYWNrZ3JvdW5kLFxuICApO1xufVxuXG5cbi8vIENyZWF0ZXMgYSBjb250YWluZXIgb2JqZWN0IGZvciBhIGRhcmsgdGhlbWUgdG8gYmUgZ2l2ZW4gdG8gaW5kaXZpZHVhbCBjb21wb25lbnQgdGhlbWUgbWl4aW5zLlxuQGZ1bmN0aW9uIG1hdC1kYXJrLXRoZW1lKCRwcmltYXJ5LCAkYWNjZW50LCAkd2FybjogbWF0LXBhbGV0dGUoJG1hdC1yZWQpKSB7XG4gIEByZXR1cm4gKFxuICAgIHByaW1hcnk6ICRwcmltYXJ5LFxuICAgIGFjY2VudDogJGFjY2VudCxcbiAgICB3YXJuOiAkd2FybixcbiAgICBpcy1kYXJrOiB0cnVlLFxuICAgIGZvcmVncm91bmQ6ICRtYXQtZGFyay10aGVtZS1mb3JlZ3JvdW5kLFxuICAgIGJhY2tncm91bmQ6ICRtYXQtZGFyay10aGVtZS1iYWNrZ3JvdW5kLFxuICApO1xufVxuXG5cblxuJG1hdC1yaXBwbGUtY29sb3Itb3BhY2l0eTogMC4xO1xuXG5AbWl4aW4gbWF0LXJpcHBsZSgpIHtcblxuICAvLyBUaGUgaG9zdCBlbGVtZW50IG9mIGFuIG1hdC1yaXBwbGUgZGlyZWN0aXZlIHNob3VsZCBhbHdheXMgaGF2ZSBhIHBvc2l0aW9uIG9mIFwiYWJzb2x1dGVcIiBvclxuICAvLyBcInJlbGF0aXZlXCIgc28gdGhhdCB0aGUgcmlwcGxlcyBpbnNpZGUgYXJlIGNvcnJlY3RseSBwb3NpdGlvbmVkIHJlbGF0aXZlbHkgdG8gdGhlIGNvbnRhaW5lci5cbiAgLm1hdC1yaXBwbGUge1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG5cbiAgICAvLyBCeSBkZWZhdWx0LCBldmVyeSByaXBwbGUgY29udGFpbmVyIHNob3VsZCBoYXZlIHBvc2l0aW9uOiByZWxhdGl2ZSBpbiBmYXZvciBvZiBjcmVhdGluZyBhblxuICAgIC8vIGVhc3kgQVBJIGZvciBkZXZlbG9wZXJzIHVzaW5nIHRoZSBNYXRSaXBwbGUgZGlyZWN0aXZlLlxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgfVxuXG4gIC5tYXQtcmlwcGxlLm1hdC1yaXBwbGUtdW5ib3VuZGVkIHtcbiAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgfVxuXG4gIC5tYXQtcmlwcGxlLWVsZW1lbnQge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG5cbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5LCB0cmFuc2Zvcm0gMG1zIGN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpO1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMCk7XG5cbiAgICAvLyBJbiBoaWdoIGNvbnRyYXN0IG1vZGUgdGhlIHJpcHBsZSBpcyBvcGFxdWUsIGNhdXNpbmcgaXQgdG8gb2JzdHJ1Y3QgdGhlIGNvbnRlbnQuXG4gICAgQGluY2x1ZGUgY2RrLWhpZ2gtY29udHJhc3Qge1xuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG4gIH1cbn1cblxuLyogVGhlbWUgZm9yIHRoZSByaXBwbGUgZWxlbWVudHMuKi9cbkBtaXhpbiBtYXQtcmlwcGxlLXRoZW1lKCR0aGVtZSkge1xuICAkZm9yZWdyb3VuZDogbWFwX2dldCgkdGhlbWUsIGZvcmVncm91bmQpO1xuICAkZm9yZWdyb3VuZC1iYXNlOiBtYXBfZ2V0KCRmb3JlZ3JvdW5kLCBiYXNlKTtcblxuICAubWF0LXJpcHBsZS1lbGVtZW50IHtcbiAgICAvLyBJZiB0aGUgcmlwcGxlIGNvbG9yIGlzIHJlc29sdmVzIHRvIGEgY29sb3IgKnR5cGUqLCB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5LCBvdGhlcndpc2VcbiAgICAvLyAoZS5nLiBpdCByZXNvbHZlcyB0byBhIENTUyB2YXJpYWJsZSkgd2UgZmFsbCBiYWNrIHRvIHVzaW5nIHRoZSBjb2xvciBhbmQgc2V0dGluZyBhbiBvcGFjaXR5LlxuICAgIEBpZiAodHlwZS1vZigkZm9yZWdyb3VuZC1iYXNlKSA9PSBjb2xvcikge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgkZm9yZWdyb3VuZC1iYXNlLCAkbWF0LXJpcHBsZS1jb2xvci1vcGFjaXR5KTtcbiAgICB9XG4gICAgQGVsc2Uge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGZvcmVncm91bmQtYmFzZTtcbiAgICAgIG9wYWNpdHk6ICRtYXQtcmlwcGxlLWNvbG9yLW9wYWNpdHk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBVdGlsaXR5IGZvciBmZXRjaGluZyBhIG5lc3RlZCB2YWx1ZSBmcm9tIGEgdHlwb2dyYXBoeSBjb25maWcuXG5AZnVuY3Rpb24gX21hdC1nZXQtdHlwZS12YWx1ZSgkY29uZmlnLCAkbGV2ZWwsICRuYW1lKSB7XG4gIEByZXR1cm4gbWFwLWdldChtYXAtZ2V0KCRjb25maWcsICRsZXZlbCksICRuYW1lKTtcbn1cblxuLy8gR2V0cyB0aGUgZm9udCBzaXplIGZvciBhIGxldmVsIGluc2lkZSBhIHR5cG9ncmFwaHkgY29uZmlnLlxuQGZ1bmN0aW9uIG1hdC1mb250LXNpemUoJGNvbmZpZywgJGxldmVsKSB7XG4gIEByZXR1cm4gX21hdC1nZXQtdHlwZS12YWx1ZSgkY29uZmlnLCAkbGV2ZWwsIGZvbnQtc2l6ZSk7XG59XG5cbi8vIEdldHMgdGhlIGxpbmUgaGVpZ2h0IGZvciBhIGxldmVsIGluc2lkZSBhIHR5cG9ncmFwaHkgY29uZmlnLlxuQGZ1bmN0aW9uIG1hdC1saW5lLWhlaWdodCgkY29uZmlnLCAkbGV2ZWwpIHtcbiAgQHJldHVybiBfbWF0LWdldC10eXBlLXZhbHVlKCRjb25maWcsICRsZXZlbCwgbGluZS1oZWlnaHQpO1xufVxuXG4vLyBHZXRzIHRoZSBmb250IHdlaWdodCBmb3IgYSBsZXZlbCBpbnNpZGUgYSB0eXBvZ3JhcGh5IGNvbmZpZy5cbkBmdW5jdGlvbiBtYXQtZm9udC13ZWlnaHQoJGNvbmZpZywgJGxldmVsKSB7XG4gIEByZXR1cm4gX21hdC1nZXQtdHlwZS12YWx1ZSgkY29uZmlnLCAkbGV2ZWwsIGZvbnQtd2VpZ2h0KTtcbn1cblxuLy8gR2V0cyB0aGUgbGV0dGVyIHNwYWNpbmcgZm9yIGEgbGV2ZWwgaW5zaWRlIGEgdHlwb2dyYXBoeSBjb25maWcuXG5AZnVuY3Rpb24gbWF0LWxldHRlci1zcGFjaW5nKCRjb25maWcsICRsZXZlbCkge1xuICBAcmV0dXJuIF9tYXQtZ2V0LXR5cGUtdmFsdWUoJGNvbmZpZywgJGxldmVsLCBsZXR0ZXItc3BhY2luZyk7XG59XG5cbi8vIEdldHMgdGhlIGZvbnQtZmFtaWx5IGZyb20gYSB0eXBvZ3JhcGh5IGNvbmZpZyBhbmQgcmVtb3ZlcyB0aGUgcXVvdGVzIGFyb3VuZCBpdC5cbkBmdW5jdGlvbiBtYXQtZm9udC1mYW1pbHkoJGNvbmZpZywgJGxldmVsOiBudWxsKSB7XG4gICRmb250LWZhbWlseTogbWFwLWdldCgkY29uZmlnLCBmb250LWZhbWlseSk7XG5cbiAgQGlmICRsZXZlbCAhPSBudWxsIHtcbiAgICAkZm9udC1mYW1pbHk6IF9tYXQtZ2V0LXR5cGUtdmFsdWUoJGNvbmZpZywgJGxldmVsLCBmb250LWZhbWlseSk7XG4gIH1cblxuICAvLyBHdWFyZCBhZ2FpbnN0IHVucXVvdGluZyBub24tc3RyaW5nIHZhbHVlcywgYmVjYXVzZSBpdCdzIGRlcHJlY2F0ZWQuXG4gIEByZXR1cm4gaWYodHlwZS1vZigkZm9udC1mYW1pbHkpID09IHN0cmluZywgdW5xdW90ZSgkZm9udC1mYW1pbHkpLCAkZm9udC1mYW1pbHkpO1xufVxuXG4vLyBPdXRwdXRzIHRoZSBzaG9ydGhhbmQgYGZvbnRgIENTUyBwcm9wZXJ0eSwgYmFzZWQgb24gYSBzZXQgb2YgdHlwb2dyYXBoeSB2YWx1ZXMuIEZhbGxzIGJhY2sgdG9cbi8vIHRoZSBpbmRpdmlkdWFsIHByb3BlcnRpZXMgaWYgYSB2YWx1ZSB0aGF0IGlzbid0IGFsbG93ZWQgaW4gdGhlIHNob3J0aGFuZCBpcyBwYXNzZWQgaW4uXG5AbWl4aW4gbWF0LXR5cG9ncmFwaHktZm9udC1zaG9ydGhhbmQoJGZvbnQtc2l6ZSwgJGZvbnQtd2VpZ2h0LCAkbGluZS1oZWlnaHQsICRmb250LWZhbWlseSkge1xuICAvLyBJZiBhbnkgb2YgdGhlIHZhbHVlcyBhcmUgc2V0IHRvIGBpbmhlcml0YCwgd2UgY2FuJ3QgdXNlIHRoZSBzaG9ydGhhbmRcbiAgLy8gc28gd2UgZmFsbCBiYWNrIHRvIHBhc3NpbmcgaW4gdGhlIGluZGl2aWR1YWwgcHJvcGVydGllcy5cbiAgQGlmICgkZm9udC1zaXplID09IGluaGVyaXQgb3JcbiAgICAgICAkZm9udC13ZWlnaHQgPT0gaW5oZXJpdCBvclxuICAgICAgICRsaW5lLWhlaWdodCA9PSBpbmhlcml0IG9yXG4gICAgICAgJGZvbnQtZmFtaWx5ID09IGluaGVyaXQgb3JcbiAgICAgICAkZm9udC1zaXplID09IG51bGwgb3JcbiAgICAgICAkZm9udC13ZWlnaHQgPT0gbnVsbCBvclxuICAgICAgICRsaW5lLWhlaWdodCA9PSBudWxsIG9yXG4gICAgICAgJGZvbnQtZmFtaWx5ID09IG51bGwpIHtcblxuICAgIGZvbnQtc2l6ZTogJGZvbnQtc2l6ZTtcbiAgICBmb250LXdlaWdodDogJGZvbnQtd2VpZ2h0O1xuICAgIGxpbmUtaGVpZ2h0OiAkbGluZS1oZWlnaHQ7XG4gICAgZm9udC1mYW1pbHk6ICRmb250LWZhbWlseTtcbiAgfVxuICBAZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlIHVzZSB0aGUgc2hvcnRoYW5kIGBmb250YCwgYmVjYXVzZSBpdCdzIHRoZSBsZWFzdCBhbW91bnQgb2YgYnl0ZXMuIE5vdGVcbiAgICAvLyB0aGF0IHdlIG5lZWQgdG8gdXNlIGludGVycG9sYXRpb24gZm9yIGBmb250LXNpemUvbGluZS1oZWlnaHRgIGluIG9yZGVyIHRvIHByZXZlbnRcbiAgICAvLyBTYXNzIGZyb20gZGl2aWRpbmcgdGhlIHR3byB2YWx1ZXMuXG4gICAgZm9udDogJGZvbnQtd2VpZ2h0ICN7JGZvbnQtc2l6ZX0vI3skbGluZS1oZWlnaHR9ICRmb250LWZhbWlseTtcbiAgfVxufVxuXG4vLyBDb252ZXJ0cyBhIHR5cG9ncmFwaHkgbGV2ZWwgaW50byBDU1Mgc3R5bGVzLlxuQG1peGluIG1hdC10eXBvZ3JhcGh5LWxldmVsLXRvLXN0eWxlcygkY29uZmlnLCAkbGV2ZWwpIHtcbiAgJGZvbnQtc2l6ZTogbWF0LWZvbnQtc2l6ZSgkY29uZmlnLCAkbGV2ZWwpO1xuICAkZm9udC13ZWlnaHQ6IG1hdC1mb250LXdlaWdodCgkY29uZmlnLCAkbGV2ZWwpO1xuICAkbGluZS1oZWlnaHQ6IG1hdC1saW5lLWhlaWdodCgkY29uZmlnLCAkbGV2ZWwpO1xuICAkZm9udC1mYW1pbHk6IG1hdC1mb250LWZhbWlseSgkY29uZmlnLCAkbGV2ZWwpO1xuXG4gIEBpbmNsdWRlIG1hdC10eXBvZ3JhcGh5LWZvbnQtc2hvcnRoYW5kKCRmb250LXNpemUsICRmb250LXdlaWdodCwgJGxpbmUtaGVpZ2h0LCAkZm9udC1mYW1pbHkpO1xuICBsZXR0ZXItc3BhY2luZzogbWF0LWxldHRlci1zcGFjaW5nKCRjb25maWcsICRsZXZlbCk7XG59XG5cblxuQG1peGluIG1hdC1vcHRpb24tdGhlbWUoJHRoZW1lKSB7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG4gICRiYWNrZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgYmFja2dyb3VuZCk7XG4gICRwcmltYXJ5OiBtYXAtZ2V0KCR0aGVtZSwgcHJpbWFyeSk7XG4gICRhY2NlbnQ6IG1hcC1nZXQoJHRoZW1lLCBhY2NlbnQpO1xuICAkd2FybjogbWFwLWdldCgkdGhlbWUsIHdhcm4pO1xuXG4gIC5tYXQtb3B0aW9uIHtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCB0ZXh0KTtcblxuICAgICY6aG92ZXI6bm90KC5tYXQtb3B0aW9uLWRpc2FibGVkKSxcbiAgICAmOmZvY3VzOm5vdCgubWF0LW9wdGlvbi1kaXNhYmxlZCkge1xuICAgICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLy8gSW4gbXVsdGlwbGUgbW9kZSB0aGVyZSBpcyBhIGNoZWNrYm94IHRvIHNob3cgdGhhdCB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkLlxuICAgICYubWF0LXNlbGVjdGVkOm5vdCgubWF0LW9wdGlvbi1tdWx0aXBsZSk6bm90KC5tYXQtb3B0aW9uLWRpc2FibGVkKSB7XG4gICAgICBiYWNrZ3JvdW5kOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAmLm1hdC1hY3RpdmUge1xuICAgICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCBob3Zlcik7XG4gICAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCB0ZXh0KTtcbiAgICB9XG5cbiAgICAmLm1hdC1vcHRpb24tZGlzYWJsZWQge1xuICAgICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgaGludC10ZXh0KTtcbiAgICB9XG4gIH1cblxuICAubWF0LXByaW1hcnkgLm1hdC1vcHRpb24ubWF0LXNlbGVjdGVkOm5vdCgubWF0LW9wdGlvbi1kaXNhYmxlZCkge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJHByaW1hcnkpO1xuICB9XG5cbiAgLm1hdC1hY2NlbnQgLm1hdC1vcHRpb24ubWF0LXNlbGVjdGVkOm5vdCgubWF0LW9wdGlvbi1kaXNhYmxlZCkge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGFjY2VudCk7XG4gIH1cblxuICAubWF0LXdhcm4gLm1hdC1vcHRpb24ubWF0LXNlbGVjdGVkOm5vdCgubWF0LW9wdGlvbi1kaXNhYmxlZCkge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJHdhcm4pO1xuICB9XG59XG5cbkBtaXhpbiBtYXQtb3B0aW9uLXR5cG9ncmFwaHkoJGNvbmZpZykge1xuICAubWF0LW9wdGlvbiB7XG4gICAgZm9udDoge1xuICAgICAgZmFtaWx5OiBtYXQtZm9udC1mYW1pbHkoJGNvbmZpZyk7XG4gICAgICBzaXplOiBtYXQtZm9udC1zaXplKCRjb25maWcsIHN1YmhlYWRpbmctMik7XG4gICAgfVxuICB9XG59XG5cblxuXG5cblxuQG1peGluIG1hdC1vcHRncm91cC10aGVtZSgkdGhlbWUpIHtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAubWF0LW9wdGdyb3VwLWxhYmVsIHtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBzZWNvbmRhcnktdGV4dCk7XG4gIH1cblxuICAubWF0LW9wdGdyb3VwLWRpc2FibGVkIC5tYXQtb3B0Z3JvdXAtbGFiZWwge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGhpbnQtdGV4dCk7XG4gIH1cbn1cblxuQG1peGluIG1hdC1vcHRncm91cC10eXBvZ3JhcGh5KCRjb25maWcpIHtcbiAgLm1hdC1vcHRncm91cC1sYWJlbCB7XG4gICAgQGluY2x1ZGUgbWF0LXR5cG9ncmFwaHktbGV2ZWwtdG8tc3R5bGVzKCRjb25maWcsIGJvZHktMik7XG4gIH1cbn1cblxuXG5cbkBtaXhpbiBtYXQtcHNldWRvLWNoZWNrYm94LXRoZW1lKCR0aGVtZSkge1xuICAkaXMtZGFyay10aGVtZTogbWFwLWdldCgkdGhlbWUsIGlzLWRhcmspO1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcblxuICAvLyBOT1RFKHRyYXZpc2thdWZtYW4pOiBXaGlsZSB0aGUgc3BlYyBjYWxscyBmb3IgdHJhbnNsdWNlbnQgYmxhY2tzL3doaXRlcyBmb3IgZGlzYWJsZWQgY29sb3JzLFxuICAvLyB0aGlzIGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIGVsZW1lbnRzIGxheWVyZWQgb24gdG9wIG9mIG9uZSBhbm90aGVyLiBUbyBnZXQgYXJvdW5kIHRoaXMgd2VcbiAgLy8gYmxlbmQgdGhlIGNvbG9ycyB0b2dldGhlciBiYXNlZCBvbiB0aGUgYmFzZSBjb2xvciBhbmQgdGhlIHRoZW1lIGJhY2tncm91bmQuXG4gICR3aGl0ZS0zMHBjdC1vcGFjaXR5LW9uLWRhcms6ICM2ODY4Njg7XG4gICRibGFjay0yNnBjdC1vcGFjaXR5LW9uLWxpZ2h0OiAjYjBiMGIwO1xuICAkZGlzYWJsZWQtY29sb3I6IGlmKCRpcy1kYXJrLXRoZW1lLCAkd2hpdGUtMzBwY3Qtb3BhY2l0eS1vbi1kYXJrLCAkYmxhY2stMjZwY3Qtb3BhY2l0eS1vbi1saWdodCk7XG4gICRjb2xvcmVkLWJveC1zZWxlY3RvcjogJy5tYXQtcHNldWRvLWNoZWNrYm94LWNoZWNrZWQsIC5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGUnO1xuXG4gIC5tYXQtcHNldWRvLWNoZWNrYm94IHtcbiAgICBjb2xvcjogbWF0LWNvbG9yKG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKSwgc2Vjb25kYXJ5LXRleHQpO1xuXG4gICAgJjo6YWZ0ZXIge1xuICAgICAgY29sb3I6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgYmFja2dyb3VuZCk7XG4gICAgfVxuICB9XG5cbiAgLm1hdC1wc2V1ZG8tY2hlY2tib3gtZGlzYWJsZWQge1xuICAgIGNvbG9yOiAkZGlzYWJsZWQtY29sb3I7XG4gIH1cblxuICAvLyBEZWZhdWx0IHRvIHRoZSBhY2NlbnQgY29sb3IuIE5vdGUgdGhhdCB0aGUgcHNldWRvIGNoZWNrYm94ZXMgYXJlIG1lYW50IHRvIGluaGVyaXQgdGhlXG4gIC8vIHRoZW1lIGZyb20gdGhlaXIgcGFyZW50LCByYXRoZXIgdGhhbiBpbXBsZW1lbnRpbmcgdGhlaXIgb3duIHRoZW1pbmcsIHdoaWNoIGlzIHdoeSB3ZVxuICAvLyBkb24ndCBhdHRhY2ggdG8gdGhlIGBtYXQtKmAgY2xhc3Nlcy5cbiAgLm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZCxcbiAgLm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZSxcbiAgLm1hdC1hY2NlbnQgLm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZCxcbiAgLm1hdC1hY2NlbnQgLm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZSB7XG4gICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKG1hcC1nZXQoJHRoZW1lLCBhY2NlbnQpKTtcbiAgfVxuXG4gIC5tYXQtcHJpbWFyeSAubWF0LXBzZXVkby1jaGVja2JveC1jaGVja2VkLFxuICAubWF0LXByaW1hcnkgLm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZSB7XG4gICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKG1hcC1nZXQoJHRoZW1lLCBwcmltYXJ5KSk7XG4gIH1cblxuICAubWF0LXdhcm4gLm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZCxcbiAgLm1hdC13YXJuIC5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGUge1xuICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcihtYXAtZ2V0KCR0aGVtZSwgd2FybikpO1xuICB9XG5cbiAgLm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZCxcbiAgLm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZSB7XG4gICAgJi5tYXQtcHNldWRvLWNoZWNrYm94LWRpc2FibGVkIHtcbiAgICAgIGJhY2tncm91bmQ6ICRkaXNhYmxlZC1jb2xvcjtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFJlcHJlc2VudHMgYSB0eXBvZ3JhcGh5IGxldmVsIGZyb20gdGhlIE1hdGVyaWFsIGRlc2lnbiBzcGVjLlxuQGZ1bmN0aW9uIG1hdC10eXBvZ3JhcGh5LWxldmVsKFxuICAkZm9udC1zaXplLFxuICAkbGluZS1oZWlnaHQ6ICRmb250LXNpemUsXG4gICRmb250LXdlaWdodDogNDAwLFxuICAkZm9udC1mYW1pbHk6IG51bGwsXG4gICRsZXR0ZXItc3BhY2luZzogbnVsbCkge1xuXG4gIEByZXR1cm4gKFxuICAgIGZvbnQtc2l6ZTogJGZvbnQtc2l6ZSxcbiAgICBsaW5lLWhlaWdodDogJGxpbmUtaGVpZ2h0LFxuICAgIGZvbnQtd2VpZ2h0OiAkZm9udC13ZWlnaHQsXG4gICAgZm9udC1mYW1pbHk6ICRmb250LWZhbWlseSxcbiAgICBsZXR0ZXItc3BhY2luZzogJGxldHRlci1zcGFjaW5nXG4gICk7XG59XG5cbi8vIFJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIHR5cG9ncmFwaHkgbGV2ZWxzLlxuLy8gRGVmYXVsdHMgY29tZSBmcm9tIGh0dHBzOi8vbWF0ZXJpYWwuaW8vZ3VpZGVsaW5lcy9zdHlsZS90eXBvZ3JhcGh5Lmh0bWxcbkBmdW5jdGlvbiBtYXQtdHlwb2dyYXBoeS1jb25maWcoXG4gICRmb250LWZhbWlseTogICAnUm9ib3RvLCBcIkhlbHZldGljYSBOZXVlXCIsIHNhbnMtc2VyaWYnLFxuICAkZGlzcGxheS00OiAgICAgbWF0LXR5cG9ncmFwaHktbGV2ZWwoMTEycHgsIDExMnB4LCAzMDApLFxuICAkZGlzcGxheS0zOiAgICAgbWF0LXR5cG9ncmFwaHktbGV2ZWwoNTZweCwgNTZweCwgNDAwKSxcbiAgJGRpc3BsYXktMjogICAgIG1hdC10eXBvZ3JhcGh5LWxldmVsKDQ1cHgsIDQ4cHgsIDQwMCksXG4gICRkaXNwbGF5LTE6ICAgICBtYXQtdHlwb2dyYXBoeS1sZXZlbCgzNHB4LCA0MHB4LCA0MDApLFxuICAkaGVhZGxpbmU6ICAgICAgbWF0LXR5cG9ncmFwaHktbGV2ZWwoMjRweCwgMzJweCwgNDAwKSxcbiAgJHRpdGxlOiAgICAgICAgIG1hdC10eXBvZ3JhcGh5LWxldmVsKDIwcHgsIDMycHgsIDUwMCksXG4gICRzdWJoZWFkaW5nLTI6ICBtYXQtdHlwb2dyYXBoeS1sZXZlbCgxNnB4LCAyOHB4LCA0MDApLFxuICAkc3ViaGVhZGluZy0xOiAgbWF0LXR5cG9ncmFwaHktbGV2ZWwoMTVweCwgMjRweCwgNDAwKSxcbiAgJGJvZHktMjogICAgICAgIG1hdC10eXBvZ3JhcGh5LWxldmVsKDE0cHgsIDI0cHgsIDUwMCksXG4gICRib2R5LTE6ICAgICAgICBtYXQtdHlwb2dyYXBoeS1sZXZlbCgxNHB4LCAyMHB4LCA0MDApLFxuICAkY2FwdGlvbjogICAgICAgbWF0LXR5cG9ncmFwaHktbGV2ZWwoMTJweCwgMjBweCwgNDAwKSxcbiAgJGJ1dHRvbjogICAgICAgIG1hdC10eXBvZ3JhcGh5LWxldmVsKDE0cHgsIDE0cHgsIDUwMCksXG4gIC8vIExpbmUtaGVpZ2h0IG11c3QgYmUgdW5pdC1sZXNzIGZyYWN0aW9uIG9mIHRoZSBmb250LXNpemUuXG4gICRpbnB1dDogICAgICAgICBtYXQtdHlwb2dyYXBoeS1sZXZlbChpbmhlcml0LCAxLjEyNSwgNDAwKVxuKSB7XG5cbiAgLy8gRGVjbGFyZSBhbiBpbml0aWFsIG1hcCB3aXRoIGFsbCBvZiB0aGUgbGV2ZWxzLlxuICAkY29uZmlnOiAoXG4gICAgZGlzcGxheS00OiAgICAgICRkaXNwbGF5LTQsXG4gICAgZGlzcGxheS0zOiAgICAgICRkaXNwbGF5LTMsXG4gICAgZGlzcGxheS0yOiAgICAgICRkaXNwbGF5LTIsXG4gICAgZGlzcGxheS0xOiAgICAgICRkaXNwbGF5LTEsXG4gICAgaGVhZGxpbmU6ICAgICAgICRoZWFkbGluZSxcbiAgICB0aXRsZTogICAgICAgICAgJHRpdGxlLFxuICAgIHN1YmhlYWRpbmctMjogICAkc3ViaGVhZGluZy0yLFxuICAgIHN1YmhlYWRpbmctMTogICAkc3ViaGVhZGluZy0xLFxuICAgIGJvZHktMjogICAgICAgICAkYm9keS0yLFxuICAgIGJvZHktMTogICAgICAgICAkYm9keS0xLFxuICAgIGNhcHRpb246ICAgICAgICAkY2FwdGlvbixcbiAgICBidXR0b246ICAgICAgICAgJGJ1dHRvbixcbiAgICBpbnB1dDogICAgICAgICAgJGlucHV0LFxuICApO1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgbGV2ZWxzIGFuZCBzZXQgdGhlIGBmb250LWZhbWlseWAgb2YgdGhlIG9uZXMgdGhhdCBkb24ndCBoYXZlIG9uZSB0byB0aGUgYmFzZS5cbiAgLy8gTm90ZSB0aGF0IFNhc3MgY2FuJ3QgbW9kaWZ5IG1hcHMgaW4gcGxhY2UsIHdoaWNoIG1lYW5zIHRoYXQgd2UgbmVlZCB0byBtZXJnZSBhbmQgcmUtYXNzaWduLlxuICBAZWFjaCAka2V5LCAkbGV2ZWwgaW4gJGNvbmZpZyB7XG4gICAgQGlmIG1hcC1nZXQoJGxldmVsLCBmb250LWZhbWlseSkgPT0gbnVsbCB7XG4gICAgICAkbmV3LWxldmVsOiBtYXAtbWVyZ2UoJGxldmVsLCAoZm9udC1mYW1pbHk6ICRmb250LWZhbWlseSkpO1xuICAgICAgJGNvbmZpZzogbWFwLW1lcmdlKCRjb25maWcsICgka2V5OiAkbmV3LWxldmVsKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHRoZSBiYXNlIGZvbnQgZmFtaWx5IHRvIHRoZSBjb25maWcuXG4gIEByZXR1cm4gbWFwLW1lcmdlKCRjb25maWcsIChmb250LWZhbWlseTogJGZvbnQtZmFtaWx5KSk7XG59XG5cbi8vIEFkZHMgdGhlIGJhc2UgdHlwb2dyYXBoeSBzdHlsZXMsIGJhc2VkIG9uIGEgY29uZmlnLlxuQG1peGluIG1hdC1iYXNlLXR5cG9ncmFwaHkoJGNvbmZpZywgJHNlbGVjdG9yOiAnLm1hdC10eXBvZ3JhcGh5Jykge1xuICAubWF0LWgxLCAubWF0LWhlYWRsaW5lLCAjeyRzZWxlY3Rvcn0gaDEge1xuICAgIEBpbmNsdWRlIG1hdC10eXBvZ3JhcGh5LWxldmVsLXRvLXN0eWxlcygkY29uZmlnLCBoZWFkbGluZSk7XG4gICAgbWFyZ2luOiAwIDAgMTZweDtcbiAgfVxuXG4gIC5tYXQtaDIsIC5tYXQtdGl0bGUsICN7JHNlbGVjdG9yfSBoMiB7XG4gICAgQGluY2x1ZGUgbWF0LXR5cG9ncmFwaHktbGV2ZWwtdG8tc3R5bGVzKCRjb25maWcsIHRpdGxlKTtcbiAgICBtYXJnaW46IDAgMCAxNnB4O1xuICB9XG5cbiAgLm1hdC1oMywgLm1hdC1zdWJoZWFkaW5nLTIsICN7JHNlbGVjdG9yfSBoMyB7XG4gICAgQGluY2x1ZGUgbWF0LXR5cG9ncmFwaHktbGV2ZWwtdG8tc3R5bGVzKCRjb25maWcsIHN1YmhlYWRpbmctMik7XG4gICAgbWFyZ2luOiAwIDAgMTZweDtcbiAgfVxuXG4gIC5tYXQtaDQsIC5tYXQtc3ViaGVhZGluZy0xLCAjeyRzZWxlY3Rvcn0gaDQge1xuICAgIEBpbmNsdWRlIG1hdC10eXBvZ3JhcGh5LWxldmVsLXRvLXN0eWxlcygkY29uZmlnLCBzdWJoZWFkaW5nLTEpO1xuICAgIG1hcmdpbjogMCAwIDE2cHg7XG4gIH1cblxuICAvLyBOb3RlOiB0aGUgc3BlYyBkb2Vzbid0IGhhdmUgYW55dGhpbmcgdGhhdCB3b3VsZCBjb3JyZXNwb25kIHRvIGg1IGFuZCBoNiwgYnV0IHdlIGFkZCB0aGVzZSBmb3JcbiAgLy8gY29uc2lzdGVuY3kuIFRoZSBmb250IHNpemVzIGNvbWUgZnJvbSB0aGUgQ2hyb21lIHVzZXIgYWdlbnQgc3R5bGVzIHdoaWNoIGhhdmUgaDUgYXQgMC44M2VtXG4gIC8vIGFuZCBoNiBhdCAwLjY3ZW0uXG4gIC5tYXQtaDUsICN7JHNlbGVjdG9yfSBoNSB7XG4gICAgQGluY2x1ZGUgbWF0LXR5cG9ncmFwaHktZm9udC1zaG9ydGhhbmQoXG4gICAgICBtYXQtZm9udC1zaXplKCRjb25maWcsIGJvZHktMSkgKiAwLjgzLFxuICAgICAgbWF0LWZvbnQtd2VpZ2h0KCRjb25maWcsIGJvZHktMSksXG4gICAgICBtYXQtbGluZS1oZWlnaHQoJGNvbmZpZywgYm9keS0xKSxcbiAgICAgIG1hdC1mb250LWZhbWlseSgkY29uZmlnLCBib2R5LTEpXG4gICAgKTtcblxuICAgIG1hcmdpbjogMCAwIDEycHg7XG4gIH1cblxuICAubWF0LWg2LCAjeyRzZWxlY3Rvcn0gaDYge1xuICAgIEBpbmNsdWRlIG1hdC10eXBvZ3JhcGh5LWZvbnQtc2hvcnRoYW5kKFxuICAgICAgbWF0LWZvbnQtc2l6ZSgkY29uZmlnLCBib2R5LTEpICogMC42NyxcbiAgICAgIG1hdC1mb250LXdlaWdodCgkY29uZmlnLCBib2R5LTEpLFxuICAgICAgbWF0LWxpbmUtaGVpZ2h0KCRjb25maWcsIGJvZHktMSksXG4gICAgICBtYXQtZm9udC1mYW1pbHkoJGNvbmZpZywgYm9keS0xKVxuICAgICk7XG5cbiAgICBtYXJnaW46IDAgMCAxMnB4O1xuICB9XG5cbiAgLm1hdC1ib2R5LXN0cm9uZywgLm1hdC1ib2R5LTIge1xuICAgIEBpbmNsdWRlIG1hdC10eXBvZ3JhcGh5LWxldmVsLXRvLXN0eWxlcygkY29uZmlnLCBib2R5LTIpO1xuICB9XG5cbiAgLm1hdC1ib2R5LCAubWF0LWJvZHktMSwgI3skc2VsZWN0b3J9IHtcbiAgICBAaW5jbHVkZSBtYXQtdHlwb2dyYXBoeS1sZXZlbC10by1zdHlsZXMoJGNvbmZpZywgYm9keS0xKTtcblxuICAgIHAge1xuICAgICAgbWFyZ2luOiAwIDAgMTJweDtcbiAgICB9XG4gIH1cblxuICAubWF0LXNtYWxsLCAubWF0LWNhcHRpb24ge1xuICAgIEBpbmNsdWRlIG1hdC10eXBvZ3JhcGh5LWxldmVsLXRvLXN0eWxlcygkY29uZmlnLCBjYXB0aW9uKTtcbiAgfVxuXG4gIC8vIE5vdGU6IFRoZSBzcGVjIGRvZXNuJ3QgbWVudGlvbiBsZXR0ZXIgc3BhY2luZy4gVGhlIHZhbHVlIGNvbWVzIGZyb21cbiAgLy8gZXllYmFsbGluZyBpdCB1bnRpbCBpdCBsb29rZWQgZXhhY3RseSBsaWtlIHRoZSBzcGVjIGV4YW1wbGVzLlxuICAubWF0LWRpc3BsYXktNCwgI3skc2VsZWN0b3J9IC5tYXQtZGlzcGxheS00IHtcbiAgICBAaW5jbHVkZSBtYXQtdHlwb2dyYXBoeS1sZXZlbC10by1zdHlsZXMoJGNvbmZpZywgZGlzcGxheS00KTtcbiAgICBtYXJnaW46IDAgMCA1NnB4O1xuICAgIGxldHRlci1zcGFjaW5nOiAtMC4wNWVtO1xuICB9XG5cbiAgLm1hdC1kaXNwbGF5LTMsICN7JHNlbGVjdG9yfSAubWF0LWRpc3BsYXktMyB7XG4gICAgQGluY2x1ZGUgbWF0LXR5cG9ncmFwaHktbGV2ZWwtdG8tc3R5bGVzKCRjb25maWcsIGRpc3BsYXktMyk7XG4gICAgbWFyZ2luOiAwIDAgNjRweDtcbiAgICBsZXR0ZXItc3BhY2luZzogLTAuMDJlbTtcbiAgfVxuXG4gIC5tYXQtZGlzcGxheS0yLCAjeyRzZWxlY3Rvcn0gLm1hdC1kaXNwbGF5LTIge1xuICAgIEBpbmNsdWRlIG1hdC10eXBvZ3JhcGh5LWxldmVsLXRvLXN0eWxlcygkY29uZmlnLCBkaXNwbGF5LTIpO1xuICAgIG1hcmdpbjogMCAwIDY0cHg7XG4gICAgbGV0dGVyLXNwYWNpbmc6IC0wLjAwNWVtO1xuICB9XG5cbiAgLm1hdC1kaXNwbGF5LTEsICN7JHNlbGVjdG9yfSAubWF0LWRpc3BsYXktMSB7XG4gICAgQGluY2x1ZGUgbWF0LXR5cG9ncmFwaHktbGV2ZWwtdG8tc3R5bGVzKCRjb25maWcsIGRpc3BsYXktMSk7XG4gICAgbWFyZ2luOiAwIDAgNjRweDtcbiAgfVxufVxuXG5cblxuXG5AbWl4aW4gbWF0LWF1dG9jb21wbGV0ZS10aGVtZSgkdGhlbWUpIHtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcblxuICAubWF0LWF1dG9jb21wbGV0ZS1wYW5lbCB7XG4gICAgQGluY2x1ZGUgX21hdC10aGVtZS1vdmVycmlkYWJsZS1lbGV2YXRpb24oNCwgJHRoZW1lKTtcbiAgICBiYWNrZ3JvdW5kOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGNhcmQpO1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHRleHQpO1xuXG4gICAgLy8gU2VsZWN0ZWQgb3B0aW9ucyBpbiBhdXRvY29tcGxldGVzIHNob3VsZCBub3QgYmUgZ3JheSwgYnV0IHdlXG4gICAgLy8gb25seSB3YW50IHRvIG92ZXJyaWRlIHRoZSBiYWNrZ3JvdW5kIGZvciBzZWxlY3RlZCBvcHRpb25zIGlmXG4gICAgLy8gdGhleSBhcmUgKm5vdCogaW4gaG92ZXIgb3IgZm9jdXMgc3RhdGUuIFRoaXMgY2hhbmdlIGhhcyB0byBiZVxuICAgIC8vIG1hZGUgaGVyZSBiZWNhdXNlIGJhc2Ugb3B0aW9uIHN0eWxlcyBhcmUgc2hhcmVkIGJldHdlZW4gdGhlXG4gICAgLy8gYXV0b2NvbXBsZXRlIGFuZCB0aGUgc2VsZWN0LlxuICAgIC5tYXQtb3B0aW9uLm1hdC1zZWxlY3RlZDpub3QoLm1hdC1hY3RpdmUpOm5vdCg6aG92ZXIpIHtcbiAgICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgY2FyZCk7XG5cbiAgICAgICY6bm90KC5tYXQtb3B0aW9uLWRpc2FibGVkKSB7XG4gICAgICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbkBtaXhpbiBtYXQtYXV0b2NvbXBsZXRlLXR5cG9ncmFwaHkoJGNvbmZpZykgeyB9XG5cbi8vIFRoaXMgY29udGFpbnMgYWxsIG9mIHRoZSBzdHlsZXMgZm9yIHRoZSBiYWRnZVxuLy8gcmF0aGVyIHRoYW4ganVzdCB0aGUgY29sb3IvdGhlbWUgYmVjYXVzZSBvZlxuLy8gbm8gc3R5bGUgc2hlZXQgc3VwcG9ydCBmb3IgZGlyZWN0aXZlcy5cblxuXG5cblxuXG4kbWF0LWJhZGdlLWZvbnQtc2l6ZTogMTJweDtcbiRtYXQtYmFkZ2UtZm9udC13ZWlnaHQ6IDYwMDtcbiRtYXQtYmFkZ2UtZGVmYXVsdC1zaXplOiAyMnB4ICFkZWZhdWx0O1xuJG1hdC1iYWRnZS1zbWFsbC1zaXplOiAkbWF0LWJhZGdlLWRlZmF1bHQtc2l6ZSAtIDY7XG4kbWF0LWJhZGdlLWxhcmdlLXNpemU6ICRtYXQtYmFkZ2UtZGVmYXVsdC1zaXplICsgNjtcblxuLy8gTWl4aW4gZm9yIGJ1aWxkaW5nIG9mZnNldCBnaXZlbiBkaWZmZXJlbnQgc2l6ZXNcbkBtaXhpbiBfbWF0LWJhZGdlLXNpemUoJHNpemUpIHtcbiAgLm1hdC1iYWRnZS1jb250ZW50IHtcbiAgICB3aWR0aDogJHNpemU7XG4gICAgaGVpZ2h0OiAkc2l6ZTtcbiAgICBsaW5lLWhlaWdodDogJHNpemU7XG4gIH1cblxuICAmLm1hdC1iYWRnZS1hYm92ZSB7XG4gICAgLm1hdC1iYWRnZS1jb250ZW50IHtcbiAgICAgIHRvcDogLSRzaXplIC8gMjtcbiAgICB9XG4gIH1cblxuICAmLm1hdC1iYWRnZS1iZWxvdyB7XG4gICAgLm1hdC1iYWRnZS1jb250ZW50IHtcbiAgICAgIGJvdHRvbTogLSRzaXplIC8gMjtcbiAgICB9XG4gIH1cblxuICAmLm1hdC1iYWRnZS1iZWZvcmUge1xuICAgIC5tYXQtYmFkZ2UtY29udGVudCB7XG4gICAgICBsZWZ0OiAtJHNpemU7XG4gICAgfVxuICB9XG5cbiAgW2Rpcj0ncnRsJ10gJi5tYXQtYmFkZ2UtYmVmb3JlIHtcbiAgICAubWF0LWJhZGdlLWNvbnRlbnQge1xuICAgICAgbGVmdDogYXV0bztcbiAgICAgIHJpZ2h0OiAtJHNpemU7XG4gICAgfVxuICB9XG5cbiAgJi5tYXQtYmFkZ2UtYWZ0ZXIge1xuICAgIC5tYXQtYmFkZ2UtY29udGVudCB7XG4gICAgICByaWdodDogLSRzaXplO1xuICAgIH1cbiAgfVxuXG4gIFtkaXI9J3J0bCddICYubWF0LWJhZGdlLWFmdGVyIHtcbiAgICAubWF0LWJhZGdlLWNvbnRlbnQge1xuICAgICAgcmlnaHQ6IGF1dG87XG4gICAgICBsZWZ0OiAtJHNpemU7XG4gICAgfVxuICB9XG5cbiAgJi5tYXQtYmFkZ2Utb3ZlcmxhcCB7XG4gICAgJi5tYXQtYmFkZ2UtYmVmb3JlIHtcbiAgICAgIC5tYXQtYmFkZ2UtY29udGVudCB7XG4gICAgICAgIGxlZnQ6IC0kc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgW2Rpcj0ncnRsJ10gJi5tYXQtYmFkZ2UtYmVmb3JlIHtcbiAgICAgIC5tYXQtYmFkZ2UtY29udGVudCB7XG4gICAgICAgIGxlZnQ6IGF1dG87XG4gICAgICAgIHJpZ2h0OiAtJHNpemUgLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgICYubWF0LWJhZGdlLWFmdGVyIHtcbiAgICAgIC5tYXQtYmFkZ2UtY29udGVudCB7XG4gICAgICAgIHJpZ2h0OiAtJHNpemUgLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIFtkaXI9J3J0bCddICYubWF0LWJhZGdlLWFmdGVyIHtcbiAgICAgIC5tYXQtYmFkZ2UtY29udGVudCB7XG4gICAgICAgIHJpZ2h0OiBhdXRvO1xuICAgICAgICBsZWZ0OiAtJHNpemUgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5AbWl4aW4gbWF0LWJhZGdlLXRoZW1lKCR0aGVtZSkge1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJHByaW1hcnk6IG1hcC1nZXQoJHRoZW1lLCBwcmltYXJ5KTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAubWF0LWJhZGdlLWNvbnRlbnQge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJHByaW1hcnksIGRlZmF1bHQtY29udHJhc3QpO1xuICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkcHJpbWFyeSk7XG5cbiAgICBAaW5jbHVkZSBjZGstaGlnaC1jb250cmFzdCB7XG4gICAgICBvdXRsaW5lOiBzb2xpZCAxcHg7XG4gICAgICBib3JkZXItcmFkaXVzOiAwO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtYmFkZ2UtYWNjZW50IHtcbiAgICAubWF0LWJhZGdlLWNvbnRlbnQge1xuICAgICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKCRhY2NlbnQpO1xuICAgICAgY29sb3I6IG1hdC1jb2xvcigkYWNjZW50LCBkZWZhdWx0LWNvbnRyYXN0KTtcbiAgICB9XG4gIH1cblxuICAubWF0LWJhZGdlLXdhcm4ge1xuICAgIC5tYXQtYmFkZ2UtY29udGVudCB7XG4gICAgICBjb2xvcjogbWF0LWNvbG9yKCR3YXJuLCBkZWZhdWx0LWNvbnRyYXN0KTtcbiAgICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkd2Fybik7XG4gICAgfVxuICB9XG5cbiAgLm1hdC1iYWRnZSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG5cbiAgLm1hdC1iYWRnZS1oaWRkZW4ge1xuICAgIC5tYXQtYmFkZ2UtY29udGVudCB7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtYmFkZ2UtZGlzYWJsZWQge1xuICAgIC5tYXQtYmFkZ2UtY29udGVudCB7XG4gICAgICAkYXBwLWJhY2tncm91bmQ6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgJ2JhY2tncm91bmQnKTtcbiAgICAgICRiYWRnZS1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBkaXNhYmxlZC1idXR0b24pO1xuXG4gICAgICAvLyBUaGUgZGlzYWJsZWQgY29sb3IgdXN1YWxseSBoYXMgc29tZSBraW5kIG9mIG9wYWNpdHksIGJ1dCBiZWNhdXNlIHRoZSBiYWRnZSBpcyBvdmVybGF5ZWRcbiAgICAgIC8vIG9uIHRvcCBvZiBzb21ldGhpbmcgZWxzZSwgaXQgd29uJ3QgbG9vayBnb29kIGlmIGl0J3Mgb3BhcXVlLiBJZiBpdCBpcyBhIGNvbG9yICp0eXBlKixcbiAgICAgIC8vIHdlIGNvbnZlcnQgaXQgaW50byBhIHNvbGlkIGNvbG9yIGJ5IHRha2luZyB0aGUgb3BhY2l0eSBmcm9tIHRoZSByZ2JhIHZhbHVlIGFuZCB1c2luZ1xuICAgICAgLy8gdGhlIHZhbHVlIHRvIGRldGVybWluZSB0aGUgcGVyY2VudGFnZSBvZiB0aGUgYmFja2dyb3VuZCB0byBwdXQgaW50byBmb3JlZ3JvdW5kIHdoZW5cbiAgICAgIC8vIG1peGluZyB0aGUgY29sb3JzIHRvZ2V0aGVyLlxuICAgICAgQGlmICh0eXBlLW9mKCRiYWRnZS1jb2xvcikgPT0gY29sb3IgYW5kIHR5cGUtb2YoJGFwcC1iYWNrZ3JvdW5kKSA9PSBjb2xvcikge1xuICAgICAgICAkYmFkZ2Utb3BhY2l0eTogb3BhY2l0eSgkYmFkZ2UtY29sb3IpO1xuICAgICAgICBiYWNrZ3JvdW5kOiBtaXgoJGFwcC1iYWNrZ3JvdW5kLCByZ2JhKCRiYWRnZS1jb2xvciwgMSksICgxIC0gJGJhZGdlLW9wYWNpdHkpICogMTAwJSk7XG4gICAgICB9XG4gICAgICBAZWxzZSB7XG4gICAgICAgIGJhY2tncm91bmQ6ICRiYWRnZS1jb2xvcjtcbiAgICAgIH1cblxuICAgICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGlzYWJsZWQtdGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLm1hdC1iYWRnZS1jb250ZW50IHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDIwMG1zIGVhc2UtaW4tb3V0O1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC42KTtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cblxuICAvLyBUaGUgYWN0aXZlIGNsYXNzIGlzIGFkZGVkIGFmdGVyIHRoZSBlbGVtZW50IGlzIGFkZGVkXG4gIC8vIHNvIGl0IGNhbiBhbmltYXRlIHNjYWxlIHRvIGRlZmF1bHRcbiAgLm1hdC1iYWRnZS1jb250ZW50Lm1hdC1iYWRnZS1hY3RpdmUge1xuICAgIC8vIFNjYWxlIHRvIGBub25lYCBpbnN0ZWFkIG9mIGAxYCB0byBhdm9pZCBibHVycnkgdGV4dCBpbiBzb21lIGJyb3dzZXJzLlxuICAgIHRyYW5zZm9ybTogbm9uZTtcbiAgfVxuXG4gIC5tYXQtYmFkZ2Utc21hbGwge1xuICAgIEBpbmNsdWRlIF9tYXQtYmFkZ2Utc2l6ZSgkbWF0LWJhZGdlLXNtYWxsLXNpemUpO1xuICB9XG4gIC5tYXQtYmFkZ2UtbWVkaXVtIHtcbiAgICBAaW5jbHVkZSBfbWF0LWJhZGdlLXNpemUoJG1hdC1iYWRnZS1kZWZhdWx0LXNpemUpO1xuICB9XG4gIC5tYXQtYmFkZ2UtbGFyZ2Uge1xuICAgIEBpbmNsdWRlIF9tYXQtYmFkZ2Utc2l6ZSgkbWF0LWJhZGdlLWxhcmdlLXNpemUpO1xuICB9XG59XG5cbkBtaXhpbiBtYXQtYmFkZ2UtdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC5tYXQtYmFkZ2UtY29udGVudCB7XG4gICAgZm9udC13ZWlnaHQ6ICRtYXQtYmFkZ2UtZm9udC13ZWlnaHQ7XG4gICAgZm9udC1zaXplOiAkbWF0LWJhZGdlLWZvbnQtc2l6ZTtcbiAgICBmb250LWZhbWlseTogbWF0LWZvbnQtZmFtaWx5KCRjb25maWcpO1xuICB9XG5cbiAgLm1hdC1iYWRnZS1zbWFsbCAubWF0LWJhZGdlLWNvbnRlbnQge1xuICAgIGZvbnQtc2l6ZTogJG1hdC1iYWRnZS1mb250LXNpemUgLyAyO1xuICB9XG5cbiAgLm1hdC1iYWRnZS1sYXJnZSAubWF0LWJhZGdlLWNvbnRlbnQge1xuICAgIGZvbnQtc2l6ZTogJG1hdC1iYWRnZS1mb250LXNpemUgKiAyO1xuICB9XG59XG5cblxuXG5cblxuQG1peGluIG1hdC1ib3R0b20tc2hlZXQtdGhlbWUoJHRoZW1lKSB7XG4gICRiYWNrZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgYmFja2dyb3VuZCk7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG5cbiAgLm1hdC1ib3R0b20tc2hlZXQtY29udGFpbmVyIHtcbiAgICBAaW5jbHVkZSBfbWF0LXRoZW1lLWVsZXZhdGlvbigxNiwgJHRoZW1lKTtcbiAgICBiYWNrZ3JvdW5kOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGRpYWxvZyk7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG4gIH1cbn1cblxuQG1peGluIG1hdC1ib3R0b20tc2hlZXQtdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC5tYXQtYm90dG9tLXNoZWV0LWNvbnRhaW5lciB7XG4gICAgQGluY2x1ZGUgbWF0LXR5cG9ncmFwaHktbGV2ZWwtdG8tc3R5bGVzKCRjb25maWcsIGJvZHktMSk7XG4gIH1cbn1cblxuXG5cblxuXG4kX21hdC1idXR0b24tcmlwcGxlLW9wYWNpdHk6IDAuMTtcblxuLy8gQXBwbGllcyBhIGZvY3VzIHN0eWxlIHRvIGFuIG1hdC1idXR0b24gZWxlbWVudCBmb3IgZWFjaCBvZiB0aGUgc3VwcG9ydGVkIHBhbGV0dGVzLlxuQG1peGluIF9tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXktY29sb3IoJHRoZW1lKSB7XG4gICRwcmltYXJ5OiBtYXAtZ2V0KCR0aGVtZSwgcHJpbWFyeSk7XG4gICRhY2NlbnQ6IG1hcC1nZXQoJHRoZW1lLCBhY2NlbnQpO1xuICAkd2FybjogbWFwLWdldCgkdGhlbWUsIHdhcm4pO1xuXG4gICYubWF0LXByaW1hcnkgLm1hdC1idXR0b24tZm9jdXMtb3ZlcmxheSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRwcmltYXJ5KTtcbiAgfVxuXG4gICYubWF0LWFjY2VudCAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBtYXQtY29sb3IoJGFjY2VudCk7XG4gIH1cblxuICAmLm1hdC13YXJuIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXkge1xuICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkd2Fybik7XG4gIH1cblxuICAmW2Rpc2FibGVkXSAubWF0LWJ1dHRvbi1mb2N1cy1vdmVybGF5IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgfVxufVxuXG5AbWl4aW4gX21hdC1idXR0b24tcmlwcGxlLWNvbG9yKCR0aGVtZSwgJGh1ZSwgJG9wYWNpdHk6ICRfbWF0LWJ1dHRvbi1yaXBwbGUtb3BhY2l0eSkge1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcblxuICAmLm1hdC1wcmltYXJ5IC5tYXQtcmlwcGxlLWVsZW1lbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkcHJpbWFyeSwgJGh1ZSwgJG9wYWNpdHkpO1xuICB9XG5cbiAgJi5tYXQtYWNjZW50IC5tYXQtcmlwcGxlLWVsZW1lbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkYWNjZW50LCAkaHVlLCAkb3BhY2l0eSk7XG4gIH1cblxuICAmLm1hdC13YXJuIC5tYXQtcmlwcGxlLWVsZW1lbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkd2FybiwgJGh1ZSwgJG9wYWNpdHkpO1xuICB9XG59XG5cbi8vIEFwcGxpZXMgYSBwcm9wZXJ0eSB0byBhbiBtYXQtYnV0dG9uIGVsZW1lbnQgZm9yIGVhY2ggb2YgdGhlIHN1cHBvcnRlZCBwYWxldHRlcy5cbkBtaXhpbiBfbWF0LWJ1dHRvbi10aGVtZS1wcm9wZXJ0eSgkdGhlbWUsICRwcm9wZXJ0eSwgJGh1ZSkge1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAmLm1hdC1wcmltYXJ5IHtcbiAgICAjeyRwcm9wZXJ0eX06IG1hdC1jb2xvcigkcHJpbWFyeSwgJGh1ZSk7XG4gIH1cbiAgJi5tYXQtYWNjZW50IHtcbiAgICAjeyRwcm9wZXJ0eX06IG1hdC1jb2xvcigkYWNjZW50LCAkaHVlKTtcbiAgfVxuICAmLm1hdC13YXJuIHtcbiAgICAjeyRwcm9wZXJ0eX06IG1hdC1jb2xvcigkd2FybiwgJGh1ZSk7XG4gIH1cblxuICAmLm1hdC1wcmltYXJ5LCAmLm1hdC1hY2NlbnQsICYubWF0LXdhcm4sICZbZGlzYWJsZWRdIHtcbiAgICAmW2Rpc2FibGVkXSB7XG4gICAgICAkcGFsZXR0ZTogaWYoJHByb3BlcnR5ID09ICdjb2xvcicsICRmb3JlZ3JvdW5kLCAkYmFja2dyb3VuZCk7XG4gICAgICAjeyRwcm9wZXJ0eX06IG1hdC1jb2xvcigkcGFsZXR0ZSwgZGlzYWJsZWQtYnV0dG9uKTtcbiAgICB9XG4gIH1cbn1cblxuQG1peGluIG1hdC1idXR0b24tdGhlbWUoJHRoZW1lKSB7XG4gICRwcmltYXJ5OiBtYXAtZ2V0KCR0aGVtZSwgcHJpbWFyeSk7XG4gICRhY2NlbnQ6IG1hcC1nZXQoJHRoZW1lLCBhY2NlbnQpO1xuICAkd2FybjogbWFwLWdldCgkdGhlbWUsIHdhcm4pO1xuICAkYmFja2dyb3VuZDogbWFwLWdldCgkdGhlbWUsIGJhY2tncm91bmQpO1xuICAkZm9yZWdyb3VuZDogbWFwLWdldCgkdGhlbWUsIGZvcmVncm91bmQpO1xuXG4gIC5tYXQtYnV0dG9uLCAubWF0LWljb24tYnV0dG9uLCAubWF0LXN0cm9rZWQtYnV0dG9uIHtcbiAgICAvLyBCdXR0b25zIHdpdGhvdXQgYSBiYWNrZ3JvdW5kIGNvbG9yIHNob3VsZCBpbmhlcml0IHRoZSBmb250IGNvbG9yLiBUaGlzIGlzIG5lY2Vzc2FyeSB0b1xuICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBidXR0b24gaXMgcmVhZGFibGUgb24gY3VzdG9tIGJhY2tncm91bmQgY29sb3JzLiBJdCdzIHdyb25nIHRvIGFsd2F5cyBhc3N1bWVcbiAgICAvLyB0aGF0IHRob3NlIGJ1dHRvbnMgYXJlIGFsd2F5cyBwbGFjZWQgaW5zaWRlIG9mIGNvbnRhaW5lcnMgd2l0aCB0aGUgZGVmYXVsdCBiYWNrZ3JvdW5kXG4gICAgLy8gY29sb3Igb2YgdGhlIHRoZW1lIChlLmcuIHRoZW1lZCB0b29sYmFycykuXG4gICAgY29sb3I6IGluaGVyaXQ7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG5cbiAgICBAaW5jbHVkZSBfbWF0LWJ1dHRvbi10aGVtZS1wcm9wZXJ0eSgkdGhlbWUsICdjb2xvcicsIGRlZmF1bHQpO1xuICAgIEBpbmNsdWRlIF9tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXktY29sb3IoJHRoZW1lKTtcblxuICAgIC8vIFNldHVwIHRoZSByaXBwbGUgY29sb3IgdG8gYmUgYmFzZWQgb24gdGhlIHRleHQgY29sb3IuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSByaXBwbGVzXG4gICAgLy8gYXJlIG1hdGNoaW5nIHdpdGggdGhlIGN1cnJlbnQgdGhlbWUgcGFsZXR0ZSBhbmQgYXJlIGluIGNvbnRyYXN0IHRvIHRoZSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgLy8gKGUuZyBpbiB0aGVtZWQgdG9vbGJhcnMpLlxuICAgIC5tYXQtcmlwcGxlLWVsZW1lbnQge1xuICAgICAgb3BhY2l0eTogJF9tYXQtYnV0dG9uLXJpcHBsZS1vcGFjaXR5O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogY3VycmVudENvbG9yO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtYnV0dG9uLWZvY3VzLW92ZXJsYXkge1xuICAgIGJhY2tncm91bmQ6IG1hcF9nZXQoJGZvcmVncm91bmQsIGJhc2UpO1xuICB9XG5cbiAgLy8gTm90ZTogdGhpcyBuZWVkcyBhIGJpdCBleHRyYSBzcGVjaWZpY2l0eSwgYmVjYXVzZSB3ZSdyZSBub3QgZ3VhcmFudGVlZCB0aGUgaW5jbHVzaW9uXG4gIC8vIG9yZGVyIG9mIHRoZSB0aGVtZSBzdHlsZXMgYW5kIHRoZSBidXR0b24gcmVzZXQgbWF5IGVuZCB1cCByZXNldHRpbmcgdGhpcyBhcyB3ZWxsLlxuICAubWF0LXN0cm9rZWQtYnV0dG9uOm5vdChbZGlzYWJsZWRdKSB7XG4gICAgYm9yZGVyLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpdmlkZXIpO1xuICB9XG5cbiAgLm1hdC1mbGF0LWJ1dHRvbiwgLm1hdC1yYWlzZWQtYnV0dG9uLCAubWF0LWZhYiwgLm1hdC1taW5pLWZhYiB7XG4gICAgLy8gRGVmYXVsdCBmb250IGFuZCBiYWNrZ3JvdW5kIGNvbG9yIHdoZW4gbm90IHVzaW5nIGFueSBjb2xvciBwYWxldHRlLlxuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHRleHQpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgcmFpc2VkLWJ1dHRvbik7XG5cbiAgICBAaW5jbHVkZSBfbWF0LWJ1dHRvbi10aGVtZS1wcm9wZXJ0eSgkdGhlbWUsICdjb2xvcicsIGRlZmF1bHQtY29udHJhc3QpO1xuICAgIEBpbmNsdWRlIF9tYXQtYnV0dG9uLXRoZW1lLXByb3BlcnR5KCR0aGVtZSwgJ2JhY2tncm91bmQtY29sb3InLCBkZWZhdWx0KTtcbiAgICBAaW5jbHVkZSBfbWF0LWJ1dHRvbi1yaXBwbGUtY29sb3IoJHRoZW1lLCBkZWZhdWx0LWNvbnRyYXN0KTtcbiAgfVxuXG4gIC5tYXQtc3Ryb2tlZC1idXR0b24sIC5tYXQtZmxhdC1idXR0b24ge1xuICAgIEBpbmNsdWRlIF9tYXQtdGhlbWUtb3ZlcnJpZGFibGUtZWxldmF0aW9uKDAsICR0aGVtZSk7XG4gIH1cblxuICAubWF0LXJhaXNlZC1idXR0b24ge1xuICAgIEBpbmNsdWRlIF9tYXQtdGhlbWUtb3ZlcnJpZGFibGUtZWxldmF0aW9uKDIsICR0aGVtZSk7XG5cbiAgICAmOm5vdChbZGlzYWJsZWRdKTphY3RpdmUge1xuICAgICAgQGluY2x1ZGUgX21hdC10aGVtZS1vdmVycmlkYWJsZS1lbGV2YXRpb24oOCwgJHRoZW1lKTtcbiAgICB9XG5cbiAgICAmW2Rpc2FibGVkXSB7XG4gICAgICBAaW5jbHVkZSBfbWF0LXRoZW1lLW92ZXJyaWRhYmxlLWVsZXZhdGlvbigwLCAkdGhlbWUpO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtZmFiLCAubWF0LW1pbmktZmFiIHtcbiAgICBAaW5jbHVkZSBfbWF0LXRoZW1lLW92ZXJyaWRhYmxlLWVsZXZhdGlvbig2LCAkdGhlbWUpO1xuXG4gICAgJjpub3QoW2Rpc2FibGVkXSk6YWN0aXZlIHtcbiAgICAgIEBpbmNsdWRlIF9tYXQtdGhlbWUtb3ZlcnJpZGFibGUtZWxldmF0aW9uKDEyLCAkdGhlbWUpO1xuICAgIH1cblxuICAgICZbZGlzYWJsZWRdIHtcbiAgICAgIEBpbmNsdWRlIF9tYXQtdGhlbWUtb3ZlcnJpZGFibGUtZWxldmF0aW9uKDAsICR0aGVtZSk7XG4gICAgfVxuICB9XG59XG5cbkBtaXhpbiBtYXQtYnV0dG9uLXR5cG9ncmFwaHkoJGNvbmZpZykge1xuICAubWF0LWJ1dHRvbiwgLm1hdC1yYWlzZWQtYnV0dG9uLCAubWF0LWljb24tYnV0dG9uLCAubWF0LXN0cm9rZWQtYnV0dG9uLFxuICAubWF0LWZsYXQtYnV0dG9uLCAubWF0LWZhYiwgLm1hdC1taW5pLWZhYiB7XG4gICAgZm9udDoge1xuICAgICAgZmFtaWx5OiBtYXQtZm9udC1mYW1pbHkoJGNvbmZpZywgYnV0dG9uKTtcbiAgICAgIHNpemU6IG1hdC1mb250LXNpemUoJGNvbmZpZywgYnV0dG9uKTtcbiAgICAgIHdlaWdodDogbWF0LWZvbnQtd2VpZ2h0KCRjb25maWcsIGJ1dHRvbik7XG4gICAgfVxuICB9XG59XG5cblxuXG5cblxuXG5AbWl4aW4gbWF0LWJ1dHRvbi10b2dnbGUtdGhlbWUoJHRoZW1lKSB7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG4gICRiYWNrZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgYmFja2dyb3VuZCk7XG4gICRkaXZpZGVyLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpdmlkZXIpO1xuXG4gIC5tYXQtYnV0dG9uLXRvZ2dsZS1zdGFuZGFsb25lLFxuICAubWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXAge1xuICAgIEBpbmNsdWRlIF9tYXQtdGhlbWUtZWxldmF0aW9uKDIsICR0aGVtZSk7XG4gIH1cblxuICAubWF0LWJ1dHRvbi10b2dnbGUtc3RhbmRhbG9uZS5tYXQtYnV0dG9uLXRvZ2dsZS1hcHBlYXJhbmNlLXN0YW5kYXJkLFxuICAubWF0LWJ1dHRvbi10b2dnbGUtZ3JvdXAtYXBwZWFyYW5jZS1zdGFuZGFyZCB7XG4gICAgYm94LXNoYWRvdzogbm9uZTtcbiAgfVxuXG4gIC5tYXQtYnV0dG9uLXRvZ2dsZSB7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgaGludC10ZXh0KTtcblxuICAgIC5tYXQtYnV0dG9uLXRvZ2dsZS1mb2N1cy1vdmVybGF5IHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgZm9jdXNlZC1idXR0b24pO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtYnV0dG9uLXRvZ2dsZS1hcHBlYXJhbmNlLXN0YW5kYXJkIHtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCB0ZXh0KTtcbiAgICBiYWNrZ3JvdW5kOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGNhcmQpO1xuXG4gICAgLm1hdC1idXR0b24tdG9nZ2xlLWZvY3VzLW92ZXJsYXkge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCBmb2N1c2VkLWJ1dHRvbiwgMSk7XG4gICAgfVxuICB9XG5cbiAgLm1hdC1idXR0b24tdG9nZ2xlLWdyb3VwLWFwcGVhcmFuY2Utc3RhbmRhcmQgLm1hdC1idXR0b24tdG9nZ2xlICsgLm1hdC1idXR0b24tdG9nZ2xlIHtcbiAgICBib3JkZXItbGVmdDogc29saWQgMXB4ICRkaXZpZGVyLWNvbG9yO1xuICB9XG5cbiAgW2Rpcj0ncnRsJ10gLm1hdC1idXR0b24tdG9nZ2xlLWdyb3VwLWFwcGVhcmFuY2Utc3RhbmRhcmQgLm1hdC1idXR0b24tdG9nZ2xlICsgLm1hdC1idXR0b24tdG9nZ2xlIHtcbiAgICBib3JkZXItbGVmdDogbm9uZTtcbiAgICBib3JkZXItcmlnaHQ6IHNvbGlkIDFweCAkZGl2aWRlci1jb2xvcjtcbiAgfVxuXG4gIC5tYXQtYnV0dG9uLXRvZ2dsZS1ncm91cC1hcHBlYXJhbmNlLXN0YW5kYXJkLm1hdC1idXR0b24tdG9nZ2xlLXZlcnRpY2FsIHtcbiAgICAubWF0LWJ1dHRvbi10b2dnbGUgKyAubWF0LWJ1dHRvbi10b2dnbGUge1xuICAgICAgYm9yZGVyLWxlZnQ6IG5vbmU7XG4gICAgICBib3JkZXItcmlnaHQ6IG5vbmU7XG4gICAgICBib3JkZXItdG9wOiBzb2xpZCAxcHggJGRpdmlkZXItY29sb3I7XG4gICAgfVxuICB9XG5cbiAgLm1hdC1idXR0b24tdG9nZ2xlLWNoZWNrZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgc2VsZWN0ZWQtYnV0dG9uKTtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBzZWNvbmRhcnktdGV4dCk7XG5cbiAgICAmLm1hdC1idXR0b24tdG9nZ2xlLWFwcGVhcmFuY2Utc3RhbmRhcmQge1xuICAgICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLm1hdC1idXR0b24tdG9nZ2xlLWRpc2FibGVkIHtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBkaXNhYmxlZC1idXR0b24pO1xuICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgZGlzYWJsZWQtYnV0dG9uLXRvZ2dsZSk7XG5cbiAgICAmLm1hdC1idXR0b24tdG9nZ2xlLWFwcGVhcmFuY2Utc3RhbmRhcmQge1xuICAgICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCBjYXJkKTtcbiAgICB9XG5cbiAgICAmLm1hdC1idXR0b24tdG9nZ2xlLWNoZWNrZWQge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCBzZWxlY3RlZC1kaXNhYmxlZC1idXR0b24pO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtYnV0dG9uLXRvZ2dsZS1zdGFuZGFsb25lLm1hdC1idXR0b24tdG9nZ2xlLWFwcGVhcmFuY2Utc3RhbmRhcmQsXG4gIC5tYXQtYnV0dG9uLXRvZ2dsZS1ncm91cC1hcHBlYXJhbmNlLXN0YW5kYXJkIHtcbiAgICBib3JkZXI6IHNvbGlkIDFweCAkZGl2aWRlci1jb2xvcjtcbiAgfVxufVxuXG5AbWl4aW4gbWF0LWJ1dHRvbi10b2dnbGUtdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC5tYXQtYnV0dG9uLXRvZ2dsZSB7XG4gICAgZm9udC1mYW1pbHk6IG1hdC1mb250LWZhbWlseSgkY29uZmlnKTtcbiAgfVxufVxuXG5cblxuXG5cblxuXG5AbWl4aW4gbWF0LWNhcmQtdGhlbWUoJHRoZW1lKSB7XG4gICRiYWNrZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgYmFja2dyb3VuZCk7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG5cbiAgLm1hdC1jYXJkIHtcbiAgICBAaW5jbHVkZSBfbWF0LXRoZW1lLW92ZXJyaWRhYmxlLWVsZXZhdGlvbigxLCAkdGhlbWUpO1xuICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgY2FyZCk7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG5cbiAgICAvLyBOZWVkcyBleHRyYSBzcGVjaWZpY2l0eSB0byBiZSBhYmxlIHRvIG92ZXJyaWRlIHRoZSBlbGV2YXRpb24gc2VsZWN0b3JzLlxuICAgICYubWF0LWNhcmQtZmxhdCB7XG4gICAgICBAaW5jbHVkZSBfbWF0LXRoZW1lLW92ZXJyaWRhYmxlLWVsZXZhdGlvbigwLCAkdGhlbWUpO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtY2FyZC1zdWJ0aXRsZSB7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgc2Vjb25kYXJ5LXRleHQpO1xuICB9XG59XG5cbkBtaXhpbiBtYXQtY2FyZC10eXBvZ3JhcGh5KCRjb25maWcpIHtcbiAgLm1hdC1jYXJkIHtcbiAgICBmb250LWZhbWlseTogbWF0LWZvbnQtZmFtaWx5KCRjb25maWcpO1xuICB9XG5cbiAgLm1hdC1jYXJkLXRpdGxlIHtcbiAgICBmb250OiB7XG4gICAgICBzaXplOiBtYXQtZm9udC1zaXplKCRjb25maWcsIGhlYWRsaW5lKTtcbiAgICAgIHdlaWdodDogbWF0LWZvbnQtd2VpZ2h0KCRjb25maWcsIHRpdGxlKTtcbiAgICB9XG4gIH1cblxuICAubWF0LWNhcmQtaGVhZGVyIC5tYXQtY2FyZC10aXRsZSB7XG4gICAgZm9udC1zaXplOiBtYXQtZm9udC1zaXplKCRjb25maWcsIHRpdGxlKTtcbiAgfVxuXG4gIC5tYXQtY2FyZC1zdWJ0aXRsZSxcbiAgLm1hdC1jYXJkLWNvbnRlbnQge1xuICAgIGZvbnQtc2l6ZTogbWF0LWZvbnQtc2l6ZSgkY29uZmlnLCBib2R5LTEpO1xuICB9XG59XG5cblxuXG5cblxuXG5AbWl4aW4gbWF0LWNoZWNrYm94LXRoZW1lKCR0aGVtZSkge1xuICAkaXMtZGFyay10aGVtZTogbWFwLWdldCgkdGhlbWUsIGlzLWRhcmspO1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuXG4gIC8vIFRoZSBjb2xvciBvZiB0aGUgY2hlY2tib3gncyBjaGVja21hcmsgLyBtaXhlZG1hcmsuXG4gICRjaGVja2JveC1tYXJrLWNvbG9yOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGJhY2tncm91bmQpO1xuXG4gIC8vIE5PVEUodHJhdmlza2F1Zm1hbik6IFdoaWxlIHRoZSBzcGVjIGNhbGxzIGZvciB0cmFuc2x1Y2VudCBibGFja3Mvd2hpdGVzIGZvciBkaXNhYmxlZCBjb2xvcnMsXG4gIC8vIHRoaXMgZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggZWxlbWVudHMgbGF5ZXJlZCBvbiB0b3Agb2Ygb25lIGFub3RoZXIuIFRvIGdldCBhcm91bmQgdGhpcyB3ZVxuICAvLyBibGVuZCB0aGUgY29sb3JzIHRvZ2V0aGVyIGJhc2VkIG9uIHRoZSBiYXNlIGNvbG9yIGFuZCB0aGUgdGhlbWUgYmFja2dyb3VuZC5cbiAgJHdoaXRlLTMwcGN0LW9wYWNpdHktb24tZGFyazogIzY4Njg2ODtcbiAgJGJsYWNrLTI2cGN0LW9wYWNpdHktb24tbGlnaHQ6ICNiMGIwYjA7XG4gICRkaXNhYmxlZC1jb2xvcjogaWYoJGlzLWRhcmstdGhlbWUsICR3aGl0ZS0zMHBjdC1vcGFjaXR5LW9uLWRhcmssICRibGFjay0yNnBjdC1vcGFjaXR5LW9uLWxpZ2h0KTtcblxuICAubWF0LWNoZWNrYm94LWZyYW1lIHtcbiAgICBib3JkZXItY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgc2Vjb25kYXJ5LXRleHQpO1xuICB9XG5cbiAgLm1hdC1jaGVja2JveC1jaGVja21hcmsge1xuICAgIGZpbGw6ICRjaGVja2JveC1tYXJrLWNvbG9yO1xuICB9XG5cbiAgLm1hdC1jaGVja2JveC1jaGVja21hcmstcGF0aCB7XG4gICAgLy8gIWltcG9ydGFudCBpcyBuZWVkZWQgaGVyZSBiZWNhdXNlIGEgc3Ryb2tlIG11c3QgYmUgc2V0IGFzIGFuXG4gICAgLy8gYXR0cmlidXRlIG9uIHRoZSBTVkcgaW4gb3JkZXIgZm9yIGxpbmUgYW5pbWF0aW9uIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgc3Ryb2tlOiAkY2hlY2tib3gtbWFyay1jb2xvciAhaW1wb3J0YW50O1xuXG4gICAgQGluY2x1ZGUgY2RrLWhpZ2gtY29udHJhc3QoYmxhY2stb24td2hpdGUpIHtcbiAgICAgIC8vIEhhdmluZyB0aGUgb25lIGFib3ZlIGJlICFpbXBvcnRhbnQgZW5kcyB1cCBvdmVycmlkaW5nIHRoZSBicm93c2VyJ3MgYXV0b21hdGljXG4gICAgICAvLyBjb2xvciBpbnZlcnNpb24gc28gd2UgbmVlZCB0byByZS1pbnZlcnQgaXQgb3Vyc2VsdmVzIGZvciBibGFjay1vbi13aGl0ZS5cbiAgICAgIHN0cm9rZTogIzAwMCAhaW1wb3J0YW50O1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtY2hlY2tib3gtbWl4ZWRtYXJrIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkY2hlY2tib3gtbWFyay1jb2xvcjtcbiAgfVxuXG4gIC5tYXQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZSwgLm1hdC1jaGVja2JveC1jaGVja2VkIHtcbiAgICAmLm1hdC1wcmltYXJ5IC5tYXQtY2hlY2tib3gtYmFja2dyb3VuZCB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBtYXQtY29sb3IoJHByaW1hcnkpO1xuICAgIH1cblxuICAgICYubWF0LWFjY2VudCAubWF0LWNoZWNrYm94LWJhY2tncm91bmQge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRhY2NlbnQpO1xuICAgIH1cblxuICAgICYubWF0LXdhcm4gLm1hdC1jaGVja2JveC1iYWNrZ3JvdW5kIHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkd2Fybik7XG4gICAgfVxuICB9XG5cbiAgLm1hdC1jaGVja2JveC1kaXNhYmxlZCB7XG4gICAgJi5tYXQtY2hlY2tib3gtY2hlY2tlZCxcbiAgICAmLm1hdC1jaGVja2JveC1pbmRldGVybWluYXRlIHtcbiAgICAgIC5tYXQtY2hlY2tib3gtYmFja2dyb3VuZCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRkaXNhYmxlZC1jb2xvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAmOm5vdCgubWF0LWNoZWNrYm94LWNoZWNrZWQpIHtcbiAgICAgIC5tYXQtY2hlY2tib3gtZnJhbWUge1xuICAgICAgICBib3JkZXItY29sb3I6ICRkaXNhYmxlZC1jb2xvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAubWF0LWNoZWNrYm94LWxhYmVsIHtcbiAgICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHNlY29uZGFyeS10ZXh0KTtcbiAgICB9XG5cbiAgICBAaW5jbHVkZSBjZGstaGlnaC1jb250cmFzdCB7XG4gICAgICBvcGFjaXR5OiAwLjU7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBvbmUgaXMgbW92ZWQgZG93biBoZXJlIHNvIGl0IGNhbiB0YXJnZXQgYm90aFxuICAvLyB0aGUgdGhlbWUgY29sb3JzIGFuZCB0aGUgZGlzYWJsZWQgc3RhdGUuXG4gIEBpbmNsdWRlIGNkay1oaWdoLWNvbnRyYXN0IHtcbiAgICAubWF0LWNoZWNrYm94LWJhY2tncm91bmQge1xuICAgICAgLy8gTmVlZHMgdG8gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IGhpZGVzIHRoZSBjaGVja2JveCBvdXRsaW5lLlxuICAgICAgYmFja2dyb3VuZDogbm9uZTtcbiAgICB9XG4gIH1cblxuICAubWF0LWNoZWNrYm94Om5vdCgubWF0LWNoZWNrYm94LWRpc2FibGVkKSB7XG4gICAgJi5tYXQtcHJpbWFyeSAubWF0LWNoZWNrYm94LXJpcHBsZSAubWF0LXJpcHBsZS1lbGVtZW50IHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgJi5tYXQtYWNjZW50IC5tYXQtY2hlY2tib3gtcmlwcGxlIC5tYXQtcmlwcGxlLWVsZW1lbnQge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRhY2NlbnQpO1xuICAgIH1cblxuICAgICYubWF0LXdhcm4gLm1hdC1jaGVja2JveC1yaXBwbGUgLm1hdC1yaXBwbGUtZWxlbWVudCB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBtYXQtY29sb3IoJHdhcm4pO1xuICAgIH1cbiAgfVxufVxuXG5AbWl4aW4gbWF0LWNoZWNrYm94LXR5cG9ncmFwaHkoJGNvbmZpZykge1xuICAubWF0LWNoZWNrYm94IHtcbiAgICBmb250LWZhbWlseTogbWF0LWZvbnQtZmFtaWx5KCRjb25maWcpO1xuICB9XG5cbiAgLy8gVE9ETyhrYXJhKTogUmVtb3ZlIHRoaXMgc3R5bGUgd2hlbiBmaXhpbmcgdmVydGljYWwgYmFzZWxpbmVcbiAgLm1hdC1jaGVja2JveC1sYXlvdXQgLm1hdC1jaGVja2JveC1sYWJlbCB7XG4gICAgbGluZS1oZWlnaHQ6IG1hdC1saW5lLWhlaWdodCgkY29uZmlnLCBib2R5LTIpO1xuICB9XG59XG5cblxuXG5cblxuXG4kbWF0LWNoaXAtcmVtb3ZlLWZvbnQtc2l6ZTogMThweDtcblxuQG1peGluIG1hdC1jaGlwcy1jb2xvcigkZm9yZWdyb3VuZCwgJGJhY2tncm91bmQpIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogJGJhY2tncm91bmQ7XG4gIGNvbG9yOiAkZm9yZWdyb3VuZDtcblxuICAubWF0LWNoaXAtcmVtb3ZlIHtcbiAgICBjb2xvcjogJGZvcmVncm91bmQ7XG4gICAgb3BhY2l0eTogMC40O1xuICB9XG59XG5cbkBtaXhpbiBtYXQtY2hpcHMtdGhlbWUtY29sb3IoJHBhbGV0dGUpIHtcbiAgQGluY2x1ZGUgbWF0LWNoaXBzLWNvbG9yKG1hdC1jb2xvcigkcGFsZXR0ZSwgZGVmYXVsdC1jb250cmFzdCksIG1hdC1jb2xvcigkcGFsZXR0ZSkpO1xuXG4gIC5tYXQtcmlwcGxlLWVsZW1lbnQge1xuICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkcGFsZXR0ZSwgZGVmYXVsdC1jb250cmFzdCwgMC4xKTtcbiAgfVxufVxuXG5AbWl4aW4gbWF0LWNoaXBzLXRoZW1lKCR0aGVtZSkge1xuICAkaXMtZGFyay10aGVtZTogbWFwLWdldCgkdGhlbWUsIGlzLWRhcmspO1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAkdW5zZWxlY3RlZC1iYWNrZ3JvdW5kOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIHVuc2VsZWN0ZWQtY2hpcCk7XG4gICR1bnNlbGVjdGVkLWZvcmVncm91bmQ6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG5cbiAgLm1hdC1jaGlwLm1hdC1zdGFuZGFyZC1jaGlwIHtcbiAgICBAaW5jbHVkZSBtYXQtY2hpcHMtY29sb3IoJHVuc2VsZWN0ZWQtZm9yZWdyb3VuZCwgJHVuc2VsZWN0ZWQtYmFja2dyb3VuZCk7XG5cbiAgICAmOm5vdCgubWF0LWNoaXAtZGlzYWJsZWQpIHtcbiAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgQGluY2x1ZGUgX21hdC10aGVtZS1lbGV2YXRpb24oMywgJHRoZW1lKTtcbiAgICAgIH1cblxuICAgICAgLm1hdC1jaGlwLXJlbW92ZTpob3ZlciB7XG4gICAgICAgIG9wYWNpdHk6IDAuNTQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJi5tYXQtY2hpcC1kaXNhYmxlZCB7XG4gICAgICBvcGFjaXR5OiAwLjQ7XG4gICAgfVxuXG4gICAgJjo6YWZ0ZXIge1xuICAgICAgYmFja2dyb3VuZDogbWFwX2dldCgkZm9yZWdyb3VuZCwgYmFzZSk7XG4gICAgfVxuICB9XG5cbiAgLm1hdC1jaGlwLm1hdC1zdGFuZGFyZC1jaGlwLm1hdC1jaGlwLXNlbGVjdGVkIHtcbiAgICAmLm1hdC1wcmltYXJ5IHtcbiAgICAgIEBpbmNsdWRlIG1hdC1jaGlwcy10aGVtZS1jb2xvcigkcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgJi5tYXQtd2FybiB7XG4gICAgICBAaW5jbHVkZSBtYXQtY2hpcHMtdGhlbWUtY29sb3IoJHdhcm4pO1xuICAgIH1cblxuICAgICYubWF0LWFjY2VudCB7XG4gICAgICBAaW5jbHVkZSBtYXQtY2hpcHMtdGhlbWUtY29sb3IoJGFjY2VudCk7XG4gICAgfVxuICB9XG59XG5cbkBtaXhpbiBtYXQtY2hpcHMtdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC5tYXQtY2hpcCB7XG4gICAgZm9udC1zaXplOiBtYXQtZm9udC1zaXplKCRjb25maWcsIGJvZHktMik7XG4gICAgZm9udC13ZWlnaHQ6IG1hdC1mb250LXdlaWdodCgkY29uZmlnLCBib2R5LTIpO1xuXG4gICAgLm1hdC1jaGlwLXRyYWlsaW5nLWljb24ubWF0LWljb24sXG4gICAgLm1hdC1jaGlwLXJlbW92ZS5tYXQtaWNvbiB7XG4gICAgICBmb250LXNpemU6ICRtYXQtY2hpcC1yZW1vdmUtZm9udC1zaXplO1xuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cbkBtaXhpbiBtYXQtdGFibGUtdGhlbWUoJHRoZW1lKSB7XG4gICRiYWNrZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgYmFja2dyb3VuZCk7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG5cbiAgLm1hdC10YWJsZSB7XG4gICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCAnY2FyZCcpO1xuICB9XG5cbiAgLm1hdC10YWJsZSB0aGVhZCwgLm1hdC10YWJsZSB0Ym9keSwgLm1hdC10YWJsZSB0Zm9vdCxcbiAgbWF0LWhlYWRlci1yb3csIG1hdC1yb3csIG1hdC1mb290ZXItcm93LFxuICBbbWF0LWhlYWRlci1yb3ddLCBbbWF0LXJvd10sIFttYXQtZm9vdGVyLXJvd10sXG4gIC5tYXQtdGFibGUtc3RpY2t5IHtcbiAgICBiYWNrZ3JvdW5kOiBpbmhlcml0O1xuICB9XG5cbiAgbWF0LXJvdywgbWF0LWhlYWRlci1yb3csIG1hdC1mb290ZXItcm93LFxuICB0aC5tYXQtaGVhZGVyLWNlbGwsIHRkLm1hdC1jZWxsLCB0ZC5tYXQtZm9vdGVyLWNlbGwge1xuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGl2aWRlcik7XG4gIH1cblxuICAubWF0LWhlYWRlci1jZWxsIHtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBzZWNvbmRhcnktdGV4dCk7XG4gIH1cblxuICAubWF0LWNlbGwsIC5tYXQtZm9vdGVyLWNlbGwge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHRleHQpO1xuICB9XG59XG5cbkBtaXhpbiBtYXQtdGFibGUtdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC5tYXQtdGFibGUge1xuICAgIGZvbnQtZmFtaWx5OiBtYXQtZm9udC1mYW1pbHkoJGNvbmZpZyk7XG4gIH1cblxuICAubWF0LWhlYWRlci1jZWxsIHtcbiAgICBmb250LXNpemU6IG1hdC1mb250LXNpemUoJGNvbmZpZywgY2FwdGlvbik7XG4gICAgZm9udC13ZWlnaHQ6IG1hdC1mb250LXdlaWdodCgkY29uZmlnLCBib2R5LTIpO1xuICB9XG5cbiAgLm1hdC1jZWxsLCAubWF0LWZvb3Rlci1jZWxsIHtcbiAgICBmb250LXNpemU6IG1hdC1mb250LXNpemUoJGNvbmZpZywgYm9keS0xKTtcbiAgfVxufVxuXG5cblxuXG5cblxuXG4kbWF0LWRhdGVwaWNrZXItc2VsZWN0ZWQtdG9kYXktYm94LXNoYWRvdy13aWR0aDogMXB4O1xuJG1hdC1kYXRlcGlja2VyLXNlbGVjdGVkLWZhZGUtYW1vdW50OiAwLjY7XG4kbWF0LWRhdGVwaWNrZXItdG9kYXktZmFkZS1hbW91bnQ6IDAuMjtcbiRtYXQtY2FsZW5kYXItYm9keS1mb250LXNpemU6IDEzcHggIWRlZmF1bHQ7XG4kbWF0LWNhbGVuZGFyLXdlZWtkYXktdGFibGUtZm9udC1zaXplOiAxMXB4ICFkZWZhdWx0O1xuXG5AbWl4aW4gX21hdC1kYXRlcGlja2VyLWNvbG9yKCRwYWxldHRlKSB7XG4gIC5tYXQtY2FsZW5kYXItYm9keS1zZWxlY3RlZCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRwYWxldHRlKTtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRwYWxldHRlLCBkZWZhdWx0LWNvbnRyYXN0KTtcbiAgfVxuXG4gIC5tYXQtY2FsZW5kYXItYm9keS1kaXNhYmxlZCA+IC5tYXQtY2FsZW5kYXItYm9keS1zZWxlY3RlZCB7XG4gICAgJGJhY2tncm91bmQ6IG1hdC1jb2xvcigkcGFsZXR0ZSk7XG5cbiAgICBAaWYgKHR5cGUtb2YoJGJhY2tncm91bmQpID09IGNvbG9yKSB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBmYWRlLW91dCgkYmFja2dyb3VuZCwgJG1hdC1kYXRlcGlja2VyLXNlbGVjdGVkLWZhZGUtYW1vdW50KTtcbiAgICB9XG4gICAgQGVsc2Uge1xuICAgICAgLy8gSWYgd2UgY291bGRuJ3QgcmVzb2x2ZSB0byBiYWNrZ3JvdW5kIHRvIGEgY29sb3IgKGUuZy4gaXQncyBhIENTUyB2YXJpYWJsZSksXG4gICAgICAvLyBmYWxsIGJhY2sgdG8gZmFkaW5nIHRoZSBjb250ZW50IG91dCB2aWEgYG9wYWNpdHlgLlxuICAgICAgb3BhY2l0eTogJG1hdC1kYXRlcGlja2VyLXRvZGF5LWZhZGUtYW1vdW50O1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtY2FsZW5kYXItYm9keS10b2RheS5tYXQtY2FsZW5kYXItYm9keS1zZWxlY3RlZCB7XG4gICAgYm94LXNoYWRvdzogaW5zZXQgMCAwIDAgJG1hdC1kYXRlcGlja2VyLXNlbGVjdGVkLXRvZGF5LWJveC1zaGFkb3ctd2lkdGhcbiAgICAgICAgICAgICAgICBtYXQtY29sb3IoJHBhbGV0dGUsIGRlZmF1bHQtY29udHJhc3QpO1xuICB9XG59XG5cbkBtaXhpbiBtYXQtZGF0ZXBpY2tlci10aGVtZSgkdGhlbWUpIHtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcblxuICAubWF0LWNhbGVuZGFyLWFycm93IHtcbiAgICBib3JkZXItdG9wLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGljb24pO1xuICB9XG5cbiAgLy8gVGhlIHByZXYvbmV4dCBidXR0b25zIG5lZWQgYSBiaXQgbW9yZSBzcGVjaWZpY2l0eSB0b1xuICAvLyBhdm9pZCBiZWluZyBvdmVyd3JpdHRlbiBieSB0aGUgLm1hdC1pY29uLWJ1dHRvbi5cbiAgLm1hdC1kYXRlcGlja2VyLXRvZ2dsZSxcbiAgLm1hdC1kYXRlcGlja2VyLWNvbnRlbnQgLm1hdC1jYWxlbmRhci1uZXh0LWJ1dHRvbixcbiAgLm1hdC1kYXRlcGlja2VyLWNvbnRlbnQgLm1hdC1jYWxlbmRhci1wcmV2aW91cy1idXR0b24ge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGljb24pO1xuICB9XG5cbiAgLm1hdC1jYWxlbmRhci10YWJsZS1oZWFkZXIge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGhpbnQtdGV4dCk7XG4gIH1cblxuICAubWF0LWNhbGVuZGFyLXRhYmxlLWhlYWRlci1kaXZpZGVyOjphZnRlciB7XG4gICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBkaXZpZGVyKTtcbiAgfVxuXG4gIC5tYXQtY2FsZW5kYXItYm9keS1sYWJlbCB7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgc2Vjb25kYXJ5LXRleHQpO1xuICB9XG5cbiAgLm1hdC1jYWxlbmRhci1ib2R5LWNlbGwtY29udGVudCB7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgfVxuXG4gIC5tYXQtY2FsZW5kYXItYm9keS1kaXNhYmxlZCA+IC5tYXQtY2FsZW5kYXItYm9keS1jZWxsLWNvbnRlbnQ6bm90KC5tYXQtY2FsZW5kYXItYm9keS1zZWxlY3RlZCkge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpc2FibGVkLXRleHQpO1xuICB9XG5cbiAgLm1hdC1jYWxlbmRhci1ib2R5LWNlbGw6bm90KC5tYXQtY2FsZW5kYXItYm9keS1kaXNhYmxlZCk6aG92ZXIsXG4gIC5jZGsta2V5Ym9hcmQtZm9jdXNlZCAubWF0LWNhbGVuZGFyLWJvZHktYWN0aXZlLFxuICAuY2RrLXByb2dyYW0tZm9jdXNlZCAubWF0LWNhbGVuZGFyLWJvZHktYWN0aXZlIHtcbiAgICAmID4gLm1hdC1jYWxlbmRhci1ib2R5LWNlbGwtY29udGVudDpub3QoLm1hdC1jYWxlbmRhci1ib2R5LXNlbGVjdGVkKSB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGhvdmVyKTtcbiAgICB9XG4gIH1cblxuICAubWF0LWNhbGVuZGFyLWJvZHktdG9kYXk6bm90KC5tYXQtY2FsZW5kYXItYm9keS1zZWxlY3RlZCkge1xuICAgIC8vIE5vdGU6IHRob3VnaCBpdCdzIG5vdCB0ZXh0LCB0aGUgYm9yZGVyIGlzIGEgaGludCBhYm91dCB0aGUgZmFjdCB0aGF0IHRoaXMgaXMgdG9kYXkncyBkYXRlLFxuICAgIC8vIHNvIHdlIHVzZSB0aGUgaGludCBjb2xvci5cbiAgICBib3JkZXItY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgaGludC10ZXh0KTtcbiAgfVxuXG4gIC5tYXQtY2FsZW5kYXItYm9keS1kaXNhYmxlZCA+IC5tYXQtY2FsZW5kYXItYm9keS10b2RheTpub3QoLm1hdC1jYWxlbmRhci1ib2R5LXNlbGVjdGVkKSB7XG4gICAgJGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGhpbnQtdGV4dCk7XG5cbiAgICBAaWYgKHR5cGUtb2YoJGNvbG9yKSA9PSBjb2xvcikge1xuICAgICAgYm9yZGVyLWNvbG9yOiBmYWRlLW91dCgkY29sb3IsICRtYXQtZGF0ZXBpY2tlci10b2RheS1mYWRlLWFtb3VudCk7XG4gICAgfVxuICAgIEBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjb2xvciBkaWRuJ3QgcmVzb2x2ZSB0byBhIGNvbG9yIHZhbHVlLCBidXQgc29tZXRoaW5nIGxpa2UgYSBDU1MgdmFyaWFibGUsIHdlIGNhbid0XG4gICAgICAvLyBmYWRlIGl0IG91dCBzbyB3ZSBmYWxsIGJhY2sgdG8gcmVkdWNpbmcgdGhlIGVsZW1lbnQgb3BhY2l0eS4gTm90ZSB0aGF0IHdlIGRvbid0IHVzZSB0aGVcbiAgICAgIC8vICRtYXQtZGF0ZXBpY2tlci10b2RheS1mYWRlLWFtb3VudCwgYmVjYXVzZSBoaW50IHRleHQgdXN1YWxseSBoYXMgc29tZSBvcGFjaXR5IGFwcGxpZWRcbiAgICAgIC8vIHRvIGl0IGFscmVhZHkgYW5kIHdlIGRvbid0IHdhbnQgdGhlbSB0byBzdGFjayBvbiB0b3Agb2YgZWFjaCBvdGhlci5cbiAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICB9XG4gIH1cblxuICBAaW5jbHVkZSBfbWF0LWRhdGVwaWNrZXItY29sb3IobWFwLWdldCgkdGhlbWUsIHByaW1hcnkpKTtcblxuICAubWF0LWRhdGVwaWNrZXItY29udGVudCB7XG4gICAgQGluY2x1ZGUgX21hdC10aGVtZS1lbGV2YXRpb24oNCwgJHRoZW1lKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGNhcmQpO1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHRleHQpO1xuXG4gICAgJi5tYXQtYWNjZW50IHtcbiAgICAgIEBpbmNsdWRlIF9tYXQtZGF0ZXBpY2tlci1jb2xvcihtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KSk7XG4gICAgfVxuXG4gICAgJi5tYXQtd2FybiB7XG4gICAgICBAaW5jbHVkZSBfbWF0LWRhdGVwaWNrZXItY29sb3IobWFwLWdldCgkdGhlbWUsIHdhcm4pKTtcbiAgICB9XG4gIH1cblxuICAubWF0LWRhdGVwaWNrZXItY29udGVudC10b3VjaCB7XG4gICAgQGluY2x1ZGUgX21hdC10aGVtZS1lbGV2YXRpb24oMCwgJHRoZW1lKTtcbiAgfVxuXG4gIC5tYXQtZGF0ZXBpY2tlci10b2dnbGUtYWN0aXZlIHtcbiAgICBjb2xvcjogbWF0LWNvbG9yKG1hcC1nZXQoJHRoZW1lLCBwcmltYXJ5KSk7XG5cbiAgICAmLm1hdC1hY2NlbnQge1xuICAgICAgY29sb3I6IG1hdC1jb2xvcihtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KSk7XG4gICAgfVxuXG4gICAgJi5tYXQtd2FybiB7XG4gICAgICBjb2xvcjogbWF0LWNvbG9yKG1hcC1nZXQoJHRoZW1lLCB3YXJuKSk7XG4gICAgfVxuICB9XG59XG5cbkBtaXhpbiBtYXQtZGF0ZXBpY2tlci10eXBvZ3JhcGh5KCRjb25maWcpIHtcbiAgLm1hdC1jYWxlbmRhciB7XG4gICAgZm9udC1mYW1pbHk6IG1hdC1mb250LWZhbWlseSgkY29uZmlnKTtcbiAgfVxuXG4gIC5tYXQtY2FsZW5kYXItYm9keSB7XG4gICAgZm9udC1zaXplOiAkbWF0LWNhbGVuZGFyLWJvZHktZm9udC1zaXplO1xuICB9XG5cbiAgLm1hdC1jYWxlbmRhci1ib2R5LWxhYmVsLFxuICAubWF0LWNhbGVuZGFyLXBlcmlvZC1idXR0b24ge1xuICAgIGZvbnQ6IHtcbiAgICAgIHNpemU6IG1hdC1mb250LXNpemUoJGNvbmZpZywgYnV0dG9uKTtcbiAgICAgIHdlaWdodDogbWF0LWZvbnQtd2VpZ2h0KCRjb25maWcsIGJ1dHRvbik7XG4gICAgfVxuICB9XG5cbiAgLm1hdC1jYWxlbmRhci10YWJsZS1oZWFkZXIgdGgge1xuICAgIGZvbnQ6IHtcbiAgICAgIHNpemU6ICRtYXQtY2FsZW5kYXItd2Vla2RheS10YWJsZS1mb250LXNpemU7XG4gICAgICB3ZWlnaHQ6IG1hdC1mb250LXdlaWdodCgkY29uZmlnLCBib2R5LTEpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cblxuXG5AbWl4aW4gbWF0LWRpYWxvZy10aGVtZSgkdGhlbWUpIHtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAubWF0LWRpYWxvZy1jb250YWluZXIge1xuICAgIEBpbmNsdWRlIF9tYXQtdGhlbWUtZWxldmF0aW9uKDI0LCAkdGhlbWUpO1xuICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgZGlhbG9nKTtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCB0ZXh0KTtcbiAgfVxufVxuXG5AbWl4aW4gbWF0LWRpYWxvZy10eXBvZ3JhcGh5KCRjb25maWcpIHtcbiAgLm1hdC1kaWFsb2ctdGl0bGUge1xuICAgIEBpbmNsdWRlIG1hdC10eXBvZ3JhcGh5LWxldmVsLXRvLXN0eWxlcygkY29uZmlnLCB0aXRsZSk7XG4gIH1cbn1cblxuXG5cblxuXG5cbkBtaXhpbiBtYXQtZXhwYW5zaW9uLXBhbmVsLXRoZW1lKCR0aGVtZSkge1xuICAkYmFja2dyb3VuZDogbWFwLWdldCgkdGhlbWUsIGJhY2tncm91bmQpO1xuICAkZm9yZWdyb3VuZDogbWFwLWdldCgkdGhlbWUsIGZvcmVncm91bmQpO1xuXG4gIC5tYXQtZXhwYW5zaW9uLXBhbmVsIHtcbiAgICBAaW5jbHVkZSBfbWF0LXRoZW1lLW92ZXJyaWRhYmxlLWVsZXZhdGlvbigyLCAkdGhlbWUpO1xuICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgY2FyZCk7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG4gIH1cblxuICAubWF0LWFjdGlvbi1yb3cge1xuICAgIGJvcmRlci10b3AtY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGl2aWRlcik7XG4gIH1cblxuICAubWF0LWV4cGFuc2lvbi1wYW5lbDpub3QoLm1hdC1leHBhbmRlZCkgLm1hdC1leHBhbnNpb24tcGFuZWwtaGVhZGVyIHtcbiAgICAmOm5vdChbYXJpYS1kaXNhYmxlZD0ndHJ1ZSddKSB7XG4gICAgICAmLmNkay1rZXlib2FyZC1mb2N1c2VkLFxuICAgICAgJi5jZGstcHJvZ3JhbS1mb2N1c2VkLFxuICAgICAgJjpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgaG92ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIERpc2FibGUgdGhlIGhvdmVyIG9uIHRvdWNoIGRldmljZXMgc2luY2UgaXQgY2FuIGFwcGVhciBsaWtlIGl0IGlzIHN0dWNrLiBXZSBjYW4ndCB1c2VcbiAgLy8gYEBtZWRpYSAoaG92ZXIpYCBhYm92ZSwgYmVjYXVzZSB0aGUgZGVza3RvcCBzdXBwb3J0IGJyb3dzZXIgc3VwcG9ydCBpc24ndCBncmVhdC5cbiAgQG1lZGlhIChob3Zlcjogbm9uZSkge1xuICAgIC5tYXQtZXhwYW5zaW9uLXBhbmVsOm5vdCgubWF0LWV4cGFuZGVkKTpub3QoW2FyaWEtZGlzYWJsZWQ9J3RydWUnXSlcbiAgICAgIC5tYXQtZXhwYW5zaW9uLXBhbmVsLWhlYWRlcjpob3ZlciB7XG4gICAgICBiYWNrZ3JvdW5kOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGNhcmQpO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtZXhwYW5zaW9uLXBhbmVsLWhlYWRlci10aXRsZSB7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG4gIH1cblxuICAubWF0LWV4cGFuc2lvbi1wYW5lbC1oZWFkZXItZGVzY3JpcHRpb24sXG4gIC5tYXQtZXhwYW5zaW9uLWluZGljYXRvcjo6YWZ0ZXIge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHNlY29uZGFyeS10ZXh0KTtcbiAgfVxuXG4gIC5tYXQtZXhwYW5zaW9uLXBhbmVsLWhlYWRlclthcmlhLWRpc2FibGVkPSd0cnVlJ10ge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpc2FibGVkLWJ1dHRvbik7XG5cbiAgICAubWF0LWV4cGFuc2lvbi1wYW5lbC1oZWFkZXItdGl0bGUsXG4gICAgLm1hdC1leHBhbnNpb24tcGFuZWwtaGVhZGVyLWRlc2NyaXB0aW9uIHtcbiAgICAgIGNvbG9yOiBpbmhlcml0O1xuICAgIH1cbiAgfVxufVxuXG5AbWl4aW4gbWF0LWV4cGFuc2lvbi1wYW5lbC10eXBvZ3JhcGh5KCRjb25maWcpIHtcbiAgLm1hdC1leHBhbnNpb24tcGFuZWwtaGVhZGVyIHtcbiAgICBmb250OiB7XG4gICAgICBmYW1pbHk6IG1hdC1mb250LWZhbWlseSgkY29uZmlnLCBzdWJoZWFkaW5nLTEpO1xuICAgICAgc2l6ZTogbWF0LWZvbnQtc2l6ZSgkY29uZmlnLCBzdWJoZWFkaW5nLTEpO1xuICAgICAgd2VpZ2h0OiBtYXQtZm9udC13ZWlnaHQoJGNvbmZpZywgc3ViaGVhZGluZy0xKTtcbiAgICB9XG4gIH1cblxuICAubWF0LWV4cGFuc2lvbi1wYW5lbC1jb250ZW50IHtcbiAgICBAaW5jbHVkZSBtYXQtdHlwb2dyYXBoeS1sZXZlbC10by1zdHlsZXMoJGNvbmZpZywgYm9keS0xKTtcbiAgfVxufVxuXG5cblxuXG4vLyBUaGlzIG1peGluIHdpbGwgZW5zdXJlIHRoYXQgbGluZXMgdGhhdCBvdmVyZmxvdyB0aGUgY29udGFpbmVyIHdpbGwgaGlkZSB0aGUgb3ZlcmZsb3cgYW5kXG4vLyB0cnVuY2F0ZSBuZWF0bHkgd2l0aCBhbiBlbGxpcHNpcy5cbkBtaXhpbiBtYXQtdHJ1bmNhdGUtbGluZSgpIHtcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG59XG5cbi8vIE1peGluIHRvIHByb3ZpZGUgYWxsIG1hdC1saW5lIHN0eWxlcywgY2hhbmdpbmcgc2Vjb25kYXJ5IGZvbnQgc2l6ZSBiYXNlZCBvbiB3aGV0aGVyIHRoZSBsaXN0XG4vLyBpcyBpbiBkZW5zZSBtb2RlLlxuQG1peGluIG1hdC1saW5lLWJhc2UoJHNlY29uZGFyeS1mb250LXNpemUpIHtcbiAgLm1hdC1saW5lIHtcbiAgICBAaW5jbHVkZSBtYXQtdHJ1bmNhdGUtbGluZSgpO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cbiAgICAvLyBhbGwgbGluZXMgYnV0IHRoZSB0b3AgbGluZSBzaG91bGQgaGF2ZSBzbWFsbGVyIHRleHRcbiAgICAmOm50aC1jaGlsZChuKzIpIHtcbiAgICAgIGZvbnQtc2l6ZTogJHNlY29uZGFyeS1mb250LXNpemU7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgbWl4aW4gbm9ybWFsaXplcyBkZWZhdWx0IGVsZW1lbnQgc3R5bGVzLCBlLmcuIGZvbnQgd2VpZ2h0IGZvciBoZWFkaW5nIHRleHQuXG5AbWl4aW4gbWF0LW5vcm1hbGl6ZS10ZXh0KCkge1xuICAmID4gKiB7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgICBmb250LXNpemU6IGluaGVyaXQ7XG4gIH1cbn1cblxuLy8gVGhpcyBtaXhpbiBwcm92aWRlcyBiYXNlIHN0eWxlcyBmb3IgdGhlIHdyYXBwZXIgYXJvdW5kIG1hdC1saW5lIGVsZW1lbnRzIGluIGEgbGlzdC5cbkBtaXhpbiBtYXQtbGluZS13cmFwcGVyLWJhc2UoKSB7XG4gIEBpbmNsdWRlIG1hdC1ub3JtYWxpemUtdGV4dCgpO1xuXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIHdpZHRoOiAxMDAlO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBvdmVyZmxvdzogaGlkZGVuO1xuXG4gIC8vIE11c3QgcmVtb3ZlIHdyYXBwZXIgd2hlbiBsaW5lcyBhcmUgZW1wdHkgb3IgaXQgdGFrZXMgdXAgaG9yaXpvbnRhbFxuICAvLyBzcGFjZSBhbmQgcHVzaGVzIG90aGVyIGVsZW1lbnRzIHRvIHRoZSByaWdodC5cbiAgJjplbXB0eSB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgfVxufVxuXG5cblxuLy8gSW5jbHVkZSB0aGlzIGVtcHR5IG1peGluIGZvciBjb25zaXN0ZW5jeSB3aXRoIHRoZSBvdGhlciBjb21wb25lbnRzLlxuQG1peGluIG1hdC1ncmlkLWxpc3QtdGhlbWUoJHRoZW1lKSB7IH1cblxuQG1peGluIG1hdC1ncmlkLWxpc3QtdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC5tYXQtZ3JpZC10aWxlLWhlYWRlcixcbiAgLm1hdC1ncmlkLXRpbGUtZm9vdGVyIHtcbiAgICBAaW5jbHVkZSBtYXQtbGluZS1iYXNlKG1hdC1mb250LXNpemUoJGNvbmZpZywgY2FwdGlvbikpO1xuICAgIGZvbnQtc2l6ZTogbWF0LWZvbnQtc2l6ZSgkY29uZmlnLCBib2R5LTEpO1xuICB9XG59XG5cblxuXG5cbi8vIEluY2x1ZGUgdGhpcyBlbXB0eSBtaXhpbiBmb3IgY29uc2lzdGVuY3kgd2l0aCB0aGUgb3RoZXIgY29tcG9uZW50cy5cbkBtaXhpbiBtYXQtaWNvbi10aGVtZSgkdGhlbWUpIHtcbiAgJHByaW1hcnk6IG1hcC1nZXQoJHRoZW1lLCBwcmltYXJ5KTtcbiAgJGFjY2VudDogbWFwLWdldCgkdGhlbWUsIGFjY2VudCk7XG4gICR3YXJuOiBtYXAtZ2V0KCR0aGVtZSwgd2Fybik7XG4gICRiYWNrZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgYmFja2dyb3VuZCk7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG5cbiAgLm1hdC1pY29uIHtcbiAgICAmLm1hdC1wcmltYXJ5IHtcbiAgICAgIGNvbG9yOiBtYXQtY29sb3IoJHByaW1hcnkpO1xuICAgIH1cblxuICAgICYubWF0LWFjY2VudCB7XG4gICAgICBjb2xvcjogbWF0LWNvbG9yKCRhY2NlbnQpO1xuICAgIH1cblxuICAgICYubWF0LXdhcm4ge1xuICAgICAgY29sb3I6IG1hdC1jb2xvcigkd2Fybik7XG4gICAgfVxuICB9XG59XG5cbkBtaXhpbiBtYXQtaWNvbi10eXBvZ3JhcGh5KCRjb25maWcpIHsgfVxuXG5cblxuXG5cbi8vIFJlbmRlcnMgYSBncmFkaWVudCBmb3Igc2hvd2luZyB0aGUgZGFzaGVkIGxpbmUgd2hlbiB0aGUgaW5wdXQgaXMgZGlzYWJsZWQuXG4vLyBVbmxpa2UgdXNpbmcgYSBib3JkZXIsIGEgZ3JhZGllbnQgYWxsb3dzIHVzIHRvIGFkanVzdCB0aGUgc3BhY2luZyBvZiB0aGUgZG90dGVkIGxpbmVcbi8vIHRvIG1hdGNoIHRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYy5cbkBtaXhpbiBtYXQtY29udHJvbC1kaXNhYmxlZC11bmRlcmxpbmUoJGNvbG9yKSB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgJGNvbG9yIDAlLCAkY29sb3IgMzMlLCB0cmFuc3BhcmVudCAwJSk7XG4gIGJhY2tncm91bmQtc2l6ZTogNHB4IDEwMCU7XG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcbn1cblxuLy8gRmlndXJlcyBvdXQgdGhlIGNvbG9yIG9mIHRoZSBwbGFjZWhvbGRlciBmb3IgYSBmb3JtIGNvbnRyb2wuXG4vLyBVc2VkIHByaW1hcmlseSB0byBwcmV2ZW50IHRoZSB2YXJpb3VzIGZvcm0gY29udHJvbHMgZnJvbVxuLy8gYmVjb21pbmcgb3V0IG9mIHN5bmMgc2luY2UgdGhlc2UgY29sb3JzIGFyZW4ndCBpbiBhIHBhbGV0dGUuXG5AZnVuY3Rpb24gX21hdC1jb250cm9sLXBsYWNlaG9sZGVyLWNvbG9yKCR0aGVtZSkge1xuICAkZm9yZWdyb3VuZDogbWFwLWdldCgkdGhlbWUsIGZvcmVncm91bmQpO1xuICAkaXMtZGFyay10aGVtZTogbWFwLWdldCgkdGhlbWUsIGlzLWRhcmspO1xuICBAcmV0dXJuIG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgc2Vjb25kYXJ5LXRleHQsIGlmKCRpcy1kYXJrLXRoZW1lLCAwLjUsIDAuNDIpKTtcbn1cblxuXG4vKiBzdHlsZWxpbnQtZGlzYWJsZSBtYXRlcmlhbC9uby1wcmVmaXhlcyAqL1xuQG1peGluIHVzZXItc2VsZWN0KCR2YWx1ZSkge1xuICAtd2Via2l0LXVzZXItc2VsZWN0OiAkdmFsdWU7XG4gIC1tb3otdXNlci1zZWxlY3Q6ICR2YWx1ZTtcbiAgLW1zLXVzZXItc2VsZWN0OiAkdmFsdWU7XG4gIHVzZXItc2VsZWN0OiAkdmFsdWU7XG59XG5cbkBtaXhpbiBpbnB1dC1wbGFjZWhvbGRlciB7XG4gICY6OnBsYWNlaG9sZGVyIHtcbiAgICBAY29udGVudDtcbiAgfVxuXG4gICY6Oi1tb3otcGxhY2Vob2xkZXIge1xuICAgIEBjb250ZW50O1xuICB9XG5cbiAgJjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgQGNvbnRlbnQ7XG4gIH1cblxuICAmOi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgQGNvbnRlbnQ7XG4gIH1cbn1cblxuQG1peGluIGN1cnNvci1ncmFiIHtcbiAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XG4gIGN1cnNvcjogZ3JhYjtcbn1cblxuQG1peGluIGN1cnNvci1ncmFiYmluZyB7XG4gIGN1cnNvcjogLXdlYmtpdC1ncmFiYmluZztcbiAgY3Vyc29yOiBncmFiYmluZztcbn1cblxuQG1peGluIGJhY2tmYWNlLXZpc2liaWxpdHkoJHZhbHVlKSB7XG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogJHZhbHVlO1xuICBiYWNrZmFjZS12aXNpYmlsaXR5OiAkdmFsdWU7XG59XG4vKiBzdHlsZWxpbnQtZW5hYmxlICovXG5cblxuXG5AbWl4aW4gbWF0LWlucHV0LXRoZW1lKCR0aGVtZSkge1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAubWF0LWZvcm0tZmllbGQtdHlwZS1tYXQtbmF0aXZlLXNlbGVjdCAubWF0LWZvcm0tZmllbGQtaW5maXg6OmFmdGVyIHtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBzZWNvbmRhcnktdGV4dCk7XG4gIH1cblxuICAubWF0LWlucHV0LWVsZW1lbnQ6ZGlzYWJsZWQsXG4gIC5tYXQtZm9ybS1maWVsZC10eXBlLW1hdC1uYXRpdmUtc2VsZWN0Lm1hdC1mb3JtLWZpZWxkLWRpc2FibGVkIC5tYXQtZm9ybS1maWVsZC1pbmZpeDo6YWZ0ZXIge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpc2FibGVkLXRleHQpO1xuICB9XG5cbiAgLm1hdC1pbnB1dC1lbGVtZW50IHtcbiAgICBjYXJldC1jb2xvcjogbWF0LWNvbG9yKCRwcmltYXJ5KTtcblxuICAgIEBpbmNsdWRlIGlucHV0LXBsYWNlaG9sZGVyIHtcbiAgICAgIGNvbG9yOiBfbWF0LWNvbnRyb2wtcGxhY2Vob2xkZXItY29sb3IoJHRoZW1lKTtcbiAgICB9XG5cbiAgICAvLyBPbiBkYXJrIHRoZW1lcyB3ZSBzZXQgdGhlIG5hdGl2ZSBgc2VsZWN0YCBjb2xvciB0byBzb21lIHNoYWRlIG9mIHdoaXRlLFxuICAgIC8vIGhvd2V2ZXIgdGhlIGNvbG9yIHByb3BhZ2F0ZXMgdG8gYWxsIG9mIHRoZSBgb3B0aW9uYCBlbGVtZW50cywgd2hpY2ggYXJlXG4gICAgLy8gYWx3YXlzIG9uIGEgd2hpdGUgYmFja2dyb3VuZCBpbnNpZGUgdGhlIGRyb3Bkb3duLCBjYXVzaW5nIHRoZW0gdG8gYmxlbmQgaW4uXG4gICAgLy8gU2luY2Ugd2UgY2FuJ3QgY2hhbmdlIGJhY2tncm91bmQgb2YgdGhlIGRyb3Bkb3duLCB3ZSBuZWVkIHRvIGV4cGxpY2l0bHlcbiAgICAvLyByZXNldCB0aGUgY29sb3Igb2YgdGhlIG9wdGlvbnMgdG8gc29tZXRoaW5nIGRhcmsuXG4gICAgQGlmIChtYXAtZ2V0KCR0aGVtZSwgaXMtZGFyaykpIHtcbiAgICAgIG9wdGlvbiB7XG4gICAgICAgIGNvbG9yOiAkZGFyay1wcmltYXJ5LXRleHQ7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbjpkaXNhYmxlZCB7XG4gICAgICAgIGNvbG9yOiAkZGFyay1kaXNhYmxlZC10ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC5tYXQtYWNjZW50IC5tYXQtaW5wdXQtZWxlbWVudCB7XG4gICAgY2FyZXQtY29sb3I6IG1hdC1jb2xvcigkYWNjZW50KTtcbiAgfVxuXG4gIC5tYXQtd2FybiAubWF0LWlucHV0LWVsZW1lbnQsXG4gIC5tYXQtZm9ybS1maWVsZC1pbnZhbGlkIC5tYXQtaW5wdXQtZWxlbWVudCB7XG4gICAgY2FyZXQtY29sb3I6IG1hdC1jb2xvcigkd2Fybik7XG4gIH1cblxuICAubWF0LWZvcm0tZmllbGQtdHlwZS1tYXQtbmF0aXZlLXNlbGVjdC5tYXQtZm9ybS1maWVsZC1pbnZhbGlkIC5tYXQtZm9ybS1maWVsZC1pbmZpeDo6YWZ0ZXIge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJHdhcm4pO1xuICB9XG59XG5cbkBtaXhpbiBtYXQtaW5wdXQtdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC8vIFRoZSB1bml0LWxlc3MgbGluZS1oZWlnaHQgZnJvbSB0aGUgZm9udCBjb25maWcuXG4gICRsaW5lLWhlaWdodDogbWF0LWxpbmUtaGVpZ2h0KCRjb25maWcsIGlucHV0KTtcblxuICAvLyBUaGUgYW1vdW50IG9mIHNwYWNlIGJldHdlZW4gdGhlIHRvcCBvZiB0aGUgbGluZSBhbmQgdGhlIHRvcCBvZiB0aGUgYWN0dWFsIHRleHRcbiAgLy8gKGFzIGEgZnJhY3Rpb24gb2YgdGhlIGZvbnQtc2l6ZSkuXG4gICRsaW5lLXNwYWNpbmc6ICgkbGluZS1oZWlnaHQgLSAxKSAvIDI7XG5cbiAgLy8gPGlucHV0PiBlbGVtZW50cyBzZWVtIHRvIGhhdmUgdGhlaXIgaGVpZ2h0IHNldCBzbGlnaHRseSB0b28gbGFyZ2Ugb24gU2FmYXJpIGNhdXNpbmcgdGhlIHRleHQgdG9cbiAgLy8gYmUgbWlzYWxpZ25lZCB3LnIudC4gdGhlIHBsYWNlaG9sZGVyLiBBZGRpbmcgdGhpcyBtYXJnaW4gY29ycmVjdHMgaXQuXG4gIGlucHV0Lm1hdC1pbnB1dC1lbGVtZW50IHtcbiAgICBtYXJnaW4tdG9wOiAtJGxpbmUtc3BhY2luZyAqIDFlbTtcbiAgfVxufVxuXG5cblxuXG5cblxuXG5AbWl4aW4gbWF0LWxpc3QtdGhlbWUoJHRoZW1lKSB7XG4gICRiYWNrZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgYmFja2dyb3VuZCk7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG5cbiAgLm1hdC1saXN0LWJhc2Uge1xuICAgIC5tYXQtbGlzdC1pdGVtIHtcbiAgICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHRleHQpO1xuICAgIH1cblxuICAgIC5tYXQtbGlzdC1vcHRpb24ge1xuICAgICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG4gICAgfVxuXG4gICAgLm1hdC1zdWJoZWFkZXIge1xuICAgICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgc2Vjb25kYXJ5LXRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtbGlzdC1pdGVtLWRpc2FibGVkIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGRpc2FibGVkLWxpc3Qtb3B0aW9uKTtcbiAgfVxuXG4gIC5tYXQtbGlzdC1vcHRpb24sXG4gIC5tYXQtbmF2LWxpc3QgLm1hdC1saXN0LWl0ZW0sXG4gIC5tYXQtYWN0aW9uLWxpc3QgLm1hdC1saXN0LWl0ZW0ge1xuICAgICY6aG92ZXIsICY6Zm9jdXMge1xuICAgICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCAnaG92ZXInKTtcbiAgICB9XG4gIH1cbn1cblxuQG1peGluIG1hdC1saXN0LXR5cG9ncmFwaHkoJGNvbmZpZykge1xuICAkZm9udC1mYW1pbHk6IG1hdC1mb250LWZhbWlseSgkY29uZmlnKTtcblxuICAubWF0LWxpc3QtaXRlbSB7XG4gICAgZm9udC1mYW1pbHk6ICRmb250LWZhbWlseTtcbiAgfVxuXG4gIC5tYXQtbGlzdC1vcHRpb24ge1xuICAgIGZvbnQtZmFtaWx5OiAkZm9udC1mYW1pbHk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGxpc3RcbiAgLm1hdC1saXN0LWJhc2Uge1xuICAgIC5tYXQtbGlzdC1pdGVtIHtcbiAgICAgIGZvbnQtc2l6ZTogbWF0LWZvbnQtc2l6ZSgkY29uZmlnLCBzdWJoZWFkaW5nLTIpO1xuICAgICAgQGluY2x1ZGUgbWF0LWxpbmUtYmFzZShtYXQtZm9udC1zaXplKCRjb25maWcsIGJvZHktMSkpO1xuICAgIH1cblxuICAgIC5tYXQtbGlzdC1vcHRpb24ge1xuICAgICAgZm9udC1zaXplOiBtYXQtZm9udC1zaXplKCRjb25maWcsIHN1YmhlYWRpbmctMik7XG4gICAgICBAaW5jbHVkZSBtYXQtbGluZS1iYXNlKG1hdC1mb250LXNpemUoJGNvbmZpZywgYm9keS0xKSk7XG4gICAgfVxuXG4gICAgLm1hdC1zdWJoZWFkZXIge1xuICAgICAgZm9udC1mYW1pbHk6IG1hdC1mb250LWZhbWlseSgkY29uZmlnLCBib2R5LTIpO1xuICAgICAgZm9udC1zaXplOiBtYXQtZm9udC1zaXplKCRjb25maWcsIGJvZHktMik7XG4gICAgICBmb250LXdlaWdodDogbWF0LWZvbnQtd2VpZ2h0KCRjb25maWcsIGJvZHktMik7XG4gICAgfVxuICB9XG5cbiAgLy8gRGVuc2UgbGlzdFxuICAubWF0LWxpc3QtYmFzZVtkZW5zZV0ge1xuICAgIC5tYXQtbGlzdC1pdGVtIHtcbiAgICAgIGZvbnQtc2l6ZTogbWF0LWZvbnQtc2l6ZSgkY29uZmlnLCBjYXB0aW9uKTtcbiAgICAgIEBpbmNsdWRlIG1hdC1saW5lLWJhc2UobWF0LWZvbnQtc2l6ZSgkY29uZmlnLCBjYXB0aW9uKSk7XG4gICAgfVxuXG4gICAgLm1hdC1saXN0LW9wdGlvbiB7XG4gICAgICBmb250LXNpemU6IG1hdC1mb250LXNpemUoJGNvbmZpZywgY2FwdGlvbik7XG4gICAgICBAaW5jbHVkZSBtYXQtbGluZS1iYXNlKG1hdC1mb250LXNpemUoJGNvbmZpZywgY2FwdGlvbikpO1xuICAgIH1cblxuICAgIC5tYXQtc3ViaGVhZGVyIHtcbiAgICAgIGZvbnQtZmFtaWx5OiAkZm9udC1mYW1pbHk7XG4gICAgICBmb250LXNpemU6IG1hdC1mb250LXNpemUoJGNvbmZpZywgY2FwdGlvbik7XG4gICAgICBmb250LXdlaWdodDogbWF0LWZvbnQtd2VpZ2h0KCRjb25maWcsIGJvZHktMik7XG4gICAgfVxuICB9XG59XG5cblxuXG5cblxuXG5cbkBtaXhpbiBtYXQtbWVudS10aGVtZSgkdGhlbWUpIHtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAubWF0LW1lbnUtcGFuZWwge1xuICAgIEBpbmNsdWRlIF9tYXQtdGhlbWUtb3ZlcnJpZGFibGUtZWxldmF0aW9uKDQsICR0aGVtZSk7XG4gICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCAnY2FyZCcpO1xuICB9XG5cbiAgLm1hdC1tZW51LWl0ZW0ge1xuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsICd0ZXh0Jyk7XG5cbiAgICAmW2Rpc2FibGVkXSB7XG4gICAgICAmLCAmOjphZnRlciB7XG4gICAgICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsICdkaXNhYmxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC5tYXQtbWVudS1pdGVtIC5tYXQtaWNvbi1uby1jb2xvcixcbiAgLm1hdC1tZW51LWl0ZW0tc3VibWVudS10cmlnZ2VyOjphZnRlciB7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgJ2ljb24nKTtcbiAgfVxuXG4gIC5tYXQtbWVudS1pdGVtOmhvdmVyLFxuICAubWF0LW1lbnUtaXRlbS5jZGstcHJvZ3JhbS1mb2N1c2VkLFxuICAubWF0LW1lbnUtaXRlbS5jZGsta2V5Ym9hcmQtZm9jdXNlZCxcbiAgLm1hdC1tZW51LWl0ZW0taGlnaGxpZ2h0ZWQge1xuICAgICY6bm90KFtkaXNhYmxlZF0pIHtcbiAgICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgJ2hvdmVyJyk7XG4gICAgfVxuICB9XG59XG5cbkBtaXhpbiBtYXQtbWVudS10eXBvZ3JhcGh5KCRjb25maWcpIHtcbiAgLm1hdC1tZW51LWl0ZW0ge1xuICAgIGZvbnQ6IHtcbiAgICAgIGZhbWlseTogbWF0LWZvbnQtZmFtaWx5KCRjb25maWcsIGJvZHktMSk7XG4gICAgICBzaXplOiBtYXQtZm9udC1zaXplKCRjb25maWcsIGJvZHktMSk7XG4gICAgICB3ZWlnaHQ6IG1hdC1mb250LXdlaWdodCgkY29uZmlnLCBib2R5LTEpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cblxuQG1peGluIG1hdC1wYWdpbmF0b3ItdGhlbWUoJHRoZW1lKSB7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG4gICRiYWNrZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgYmFja2dyb3VuZCk7XG5cbiAgLm1hdC1wYWdpbmF0b3Ige1xuICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgJ2NhcmQnKTtcbiAgfVxuXG4gIC5tYXQtcGFnaW5hdG9yLFxuICAubWF0LXBhZ2luYXRvci1wYWdlLXNpemUgLm1hdC1zZWxlY3QtdHJpZ2dlciB7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgc2Vjb25kYXJ5LXRleHQpO1xuICB9XG5cbiAgLm1hdC1wYWdpbmF0b3ItZGVjcmVtZW50LFxuICAubWF0LXBhZ2luYXRvci1pbmNyZW1lbnQge1xuICAgIGJvcmRlci10b3A6IDJweCBzb2xpZCBtYXQtY29sb3IoJGZvcmVncm91bmQsICdpY29uJyk7XG4gICAgYm9yZGVyLXJpZ2h0OiAycHggc29saWQgbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCAnaWNvbicpO1xuICB9XG5cbiAgLm1hdC1wYWdpbmF0b3ItZmlyc3QsXG4gIC5tYXQtcGFnaW5hdG9yLWxhc3Qge1xuICAgIGJvcmRlci10b3A6IDJweCBzb2xpZCBtYXQtY29sb3IoJGZvcmVncm91bmQsICdpY29uJyk7XG4gIH1cblxuICAubWF0LWljb24tYnV0dG9uW2Rpc2FibGVkXSB7XG4gICAgLm1hdC1wYWdpbmF0b3ItZGVjcmVtZW50LFxuICAgIC5tYXQtcGFnaW5hdG9yLWluY3JlbWVudCxcbiAgICAubWF0LXBhZ2luYXRvci1maXJzdCxcbiAgICAubWF0LXBhZ2luYXRvci1sYXN0IHtcbiAgICAgIGJvcmRlci1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCAnZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuQG1peGluIG1hdC1wYWdpbmF0b3ItdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC5tYXQtcGFnaW5hdG9yLFxuICAubWF0LXBhZ2luYXRvci1wYWdlLXNpemUgLm1hdC1zZWxlY3QtdHJpZ2dlciB7XG4gICAgZm9udDoge1xuICAgICAgZmFtaWx5OiBtYXQtZm9udC1mYW1pbHkoJGNvbmZpZywgY2FwdGlvbik7XG4gICAgICBzaXplOiBtYXQtZm9udC1zaXplKCRjb25maWcsIGNhcHRpb24pO1xuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cbkBtaXhpbiBtYXQtcHJvZ3Jlc3MtYmFyLXRoZW1lKCR0aGVtZSkge1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcblxuICAubWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5kIHtcbiAgICBmaWxsOiBtYXQtY29sb3IoJHByaW1hcnksIGxpZ2h0ZXIpO1xuICB9XG5cbiAgLm1hdC1wcm9ncmVzcy1iYXItYnVmZmVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBtYXQtY29sb3IoJHByaW1hcnksIGxpZ2h0ZXIpO1xuICB9XG5cbiAgLm1hdC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkcHJpbWFyeSk7XG4gIH1cblxuICAubWF0LXByb2dyZXNzLWJhci5tYXQtYWNjZW50IHtcbiAgICAubWF0LXByb2dyZXNzLWJhci1iYWNrZ3JvdW5kIHtcbiAgICAgIGZpbGw6IG1hdC1jb2xvcigkYWNjZW50LCBsaWdodGVyKTtcbiAgICB9XG5cbiAgICAubWF0LXByb2dyZXNzLWJhci1idWZmZXIge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRhY2NlbnQsIGxpZ2h0ZXIpO1xuICAgIH1cblxuICAgIC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVyIHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkYWNjZW50KTtcbiAgICB9XG4gIH1cblxuICAubWF0LXByb2dyZXNzLWJhci5tYXQtd2FybiB7XG4gICAgLm1hdC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZCB7XG4gICAgICBmaWxsOiBtYXQtY29sb3IoJHdhcm4sIGxpZ2h0ZXIpO1xuICAgIH1cblxuICAgIC5tYXQtcHJvZ3Jlc3MtYmFyLWJ1ZmZlciB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiBtYXQtY29sb3IoJHdhcm4sIGxpZ2h0ZXIpO1xuICAgIH1cblxuICAgIC5tYXQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVyIHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkd2Fybik7XG4gICAgfVxuICB9XG59XG5cbkBtaXhpbiBtYXQtcHJvZ3Jlc3MtYmFyLXR5cG9ncmFwaHkoJGNvbmZpZykgeyB9XG5cblxuXG5cblxuXG5AbWl4aW4gbWF0LXByb2dyZXNzLXNwaW5uZXItdGhlbWUoJHRoZW1lKSB7XG4gICRwcmltYXJ5OiBtYXAtZ2V0KCR0aGVtZSwgcHJpbWFyeSk7XG4gICRhY2NlbnQ6IG1hcC1nZXQoJHRoZW1lLCBhY2NlbnQpO1xuICAkd2FybjogbWFwLWdldCgkdGhlbWUsIHdhcm4pO1xuXG4gIC5tYXQtcHJvZ3Jlc3Mtc3Bpbm5lciwgLm1hdC1zcGlubmVyIHtcbiAgICBjaXJjbGUge1xuICAgICAgc3Ryb2tlOiBtYXQtY29sb3IoJHByaW1hcnkpO1xuICAgIH1cblxuICAgICYubWF0LWFjY2VudCBjaXJjbGUge1xuICAgICAgc3Ryb2tlOiBtYXQtY29sb3IoJGFjY2VudCk7XG4gICAgfVxuXG4gICAgJi5tYXQtd2FybiBjaXJjbGUge1xuICAgICAgc3Ryb2tlOiBtYXQtY29sb3IoJHdhcm4pO1xuICAgIH1cbiAgfVxufVxuXG5AbWl4aW4gbWF0LXByb2dyZXNzLXNwaW5uZXItdHlwb2dyYXBoeSgkY29uZmlnKSB7IH1cblxuXG5cblxuXG5AbWl4aW4gX21hdC1yYWRpby1jb2xvcigkcGFsZXR0ZSkge1xuICAmLm1hdC1yYWRpby1jaGVja2VkIC5tYXQtcmFkaW8tb3V0ZXItY2lyY2xlIHtcbiAgICBib3JkZXItY29sb3I6IG1hdC1jb2xvcigkcGFsZXR0ZSk7XG4gIH1cblxuICAubWF0LXJhZGlvLWlubmVyLWNpcmNsZSxcbiAgLm1hdC1yYWRpby1yaXBwbGUgLm1hdC1yaXBwbGUtZWxlbWVudDpub3QoLm1hdC1yYWRpby1wZXJzaXN0ZW50LXJpcHBsZSksXG4gICYubWF0LXJhZGlvLWNoZWNrZWQgLm1hdC1yYWRpby1wZXJzaXN0ZW50LXJpcHBsZSxcbiAgJjphY3RpdmUgLm1hdC1yYWRpby1wZXJzaXN0ZW50LXJpcHBsZSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRwYWxldHRlKTtcbiAgfVxufVxuXG5AbWl4aW4gbWF0LXJhZGlvLXRoZW1lKCR0aGVtZSkge1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAubWF0LXJhZGlvLW91dGVyLWNpcmNsZSB7XG4gICAgYm9yZGVyLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHNlY29uZGFyeS10ZXh0KTtcbiAgfVxuXG4gIC5tYXQtcmFkaW8tYnV0dG9uIHtcbiAgICAmLm1hdC1wcmltYXJ5IHtcbiAgICAgIEBpbmNsdWRlIF9tYXQtcmFkaW8tY29sb3IoJHByaW1hcnkpO1xuICAgIH1cblxuICAgICYubWF0LWFjY2VudCB7XG4gICAgICBAaW5jbHVkZSBfbWF0LXJhZGlvLWNvbG9yKCRhY2NlbnQpO1xuICAgIH1cblxuICAgICYubWF0LXdhcm4ge1xuICAgICAgQGluY2x1ZGUgX21hdC1yYWRpby1jb2xvcigkd2Fybik7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBuZWVkcyBleHRyYSBzcGVjaWZpY2l0eSwgYmVjYXVzZSB0aGUgY2xhc3NlcyBhYm92ZSBhcmUgY29tYmluZWRcbiAgICAvLyAoZS5nLiBgLm1hdC1yYWRpby1idXR0b24ubWF0LWFjY2VudGApIHdoaWNoIGluY3JlYXNlcyB0aGVpciBzcGVjaWZpY2l0eSBhIGxvdC5cbiAgICAvLyBUT0RPOiBjb25zaWRlciBtYWtpbmcgdGhlIHNlbGVjdG9ycyBpbnRvIGRlc2NlbmRhbnRzIChgLm1hdC1wcmltYXJ5IC5tYXQtcmFkaW8tYnV0dG9uYCkuXG4gICAgJi5tYXQtcmFkaW8tZGlzYWJsZWQge1xuICAgICAgJi5tYXQtcmFkaW8tY2hlY2tlZCAubWF0LXJhZGlvLW91dGVyLWNpcmNsZSxcbiAgICAgIC5tYXQtcmFkaW8tb3V0ZXItY2lyY2xlIHtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpc2FibGVkKTtcbiAgICAgIH1cblxuICAgICAgLm1hdC1yYWRpby1yaXBwbGUgLm1hdC1yaXBwbGUtZWxlbWVudCxcbiAgICAgIC5tYXQtcmFkaW8taW5uZXItY2lyY2xlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBkaXNhYmxlZCk7XG4gICAgICB9XG5cbiAgICAgIC5tYXQtcmFkaW8tbGFiZWwtY29udGVudCB7XG4gICAgICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpc2FibGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTd2l0Y2ggdGhpcyB0byBhIHNvbGlkIGNvbG9yIHNpbmNlIHdlJ3JlIHVzaW5nIGBvcGFjaXR5YFxuICAgIC8vIHRvIGNvbnRyb2wgaG93IG9wYXF1ZSB0aGUgcmlwcGxlIHNob3VsZCBiZS5cbiAgICAubWF0LXJpcHBsZS1lbGVtZW50IHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hcF9nZXQoJGZvcmVncm91bmQsIGJhc2UpO1xuICAgIH1cbiAgfVxufVxuXG5AbWl4aW4gbWF0LXJhZGlvLXR5cG9ncmFwaHkoJGNvbmZpZykge1xuICAubWF0LXJhZGlvLWJ1dHRvbiB7XG4gICAgZm9udC1mYW1pbHk6IG1hdC1mb250LWZhbWlseSgkY29uZmlnKTtcbiAgfVxufVxuXG5cblxuXG5cblxuXG5cbkBtaXhpbiBtYXQtc2VsZWN0LXRoZW1lKCR0aGVtZSkge1xuICAkZm9yZWdyb3VuZDogbWFwLWdldCgkdGhlbWUsIGZvcmVncm91bmQpO1xuICAkYmFja2dyb3VuZDogbWFwLWdldCgkdGhlbWUsIGJhY2tncm91bmQpO1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcblxuICAubWF0LXNlbGVjdC12YWx1ZSB7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG4gIH1cblxuICAubWF0LXNlbGVjdC1wbGFjZWhvbGRlciB7XG4gICAgY29sb3I6IF9tYXQtY29udHJvbC1wbGFjZWhvbGRlci1jb2xvcigkdGhlbWUpO1xuICB9XG5cbiAgLm1hdC1zZWxlY3QtZGlzYWJsZWQgLm1hdC1zZWxlY3QtdmFsdWUge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpc2FibGVkLXRleHQpO1xuICB9XG5cbiAgLm1hdC1zZWxlY3QtYXJyb3cge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHNlY29uZGFyeS10ZXh0KTtcbiAgfVxuXG4gIC5tYXQtc2VsZWN0LXBhbmVsIHtcbiAgICBiYWNrZ3JvdW5kOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGNhcmQpO1xuICAgIEBpbmNsdWRlIF9tYXQtdGhlbWUtb3ZlcnJpZGFibGUtZWxldmF0aW9uKDQsICR0aGVtZSk7XG5cbiAgICAubWF0LW9wdGlvbi5tYXQtc2VsZWN0ZWQ6bm90KC5tYXQtb3B0aW9uLW11bHRpcGxlKSB7XG4gICAgICBiYWNrZ3JvdW5kOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGhvdmVyLCAwLjEyKTtcbiAgICB9XG4gIH1cblxuICAubWF0LWZvcm0tZmllbGQge1xuICAgICYubWF0LWZvY3VzZWQge1xuICAgICAgJi5tYXQtcHJpbWFyeSAubWF0LXNlbGVjdC1hcnJvdyB7XG4gICAgICAgIGNvbG9yOiBtYXQtY29sb3IoJHByaW1hcnkpO1xuICAgICAgfVxuXG4gICAgICAmLm1hdC1hY2NlbnQgLm1hdC1zZWxlY3QtYXJyb3cge1xuICAgICAgICBjb2xvcjogbWF0LWNvbG9yKCRhY2NlbnQpO1xuICAgICAgfVxuXG4gICAgICAmLm1hdC13YXJuIC5tYXQtc2VsZWN0LWFycm93IHtcbiAgICAgICAgY29sb3I6IG1hdC1jb2xvcigkd2Fybik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLm1hdC1zZWxlY3QubWF0LXNlbGVjdC1pbnZhbGlkIC5tYXQtc2VsZWN0LWFycm93IHtcbiAgICAgIGNvbG9yOiBtYXQtY29sb3IoJHdhcm4pO1xuICAgIH1cblxuICAgIC5tYXQtc2VsZWN0Lm1hdC1zZWxlY3QtZGlzYWJsZWQgLm1hdC1zZWxlY3QtYXJyb3cge1xuICAgICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGlzYWJsZWQtdGV4dCk7XG4gICAgfVxuICB9XG59XG5cbkBtaXhpbiBtYXQtc2VsZWN0LXR5cG9ncmFwaHkoJGNvbmZpZykge1xuICAvLyBUaGUgdW5pdC1sZXNzIGxpbmUtaGVpZ2h0IGZyb20gdGhlIGZvbnQgY29uZmlnLlxuICAkbGluZS1oZWlnaHQ6IG1hdC1saW5lLWhlaWdodCgkY29uZmlnLCBpbnB1dCk7XG5cbiAgLm1hdC1zZWxlY3Qge1xuICAgIGZvbnQtZmFtaWx5OiBtYXQtZm9udC1mYW1pbHkoJGNvbmZpZyk7XG4gIH1cblxuICAubWF0LXNlbGVjdC10cmlnZ2VyIHtcbiAgICBoZWlnaHQ6ICRsaW5lLWhlaWdodCAqIDFlbTtcbiAgfVxufVxuXG5cblxuXG5cblxuQG1peGluIG1hdC1zaWRlbmF2LXRoZW1lKCR0aGVtZSkge1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAkZHJhd2VyLWJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgZGlhbG9nKTtcbiAgJGRyYXdlci1jb250YWluZXItYmFja2dyb3VuZC1jb2xvcjogIG1hdC1jb2xvcigkYmFja2dyb3VuZCwgYmFja2dyb3VuZCk7XG4gICRkcmF3ZXItcHVzaC1iYWNrZ3JvdW5kLWNvbG9yOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGRpYWxvZyk7XG4gICRkcmF3ZXItc2lkZS1ib3JkZXI6IHNvbGlkIDFweCBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpdmlkZXIpO1xuXG4gIC5tYXQtZHJhd2VyLWNvbnRhaW5lciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJGRyYXdlci1jb250YWluZXItYmFja2dyb3VuZC1jb2xvcjtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCB0ZXh0KTtcbiAgfVxuXG4gIC5tYXQtZHJhd2VyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZHJhd2VyLWJhY2tncm91bmQtY29sb3I7XG4gICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG5cbiAgICAmLm1hdC1kcmF3ZXItcHVzaCB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZHJhd2VyLXB1c2gtYmFja2dyb3VuZC1jb2xvcjtcbiAgICB9XG5cbiAgICAmOm5vdCgubWF0LWRyYXdlci1zaWRlKSB7XG4gICAgICAvLyBUaGUgZWxldmF0aW9uIG9mIHotMTYgaXMgbm90ZWQgaW4gdGhlIGRlc2lnbiBzcGVjaWZpY2F0aW9ucy5cbiAgICAgIC8vIFNlZSBodHRwczovL21hdGVyaWFsLmlvL2Rlc2lnbi9jb21wb25lbnRzL25hdmlnYXRpb24tZHJhd2VyLmh0bWxcbiAgICAgIEBpbmNsdWRlIF9tYXQtdGhlbWUtZWxldmF0aW9uKDE2LCAkdGhlbWUpO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtZHJhd2VyLXNpZGUge1xuICAgIGJvcmRlci1yaWdodDogJGRyYXdlci1zaWRlLWJvcmRlcjtcblxuICAgICYubWF0LWRyYXdlci1lbmQge1xuICAgICAgYm9yZGVyLWxlZnQ6ICRkcmF3ZXItc2lkZS1ib3JkZXI7XG4gICAgICBib3JkZXItcmlnaHQ6IG5vbmU7XG4gICAgfVxuICB9XG5cbiAgW2Rpcj0ncnRsJ10gLm1hdC1kcmF3ZXItc2lkZSB7XG4gICAgYm9yZGVyLWxlZnQ6ICRkcmF3ZXItc2lkZS1ib3JkZXI7XG4gICAgYm9yZGVyLXJpZ2h0OiBub25lO1xuXG4gICAgJi5tYXQtZHJhd2VyLWVuZCB7XG4gICAgICBib3JkZXItbGVmdDogbm9uZTtcbiAgICAgIGJvcmRlci1yaWdodDogJGRyYXdlci1zaWRlLWJvcmRlcjtcbiAgICB9XG4gIH1cblxuICAubWF0LWRyYXdlci1iYWNrZHJvcC5tYXQtZHJhd2VyLXNob3duIHtcbiAgICAkb3BhY2l0eTogMC42O1xuICAgICRiYWNrZHJvcC1jb2xvcjogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCBjYXJkLCAkb3BhY2l0eSk7XG5cbiAgICBAaWYgKHR5cGUtb2YoJGJhY2tkcm9wLWNvbG9yKSA9PSBjb2xvcikge1xuICAgICAgLy8gV2UgdXNlIGludmVydCgpIGhlcmUgdG8gaGF2ZSB0aGUgZGFya2VuIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGV4cGVjdGVkIHRvIGJlIHVzZWQuIElmIHRoZVxuICAgICAgLy8gYmFja2dyb3VuZCBpcyBsaWdodCwgd2UgdXNlIGEgZGFyayBiYWNrZHJvcC4gSWYgdGhlIGJhY2tncm91bmQgaXMgZGFyayxcbiAgICAgIC8vIHdlIHVzZSBhIGxpZ2h0IGJhY2tkcm9wLlxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogaW52ZXJ0KCRiYWNrZHJvcC1jb2xvcik7XG4gICAgfVxuICAgIEBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGNvdWxkbid0IHJlc29sdmUgdGhlIGJhY2tkcm9wIGNvbG9yIHRvIGEgY29sb3IgdmFsdWUsIGZhbGwgYmFjayB0byB1c2luZ1xuICAgICAgLy8gYG9wYWNpdHlgIHRvIG1ha2UgaXQgb3BhcXVlIHNpbmNlIGl0cyBlbmQgdmFsdWUgY291bGQgYmUgYSBzb2xpZCBjb2xvci5cbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICRiYWNrZHJvcC1jb2xvcjtcbiAgICAgIG9wYWNpdHk6ICRvcGFjaXR5O1xuICAgIH1cbiAgfVxufVxuXG5AbWl4aW4gbWF0LXNpZGVuYXYtdHlwb2dyYXBoeSgkY29uZmlnKSB7IH1cblxuXG5cblxuXG5cbkBtaXhpbiBfbWF0LXNsaWRlLXRvZ2dsZS1jaGVja2VkKCRwYWxldHRlLCAkdGh1bWItY2hlY2tlZC1odWUpIHtcbiAgJi5tYXQtY2hlY2tlZCB7XG4gICAgLm1hdC1zbGlkZS10b2dnbGUtdGh1bWIge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRwYWxldHRlLCAkdGh1bWItY2hlY2tlZC1odWUpO1xuICAgIH1cblxuICAgIC5tYXQtc2xpZGUtdG9nZ2xlLWJhciB7XG4gICAgICAvLyBPcGFjaXR5IGlzIGRldGVybWluZWQgZnJvbSB0aGUgc3BlY3MgZm9yIHRoZSBzZWxlY3Rpb24gY29udHJvbHMuXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL2NvbXBvbmVudHMvc2VsZWN0aW9uLWNvbnRyb2xzLmh0bWwjc3BlY3NcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkcGFsZXR0ZSwgJHRodW1iLWNoZWNrZWQtaHVlLCAwLjU0KTtcbiAgICB9XG5cbiAgICAubWF0LXJpcHBsZS1lbGVtZW50IHtcbiAgICAgIC8vIFNldCBubyBvcGFjaXR5IGZvciB0aGUgcmlwcGxlcyBiZWNhdXNlIHRoZSByaXBwbGUgb3BhY2l0eSB3aWxsIGJlIGFkanVzdGVkIGR5bmFtaWNhbGx5XG4gICAgICAvLyBiYXNlZCBvbiB0aGUgdHlwZSBvZiBpbnRlcmFjdGlvbiB3aXRoIHRoZSBzbGlkZS10b2dnbGUgKGUuZy4gZm9yIGhvdmVyLCBmb2N1cylcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkcGFsZXR0ZSwgJHRodW1iLWNoZWNrZWQtaHVlKTtcbiAgICB9XG4gIH1cbn1cblxuQG1peGluIG1hdC1zbGlkZS10b2dnbGUtdGhlbWUoJHRoZW1lKSB7XG4gICRpcy1kYXJrOiBtYXBfZ2V0KCR0aGVtZSwgaXMtZGFyayk7XG4gICRwcmltYXJ5OiBtYXAtZ2V0KCR0aGVtZSwgcHJpbWFyeSk7XG4gICRhY2NlbnQ6IG1hcC1nZXQoJHRoZW1lLCBhY2NlbnQpO1xuICAkd2FybjogbWFwLWdldCgkdGhlbWUsIHdhcm4pO1xuICAkYmFja2dyb3VuZDogbWFwLWdldCgkdGhlbWUsIGJhY2tncm91bmQpO1xuICAkZm9yZWdyb3VuZDogbWFwLWdldCgkdGhlbWUsIGZvcmVncm91bmQpO1xuXG4gIC8vIENvbG9yIGh1ZXMgYXJlIGJhc2VkIG9uIHRoZSBzcGVjcyB3aGljaCBicmllZmx5IHNob3cgdGhlIGh1ZXMgdGhhdCBhcmUgYXBwbGllZCB0byBhIHN3aXRjaC5cbiAgLy8gVGhlIDIwMTggc3BlY3Mgbm8gbG9uZ2VyIGRlc2NyaWJlIGhvdyBkYXJrIHN3aXRjaGVzIHNob3VsZCBsb29rIGxpa2UuIER1ZSB0byB0aGUgbGFjayBvZlxuICAvLyBpbmZvcm1hdGlvbiBmb3IgZGFyayB0aGVtZWQgc3dpdGNoZXMsIHdlIHBhcnRpYWxseSBrZWVwIHRoZSBvbGQgYmVoYXZpb3IgdGhhdCBpcyBiYXNlZCBvblxuICAvLyB0aGUgcHJldmlvdXMgc3BlY2lmaWNhdGlvbnMuIEZvciB0aGUgY2hlY2tlZCBjb2xvciB3ZSBhbHdheXMgdXNlIHRoZSBgZGVmYXVsdGAgaHVlIGJlY2F1c2VcbiAgLy8gdGhhdCBmb2xsb3dzIE1EQyBhbmQgYWxzbyBtYWtlcyBpdCBlYXNpZXIgZm9yIHBlb3BsZSB0byBjcmVhdGUgYSBjdXN0b20gdGhlbWUgd2l0aG91dCBuZWVkaW5nXG4gIC8vIHRvIHNwZWNpZnkgZWFjaCBodWUgaW5kaXZpZHVhbGx5LlxuICAkdGh1bWItdW5jaGVja2VkLWh1ZTogaWYoJGlzLWRhcmssIDQwMCwgNTApO1xuICAkdGh1bWItY2hlY2tlZC1odWU6IGRlZmF1bHQ7XG5cbiAgJGJhci11bmNoZWNrZWQtY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGlzYWJsZWQpO1xuICAkcmlwcGxlLXVuY2hlY2tlZC1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBiYXNlKTtcblxuICAubWF0LXNsaWRlLXRvZ2dsZSB7XG4gICAgQGluY2x1ZGUgX21hdC1zbGlkZS10b2dnbGUtY2hlY2tlZCgkYWNjZW50LCAkdGh1bWItY2hlY2tlZC1odWUpO1xuXG4gICAgJi5tYXQtcHJpbWFyeSB7XG4gICAgICBAaW5jbHVkZSBfbWF0LXNsaWRlLXRvZ2dsZS1jaGVja2VkKCRwcmltYXJ5LCAkdGh1bWItY2hlY2tlZC1odWUpO1xuICAgIH1cblxuICAgICYubWF0LXdhcm4ge1xuICAgICAgQGluY2x1ZGUgX21hdC1zbGlkZS10b2dnbGUtY2hlY2tlZCgkd2FybiwgJHRodW1iLWNoZWNrZWQtaHVlKTtcbiAgICB9XG5cbiAgICAmOm5vdCgubWF0LWNoZWNrZWQpIC5tYXQtcmlwcGxlLWVsZW1lbnQge1xuICAgICAgLy8gU2V0IG5vIG9wYWNpdHkgZm9yIHRoZSByaXBwbGVzIGJlY2F1c2UgdGhlIHJpcHBsZSBvcGFjaXR5IHdpbGwgYmUgYWRqdXN0ZWQgZHluYW1pY2FsbHlcbiAgICAgIC8vIGJhc2VkIG9uIHRoZSB0eXBlIG9mIGludGVyYWN0aW9uIHdpdGggdGhlIHNsaWRlLXRvZ2dsZSAoZS5nLiBmb3IgaG92ZXIsIGZvY3VzKVxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHJpcHBsZS11bmNoZWNrZWQtY29sb3I7XG4gICAgfVxuICB9XG5cbiAgLm1hdC1zbGlkZS10b2dnbGUtdGh1bWIge1xuICAgIEBpbmNsdWRlIF9tYXQtdGhlbWUtZWxldmF0aW9uKDEsICR0aGVtZSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRtYXQtZ3JleSwgJHRodW1iLXVuY2hlY2tlZC1odWUpO1xuICB9XG5cbiAgLm1hdC1zbGlkZS10b2dnbGUtYmFyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkYmFyLXVuY2hlY2tlZC1jb2xvcjtcbiAgfVxufVxuXG5AbWl4aW4gbWF0LXNsaWRlLXRvZ2dsZS10eXBvZ3JhcGh5KCRjb25maWcpIHtcbiAgLm1hdC1zbGlkZS10b2dnbGUtY29udGVudCB7XG4gICAgZm9udC1mYW1pbHk6IG1hdC1mb250LWZhbWlseSgkY29uZmlnKTtcbiAgfVxufVxuXG5cblxuXG5cbkBtaXhpbiBfbWF0LXNsaWRlci1pbm5lci1jb250ZW50LXRoZW1lKCRwYWxldHRlKSB7XG4gIC5tYXQtc2xpZGVyLXRyYWNrLWZpbGwsXG4gIC5tYXQtc2xpZGVyLXRodW1iLFxuICAubWF0LXNsaWRlci10aHVtYi1sYWJlbCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRwYWxldHRlKTtcbiAgfVxuXG4gIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHQge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJHBhbGV0dGUsIGRlZmF1bHQtY29udHJhc3QpO1xuICB9XG59XG5cbkBtaXhpbiBtYXQtc2xpZGVyLXRoZW1lKCR0aGVtZSkge1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAkbWF0LXNsaWRlci1vZmYtY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgc2xpZGVyLW9mZik7XG4gICRtYXQtc2xpZGVyLW9mZi1mb2N1c2VkLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHNsaWRlci1vZmYtYWN0aXZlKTtcbiAgJG1hdC1zbGlkZXItZGlzYWJsZWQtY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgc2xpZGVyLW9mZik7XG4gICRtYXQtc2xpZGVyLWxhYmVsZWQtbWluLXZhbHVlLXRodW1iLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHNsaWRlci1taW4pO1xuICAkbWF0LXNsaWRlci1sYWJlbGVkLW1pbi12YWx1ZS10aHVtYi1sYWJlbC1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBzbGlkZXItb2ZmKTtcbiAgJG1hdC1zbGlkZXItZm9jdXMtcmluZy1jb2xvcjogbWF0LWNvbG9yKCRhY2NlbnQsIGRlZmF1bHQsIDAuMik7XG4gICRtYXQtc2xpZGVyLWZvY3VzLXJpbmctbWluLXZhbHVlLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGJhc2UsIDAuMTIpO1xuICAkbWF0LXNsaWRlci10aWNrLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGJhc2UsIDAuNyk7XG4gICRtYXQtc2xpZGVyLXRpY2stc2l6ZTogMnB4O1xuXG4gIC5tYXQtc2xpZGVyLXRyYWNrLWJhY2tncm91bmQge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICRtYXQtc2xpZGVyLW9mZi1jb2xvcjtcbiAgfVxuXG4gIC5tYXQtcHJpbWFyeSB7XG4gICAgQGluY2x1ZGUgX21hdC1zbGlkZXItaW5uZXItY29udGVudC10aGVtZSgkcHJpbWFyeSk7XG4gIH1cblxuICAubWF0LWFjY2VudCB7XG4gICAgQGluY2x1ZGUgX21hdC1zbGlkZXItaW5uZXItY29udGVudC10aGVtZSgkYWNjZW50KTtcbiAgfVxuXG4gIC5tYXQtd2FybiB7XG4gICAgQGluY2x1ZGUgX21hdC1zbGlkZXItaW5uZXItY29udGVudC10aGVtZSgkd2Fybik7XG4gIH1cblxuICAubWF0LXNsaWRlci1mb2N1cy1yaW5nIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkbWF0LXNsaWRlci1mb2N1cy1yaW5nLWNvbG9yO1xuICB9XG5cbiAgLm1hdC1zbGlkZXI6aG92ZXIsXG4gIC5jZGstZm9jdXNlZCB7XG4gICAgLm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZCB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkbWF0LXNsaWRlci1vZmYtZm9jdXNlZC1jb2xvcjtcbiAgICB9XG4gIH1cblxuICAubWF0LXNsaWRlci1kaXNhYmxlZCB7XG4gICAgLm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZCxcbiAgICAubWF0LXNsaWRlci10cmFjay1maWxsLFxuICAgIC5tYXQtc2xpZGVyLXRodW1iIHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICRtYXQtc2xpZGVyLWRpc2FibGVkLWNvbG9yO1xuICAgIH1cblxuICAgICY6aG92ZXIge1xuICAgICAgLm1hdC1zbGlkZXItdHJhY2stYmFja2dyb3VuZCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRtYXQtc2xpZGVyLWRpc2FibGVkLWNvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC5tYXQtc2xpZGVyLW1pbi12YWx1ZSB7XG4gICAgLm1hdC1zbGlkZXItZm9jdXMtcmluZyB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkbWF0LXNsaWRlci1mb2N1cy1yaW5nLW1pbi12YWx1ZS1jb2xvcjtcbiAgICB9XG5cbiAgICAmLm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZyB7XG4gICAgICAubWF0LXNsaWRlci10aHVtYixcbiAgICAgIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVsIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJG1hdC1zbGlkZXItbGFiZWxlZC1taW4tdmFsdWUtdGh1bWItY29sb3I7XG4gICAgICB9XG5cbiAgICAgICYuY2RrLWZvY3VzZWQge1xuICAgICAgICAubWF0LXNsaWRlci10aHVtYixcbiAgICAgICAgLm1hdC1zbGlkZXItdGh1bWItbGFiZWwge1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICRtYXQtc2xpZGVyLWxhYmVsZWQtbWluLXZhbHVlLXRodW1iLWxhYmVsLWNvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgJjpub3QoLm1hdC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZykge1xuICAgICAgLm1hdC1zbGlkZXItdGh1bWIge1xuICAgICAgICBib3JkZXItY29sb3I6ICRtYXQtc2xpZGVyLW9mZi1jb2xvcjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgICY6aG92ZXIsXG4gICAgICAmLmNkay1mb2N1c2VkIHtcbiAgICAgICAgLm1hdC1zbGlkZXItdGh1bWIge1xuICAgICAgICAgIGJvcmRlci1jb2xvcjogJG1hdC1zbGlkZXItb2ZmLWZvY3VzZWQtY29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICAmLm1hdC1zbGlkZXItZGlzYWJsZWQgLm1hdC1zbGlkZXItdGh1bWIge1xuICAgICAgICAgIGJvcmRlci1jb2xvcjogJG1hdC1zbGlkZXItZGlzYWJsZWQtY29sb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAubWF0LXNsaWRlci1oYXMtdGlja3MgLm1hdC1zbGlkZXItd3JhcHBlcjo6YWZ0ZXIge1xuICAgIGJvcmRlci1jb2xvcjogJG1hdC1zbGlkZXItdGljay1jb2xvcjtcbiAgfVxuXG4gIC5tYXQtc2xpZGVyLWhvcml6b250YWwgLm1hdC1zbGlkZXItdGlja3Mge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IHJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICRtYXQtc2xpZGVyLXRpY2stY29sb3IsXG4gICAgICAgICRtYXQtc2xpZGVyLXRpY2stY29sb3IgJG1hdC1zbGlkZXItdGljay1zaXplLCB0cmFuc3BhcmVudCAwLCB0cmFuc3BhcmVudCk7XG4gICAgLy8gRmlyZWZveCBkb2Vzbid0IGRyYXcgdGhlIGdyYWRpZW50IGNvcnJlY3RseSB3aXRoICd0byByaWdodCdcbiAgICAvLyAoc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzMTQzMTkpLlxuICAgIGJhY2tncm91bmQtaW1hZ2U6IC1tb3otcmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCgwLjAwMDFkZWcsICRtYXQtc2xpZGVyLXRpY2stY29sb3IsXG4gICAgICAgICRtYXQtc2xpZGVyLXRpY2stY29sb3IgJG1hdC1zbGlkZXItdGljay1zaXplLCB0cmFuc3BhcmVudCAwLCB0cmFuc3BhcmVudCk7XG4gIH1cblxuICAubWF0LXNsaWRlci12ZXJ0aWNhbCAubWF0LXNsaWRlci10aWNrcyB7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogcmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCh0byBib3R0b20sICRtYXQtc2xpZGVyLXRpY2stY29sb3IsXG4gICAgICAgICRtYXQtc2xpZGVyLXRpY2stY29sb3IgJG1hdC1zbGlkZXItdGljay1zaXplLCB0cmFuc3BhcmVudCAwLCB0cmFuc3BhcmVudCk7XG4gIH1cbn1cblxuQG1peGluIG1hdC1zbGlkZXItdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC5tYXQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHQge1xuICAgIGZvbnQ6IHtcbiAgICAgIGZhbWlseTogbWF0LWZvbnQtZmFtaWx5KCRjb25maWcpO1xuICAgICAgc2l6ZTogbWF0LWZvbnQtc2l6ZSgkY29uZmlnLCBjYXB0aW9uKTtcbiAgICAgIHdlaWdodDogbWF0LWZvbnQtd2VpZ2h0KCRjb25maWcsIGJvZHktMik7XG4gICAgfVxuICB9XG59XG5cblxuXG5cblxuQG1peGluIG1hdC1zdGVwcGVyLXRoZW1lKCR0aGVtZSkge1xuICAkZm9yZWdyb3VuZDogbWFwLWdldCgkdGhlbWUsIGZvcmVncm91bmQpO1xuICAkYmFja2dyb3VuZDogbWFwLWdldCgkdGhlbWUsIGJhY2tncm91bmQpO1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkd2FybjogbWFwLWdldCgkdGhlbWUsIHdhcm4pO1xuXG4gIC5tYXQtc3RlcC1oZWFkZXIge1xuICAgICYuY2RrLWtleWJvYXJkLWZvY3VzZWQsXG4gICAgJi5jZGstcHJvZ3JhbS1mb2N1c2VkLFxuICAgICY6aG92ZXIge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLy8gT24gdG91Y2ggZGV2aWNlcyB0aGUgOmhvdmVyIHN0YXRlIHdpbGwgbGluZ2VyIG9uIHRoZSBlbGVtZW50IGFmdGVyIGEgdGFwLlxuICAgIC8vIFJlc2V0IGl0IHZpYSBgQG1lZGlhYCBhZnRlciB0aGUgZGVjbGFyYXRpb24sIGJlY2F1c2UgdGhlIG1lZGlhIHF1ZXJ5IGlzbid0XG4gICAgLy8gc3VwcG9ydGVkIGJ5IGFsbCBicm93c2VycyB5ZXQuXG4gICAgQG1lZGlhIChob3Zlcjogbm9uZSkge1xuICAgICAgJjpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLm1hdC1zdGVwLWxhYmVsLFxuICAgIC5tYXQtc3RlcC1vcHRpb25hbCB7XG4gICAgICAvLyBUT0RPKGpvc2VwaHBlcnJvdHQpOiBVcGRhdGUgdG8gdXNpbmcgYSBjb3JyZWN0ZWQgZGlzYWJsZWQtdGV4dCBjb250cmFzdFxuICAgICAgLy8gaW5zdGVhZCBvZiBzZWNvbmRhcnktdGV4dC5cbiAgICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHNlY29uZGFyeS10ZXh0KTtcbiAgICB9XG5cbiAgICAubWF0LXN0ZXAtaWNvbiB7XG4gICAgICAvLyBUT0RPKGpvc2VwaHBlcnJvdHQpOiBVcGRhdGUgdG8gdXNpbmcgYSBjb3JyZWN0ZWQgZGlzYWJsZWQtdGV4dCBjb250cmFzdFxuICAgICAgLy8gaW5zdGVhZCBvZiBzZWNvbmRhcnktdGV4dC5cbiAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgc2Vjb25kYXJ5LXRleHQpO1xuICAgICAgY29sb3I6IG1hdC1jb2xvcigkcHJpbWFyeSwgZGVmYXVsdC1jb250cmFzdCk7XG4gICAgfVxuXG4gICAgLm1hdC1zdGVwLWljb24tc2VsZWN0ZWQsXG4gICAgLm1hdC1zdGVwLWljb24tc3RhdGUtZG9uZSxcbiAgICAubWF0LXN0ZXAtaWNvbi1zdGF0ZS1lZGl0IHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkcHJpbWFyeSk7XG4gICAgICBjb2xvcjogbWF0LWNvbG9yKCRwcmltYXJ5LCBkZWZhdWx0LWNvbnRyYXN0KTtcbiAgICB9XG5cbiAgICAubWF0LXN0ZXAtaWNvbi1zdGF0ZS1lcnJvciB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgIGNvbG9yOiBtYXQtY29sb3IoJHdhcm4pO1xuICAgIH1cblxuICAgIC5tYXQtc3RlcC1sYWJlbC5tYXQtc3RlcC1sYWJlbC1hY3RpdmUge1xuICAgICAgY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG4gICAgfVxuXG4gICAgLm1hdC1zdGVwLWxhYmVsLm1hdC1zdGVwLWxhYmVsLWVycm9yIHtcbiAgICAgIGNvbG9yOiBtYXQtY29sb3IoJHdhcm4pO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtc3RlcHBlci1ob3Jpem9udGFsLCAubWF0LXN0ZXBwZXItdmVydGljYWwge1xuICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgY2FyZCk7XG4gIH1cblxuICAubWF0LXN0ZXBwZXItdmVydGljYWwtbGluZTo6YmVmb3JlIHtcbiAgICBib3JkZXItbGVmdC1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBkaXZpZGVyKTtcbiAgfVxuXG4gIC5tYXQtaG9yaXpvbnRhbC1zdGVwcGVyLWhlYWRlcjo6YmVmb3JlLFxuICAubWF0LWhvcml6b250YWwtc3RlcHBlci1oZWFkZXI6OmFmdGVyLFxuICAubWF0LXN0ZXBwZXItaG9yaXpvbnRhbC1saW5lIHtcbiAgICBib3JkZXItdG9wLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpdmlkZXIpO1xuICB9XG59XG5cbkBtaXhpbiBtYXQtc3RlcHBlci10eXBvZ3JhcGh5KCRjb25maWcpIHtcbiAgLm1hdC1zdGVwcGVyLXZlcnRpY2FsLCAubWF0LXN0ZXBwZXItaG9yaXpvbnRhbCB7XG4gICAgZm9udC1mYW1pbHk6IG1hdC1mb250LWZhbWlseSgkY29uZmlnKTtcbiAgfVxuXG4gIC5tYXQtc3RlcC1sYWJlbCB7XG4gICAgZm9udDoge1xuICAgICAgc2l6ZTogbWF0LWZvbnQtc2l6ZSgkY29uZmlnLCBib2R5LTEpO1xuICAgICAgd2VpZ2h0OiBtYXQtZm9udC13ZWlnaHQoJGNvbmZpZywgYm9keS0xKTtcbiAgICB9O1xuICB9XG5cbiAgLm1hdC1zdGVwLXN1Yi1sYWJlbC1lcnJvciB7XG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgfVxuXG4gIC5tYXQtc3RlcC1sYWJlbC1lcnJvciB7XG4gICAgZm9udC1zaXplOiBtYXQtZm9udC1zaXplKCRjb25maWcsIGJvZHktMik7XG4gIH1cblxuICAubWF0LXN0ZXAtbGFiZWwtc2VsZWN0ZWQge1xuICAgIGZvbnQ6IHtcbiAgICAgIHNpemU6IG1hdC1mb250LXNpemUoJGNvbmZpZywgYm9keS0yKTtcbiAgICAgIHdlaWdodDogbWF0LWZvbnQtd2VpZ2h0KCRjb25maWcsIGJvZHktMik7XG4gICAgfTtcbiAgfVxufVxuXG5AbWl4aW4gbWF0LXNvcnQtdGhlbWUoJHRoZW1lKSB7XG4gICRiYWNrZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgYmFja2dyb3VuZCk7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG5cbiAgLm1hdC1zb3J0LWhlYWRlci1hcnJvdyB7XG4gICAgJHRhYmxlLWJhY2tncm91bmQ6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgJ2NhcmQnKTtcbiAgICAkdGV4dC1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBzZWNvbmRhcnktdGV4dCk7XG5cbiAgICAvLyBCZWNhdXNlIHRoZSBhcnJvdyBpcyBtYWRlIHVwIG9mIG11bHRpcGxlIGVsZW1lbnRzIHRoYXQgYXJlIHN0YWNrZWQgb24gdG9wIG9mIGVhY2ggb3RoZXIsXG4gICAgLy8gd2UgY2FuJ3QgdXNlIHRoZSBzZW1pLXRyYXNwYXJlbnQgY29sb3IgZnJvbSB0aGUgdGhlbWUgZGlyZWN0bHkuIElmIHRoZSB2YWx1ZSBpcyBhIGNvbG9yXG4gICAgLy8gKnR5cGUqLCB3ZSBjb252ZXJ0IGl0IGludG8gYSBzb2xpZCBjb2xvciBieSB0YWtpbmcgdGhlIG9wYWNpdHkgZnJvbSB0aGUgcmdiYSB2YWx1ZSBhbmRcbiAgICAvLyB1c2luZyB0aGUgdmFsdWUgdG8gZGV0ZXJtaW5lIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBiYWNrZ3JvdW5kIHRvIHB1dCBpbnRvIGZvcmVncm91bmRcbiAgICAvLyB3aGVuIG1peGluZyB0aGUgY29sb3JzIHRvZ2V0aGVyLiBPdGhlcndpc2UsIGlmIGl0IHJlc29sdmVzIHRvIHNvbWV0aGluZyBkaWZmZXJlbnRcbiAgICAvLyAoZS5nLiBpdCByZXNvbHZlcyB0byBhIENTUyB2YXJpYWJsZSksIHdlIHVzZSB0aGUgY29sb3IgZGlyZWN0bHkuXG4gICAgQGlmICh0eXBlLW9mKCR0YWJsZS1iYWNrZ3JvdW5kKSA9PSBjb2xvciBhbmQgdHlwZS1vZigkdGV4dC1jb2xvcikgPT0gY29sb3IpIHtcbiAgICAgICR0ZXh0LW9wYWNpdHk6IG9wYWNpdHkoJHRleHQtY29sb3IpO1xuICAgICAgY29sb3I6IG1peCgkdGFibGUtYmFja2dyb3VuZCwgcmdiYSgkdGV4dC1jb2xvciwgMSksICgxIC0gJHRleHQtb3BhY2l0eSkgKiAxMDAlKTtcbiAgICB9XG4gICAgQGVsc2Uge1xuICAgICAgY29sb3I6ICR0ZXh0LWNvbG9yO1xuICAgIH1cbiAgfVxufVxuXG5AbWl4aW4gbWF0LXNvcnQtdHlwb2dyYXBoeSgkY29uZmlnKSB7IH1cblxuXG5cblxuXG5AbWl4aW4gbWF0LXRhYnMtdGhlbWUoJHRoZW1lKSB7XG4gICRwcmltYXJ5OiBtYXAtZ2V0KCR0aGVtZSwgcHJpbWFyeSk7XG4gICRhY2NlbnQ6IG1hcC1nZXQoJHRoZW1lLCBhY2NlbnQpO1xuICAkd2FybjogbWFwLWdldCgkdGhlbWUsIHdhcm4pO1xuICAkYmFja2dyb3VuZDogbWFwLWdldCgkdGhlbWUsIGJhY2tncm91bmQpO1xuICAkZm9yZWdyb3VuZDogbWFwLWdldCgkdGhlbWUsIGZvcmVncm91bmQpO1xuICAkaGVhZGVyLWJvcmRlcjogMXB4IHNvbGlkIG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGl2aWRlcik7XG5cbiAgLm1hdC10YWItbmF2LWJhcixcbiAgLm1hdC10YWItaGVhZGVyIHtcbiAgICBib3JkZXItYm90dG9tOiAkaGVhZGVyLWJvcmRlcjtcbiAgfVxuXG4gIC5tYXQtdGFiLWdyb3VwLWludmVydGVkLWhlYWRlciB7XG4gICAgLm1hdC10YWItbmF2LWJhcixcbiAgICAubWF0LXRhYi1oZWFkZXIge1xuICAgICAgYm9yZGVyLXRvcDogJGhlYWRlci1ib3JkZXI7XG4gICAgICBib3JkZXItYm90dG9tOiBub25lO1xuICAgIH1cbiAgfVxuXG4gIC5tYXQtdGFiLWxhYmVsLCAubWF0LXRhYi1saW5rIHtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCB0ZXh0KTtcblxuICAgICYubWF0LXRhYi1kaXNhYmxlZCB7XG4gICAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBkaXNhYmxlZC10ZXh0KTtcbiAgICB9XG4gIH1cblxuICAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9uIHtcbiAgICBib3JkZXItY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgdGV4dCk7XG4gIH1cblxuICAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1kaXNhYmxlZCAubWF0LXRhYi1oZWFkZXItcGFnaW5hdGlvbi1jaGV2cm9uIHtcbiAgICBib3JkZXItY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGlzYWJsZWQtdGV4dCk7XG4gIH1cblxuICAvLyBSZW1vdmUgaGVhZGVyIGJvcmRlciB3aGVuIHRoZXJlIGlzIGEgYmFja2dyb3VuZCBjb2xvclxuICAubWF0LXRhYi1ncm91cFtjbGFzcyo9J21hdC1iYWNrZ3JvdW5kLSddIC5tYXQtdGFiLWhlYWRlcixcbiAgLm1hdC10YWItbmF2LWJhcltjbGFzcyo9J21hdC1iYWNrZ3JvdW5kLSddIHtcbiAgICBib3JkZXItYm90dG9tOiBub25lO1xuICAgIGJvcmRlci10b3A6IG5vbmU7XG4gIH1cblxuICAubWF0LXRhYi1ncm91cCwgLm1hdC10YWItbmF2LWJhciB7XG4gICAgJHRoZW1lLWNvbG9yczogKFxuICAgICAgcHJpbWFyeTogJHByaW1hcnksXG4gICAgICBhY2NlbnQ6ICRhY2NlbnQsXG4gICAgICB3YXJuOiAkd2FyblxuICAgICk7XG5cbiAgICBAZWFjaCAkbmFtZSwgJGNvbG9yIGluICR0aGVtZS1jb2xvcnMge1xuICAgICAgLy8gU2V0IHRoZSBmb3JlZ3JvdW5kIGNvbG9yIG9mIHRoZSB0YWJzXG4gICAgICAmLm1hdC0jeyRuYW1lfSB7XG4gICAgICAgIEBpbmNsdWRlIF9tYXQtdGFiLWxhYmVsLWZvY3VzKCRjb2xvcik7XG4gICAgICAgIEBpbmNsdWRlIF9tYXQtaW5rLWJhcigkY29sb3IpO1xuXG4gICAgICAgIC8vIE92ZXJyaWRlIGluayBiYXIgd2hlbiBiYWNrZ3JvdW5kIGNvbG9yIGlzIHRoZSBzYW1lXG4gICAgICAgICYubWF0LWJhY2tncm91bmQtI3skbmFtZX0ge1xuICAgICAgICAgIEBpbmNsdWRlIF9tYXQtaW5rLWJhcigkY29sb3IsIGRlZmF1bHQtY29udHJhc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGVhY2ggJG5hbWUsICRjb2xvciBpbiAkdGhlbWUtY29sb3JzIHtcbiAgICAgIC8vIFNldCBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSB0YWJzIGFuZCBvdmVycmlkZSBmb2N1cyBjb2xvclxuICAgICAgJi5tYXQtYmFja2dyb3VuZC0jeyRuYW1lfSB7XG4gICAgICAgIEBpbmNsdWRlIF9tYXQtdGFiLWxhYmVsLWZvY3VzKCRjb2xvcik7XG4gICAgICAgIEBpbmNsdWRlIF9tYXQtdGFicy1iYWNrZ3JvdW5kKCRjb2xvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkBtaXhpbiBfbWF0LWluay1iYXIoJGNvbG9yLCAkaHVlOiBkZWZhdWx0KSB7XG4gIC5tYXQtaW5rLWJhciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRjb2xvciwgJGh1ZSk7XG4gIH1cbn1cblxuQG1peGluIF9tYXQtdGFiLWxhYmVsLWZvY3VzKCR0YWItZm9jdXMtY29sb3IpIHtcbiAgLm1hdC10YWItbGFiZWwsXG4gIC5tYXQtdGFiLWxpbmsge1xuICAgICYuY2RrLWtleWJvYXJkLWZvY3VzZWQsXG4gICAgJi5jZGstcHJvZ3JhbS1mb2N1c2VkIHtcbiAgICAgICY6bm90KC5tYXQtdGFiLWRpc2FibGVkKSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IG1hdC1jb2xvcigkdGFiLWZvY3VzLWNvbG9yLCBsaWdodGVyLCAwLjMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5AbWl4aW4gX21hdC10YWJzLWJhY2tncm91bmQoJGJhY2tncm91bmQtY29sb3IpIHtcbiAgLy8gU2V0IGJhY2tncm91bmQgY29sb3IgZm9yIHRoZSB0YWIgZ3JvdXBcbiAgLm1hdC10YWItaGVhZGVyLCAubWF0LXRhYi1saW5rcyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLWNvbG9yKTtcbiAgfVxuXG4gIC8vIFNldCBsYWJlbHMgdG8gY29udHJhc3QgYWdhaW5zdCBiYWNrZ3JvdW5kXG4gIC5tYXQtdGFiLWxhYmVsLCAubWF0LXRhYi1saW5rIHtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLWNvbG9yLCBkZWZhdWx0LWNvbnRyYXN0KTtcblxuICAgICYubWF0LXRhYi1kaXNhYmxlZCB7XG4gICAgICBjb2xvcjogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLWNvbG9yLCBkZWZhdWx0LWNvbnRyYXN0LCAwLjQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldCBwYWdpbmF0aW9uIGNoZXZyb25zIHRvIGNvbnRyYXN0IGJhY2tncm91bmRcbiAgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbiB7XG4gICAgYm9yZGVyLWNvbG9yOiBtYXQtY29sb3IoJGJhY2tncm91bmQtY29sb3IsIGRlZmF1bHQtY29udHJhc3QpO1xuICB9XG5cbiAgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tZGlzYWJsZWQgLm1hdC10YWItaGVhZGVyLXBhZ2luYXRpb24tY2hldnJvbiB7XG4gICAgYm9yZGVyLWNvbG9yOiBtYXQtY29sb3IoJGJhY2tncm91bmQtY29sb3IsIGRlZmF1bHQtY29udHJhc3QsIDAuNCk7XG4gIH1cblxuICAvLyBTZXQgcmlwcGxlcyBjb2xvciB0byBiZSB0aGUgY29udHJhc3QgY29sb3Igb2YgdGhlIG5ldyBiYWNrZ3JvdW5kLiBPdGhlcndpc2UgdGhlIHJpcHBsZVxuICAvLyBjb2xvciB3aWxsIGJlIGJhc2VkIG9uIHRoZSBhcHAgYmFja2dyb3VuZCBjb2xvci5cbiAgLm1hdC1yaXBwbGUtZWxlbWVudCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLWNvbG9yLCBkZWZhdWx0LWNvbnRyYXN0LCAwLjEyKTtcbiAgfVxufVxuXG5AbWl4aW4gbWF0LXRhYnMtdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC5tYXQtdGFiLWdyb3VwIHtcbiAgICBmb250LWZhbWlseTogbWF0LWZvbnQtZmFtaWx5KCRjb25maWcpO1xuICB9XG5cbiAgLm1hdC10YWItbGFiZWwsIC5tYXQtdGFiLWxpbmsge1xuICAgIGZvbnQ6IHtcbiAgICAgIGZhbWlseTogbWF0LWZvbnQtZmFtaWx5KCRjb25maWcsIGJ1dHRvbik7XG4gICAgICBzaXplOiBtYXQtZm9udC1zaXplKCRjb25maWcsIGJ1dHRvbik7XG4gICAgICB3ZWlnaHQ6IG1hdC1mb250LXdlaWdodCgkY29uZmlnLCBidXR0b24pO1xuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cblxuQG1peGluIF9tYXQtdG9vbGJhci1jb2xvcigkcGFsZXR0ZSkge1xuICBiYWNrZ3JvdW5kOiBtYXQtY29sb3IoJHBhbGV0dGUpO1xuICBjb2xvcjogbWF0LWNvbG9yKCRwYWxldHRlLCBkZWZhdWx0LWNvbnRyYXN0KTtcbn1cblxuQG1peGluIF9tYXQtdG9vbGJhci1mb3JtLWZpZWxkLW92ZXJyaWRlcyB7XG4gIC5tYXQtZm9ybS1maWVsZC11bmRlcmxpbmUsXG4gIC5tYXQtZm9ybS1maWVsZC1yaXBwbGUsXG4gIC5tYXQtZm9jdXNlZCAubWF0LWZvcm0tZmllbGQtcmlwcGxlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjdXJyZW50Q29sb3I7XG4gIH1cblxuICAubWF0LWZvcm0tZmllbGQtbGFiZWwsXG4gIC5tYXQtZm9jdXNlZCAubWF0LWZvcm0tZmllbGQtbGFiZWwsXG4gIC5tYXQtc2VsZWN0LXZhbHVlLFxuICAubWF0LXNlbGVjdC1hcnJvdyxcbiAgLm1hdC1mb3JtLWZpZWxkLm1hdC1mb2N1c2VkIC5tYXQtc2VsZWN0LWFycm93IHtcbiAgICBjb2xvcjogaW5oZXJpdDtcbiAgfVxuXG4gIC5tYXQtaW5wdXQtZWxlbWVudCB7XG4gICAgY2FyZXQtY29sb3I6IGN1cnJlbnRDb2xvcjtcbiAgfVxufVxuXG5AbWl4aW4gbWF0LXRvb2xiYXItdGhlbWUoJHRoZW1lKSB7XG4gICRwcmltYXJ5OiBtYXAtZ2V0KCR0aGVtZSwgcHJpbWFyeSk7XG4gICRhY2NlbnQ6IG1hcC1nZXQoJHRoZW1lLCBhY2NlbnQpO1xuICAkd2FybjogbWFwLWdldCgkdGhlbWUsIHdhcm4pO1xuICAkYmFja2dyb3VuZDogbWFwLWdldCgkdGhlbWUsIGJhY2tncm91bmQpO1xuICAkZm9yZWdyb3VuZDogbWFwLWdldCgkdGhlbWUsIGZvcmVncm91bmQpO1xuXG4gIC5tYXQtdG9vbGJhciB7XG4gICAgYmFja2dyb3VuZDogbWF0LWNvbG9yKCRiYWNrZ3JvdW5kLCBhcHAtYmFyKTtcbiAgICBjb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCB0ZXh0KTtcblxuICAgICYubWF0LXByaW1hcnkge1xuICAgICAgQGluY2x1ZGUgX21hdC10b29sYmFyLWNvbG9yKCRwcmltYXJ5KTtcbiAgICB9XG5cbiAgICAmLm1hdC1hY2NlbnQge1xuICAgICAgQGluY2x1ZGUgX21hdC10b29sYmFyLWNvbG9yKCRhY2NlbnQpO1xuICAgIH1cblxuICAgICYubWF0LXdhcm4ge1xuICAgICAgQGluY2x1ZGUgX21hdC10b29sYmFyLWNvbG9yKCR3YXJuKTtcbiAgICB9XG5cbiAgICBAaW5jbHVkZSBfbWF0LXRvb2xiYXItZm9ybS1maWVsZC1vdmVycmlkZXM7XG4gIH1cbn1cblxuQG1peGluIG1hdC10b29sYmFyLXR5cG9ncmFwaHkoJGNvbmZpZykge1xuICAubWF0LXRvb2xiYXIsXG4gIC5tYXQtdG9vbGJhciBoMSxcbiAgLm1hdC10b29sYmFyIGgyLFxuICAubWF0LXRvb2xiYXIgaDMsXG4gIC5tYXQtdG9vbGJhciBoNCxcbiAgLm1hdC10b29sYmFyIGg1LFxuICAubWF0LXRvb2xiYXIgaDYge1xuICAgIEBpbmNsdWRlIG1hdC10eXBvZ3JhcGh5LWxldmVsLXRvLXN0eWxlcygkY29uZmlnLCB0aXRsZSk7XG4gICAgbWFyZ2luOiAwO1xuICB9XG59XG5cblxuXG5cblxuJG1hdC10b29sdGlwLXRhcmdldC1oZWlnaHQ6IDIycHg7XG4kbWF0LXRvb2x0aXAtZm9udC1zaXplOiAxMHB4O1xuJG1hdC10b29sdGlwLXZlcnRpY2FsLXBhZGRpbmc6ICgkbWF0LXRvb2x0aXAtdGFyZ2V0LWhlaWdodCAtICRtYXQtdG9vbHRpcC1mb250LXNpemUpIC8gMjtcblxuJG1hdC10b29sdGlwLWhhbmRzZXQtdGFyZ2V0LWhlaWdodDogMzBweDtcbiRtYXQtdG9vbHRpcC1oYW5kc2V0LWZvbnQtc2l6ZTogMTRweDtcbiRtYXQtdG9vbHRpcC1oYW5kc2V0LXZlcnRpY2FsLXBhZGRpbmc6XG4gICAgKCRtYXQtdG9vbHRpcC1oYW5kc2V0LXRhcmdldC1oZWlnaHQgLSAkbWF0LXRvb2x0aXAtaGFuZHNldC1mb250LXNpemUpIC8gMjtcblxuQG1peGluIG1hdC10b29sdGlwLXRoZW1lKCR0aGVtZSkge1xuICAubWF0LXRvb2x0aXAge1xuICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkbWF0LWdyZXksIDcwMCwgMC45KTtcbiAgfVxufVxuXG5AbWl4aW4gbWF0LXRvb2x0aXAtdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC5tYXQtdG9vbHRpcCB7XG4gICAgZm9udC1mYW1pbHk6IG1hdC1mb250LWZhbWlseSgkY29uZmlnKTtcbiAgICBmb250LXNpemU6ICRtYXQtdG9vbHRpcC1mb250LXNpemU7XG4gICAgcGFkZGluZy10b3A6ICRtYXQtdG9vbHRpcC12ZXJ0aWNhbC1wYWRkaW5nO1xuICAgIHBhZGRpbmctYm90dG9tOiAkbWF0LXRvb2x0aXAtdmVydGljYWwtcGFkZGluZztcbiAgfVxuXG4gIC5tYXQtdG9vbHRpcC1oYW5kc2V0IHtcbiAgICBmb250LXNpemU6ICRtYXQtdG9vbHRpcC1oYW5kc2V0LWZvbnQtc2l6ZTtcbiAgICBwYWRkaW5nLXRvcDogJG1hdC10b29sdGlwLWhhbmRzZXQtdmVydGljYWwtcGFkZGluZztcbiAgICBwYWRkaW5nLWJvdHRvbTogJG1hdC10b29sdGlwLWhhbmRzZXQtdmVydGljYWwtcGFkZGluZztcbiAgfVxufVxuXG5cblxuXG5cbkBtaXhpbiBtYXQtc25hY2stYmFyLXRoZW1lKCR0aGVtZSkge1xuICAkaXMtZGFyay10aGVtZTogbWFwLWdldCgkdGhlbWUsIGlzLWRhcmspO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcblxuICAubWF0LXNuYWNrLWJhci1jb250YWluZXIge1xuICAgIC8vIFVzZSB0aGUgcHJpbWFyeSB0ZXh0IG9uIHRoZSBkYXJrIHRoZW1lLCBldmVuIHRob3VnaCB0aGUgbGlnaHRlciBvbmUgdXNlc1xuICAgIC8vIGEgc2Vjb25kYXJ5LCBiZWNhdXNlIHRoZSBjb250cmFzdCBvbiB0aGUgbGlnaHQgcHJpbWFyeSB0ZXh0IGlzIHBvb3IuXG4gICAgY29sb3I6IGlmKCRpcy1kYXJrLXRoZW1lLCAkZGFyay1wcmltYXJ5LXRleHQsICRsaWdodC1zZWNvbmRhcnktdGV4dCk7XG4gICAgYmFja2dyb3VuZDogaWYoJGlzLWRhcmstdGhlbWUsIG1hcC1nZXQoJG1hdC1ncmV5LCA1MCksICMzMjMyMzIpO1xuXG4gICAgQGluY2x1ZGUgX21hdC10aGVtZS1lbGV2YXRpb24oNiwgJHRoZW1lKTtcbiAgfVxuXG4gIC5tYXQtc2ltcGxlLXNuYWNrYmFyLWFjdGlvbiB7XG4gICAgY29sb3I6IGlmKCRpcy1kYXJrLXRoZW1lLCBpbmhlcml0LCBtYXQtY29sb3IoJGFjY2VudCkpO1xuICB9XG59XG5cbkBtaXhpbiBtYXQtc25hY2stYmFyLXR5cG9ncmFwaHkoJGNvbmZpZykge1xuICAubWF0LXNpbXBsZS1zbmFja2JhciB7XG4gICAgZm9udDoge1xuICAgICAgZmFtaWx5OiBtYXQtZm9udC1mYW1pbHkoJGNvbmZpZywgYm9keS0xKTtcbiAgICAgIHNpemU6IG1hdC1mb250LXNpemUoJGNvbmZpZywgYm9keS0xKTtcbiAgICB9XG4gIH1cblxuICAubWF0LXNpbXBsZS1zbmFja2Jhci1hY3Rpb24ge1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgIGZvbnQ6IHtcbiAgICAgIGZhbWlseTogaW5oZXJpdDtcbiAgICAgIHNpemU6IGluaGVyaXQ7XG4gICAgICB3ZWlnaHQ6IG1hdC1mb250LXdlaWdodCgkY29uZmlnLCBidXR0b24pO1xuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vIFRoZW1lIHN0eWxlcyB0aGF0IG9ubHkgYXBwbHkgdG8gdGhlIGZpbGwgYXBwZWFyYW5jZSBvZiB0aGUgZm9ybS1maWVsZC5cblxuQG1peGluIG1hdC1mb3JtLWZpZWxkLWZpbGwtdGhlbWUoJHRoZW1lKSB7XG4gICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG4gICRpcy1kYXJrLXRoZW1lOiBtYXAtZ2V0KCR0aGVtZSwgaXMtZGFyayk7XG5cbiAgJGZpbGwtYmFja2dyb3VuZDogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBiYXNlLCBpZigkaXMtZGFyay10aGVtZSwgMC4xLCAwLjA0KSk7XG4gICRmaWxsLWRpc2FibGVkLWJhY2tncm91bmQ6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgYmFzZSwgaWYoJGlzLWRhcmstdGhlbWUsIDAuMDUsIDAuMDIpKTtcbiAgJHVuZGVybGluZS1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBkaXZpZGVyLCBpZigkaXMtZGFyay10aGVtZSwgMC41LCAwLjQyKSk7XG4gICRsYWJlbC1kaXNhYmxlZC1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBkaXNhYmxlZC10ZXh0KTtcblxuICAubWF0LWZvcm0tZmllbGQtYXBwZWFyYW5jZS1maWxsIHtcbiAgICAubWF0LWZvcm0tZmllbGQtZmxleCB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkZmlsbC1iYWNrZ3JvdW5kO1xuICAgIH1cblxuICAgICYubWF0LWZvcm0tZmllbGQtZGlzYWJsZWQgLm1hdC1mb3JtLWZpZWxkLWZsZXgge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJGZpbGwtZGlzYWJsZWQtYmFja2dyb3VuZDtcbiAgICB9XG5cbiAgICAubWF0LWZvcm0tZmllbGQtdW5kZXJsaW5lOjpiZWZvcmUge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHVuZGVybGluZS1jb2xvcjtcbiAgICB9XG5cbiAgICAmLm1hdC1mb3JtLWZpZWxkLWRpc2FibGVkIHtcbiAgICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICAgIGNvbG9yOiAkbGFiZWwtZGlzYWJsZWQtY29sb3I7XG4gICAgICB9XG5cbiAgICAgIC5tYXQtZm9ybS1maWVsZC11bmRlcmxpbmU6OmJlZm9yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBVc2VkIHRvIG1ha2UgaW5zdGFuY2VzIG9mIHRoZSBfbWF0LWZvcm0tZmllbGQtbGFiZWwtZmxvYXRpbmcgbWl4aW4gbmVnbGlnaWJseSBkaWZmZXJlbnQsXG4vLyBhbmQgcHJldmVudCBHb29nbGUncyBDU1MgT3B0aW1pemVyIGZyb20gY29sbGFwc2luZyB0aGUgZGVjbGFyYXRpb25zLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHNvbWVcbi8vIG9mIHRoZSBzZWxlY3RvcnMgY29udGFpbiBwc2V1ZG8tY2xhc3NlcyBub3QgcmVjb2duaXplZCBpbiBhbGwgYnJvd3NlcnMuIElmIGEgYnJvd3NlciBlbmNvdW50ZXJzXG4vLyBhbiB1bmtub3duIHBzZXVkby1jbGFzcyBpdCB3aWxsIGRpc2NhcmQgdGhlIGVudGlyZSBydWxlIHNldC5cbiRtYXQtZm9ybS1maWVsZC1maWxsLWRlZHVwZTogMDtcblxuLy8gQXBwbGllcyBhIGZsb2F0aW5nIGxhYmVsIGFib3ZlIHRoZSBmb3JtIGZpZWxkIGNvbnRyb2wgaXRzZWxmLlxuQG1peGluIF9tYXQtZm9ybS1maWVsZC1maWxsLWxhYmVsLWZsb2F0aW5nKCRmb250LXNjYWxlLCAkaW5maXgtcGFkZGluZywgJGluZml4LW1hcmdpbi10b3ApIHtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0kaW5maXgtbWFyZ2luLXRvcCAtICRpbmZpeC1wYWRkaW5nICsgJG1hdC1mb3JtLWZpZWxkLWZpbGwtZGVkdXBlKVxuICAgICAgICAgICAgIHNjYWxlKCRmb250LXNjYWxlKTtcbiAgd2lkdGg6IDEwMCUgLyAkZm9udC1zY2FsZSArICRtYXQtZm9ybS1maWVsZC1maWxsLWRlZHVwZTtcblxuICAkbWF0LWZvcm0tZmllbGQtZmlsbC1kZWR1cGU6ICRtYXQtZm9ybS1maWVsZC1maWxsLWRlZHVwZSArIDAuMDAwMDEgIWdsb2JhbDtcbn1cblxuQG1peGluIG1hdC1mb3JtLWZpZWxkLWZpbGwtdHlwb2dyYXBoeSgkY29uZmlnKSB7XG4gIC8vIFRoZSB1bml0LWxlc3MgbGluZS1oZWlnaHQgZnJvbSB0aGUgZm9udCBjb25maWcuXG4gICRsaW5lLWhlaWdodDogbWF0LWxpbmUtaGVpZ2h0KCRjb25maWcsIGlucHV0KTtcbiAgLy8gVGhlIGFtb3VudCB0byBzY2FsZSB0aGUgZm9udCBmb3IgdGhlIGZsb2F0aW5nIGxhYmVsIGFuZCBzdWJzY3JpcHQuXG4gICRzdWJzY3JpcHQtZm9udC1zY2FsZTogMC43NTtcbiAgLy8gVGhlIHBhZGRpbmcgb24gdG9wIG9mIHRoZSBpbmZpeC5cbiAgJGluZml4LXBhZGRpbmctdG9wOiAwLjI1ZW07XG4gIC8vIFRoZSBwYWRkaW5nIGJlbG93IHRoZSBpbmZpeC5cbiAgJGluZml4LXBhZGRpbmctYm90dG9tOiAwLjc1ZW07XG4gIC8vIFRoZSBtYXJnaW4gYXBwbGllZCB0byB0aGUgZm9ybS1maWVsZC1pbmZpeCB0byByZXNlcnZlIHNwYWNlIGZvciB0aGUgZmxvYXRpbmcgbGFiZWwuXG4gICRpbmZpeC1tYXJnaW4tdG9wOiAxZW0gKiAkbGluZS1oZWlnaHQgKiAkc3Vic2NyaXB0LWZvbnQtc2NhbGU7XG4gIC8vIFRoZSBhbW91bnQgd2Ugb2Zmc2V0IHRoZSBsYWJlbCBmcm9tIHRoZSBpbnB1dCB0ZXh0IGluIHRoZSBmaWxsIGFwcGVhcmFuY2UuXG4gICRmaWxsLWFwcGVhcmFuY2UtbGFiZWwtb2Zmc2V0OiAtMC41ZW07XG5cbiAgLm1hdC1mb3JtLWZpZWxkLWFwcGVhcmFuY2UtZmlsbCB7XG4gICAgLm1hdC1mb3JtLWZpZWxkLWluZml4IHtcbiAgICAgIHBhZGRpbmc6ICRpbmZpeC1wYWRkaW5nLXRvcCAwICRpbmZpeC1wYWRkaW5nLWJvdHRvbSAwO1xuICAgIH1cblxuICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICB0b3A6ICRpbmZpeC1tYXJnaW4tdG9wICsgJGluZml4LXBhZGRpbmctdG9wO1xuICAgICAgbWFyZ2luLXRvcDogJGZpbGwtYXBwZWFyYW5jZS1sYWJlbC1vZmZzZXQ7XG4gICAgfVxuXG4gICAgJi5tYXQtZm9ybS1maWVsZC1jYW4tZmxvYXQge1xuICAgICAgJi5tYXQtZm9ybS1maWVsZC1zaG91bGQtZmxvYXQgLm1hdC1mb3JtLWZpZWxkLWxhYmVsLFxuICAgICAgLm1hdC1pbnB1dC1zZXJ2ZXI6Zm9jdXMgKyAubWF0LWZvcm0tZmllbGQtbGFiZWwtd3JhcHBlciAubWF0LWZvcm0tZmllbGQtbGFiZWwge1xuICAgICAgICBAaW5jbHVkZSBfbWF0LWZvcm0tZmllbGQtZmlsbC1sYWJlbC1mbG9hdGluZyhcbiAgICAgICAgICAgICAgICAkc3Vic2NyaXB0LWZvbnQtc2NhbGUsICRpbmZpeC1wYWRkaW5nLXRvcCArICRmaWxsLWFwcGVhcmFuY2UtbGFiZWwtb2Zmc2V0LFxuICAgICAgICAgICAgICAgICRpbmZpeC1tYXJnaW4tdG9wKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VydmVyLXNpZGUgcmVuZGVyZWQgbWF0SW5wdXQgd2l0aCBhIGxhYmVsIGF0dHJpYnV0ZSBidXQgbGFiZWwgbm90IHNob3duXG4gICAgICAvLyAodXNlZCBhcyBhIHB1cmUgQ1NTIHN0YW5kLWluIGZvciBtYXQtZm9ybS1maWVsZC1zaG91bGQtZmxvYXQpLlxuICAgICAgLm1hdC1pbnB1dC1zZXJ2ZXJbbGFiZWxdOm5vdCg6bGFiZWwtc2hvd24pICsgLm1hdC1mb3JtLWZpZWxkLWxhYmVsLXdyYXBwZXJcbiAgICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICAgIEBpbmNsdWRlIF9tYXQtZm9ybS1maWVsZC1maWxsLWxhYmVsLWZsb2F0aW5nKFxuICAgICAgICAgICAgICAgICRzdWJzY3JpcHQtZm9udC1zY2FsZSwgJGluZml4LXBhZGRpbmctdG9wICsgJGZpbGwtYXBwZWFyYW5jZS1sYWJlbC1vZmZzZXQsXG4gICAgICAgICAgICAgICAgJGluZml4LW1hcmdpbi10b3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cblxuXG4vLyBUaGVtZSBzdHlsZXMgdGhhdCBvbmx5IGFwcGx5IHRvIHRoZSBsZWdhY3kgYXBwZWFyYW5jZSBvZiB0aGUgZm9ybS1maWVsZC5cblxuQG1peGluIG1hdC1mb3JtLWZpZWxkLWxlZ2FjeS10aGVtZSgkdGhlbWUpIHtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcbiAgJGlzLWRhcmstdGhlbWU6IG1hcC1nZXQoJHRoZW1lLCBpcy1kYXJrKTtcblxuICAkbGFiZWwtY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgc2Vjb25kYXJ5LXRleHQpO1xuICAkdW5kZXJsaW5lLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpdmlkZXIsIGlmKCRpcy1kYXJrLXRoZW1lLCAwLjcsIDAuNDIpKTtcblxuICAubWF0LWZvcm0tZmllbGQtYXBwZWFyYW5jZS1sZWdhY3kge1xuICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICBjb2xvcjogJGxhYmVsLWNvbG9yO1xuICAgIH1cblxuICAgIC5tYXQtaGludCB7XG4gICAgICBjb2xvcjogJGxhYmVsLWNvbG9yO1xuICAgIH1cblxuICAgIC5tYXQtZm9ybS1maWVsZC11bmRlcmxpbmUge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHVuZGVybGluZS1jb2xvcjtcbiAgICB9XG5cbiAgICAmLm1hdC1mb3JtLWZpZWxkLWRpc2FibGVkIC5tYXQtZm9ybS1maWVsZC11bmRlcmxpbmUge1xuICAgICAgQGluY2x1ZGUgbWF0LWNvbnRyb2wtZGlzYWJsZWQtdW5kZXJsaW5lKCR1bmRlcmxpbmUtY29sb3IpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBVc2VkIHRvIG1ha2UgaW5zdGFuY2VzIG9mIHRoZSBfbWF0LWZvcm0tZmllbGQtbGFiZWwtZmxvYXRpbmcgbWl4aW4gbmVnbGlnaWJseSBkaWZmZXJlbnQsXG4vLyBhbmQgcHJldmVudCBHb29nbGUncyBDU1MgT3B0aW1pemVyIGZyb20gY29sbGFwc2luZyB0aGUgZGVjbGFyYXRpb25zLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHNvbWVcbi8vIG9mIHRoZSBzZWxlY3RvcnMgY29udGFpbiBwc2V1ZG8tY2xhc3NlcyBub3QgcmVjb2duaXplZCBpbiBhbGwgYnJvd3NlcnMuIElmIGEgYnJvd3NlciBlbmNvdW50ZXJzXG4vLyBhbiB1bmtub3duIHBzZXVkby1jbGFzcyBpdCB3aWxsIGRpc2NhcmQgdGhlIGVudGlyZSBydWxlIHNldC5cbiRtYXQtZm9ybS1maWVsZC1sZWdhY3ktZGVkdXBlOiAwO1xuXG4vLyBBcHBsaWVzIGEgZmxvYXRpbmcgbGFiZWwgYWJvdmUgdGhlIGZvcm0gZmllbGQgY29udHJvbCBpdHNlbGYuXG5AbWl4aW4gX21hdC1mb3JtLWZpZWxkLWxlZ2FjeS1sYWJlbC1mbG9hdGluZygkZm9udC1zY2FsZSwgJGluZml4LXBhZGRpbmcsICRpbmZpeC1tYXJnaW4tdG9wKSB7XG4gIC8vIFdlIHVzZSBwZXJzcGVjdGl2ZSB0byBmaXggdGhlIHRleHQgYmx1cnJpbmVzcyBhcyBkZXNjcmliZWQgaGVyZTpcbiAgLy8gaHR0cDovL3d3dy51c2VyYWdlbnRtYW4uY29tL2Jsb2cvMjAxNC8wNS8wNC9maXhpbmctdHlwb2dyYXBoeS1pbnNpZGUtb2YtMi1kLWNzcy10cmFuc2Zvcm1zL1xuICAvLyBUaGlzIHJlc3VsdHMgaW4gYSBzbWFsbCBqaXR0ZXIgYWZ0ZXIgdGhlIGxhYmVsIGZsb2F0cyBvbiBGaXJlZm94LCB3aGljaCB0aGVcbiAgLy8gdHJhbnNsYXRlWiBmaXhlcy5cbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0kaW5maXgtbWFyZ2luLXRvcCAtICRpbmZpeC1wYWRkaW5nKSBzY2FsZSgkZm9udC1zY2FsZSkgcGVyc3BlY3RpdmUoMTAwcHgpXG4gIHRyYW5zbGF0ZVooMC4wMDFweCArICRtYXQtZm9ybS1maWVsZC1sZWdhY3ktZGVkdXBlKTtcbiAgLy8gVGhlIHRyaWNrcyBhYm92ZSB1c2VkIHRvIHNtb290aCBvdXQgdGhlIGFuaW1hdGlvbiBvbiBjaHJvbWUgYW5kIGZpcmVmb3ggYWN0dWFsbHkgbWFrZSB0aGluZ3NcbiAgLy8gd29yc2Ugb24gSUUsIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBpbiB0aGUgSUUgdmVyc2lvbi5cbiAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtJGluZml4LW1hcmdpbi10b3AgLSAkaW5maXgtcGFkZGluZyArICRtYXQtZm9ybS1maWVsZC1sZWdhY3ktZGVkdXBlKVxuICAgICAgICAgICAgICAgICAgc2NhbGUoJGZvbnQtc2NhbGUpO1xuXG4gIHdpZHRoOiAxMDAlIC8gJGZvbnQtc2NhbGUgKyAkbWF0LWZvcm0tZmllbGQtbGVnYWN5LWRlZHVwZTtcblxuICAkbWF0LWZvcm0tZmllbGQtbGVnYWN5LWRlZHVwZTogJG1hdC1mb3JtLWZpZWxkLWxlZ2FjeS1kZWR1cGUgKyAwLjAwMDAxICFnbG9iYWw7XG59XG5cbi8vIFNhbWUgYXMgbWl4aW4gYWJvdmUsIGJ1dCBvbWl0cyB0aGUgdHJhbnNsYXRlWiBmb3IgcHJpbnRpbmcgcHVycG9zZXMuXG5AbWl4aW4gX21hdC1mb3JtLWZpZWxkLWxlZ2FjeS1sYWJlbC1mbG9hdGluZy1wcmludCgkZm9udC1zY2FsZSwgJGluZml4LXBhZGRpbmcsICRpbmZpeC1tYXJnaW4tdG9wKSB7XG4gIC8vIFRoaXMgcmVzdWx0cyBpbiBhIHNtYWxsIGppdHRlciBhZnRlciB0aGUgbGFiZWwgZmxvYXRzIG9uIEZpcmVmb3gsIHdoaWNoIHRoZVxuICAvLyB0cmFuc2xhdGVaIGZpeGVzLlxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLSRpbmZpeC1tYXJnaW4tdG9wIC0gJGluZml4LXBhZGRpbmcgKyAkbWF0LWZvcm0tZmllbGQtbGVnYWN5LWRlZHVwZSlcbiAgICAgICAgICAgICAgICAgIHNjYWxlKCRmb250LXNjYWxlKTtcbiAgLy8gVGhlIHRyaWNrcyBhYm92ZSB1c2VkIHRvIHNtb290aCBvdXQgdGhlIGFuaW1hdGlvbiBvbiBjaHJvbWUgYW5kIGZpcmVmb3ggYWN0dWFsbHkgbWFrZSB0aGluZ3NcbiAgLy8gd29yc2Ugb24gSUUsIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBpbiB0aGUgSUUgdmVyc2lvbi5cbiAgJG1hdC1mb3JtLWZpZWxkLWxlZ2FjeS1kZWR1cGU6ICRtYXQtZm9ybS1maWVsZC1sZWdhY3ktZGVkdXBlICsgMC4wMDAwMSAhZ2xvYmFsO1xufVxuXG5AbWl4aW4gbWF0LWZvcm0tZmllbGQtbGVnYWN5LXR5cG9ncmFwaHkoJGNvbmZpZykge1xuICAvLyBUaGUgdW5pdC1sZXNzIGxpbmUtaGVpZ2h0IGZyb20gdGhlIGZvbnQgY29uZmlnLlxuICAkbGluZS1oZWlnaHQ6IG1hdC1saW5lLWhlaWdodCgkY29uZmlnLCBpbnB1dCk7XG4gIC8vIFRoZSBhbW91bnQgdG8gc2NhbGUgdGhlIGZvbnQgZm9yIHRoZSBmbG9hdGluZyBsYWJlbCBhbmQgc3Vic2NyaXB0LlxuICAkc3Vic2NyaXB0LWZvbnQtc2NhbGU6IDAuNzU7XG4gIC8vIFRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBsaW5lIGFuZCB0aGUgdG9wIG9mIHRoZSBhY3R1YWwgdGV4dFxuICAvLyAoYXMgYSBmcmFjdGlvbiBvZiB0aGUgZm9udC1zaXplKS5cbiAgJGxpbmUtc3BhY2luZzogKCRsaW5lLWhlaWdodCAtIDEpIC8gMjtcbiAgLy8gVGhlIHBhZGRpbmcgb24gdGhlIGluZml4LiBNb2NrcyBzaG93IGhhbGYgb2YgdGhlIHRleHQgc2l6ZSwgYnV0IHNlZW0gdG8gbWVhc3VyZSBmcm9tIHRoZSBlZGdlXG4gIC8vIG9mIHRoZSB0ZXh0IGl0c2VsZiwgbm90IHRoZSBlZGdlIG9mIHRoZSBsaW5lOyB0aGVyZWZvcmUgd2Ugc3VidHJhY3Qgb2ZmIHRoZSBsaW5lIHNwYWNpbmcuXG4gICRpbmZpeC1wYWRkaW5nOiAwLjVlbSAtICRsaW5lLXNwYWNpbmc7XG4gIC8vIFRoZSBtYXJnaW4gYXBwbGllZCB0byB0aGUgZm9ybS1maWVsZC1pbmZpeCB0byByZXNlcnZlIHNwYWNlIGZvciB0aGUgZmxvYXRpbmcgbGFiZWwuXG4gICRpbmZpeC1tYXJnaW4tdG9wOiAxZW0gKiAkbGluZS1oZWlnaHQgKiAkc3Vic2NyaXB0LWZvbnQtc2NhbGU7XG4gIC8vIFRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBib3R0b20gb2YgdGhlIC5tYXQtZm9ybS1maWVsZC1mbGV4IGFyZWEgYW5kIHRoZSBzdWJzY3JpcHQgd3JhcHBlci5cbiAgLy8gTW9ja3Mgc2hvdyBoYWxmIG9mIHRoZSB0ZXh0IHNpemUsIGJ1dCB0aGlzIG1hcmdpbiBpcyBhcHBsaWVkIHRvIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3Vic2NyaXB0XG4gIC8vIHRleHQgZm9udCBzaXplLCBzbyB3ZSBuZWVkIHRvIGRpdmlkZSBieSB0aGUgc2NhbGUgZmFjdG9yIHRvIG1ha2UgaXQgaGFsZiBvZiB0aGUgb3JpZ2luYWwgdGV4dFxuICAvLyBzaXplLiBXZSBhZ2FpbiBuZWVkIHRvIHN1YnRyYWN0IG9mZiB0aGUgbGluZSBzcGFjaW5nIHNpbmNlIHRoZSBtb2NrcyBtZWFzdXJlIHRvIHRoZSBlZGdlIG9mIHRoZVxuICAvLyB0ZXh0LCBub3QgdGhlICBlZGdlIG9mIHRoZSBsaW5lLlxuICAkc3Vic2NyaXB0LW1hcmdpbi10b3A6IDAuNWVtIC8gJHN1YnNjcmlwdC1mb250LXNjYWxlIC0gKCRsaW5lLXNwYWNpbmcgKiAyKTtcbiAgLy8gVGhlIHBhZGRpbmcgYXBwbGllZCB0byB0aGUgZm9ybS1maWVsZC13cmFwcGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIHRoZSBzdWJzY3JpcHQsIHNpbmNlIGl0J3NcbiAgLy8gYWJzb2x1dGVseSBwb3NpdGlvbmVkLiBUaGlzIGlzIGEgY29tYmluYXRpb24gb2YgdGhlIHN1YnNjcmlwdCdzIG1hcmdpbiBhbmQgbGluZS1oZWlnaHQsIGJ1dCB3ZVxuICAvLyBuZWVkIHRvIG11bHRpcGx5IGJ5IHRoZSBzdWJzY3JpcHQgZm9udCBzY2FsZSBmYWN0b3Igc2luY2UgdGhlIHdyYXBwZXIgaGFzIGEgbGFyZ2VyIGZvbnQgc2l6ZS5cbiAgJHdyYXBwZXItcGFkZGluZy1ib3R0b206ICgkc3Vic2NyaXB0LW1hcmdpbi10b3AgKyAkbGluZS1oZWlnaHQpICogJHN1YnNjcmlwdC1mb250LXNjYWxlO1xuXG4gIC5tYXQtZm9ybS1maWVsZC1hcHBlYXJhbmNlLWxlZ2FjeSB7XG4gICAgLm1hdC1mb3JtLWZpZWxkLXdyYXBwZXIge1xuICAgICAgcGFkZGluZy1ib3R0b206ICR3cmFwcGVyLXBhZGRpbmctYm90dG9tO1xuICAgIH1cblxuICAgIC5tYXQtZm9ybS1maWVsZC1pbmZpeCB7XG4gICAgICBwYWRkaW5nOiAkaW5maXgtcGFkZGluZyAwO1xuICAgIH1cblxuICAgICYubWF0LWZvcm0tZmllbGQtY2FuLWZsb2F0IHtcbiAgICAgICYubWF0LWZvcm0tZmllbGQtc2hvdWxkLWZsb2F0IC5tYXQtZm9ybS1maWVsZC1sYWJlbCxcbiAgICAgIC5tYXQtaW5wdXQtc2VydmVyOmZvY3VzICsgLm1hdC1mb3JtLWZpZWxkLWxhYmVsLXdyYXBwZXIgLm1hdC1mb3JtLWZpZWxkLWxhYmVsIHtcbiAgICAgICAgQGluY2x1ZGUgX21hdC1mb3JtLWZpZWxkLWxlZ2FjeS1sYWJlbC1mbG9hdGluZyhcbiAgICAgICAgICAgICAgICAkc3Vic2NyaXB0LWZvbnQtc2NhbGUsICRpbmZpeC1wYWRkaW5nLCAkaW5maXgtbWFyZ2luLXRvcCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEBicmVha2luZy1jaGFuZ2UgOC4wLjAgd2lsbCByZWx5IG9uIEF1dG9maWxsTW9uaXRvciBpbnN0ZWFkLlxuICAgICAgLm1hdC1mb3JtLWZpZWxkLWF1dG9maWxsLWNvbnRyb2w6LXdlYmtpdC1hdXRvZmlsbCArIC5tYXQtZm9ybS1maWVsZC1sYWJlbC13cmFwcGVyXG4gICAgICAubWF0LWZvcm0tZmllbGQtbGFiZWwge1xuICAgICAgICBAaW5jbHVkZSBfbWF0LWZvcm0tZmllbGQtbGVnYWN5LWxhYmVsLWZsb2F0aW5nKFxuICAgICAgICAgICAgICAgICRzdWJzY3JpcHQtZm9udC1zY2FsZSwgJGluZml4LXBhZGRpbmcsICRpbmZpeC1tYXJnaW4tdG9wKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VydmVyLXNpZGUgcmVuZGVyZWQgbWF0SW5wdXQgd2l0aCBhIGxhYmVsIGF0dHJpYnV0ZSBidXQgbGFiZWwgbm90IHNob3duXG4gICAgICAvLyAodXNlZCBhcyBhIHB1cmUgQ1NTIHN0YW5kLWluIGZvciBtYXQtZm9ybS1maWVsZC1zaG91bGQtZmxvYXQpLlxuICAgICAgLm1hdC1pbnB1dC1zZXJ2ZXJbbGFiZWxdOm5vdCg6bGFiZWwtc2hvd24pICsgLm1hdC1mb3JtLWZpZWxkLWxhYmVsLXdyYXBwZXJcbiAgICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICAgIEBpbmNsdWRlIF9tYXQtZm9ybS1maWVsZC1sZWdhY3ktbGFiZWwtZmxvYXRpbmcoXG4gICAgICAgICAgICAgICAgJHN1YnNjcmlwdC1mb250LXNjYWxlLCAkaW5maXgtcGFkZGluZywgJGluZml4LW1hcmdpbi10b3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICB0b3A6ICRpbmZpeC1tYXJnaW4tdG9wICsgJGluZml4LXBhZGRpbmc7XG4gICAgfVxuXG4gICAgLm1hdC1mb3JtLWZpZWxkLXVuZGVybGluZSB7XG4gICAgICAvLyBXZSB3YW50IHRoZSB1bmRlcmxpbmUgdG8gc3RhcnQgYXQgdGhlIGVuZCBvZiB0aGUgY29udGVudCBib3gsIG5vdCB0aGUgcGFkZGluZyBib3gsXG4gICAgICAvLyBzbyB3ZSBtb3ZlIGl0IHVwIGJ5IHRoZSBwYWRkaW5nIGFtb3VudC5cbiAgICAgIGJvdHRvbTogJHdyYXBwZXItcGFkZGluZy1ib3R0b207XG4gICAgfVxuXG4gICAgLm1hdC1mb3JtLWZpZWxkLXN1YnNjcmlwdC13cmFwcGVyIHtcbiAgICAgIG1hcmdpbi10b3A6ICRzdWJzY3JpcHQtbWFyZ2luLXRvcDtcblxuICAgICAgLy8gV2Ugd2FudCB0aGUgc3Vic2NyaXB0IHRvIHN0YXJ0IGF0IHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQgYm94LCBub3QgdGhlIHBhZGRpbmcgYm94LFxuICAgICAgLy8gc28gd2UgbW92ZSBpdCB1cCBieSB0aGUgcGFkZGluZyBhbW91bnQgKGFkanVzdGVkIGZvciB0aGUgc21hbGxlciBmb250IHNpemUpO1xuICAgICAgdG9wOiBjYWxjKDEwMCUgLSAjeyR3cmFwcGVyLXBhZGRpbmctYm90dG9tIC8gJHN1YnNjcmlwdC1mb250LXNjYWxlfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gdHJhbnNsYXRlWiBjYXVzZXMgdGhlIGxhYmVsIHRvIG5vdCBhcHBlYXIgd2hpbGUgcHJpbnRpbmcsIHNvIHdlIG92ZXJyaWRlIGl0IHRvIG5vdFxuICAvLyBhcHBseSB0cmFuc2xhdGVaIHdoaWxlIHByaW50aW5nXG4gIEBtZWRpYSBwcmludCB7XG4gICAgLm1hdC1mb3JtLWZpZWxkLWFwcGVhcmFuY2UtbGVnYWN5IHtcbiAgICAgICYubWF0LWZvcm0tZmllbGQtY2FuLWZsb2F0IHtcbiAgICAgICAgJi5tYXQtZm9ybS1maWVsZC1zaG91bGQtZmxvYXQgLm1hdC1mb3JtLWZpZWxkLWxhYmVsLFxuICAgICAgICAubWF0LWlucHV0LXNlcnZlcjpmb2N1cyArIC5tYXQtZm9ybS1maWVsZC1sYWJlbC13cmFwcGVyIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICAgICAgQGluY2x1ZGUgX21hdC1mb3JtLWZpZWxkLWxlZ2FjeS1sYWJlbC1mbG9hdGluZy1wcmludChcbiAgICAgICAgICAgICAgICAgICRzdWJzY3JpcHQtZm9udC1zY2FsZSwgJGluZml4LXBhZGRpbmcsICRpbmZpeC1tYXJnaW4tdG9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEBicmVha2luZy1jaGFuZ2UgOC4wLjAgd2lsbCByZWx5IG9uIEF1dG9maWxsTW9uaXRvciBpbnN0ZWFkLlxuICAgICAgICAubWF0LWZvcm0tZmllbGQtYXV0b2ZpbGwtY29udHJvbDotd2Via2l0LWF1dG9maWxsICsgLm1hdC1mb3JtLWZpZWxkLWxhYmVsLXdyYXBwZXJcbiAgICAgICAgLm1hdC1mb3JtLWZpZWxkLWxhYmVsIHtcbiAgICAgICAgICBAaW5jbHVkZSBfbWF0LWZvcm0tZmllbGQtbGVnYWN5LWxhYmVsLWZsb2F0aW5nLXByaW50KFxuICAgICAgICAgICAgICAgICAgJHN1YnNjcmlwdC1mb250LXNjYWxlLCAkaW5maXgtcGFkZGluZywgJGluZml4LW1hcmdpbi10b3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VydmVyLXNpZGUgcmVuZGVyZWQgbWF0SW5wdXQgd2l0aCBhIGxhYmVsIGF0dHJpYnV0ZSBidXQgbGFiZWwgbm90IHNob3duXG4gICAgICAgIC8vICh1c2VkIGFzIGEgcHVyZSBDU1Mgc3RhbmQtaW4gZm9yIG1hdC1mb3JtLWZpZWxkLXNob3VsZC1mbG9hdCkuXG4gICAgICAgIC5tYXQtaW5wdXQtc2VydmVyW2xhYmVsXTpub3QoOmxhYmVsLXNob3duKSArIC5tYXQtZm9ybS1maWVsZC1sYWJlbC13cmFwcGVyXG4gICAgICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICAgICAgQGluY2x1ZGUgX21hdC1mb3JtLWZpZWxkLWxlZ2FjeS1sYWJlbC1mbG9hdGluZy1wcmludChcbiAgICAgICAgICAgICAgICAgICRzdWJzY3JpcHQtZm9udC1zY2FsZSwgJGluZml4LXBhZGRpbmcsICRpbmZpeC1tYXJnaW4tdG9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cblxuXG4vLyBUaGVtZSBzdHlsZXMgdGhhdCBvbmx5IGFwcGx5IHRvIHRoZSBvdXRsaW5lIGFwcGVhcmFuY2Ugb2YgdGhlIGZvcm0tZmllbGQuXG5cbkBtaXhpbiBtYXQtZm9ybS1maWVsZC1vdXRsaW5lLXRoZW1lKCR0aGVtZSkge1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcbiAgJGlzLWRhcmstdGhlbWU6IG1hcC1nZXQoJHRoZW1lLCBpcy1kYXJrKTtcblxuICAkbGFiZWwtZGlzYWJsZWQtY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGlzYWJsZWQtdGV4dCk7XG4gICRvdXRsaW5lLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpdmlkZXIsIGlmKCRpcy1kYXJrLXRoZW1lLCAwLjMsIDAuMTIpKTtcbiAgJG91dGxpbmUtY29sb3ItaG92ZXI6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGl2aWRlciwgaWYoJGlzLWRhcmstdGhlbWUsIDEsIDAuODcpKTtcbiAgJG91dGxpbmUtY29sb3ItcHJpbWFyeTogbWF0LWNvbG9yKCRwcmltYXJ5KTtcbiAgJG91dGxpbmUtY29sb3ItYWNjZW50OiBtYXQtY29sb3IoJGFjY2VudCk7XG4gICRvdXRsaW5lLWNvbG9yLXdhcm46IG1hdC1jb2xvcigkd2Fybik7XG4gICRvdXRsaW5lLWNvbG9yLWRpc2FibGVkOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpdmlkZXIsIGlmKCRpcy1kYXJrLXRoZW1lLCAwLjE1LCAwLjA2KSk7XG5cbiAgLm1hdC1mb3JtLWZpZWxkLWFwcGVhcmFuY2Utb3V0bGluZSB7XG4gICAgLm1hdC1mb3JtLWZpZWxkLW91dGxpbmUge1xuICAgICAgY29sb3I6ICRvdXRsaW5lLWNvbG9yO1xuICAgIH1cblxuICAgIC5tYXQtZm9ybS1maWVsZC1vdXRsaW5lLXRoaWNrIHtcbiAgICAgIGNvbG9yOiAkb3V0bGluZS1jb2xvci1ob3ZlcjtcbiAgICB9XG5cbiAgICAmLm1hdC1mb2N1c2VkIHtcbiAgICAgIC5tYXQtZm9ybS1maWVsZC1vdXRsaW5lLXRoaWNrIHtcbiAgICAgICAgY29sb3I6ICRvdXRsaW5lLWNvbG9yLXByaW1hcnk7XG4gICAgICB9XG5cbiAgICAgICYubWF0LWFjY2VudCAubWF0LWZvcm0tZmllbGQtb3V0bGluZS10aGljayB7XG4gICAgICAgIGNvbG9yOiAkb3V0bGluZS1jb2xvci1hY2NlbnQ7XG4gICAgICB9XG5cbiAgICAgICYubWF0LXdhcm4gLm1hdC1mb3JtLWZpZWxkLW91dGxpbmUtdGhpY2sge1xuICAgICAgICBjb2xvcjogJG91dGxpbmUtY29sb3Itd2FybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGFzcyByZXBlYXRlZCBzbyB0aGF0IHJ1bGUgaXMgc3BlY2lmaWMgZW5vdWdoIHRvIG92ZXJyaWRlIGZvY3VzZWQgYWNjZW50IGNvbG9yIGNhc2UuXG4gICAgJi5tYXQtZm9ybS1maWVsZC1pbnZhbGlkLm1hdC1mb3JtLWZpZWxkLWludmFsaWQge1xuICAgICAgLm1hdC1mb3JtLWZpZWxkLW91dGxpbmUtdGhpY2sge1xuICAgICAgICBjb2xvcjogJG91dGxpbmUtY29sb3Itd2FybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAmLm1hdC1mb3JtLWZpZWxkLWRpc2FibGVkIHtcbiAgICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICAgIGNvbG9yOiAkbGFiZWwtZGlzYWJsZWQtY29sb3I7XG4gICAgICB9XG5cbiAgICAgIC5tYXQtZm9ybS1maWVsZC1vdXRsaW5lIHtcbiAgICAgICAgY29sb3I6ICRvdXRsaW5lLWNvbG9yLWRpc2FibGVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBVc2VkIHRvIG1ha2UgaW5zdGFuY2VzIG9mIHRoZSBfbWF0LWZvcm0tZmllbGQtbGFiZWwtZmxvYXRpbmcgbWl4aW4gbmVnbGlnaWJseSBkaWZmZXJlbnQsXG4vLyBhbmQgcHJldmVudCBHb29nbGUncyBDU1MgT3B0aW1pemVyIGZyb20gY29sbGFwc2luZyB0aGUgZGVjbGFyYXRpb25zLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHNvbWVcbi8vIG9mIHRoZSBzZWxlY3RvcnMgY29udGFpbiBwc2V1ZG8tY2xhc3NlcyBub3QgcmVjb2duaXplZCBpbiBhbGwgYnJvd3NlcnMuIElmIGEgYnJvd3NlciBlbmNvdW50ZXJzXG4vLyBhbiB1bmtub3duIHBzZXVkby1jbGFzcyBpdCB3aWxsIGRpc2NhcmQgdGhlIGVudGlyZSBydWxlIHNldC5cbiRtYXQtZm9ybS1maWVsZC1vdXRsaW5lLWRlZHVwZTogMDtcblxuLy8gQXBwbGllcyBhIGZsb2F0aW5nIGxhYmVsIGFib3ZlIHRoZSBmb3JtIGZpZWxkIGNvbnRyb2wgaXRzZWxmLlxuQG1peGluIF9tYXQtZm9ybS1maWVsZC1vdXRsaW5lLWxhYmVsLWZsb2F0aW5nKCRmb250LXNjYWxlLCAkaW5maXgtcGFkZGluZywgJGluZml4LW1hcmdpbi10b3ApIHtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0kaW5maXgtbWFyZ2luLXRvcCAtICRpbmZpeC1wYWRkaW5nICsgJG1hdC1mb3JtLWZpZWxkLW91dGxpbmUtZGVkdXBlKVxuICBzY2FsZSgkZm9udC1zY2FsZSk7XG4gIHdpZHRoOiAxMDAlIC8gJGZvbnQtc2NhbGUgKyAkbWF0LWZvcm0tZmllbGQtb3V0bGluZS1kZWR1cGU7XG5cbiAgJG1hdC1mb3JtLWZpZWxkLW91dGxpbmUtZGVkdXBlOiAkbWF0LWZvcm0tZmllbGQtb3V0bGluZS1kZWR1cGUgKyAwLjAwMDAxICFnbG9iYWw7XG59XG5cbkBtaXhpbiBtYXQtZm9ybS1maWVsZC1vdXRsaW5lLXR5cG9ncmFwaHkoJGNvbmZpZykge1xuICAvLyBUaGUgdW5pdC1sZXNzIGxpbmUtaGVpZ2h0IGZyb20gdGhlIGZvbnQgY29uZmlnLlxuICAkbGluZS1oZWlnaHQ6IG1hdC1saW5lLWhlaWdodCgkY29uZmlnLCBpbnB1dCk7XG4gIC8vIFRoZSBhbW91bnQgdG8gc2NhbGUgdGhlIGZvbnQgZm9yIHRoZSBmbG9hdGluZyBsYWJlbCBhbmQgc3Vic2NyaXB0LlxuICAkc3Vic2NyaXB0LWZvbnQtc2NhbGU6IDAuNzU7XG4gIC8vIFRoZSBwYWRkaW5nIGFib3ZlIGFuZCBiZWxvdyB0aGUgaW5maXguXG4gICRpbmZpeC1wYWRkaW5nOiAxZW07XG4gIC8vIFRoZSBtYXJnaW4gYXBwbGllZCB0byB0aGUgZm9ybS1maWVsZC1pbmZpeCB0byByZXNlcnZlIHNwYWNlIGZvciB0aGUgZmxvYXRpbmcgbGFiZWwuXG4gICRpbmZpeC1tYXJnaW4tdG9wOiAxZW0gKiAkbGluZS1oZWlnaHQgKiAkc3Vic2NyaXB0LWZvbnQtc2NhbGU7XG4gIC8vIFRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBib3R0b20gb2YgdGhlIC5tYXQtZm9ybS1maWVsZC1mbGV4IGFyZWEgYW5kIHRoZSBzdWJzY3JpcHQgd3JhcHBlci5cbiAgLy8gTW9ja3Mgc2hvdyBoYWxmIG9mIHRoZSB0ZXh0IHNpemUsIGJ1dCB0aGlzIG1hcmdpbiBpcyBhcHBsaWVkIHRvIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3Vic2NyaXB0XG4gIC8vIHRleHQgZm9udCBzaXplLCBzbyB3ZSBuZWVkIHRvIGRpdmlkZSBieSB0aGUgc2NhbGUgZmFjdG9yIHRvIG1ha2UgaXQgaGFsZiBvZiB0aGUgb3JpZ2luYWwgdGV4dFxuICAvLyBzaXplLlxuICAkc3Vic2NyaXB0LW1hcmdpbi10b3A6IDAuNWVtIC8gJHN1YnNjcmlwdC1mb250LXNjYWxlO1xuICAvLyBUaGUgcGFkZGluZyBhcHBsaWVkIHRvIHRoZSBmb3JtLWZpZWxkLXdyYXBwZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgdGhlIHN1YnNjcmlwdCwgc2luY2UgaXQnc1xuICAvLyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQuIFRoaXMgaXMgYSBjb21iaW5hdGlvbiBvZiB0aGUgc3Vic2NyaXB0J3MgbWFyZ2luIGFuZCBsaW5lLWhlaWdodCwgYnV0IHdlXG4gIC8vIG5lZWQgdG8gbXVsdGlwbHkgYnkgdGhlIHN1YnNjcmlwdCBmb250IHNjYWxlIGZhY3RvciBzaW5jZSB0aGUgd3JhcHBlciBoYXMgYSBsYXJnZXIgZm9udCBzaXplLlxuICAkd3JhcHBlci1wYWRkaW5nLWJvdHRvbTogKCRzdWJzY3JpcHQtbWFyZ2luLXRvcCArICRsaW5lLWhlaWdodCkgKiAkc3Vic2NyaXB0LWZvbnQtc2NhbGU7XG4gIC8vIFRoZSBhbW91bnQgd2Ugb2Zmc2V0IHRoZSBsYWJlbCBmcm9tIHRoZSBpbnB1dCB0ZXh0IGluIHRoZSBvdXRsaW5lIGFwcGVhcmFuY2UuXG4gICRvdXRsaW5lLWFwcGVhcmFuY2UtbGFiZWwtb2Zmc2V0OiAtMC4yNWVtO1xuXG4gIC5tYXQtZm9ybS1maWVsZC1hcHBlYXJhbmNlLW91dGxpbmUge1xuICAgIC5tYXQtZm9ybS1maWVsZC1pbmZpeCB7XG4gICAgICBwYWRkaW5nOiAkaW5maXgtcGFkZGluZyAwICRpbmZpeC1wYWRkaW5nIDA7XG4gICAgfVxuXG4gICAgLm1hdC1mb3JtLWZpZWxkLWxhYmVsIHtcbiAgICAgIHRvcDogJGluZml4LW1hcmdpbi10b3AgKyAkaW5maXgtcGFkZGluZztcbiAgICAgIG1hcmdpbi10b3A6ICRvdXRsaW5lLWFwcGVhcmFuY2UtbGFiZWwtb2Zmc2V0O1xuICAgIH1cblxuICAgICYubWF0LWZvcm0tZmllbGQtY2FuLWZsb2F0IHtcbiAgICAgICYubWF0LWZvcm0tZmllbGQtc2hvdWxkLWZsb2F0IC5tYXQtZm9ybS1maWVsZC1sYWJlbCxcbiAgICAgIC5tYXQtaW5wdXQtc2VydmVyOmZvY3VzICsgLm1hdC1mb3JtLWZpZWxkLWxhYmVsLXdyYXBwZXIgLm1hdC1mb3JtLWZpZWxkLWxhYmVsIHtcbiAgICAgICAgQGluY2x1ZGUgX21hdC1mb3JtLWZpZWxkLW91dGxpbmUtbGFiZWwtZmxvYXRpbmcoXG4gICAgICAgICAgICAgICAgJHN1YnNjcmlwdC1mb250LXNjYWxlLCAkaW5maXgtcGFkZGluZyArICRvdXRsaW5lLWFwcGVhcmFuY2UtbGFiZWwtb2Zmc2V0LFxuICAgICAgICAgICAgICAgICRpbmZpeC1tYXJnaW4tdG9wKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VydmVyLXNpZGUgcmVuZGVyZWQgbWF0SW5wdXQgd2l0aCBhIGxhYmVsIGF0dHJpYnV0ZSBidXQgbGFiZWwgbm90IHNob3duXG4gICAgICAvLyAodXNlZCBhcyBhIHB1cmUgQ1NTIHN0YW5kLWluIGZvciBtYXQtZm9ybS1maWVsZC1zaG91bGQtZmxvYXQpLlxuICAgICAgLm1hdC1pbnB1dC1zZXJ2ZXJbbGFiZWxdOm5vdCg6bGFiZWwtc2hvd24pICsgLm1hdC1mb3JtLWZpZWxkLWxhYmVsLXdyYXBwZXJcbiAgICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICAgIEBpbmNsdWRlIF9tYXQtZm9ybS1maWVsZC1vdXRsaW5lLWxhYmVsLWZsb2F0aW5nKFxuICAgICAgICAgICAgICAgICRzdWJzY3JpcHQtZm9udC1zY2FsZSwgJGluZml4LXBhZGRpbmcgKyAkb3V0bGluZS1hcHBlYXJhbmNlLWxhYmVsLW9mZnNldCxcbiAgICAgICAgICAgICAgICAkaW5maXgtbWFyZ2luLXRvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG5cblxuXG5cbi8vIFRoZW1lIHN0eWxlcyB0aGF0IG9ubHkgYXBwbHkgdG8gdGhlIHN0YW5kYXJkIGFwcGVhcmFuY2Ugb2YgdGhlIGZvcm0tZmllbGQuXG5cbkBtaXhpbiBtYXQtZm9ybS1maWVsZC1zdGFuZGFyZC10aGVtZSgkdGhlbWUpIHtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcbiAgJGlzLWRhcmstdGhlbWU6IG1hcC1nZXQoJHRoZW1lLCBpcy1kYXJrKTtcblxuICAkdW5kZXJsaW5lLWNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIGRpdmlkZXIsIGlmKCRpcy1kYXJrLXRoZW1lLCAwLjcsIDAuNDIpKTtcblxuICAubWF0LWZvcm0tZmllbGQtYXBwZWFyYW5jZS1zdGFuZGFyZCB7XG4gICAgLm1hdC1mb3JtLWZpZWxkLXVuZGVybGluZSB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkdW5kZXJsaW5lLWNvbG9yO1xuICAgIH1cblxuICAgICYubWF0LWZvcm0tZmllbGQtZGlzYWJsZWQgLm1hdC1mb3JtLWZpZWxkLXVuZGVybGluZSB7XG4gICAgICBAaW5jbHVkZSBtYXQtY29udHJvbC1kaXNhYmxlZC11bmRlcmxpbmUoJHVuZGVybGluZS1jb2xvcik7XG4gICAgfVxuICB9XG59XG5cbkBtaXhpbiBtYXQtZm9ybS1maWVsZC1zdGFuZGFyZC10eXBvZ3JhcGh5KCRjb25maWcpIHt9XG5cblxuLy8gVGhlbWUgc3R5bGVzIHRoYXQgYXBwbHkgdG8gYWxsIGFwcGVhcmFuY2VzIG9mIHRoZSBmb3JtLWZpZWxkLlxuQG1peGluIG1hdC1mb3JtLWZpZWxkLXRoZW1lKCR0aGVtZSkge1xuICAkcHJpbWFyeTogbWFwLWdldCgkdGhlbWUsIHByaW1hcnkpO1xuICAkYWNjZW50OiBtYXAtZ2V0KCR0aGVtZSwgYWNjZW50KTtcbiAgJHdhcm46IG1hcC1nZXQoJHRoZW1lLCB3YXJuKTtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcbiAgJGlzLWRhcmstdGhlbWU6IG1hcC1nZXQoJHRoZW1lLCBpcy1kYXJrKTtcblxuICAvLyBMYWJlbCBjb2xvcnMuIFJlcXVpcmVkIGlzIHVzZWQgZm9yIHRoZSBgKmAgc3RhciBzaG93biBpbiB0aGUgbGFiZWwuXG4gICRsYWJlbC1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBzZWNvbmRhcnktdGV4dCwgaWYoJGlzLWRhcmstdGhlbWUsIDAuNywgMC42KSk7XG4gICRmb2N1c2VkLWxhYmVsLWNvbG9yOiBtYXQtY29sb3IoJHByaW1hcnkpO1xuICAkcmVxdWlyZWQtbGFiZWwtY29sb3I6IG1hdC1jb2xvcigkYWNjZW50KTtcblxuICAvLyBVbmRlcmxpbmUgY29sb3JzLlxuICAkdW5kZXJsaW5lLWNvbG9yLWJhc2U6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGl2aWRlciwgaWYoJGlzLWRhcmstdGhlbWUsIDEsIDAuODcpKTtcbiAgJHVuZGVybGluZS1jb2xvci1hY2NlbnQ6IG1hdC1jb2xvcigkYWNjZW50KTtcbiAgJHVuZGVybGluZS1jb2xvci13YXJuOiBtYXQtY29sb3IoJHdhcm4pO1xuICAkdW5kZXJsaW5lLWZvY3VzZWQtY29sb3I6IG1hdC1jb2xvcigkcHJpbWFyeSk7XG5cbiAgLm1hdC1mb3JtLWZpZWxkLWxhYmVsIHtcbiAgICBjb2xvcjogJGxhYmVsLWNvbG9yO1xuICB9XG5cbiAgLm1hdC1oaW50IHtcbiAgICBjb2xvcjogJGxhYmVsLWNvbG9yO1xuICB9XG5cbiAgLm1hdC1mb3JtLWZpZWxkLm1hdC1mb2N1c2VkIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgY29sb3I6ICRmb2N1c2VkLWxhYmVsLWNvbG9yO1xuXG4gICAgJi5tYXQtYWNjZW50IHtcbiAgICAgIGNvbG9yOiAkdW5kZXJsaW5lLWNvbG9yLWFjY2VudDtcbiAgICB9XG5cbiAgICAmLm1hdC13YXJuIHtcbiAgICAgIGNvbG9yOiAkdW5kZXJsaW5lLWNvbG9yLXdhcm47XG4gICAgfVxuICB9XG5cbiAgLm1hdC1mb2N1c2VkIC5tYXQtZm9ybS1maWVsZC1yZXF1aXJlZC1tYXJrZXIge1xuICAgIGNvbG9yOiAkcmVxdWlyZWQtbGFiZWwtY29sb3I7XG4gIH1cblxuICAubWF0LWZvcm0tZmllbGQtcmlwcGxlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkdW5kZXJsaW5lLWNvbG9yLWJhc2U7XG4gIH1cblxuICAubWF0LWZvcm0tZmllbGQubWF0LWZvY3VzZWQge1xuICAgIC5tYXQtZm9ybS1maWVsZC1yaXBwbGUge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHVuZGVybGluZS1mb2N1c2VkLWNvbG9yO1xuXG4gICAgICAmLm1hdC1hY2NlbnQge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkdW5kZXJsaW5lLWNvbG9yLWFjY2VudDtcbiAgICAgIH1cblxuICAgICAgJi5tYXQtd2FybiB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR1bmRlcmxpbmUtY29sb3Itd2FybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAubWF0LWZvcm0tZmllbGQtdHlwZS1tYXQtbmF0aXZlLXNlbGVjdC5tYXQtZm9jdXNlZDpub3QoLm1hdC1mb3JtLWZpZWxkLWludmFsaWQpIHtcbiAgICAubWF0LWZvcm0tZmllbGQtaW5maXg6OmFmdGVyIHtcbiAgICAgIGNvbG9yOiAkdW5kZXJsaW5lLWZvY3VzZWQtY29sb3I7XG4gICAgfVxuXG4gICAgJi5tYXQtYWNjZW50IC5tYXQtZm9ybS1maWVsZC1pbmZpeDo6YWZ0ZXIge1xuICAgICAgY29sb3I6ICR1bmRlcmxpbmUtY29sb3ItYWNjZW50O1xuICAgIH1cblxuICAgICYubWF0LXdhcm4gLm1hdC1mb3JtLWZpZWxkLWluZml4OjphZnRlciB7XG4gICAgICBjb2xvcjogJHVuZGVybGluZS1jb2xvci13YXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0eWxpbmcgZm9yIHRoZSBlcnJvciBzdGF0ZSBvZiB0aGUgZm9ybSBmaWVsZC4gTm90ZSB0aGF0IHdoaWxlIHRoZSBzYW1lIGNhbiBiZVxuICAvLyBhY2hpZXZlZCB3aXRoIHRoZSBuZy0qIGNsYXNzZXMsIHdlIHVzZSB0aGlzIGFwcHJvYWNoIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IHRoZSBzYW1lXG4gIC8vIGxvZ2ljIGlzIHVzZWQgdG8gc3R5bGUgdGhlIGVycm9yIHN0YXRlIGFuZCB0byBzaG93IHRoZSBlcnJvciBtZXNzYWdlcy5cbiAgLm1hdC1mb3JtLWZpZWxkLm1hdC1mb3JtLWZpZWxkLWludmFsaWQge1xuICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICBjb2xvcjogJHVuZGVybGluZS1jb2xvci13YXJuO1xuXG4gICAgICAmLm1hdC1hY2NlbnQsXG4gICAgICAubWF0LWZvcm0tZmllbGQtcmVxdWlyZWQtbWFya2VyIHtcbiAgICAgICAgY29sb3I6ICR1bmRlcmxpbmUtY29sb3Itd2FybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAubWF0LWZvcm0tZmllbGQtcmlwcGxlLFxuICAgIC5tYXQtZm9ybS1maWVsZC1yaXBwbGUubWF0LWFjY2VudCB7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkdW5kZXJsaW5lLWNvbG9yLXdhcm47XG4gICAgfVxuICB9XG5cbiAgLm1hdC1lcnJvciB7XG4gICAgY29sb3I6ICR1bmRlcmxpbmUtY29sb3Itd2FybjtcbiAgfVxuXG4gIEBpbmNsdWRlIG1hdC1mb3JtLWZpZWxkLWxlZ2FjeS10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtZm9ybS1maWVsZC1zdGFuZGFyZC10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtZm9ybS1maWVsZC1maWxsLXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1mb3JtLWZpZWxkLW91dGxpbmUtdGhlbWUoJHRoZW1lKTtcbn1cblxuLy8gVXNlZCB0byBtYWtlIGluc3RhbmNlcyBvZiB0aGUgX21hdC1mb3JtLWZpZWxkLWxhYmVsLWZsb2F0aW5nIG1peGluIG5lZ2xpZ2libHkgZGlmZmVyZW50LFxuLy8gYW5kIHByZXZlbnQgR29vZ2xlJ3MgQ1NTIE9wdGltaXplciBmcm9tIGNvbGxhcHNpbmcgdGhlIGRlY2xhcmF0aW9ucy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBzb21lXG4vLyBvZiB0aGUgc2VsZWN0b3JzIGNvbnRhaW4gcHNldWRvLWNsYXNzZXMgbm90IHJlY29nbml6ZWQgaW4gYWxsIGJyb3dzZXJzLiBJZiBhIGJyb3dzZXIgZW5jb3VudGVyc1xuLy8gYW4gdW5rbm93biBwc2V1ZG8tY2xhc3MgaXQgd2lsbCBkaXNjYXJkIHRoZSBlbnRpcmUgcnVsZSBzZXQuXG4kbWF0LWZvcm0tZmllbGQtZGVkdXBlOiAwO1xuXG4vLyBBcHBsaWVzIGEgZmxvYXRpbmcgbGFiZWwgYWJvdmUgdGhlIGZvcm0gZmllbGQgY29udHJvbCBpdHNlbGYuXG5AbWl4aW4gX21hdC1mb3JtLWZpZWxkLWxhYmVsLWZsb2F0aW5nKCRmb250LXNjYWxlLCAkaW5maXgtcGFkZGluZywgJGluZml4LW1hcmdpbi10b3ApIHtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0kaW5maXgtbWFyZ2luLXRvcCAtICRpbmZpeC1wYWRkaW5nICsgJG1hdC1mb3JtLWZpZWxkLWRlZHVwZSlcbiAgICAgICAgICAgICBzY2FsZSgkZm9udC1zY2FsZSk7XG4gIHdpZHRoOiAxMDAlIC8gJGZvbnQtc2NhbGUgKyAkbWF0LWZvcm0tZmllbGQtZGVkdXBlO1xuXG4gICRtYXQtZm9ybS1maWVsZC1kZWR1cGU6ICRtYXQtZm9ybS1maWVsZC1kZWR1cGUgKyAwLjAwMDAxICFnbG9iYWw7XG59XG5cbkBtaXhpbiBtYXQtZm9ybS1maWVsZC10eXBvZ3JhcGh5KCRjb25maWcpIHtcbiAgLy8gVGhlIHVuaXQtbGVzcyBsaW5lLWhlaWdodCBmcm9tIHRoZSBmb250IGNvbmZpZy5cbiAgJGxpbmUtaGVpZ2h0OiBtYXQtbGluZS1oZWlnaHQoJGNvbmZpZywgaW5wdXQpO1xuXG4gIC8vIFRoZSBhbW91bnQgdG8gc2NhbGUgdGhlIGZvbnQgZm9yIHRoZSBmbG9hdGluZyBsYWJlbCBhbmQgc3Vic2NyaXB0LlxuICAkc3Vic2NyaXB0LWZvbnQtc2NhbGU6IDAuNzU7XG4gIC8vIFRoZSBhbW91bnQgdG8gc2NhbGUgdGhlIGZvbnQgZm9yIHRoZSBwcmVmaXggYW5kIHN1ZmZpeCBpY29ucy5cbiAgJHByZWZpeC1zdWZmaXgtaWNvbi1mb250LXNjYWxlOiAxLjU7XG5cbiAgLy8gVGhlIHBhZGRpbmcgb24gdGhlIGluZml4LiBNb2NrcyBzaG93IGhhbGYgb2YgdGhlIHRleHQgc2l6ZS5cbiAgJGluZml4LXBhZGRpbmc6IDAuNWVtO1xuICAvLyBUaGUgbWFyZ2luIGFwcGxpZWQgdG8gdGhlIGZvcm0tZmllbGQtaW5maXggdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgdGhlIGZsb2F0aW5nIGxhYmVsLlxuICAkaW5maXgtbWFyZ2luLXRvcDogMWVtICogJGxpbmUtaGVpZ2h0ICogJHN1YnNjcmlwdC1mb250LXNjYWxlO1xuICAvLyBGb250IHNpemUgdG8gdXNlIGZvciB0aGUgbGFiZWwgYW5kIHN1YnNjcmlwdCB0ZXh0LlxuICAkc3Vic2NyaXB0LWZvbnQtc2l6ZTogJHN1YnNjcmlwdC1mb250LXNjYWxlICogMTAwJTtcbiAgLy8gRm9udCBzaXplIHRvIHVzZSBmb3IgdGhlIGZvciB0aGUgcHJlZml4IGFuZCBzdWZmaXggaWNvbnMuXG4gICRwcmVmaXgtc3VmZml4LWljb24tZm9udC1zaXplOiAkcHJlZml4LXN1ZmZpeC1pY29uLWZvbnQtc2NhbGUgKiAxMDAlO1xuICAvLyBUaGUgc3BhY2UgYmV0d2VlbiB0aGUgYm90dG9tIG9mIHRoZSAubWF0LWZvcm0tZmllbGQtZmxleCBhcmVhIGFuZCB0aGUgc3Vic2NyaXB0IHdyYXBwZXIuXG4gIC8vIE1vY2tzIHNob3cgaGFsZiBvZiB0aGUgdGV4dCBzaXplLCBidXQgdGhpcyBtYXJnaW4gaXMgYXBwbGllZCB0byBhbiBlbGVtZW50IHdpdGggdGhlIHN1YnNjcmlwdFxuICAvLyB0ZXh0IGZvbnQgc2l6ZSwgc28gd2UgbmVlZCB0byBkaXZpZGUgYnkgdGhlIHNjYWxlIGZhY3RvciB0byBtYWtlIGl0IGhhbGYgb2YgdGhlIG9yaWdpbmFsIHRleHRcbiAgLy8gc2l6ZS5cbiAgJHN1YnNjcmlwdC1tYXJnaW4tdG9wOiAwLjVlbSAvICRzdWJzY3JpcHQtZm9udC1zY2FsZTtcbiAgLy8gVGhlIHBhZGRpbmcgYXBwbGllZCB0byB0aGUgZm9ybS1maWVsZC13cmFwcGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIHRoZSBzdWJzY3JpcHQsIHNpbmNlIGl0J3NcbiAgLy8gYWJzb2x1dGVseSBwb3NpdGlvbmVkLiBUaGlzIGlzIGEgY29tYmluYXRpb24gb2YgdGhlIHN1YnNjcmlwdCdzIG1hcmdpbiBhbmQgbGluZS1oZWlnaHQsIGJ1dCB3ZVxuICAvLyBuZWVkIHRvIG11bHRpcGx5IGJ5IHRoZSBzdWJzY3JpcHQgZm9udCBzY2FsZSBmYWN0b3Igc2luY2UgdGhlIHdyYXBwZXIgaGFzIGEgbGFyZ2VyIGZvbnQgc2l6ZS5cbiAgJHdyYXBwZXItcGFkZGluZy1ib3R0b206ICgkc3Vic2NyaXB0LW1hcmdpbi10b3AgKyAkbGluZS1oZWlnaHQpICogJHN1YnNjcmlwdC1mb250LXNjYWxlO1xuXG4gIC5tYXQtZm9ybS1maWVsZCB7XG4gICAgQGluY2x1ZGUgbWF0LXR5cG9ncmFwaHktbGV2ZWwtdG8tc3R5bGVzKCRjb25maWcsIGlucHV0KTtcbiAgfVxuXG4gIC5tYXQtZm9ybS1maWVsZC13cmFwcGVyIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogJHdyYXBwZXItcGFkZGluZy1ib3R0b207XG4gIH1cblxuICAubWF0LWZvcm0tZmllbGQtcHJlZml4LFxuICAubWF0LWZvcm0tZmllbGQtc3VmZml4IHtcbiAgICAvLyBBbGxvdyBpY29ucyBpbiBhIHByZWZpeCBvciBzdWZmaXggdG8gYWRhcHQgdG8gdGhlIGNvcnJlY3Qgc2l6ZS5cbiAgICAubWF0LWljb24ge1xuICAgICAgZm9udC1zaXplOiAkcHJlZml4LXN1ZmZpeC1pY29uLWZvbnQtc2l6ZTtcbiAgICAgIGxpbmUtaGVpZ2h0OiAkbGluZS1oZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgaWNvbiBidXR0b25zIGluIGEgcHJlZml4IG9yIHN1ZmZpeCB0byBhZGFwdCB0byB0aGUgY29ycmVjdCBzaXplLlxuICAgIC5tYXQtaWNvbi1idXR0b24ge1xuICAgICAgaGVpZ2h0OiAkcHJlZml4LXN1ZmZpeC1pY29uLWZvbnQtc2NhbGUgKiAxZW07XG4gICAgICB3aWR0aDogJHByZWZpeC1zdWZmaXgtaWNvbi1mb250LXNjYWxlICogMWVtO1xuXG4gICAgICAubWF0LWljb24ge1xuICAgICAgICBoZWlnaHQ6ICRsaW5lLWhlaWdodCAqIDFlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6ICRsaW5lLWhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAubWF0LWZvcm0tZmllbGQtaW5maXgge1xuICAgIHBhZGRpbmc6ICRpbmZpeC1wYWRkaW5nIDA7XG4gICAgLy8gVGhyb3dzIG9mZiB0aGUgYmFzZWxpbmUgaWYgd2UgZG8gaXQgYXMgYSByZWFsIG1hcmdpbiwgc28gd2UgZG8gaXQgYXMgYSBib3JkZXIgaW5zdGVhZC5cbiAgICBib3JkZXItdG9wOiAkaW5maXgtbWFyZ2luLXRvcCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgfVxuXG4gIC5tYXQtZm9ybS1maWVsZC1jYW4tZmxvYXQge1xuICAgICYubWF0LWZvcm0tZmllbGQtc2hvdWxkLWZsb2F0IC5tYXQtZm9ybS1maWVsZC1sYWJlbCxcbiAgICAubWF0LWlucHV0LXNlcnZlcjpmb2N1cyArIC5tYXQtZm9ybS1maWVsZC1sYWJlbC13cmFwcGVyIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICBAaW5jbHVkZSBfbWF0LWZvcm0tZmllbGQtbGFiZWwtZmxvYXRpbmcoXG4gICAgICAgICAgICAgICRzdWJzY3JpcHQtZm9udC1zY2FsZSwgJGluZml4LXBhZGRpbmcsICRpbmZpeC1tYXJnaW4tdG9wKTtcbiAgICB9XG5cbiAgICAvLyBTZXJ2ZXItc2lkZSByZW5kZXJlZCBtYXRJbnB1dCB3aXRoIGEgbGFiZWwgYXR0cmlidXRlIGJ1dCBsYWJlbCBub3Qgc2hvd25cbiAgICAvLyAodXNlZCBhcyBhIHB1cmUgQ1NTIHN0YW5kLWluIGZvciBtYXQtZm9ybS1maWVsZC1zaG91bGQtZmxvYXQpLlxuICAgIC5tYXQtaW5wdXQtc2VydmVyW2xhYmVsXTpub3QoOmxhYmVsLXNob3duKSArIC5tYXQtZm9ybS1maWVsZC1sYWJlbC13cmFwcGVyXG4gICAgICAgIC5tYXQtZm9ybS1maWVsZC1sYWJlbCB7XG4gICAgICBAaW5jbHVkZSBfbWF0LWZvcm0tZmllbGQtbGFiZWwtZmxvYXRpbmcoXG4gICAgICAgICAgICAgICRzdWJzY3JpcHQtZm9udC1zY2FsZSwgJGluZml4LXBhZGRpbmcsICRpbmZpeC1tYXJnaW4tdG9wKTtcbiAgICB9XG4gIH1cblxuICAubWF0LWZvcm0tZmllbGQtbGFiZWwtd3JhcHBlciB7XG4gICAgdG9wOiAtJGluZml4LW1hcmdpbi10b3A7XG4gICAgcGFkZGluZy10b3A6ICRpbmZpeC1tYXJnaW4tdG9wO1xuICB9XG5cbiAgLm1hdC1mb3JtLWZpZWxkLWxhYmVsIHtcbiAgICB0b3A6ICRpbmZpeC1tYXJnaW4tdG9wICsgJGluZml4LXBhZGRpbmc7XG4gIH1cblxuICAubWF0LWZvcm0tZmllbGQtdW5kZXJsaW5lIHtcbiAgICAvLyBXZSB3YW50IHRoZSB1bmRlcmxpbmUgdG8gc3RhcnQgYXQgdGhlIGVuZCBvZiB0aGUgY29udGVudCBib3gsIG5vdCB0aGUgcGFkZGluZyBib3gsXG4gICAgLy8gc28gd2UgbW92ZSBpdCB1cCBieSB0aGUgcGFkZGluZyBhbW91bnQuXG4gICAgYm90dG9tOiAkd3JhcHBlci1wYWRkaW5nLWJvdHRvbTtcbiAgfVxuXG4gIC5tYXQtZm9ybS1maWVsZC1zdWJzY3JpcHQtd3JhcHBlciB7XG4gICAgZm9udC1zaXplOiAkc3Vic2NyaXB0LWZvbnQtc2l6ZTtcbiAgICBtYXJnaW4tdG9wOiAkc3Vic2NyaXB0LW1hcmdpbi10b3A7XG5cbiAgICAvLyBXZSB3YW50IHRoZSBzdWJzY3JpcHQgdG8gc3RhcnQgYXQgdGhlIGVuZCBvZiB0aGUgY29udGVudCBib3gsIG5vdCB0aGUgcGFkZGluZyBib3gsXG4gICAgLy8gc28gd2UgbW92ZSBpdCB1cCBieSB0aGUgcGFkZGluZyBhbW91bnQgKGFkanVzdGVkIGZvciB0aGUgc21hbGxlciBmb250IHNpemUpO1xuICAgIHRvcDogY2FsYygxMDAlIC0gI3skd3JhcHBlci1wYWRkaW5nLWJvdHRvbSAvICRzdWJzY3JpcHQtZm9udC1zY2FsZX0pO1xuICB9XG5cbiAgQGluY2x1ZGUgbWF0LWZvcm0tZmllbGQtbGVnYWN5LXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC1mb3JtLWZpZWxkLXN0YW5kYXJkLXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC1mb3JtLWZpZWxkLWZpbGwtdHlwb2dyYXBoeSgkY29uZmlnKTtcbiAgQGluY2x1ZGUgbWF0LWZvcm0tZmllbGQtb3V0bGluZS10eXBvZ3JhcGh5KCRjb25maWcpO1xufVxuXG5cblxuXG5cbkBtaXhpbiBtYXQtdHJlZS10aGVtZSgkdGhlbWUpIHtcbiAgJGJhY2tncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBiYWNrZ3JvdW5kKTtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAubWF0LXRyZWUge1xuICAgIGJhY2tncm91bmQ6IG1hdC1jb2xvcigkYmFja2dyb3VuZCwgJ2NhcmQnKTtcbiAgfVxuXG4gIC5tYXQtdHJlZS1ub2RlLFxuICAubWF0LW5lc3RlZC10cmVlLW5vZGUge1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHRleHQpO1xuICB9XG59XG5cbkBtaXhpbiBtYXQtdHJlZS10eXBvZ3JhcGh5KCRjb25maWcpIHtcbiAgLm1hdC10cmVlIHtcbiAgICBmb250LWZhbWlseTogbWF0LWZvbnQtZmFtaWx5KCRjb25maWcpO1xuICB9XG5cbiAgLm1hdC10cmVlLW5vZGUsXG4gIC5tYXQtbmVzdGVkLXRyZWUtbm9kZSB7XG4gICAgZm9udC13ZWlnaHQ6IG1hdC1mb250LXdlaWdodCgkY29uZmlnLCBib2R5LTEpO1xuICAgIGZvbnQtc2l6ZTogbWF0LWZvbnQtc2l6ZSgkY29uZmlnLCBib2R5LTEpO1xuICB9XG59XG5cblxuXG4vLyBJbmNsdWRlcyBhbGwgb2YgdGhlIHR5cG9ncmFwaGljIHN0eWxlcy5cbkBtaXhpbiBhbmd1bGFyLW1hdGVyaWFsLXR5cG9ncmFwaHkoJGNvbmZpZzogbnVsbCkge1xuICBAaWYgJGNvbmZpZyA9PSBudWxsIHtcbiAgICAkY29uZmlnOiBtYXQtdHlwb2dyYXBoeS1jb25maWcoKTtcbiAgfVxuXG4gIEBpbmNsdWRlIG1hdC1iYWRnZS10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtYmFzZS10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtYXV0b2NvbXBsZXRlLXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC1ib3R0b20tc2hlZXQtdHlwb2dyYXBoeSgkY29uZmlnKTtcbiAgQGluY2x1ZGUgbWF0LWJ1dHRvbi10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtYnV0dG9uLXRvZ2dsZS10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtY2FyZC10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtY2hlY2tib3gtdHlwb2dyYXBoeSgkY29uZmlnKTtcbiAgQGluY2x1ZGUgbWF0LWNoaXBzLXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC10YWJsZS10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtZGF0ZXBpY2tlci10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtZGlhbG9nLXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC1leHBhbnNpb24tcGFuZWwtdHlwb2dyYXBoeSgkY29uZmlnKTtcbiAgQGluY2x1ZGUgbWF0LWZvcm0tZmllbGQtdHlwb2dyYXBoeSgkY29uZmlnKTtcbiAgQGluY2x1ZGUgbWF0LWdyaWQtbGlzdC10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtaWNvbi10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtaW5wdXQtdHlwb2dyYXBoeSgkY29uZmlnKTtcbiAgQGluY2x1ZGUgbWF0LW1lbnUtdHlwb2dyYXBoeSgkY29uZmlnKTtcbiAgQGluY2x1ZGUgbWF0LXBhZ2luYXRvci10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtcHJvZ3Jlc3MtYmFyLXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC1wcm9ncmVzcy1zcGlubmVyLXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC1yYWRpby10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtc2VsZWN0LXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC1zaWRlbmF2LXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC1zbGlkZS10b2dnbGUtdHlwb2dyYXBoeSgkY29uZmlnKTtcbiAgQGluY2x1ZGUgbWF0LXNsaWRlci10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtc3RlcHBlci10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtc29ydC10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtdGFicy10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtdG9vbGJhci10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtdG9vbHRpcC10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtbGlzdC10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtb3B0aW9uLXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC1vcHRncm91cC10eXBvZ3JhcGh5KCRjb25maWcpO1xuICBAaW5jbHVkZSBtYXQtc25hY2stYmFyLXR5cG9ncmFwaHkoJGNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC10cmVlLXR5cG9ncmFwaHkoJGNvbmZpZyk7XG59XG5cblxuLy8gTWl4aW4gdGhhdCByZW5kZXJzIGFsbCBvZiB0aGUgY29yZSBzdHlsZXMgdGhhdCBhcmUgbm90IHRoZW1lLWRlcGVuZGVudC5cbkBtaXhpbiBtYXQtY29yZSgkdHlwb2dyYXBoeS1jb25maWc6IG51bGwpIHtcbiAgQGluY2x1ZGUgYW5ndWxhci1tYXRlcmlhbC10eXBvZ3JhcGh5KCR0eXBvZ3JhcGh5LWNvbmZpZyk7XG4gIEBpbmNsdWRlIG1hdC1yaXBwbGUoKTtcbiAgQGluY2x1ZGUgY2RrLWExMXkoKTtcbiAgQGluY2x1ZGUgY2RrLW92ZXJsYXkoKTtcbiAgQGluY2x1ZGUgY2RrLXRleHQtZmllbGQoKTtcbn1cblxuLy8gTWl4aW4gdGhhdCByZW5kZXJzIGFsbCBvZiB0aGUgY29yZSBzdHlsZXMgdGhhdCBkZXBlbmQgb24gdGhlIHRoZW1lLlxuQG1peGluIG1hdC1jb3JlLXRoZW1lKCR0aGVtZSkge1xuICBAaW5jbHVkZSBtYXQtcmlwcGxlLXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1vcHRpb24tdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LW9wdGdyb3VwLXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1wc2V1ZG8tY2hlY2tib3gtdGhlbWUoJHRoZW1lKTtcblxuICAvLyBQcm92aWRlcyBleHRlcm5hbCBDU1MgY2xhc3NlcyBmb3IgZWFjaCBlbGV2YXRpb24gdmFsdWUuIEVhY2ggQ1NTIGNsYXNzIGlzIGZvcm1hdHRlZCBhc1xuICAvLyBgbWF0LWVsZXZhdGlvbi16JHpWYWx1ZWAgd2hlcmUgYCR6VmFsdWVgIGNvcnJlc3BvbmRzIHRvIHRoZSB6LXNwYWNlIHRvIHdoaWNoIHRoZSBlbGVtZW50IGlzXG4gIC8vIGVsZXZhdGVkLlxuICBAZm9yICR6VmFsdWUgZnJvbSAwIHRocm91Z2ggMjQge1xuICAgIC4jeyRfbWF0LWVsZXZhdGlvbi1wcmVmaXh9I3skelZhbHVlfSB7XG4gICAgICBAaW5jbHVkZSBfbWF0LXRoZW1lLWVsZXZhdGlvbigkelZhbHVlLCAkdGhlbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdyYXBwZXIgZWxlbWVudCB0aGF0IHByb3ZpZGVzIHRoZSB0aGVtZSBiYWNrZ3JvdW5kIHdoZW4gdGhlIHVzZXIncyBjb250ZW50IGlzbid0XG4gIC8vIGluc2lkZSBvZiBhIGBtYXQtc2lkZW5hdi1jb250YWluZXJgLiBOb3RlIHRoYXQgd2UgbmVlZCB0byBleGNsdWRlIHRoZSBhbXBlcnNhbmRcbiAgLy8gc2VsZWN0b3IgaW4gY2FzZSB0aGUgbWl4aW4gaXMgaW5jbHVkZWQgYXQgdGhlIHRvcCBsZXZlbC5cbiAgLm1hdC1hcHAtYmFja2dyb3VuZCN7aWYoJiwgJywgJi5tYXQtYXBwLWJhY2tncm91bmQnLCAnJyl9IHtcbiAgICAkYmFja2dyb3VuZDogbWFwLWdldCgkdGhlbWUsIGJhY2tncm91bmQpO1xuICAgICRmb3JlZ3JvdW5kOiBtYXAtZ2V0KCR0aGVtZSwgZm9yZWdyb3VuZCk7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBtYXQtY29sb3IoJGJhY2tncm91bmQsIGJhY2tncm91bmQpO1xuICAgIGNvbG9yOiBtYXQtY29sb3IoJGZvcmVncm91bmQsIHRleHQpO1xuICB9XG5cbiAgLy8gTWFya2VyIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgdXNlciBoYXMgYWRkZWQgYSB0aGVtZSB0byB0aGVpciBwYWdlLlxuICBAYXQtcm9vdCB7XG4gICAgLm1hdC10aGVtZS1sb2FkZWQtbWFya2VyIHtcbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICB9XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbkBtaXhpbiBtYXQtZGl2aWRlci10aGVtZSgkdGhlbWUpIHtcbiAgJGZvcmVncm91bmQ6IG1hcC1nZXQoJHRoZW1lLCBmb3JlZ3JvdW5kKTtcblxuICAubWF0LWRpdmlkZXIge1xuICAgIGJvcmRlci10b3AtY29sb3I6IG1hdC1jb2xvcigkZm9yZWdyb3VuZCwgZGl2aWRlcik7XG4gIH1cblxuICAubWF0LWRpdmlkZXItdmVydGljYWwge1xuICAgIGJvcmRlci1yaWdodC1jb2xvcjogbWF0LWNvbG9yKCRmb3JlZ3JvdW5kLCBkaXZpZGVyKTtcbiAgfVxufVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyBDcmVhdGUgYSB0aGVtZS5cbkBtaXhpbiBhbmd1bGFyLW1hdGVyaWFsLXRoZW1lKCR0aGVtZSkge1xuICBAaW5jbHVkZSBtYXQtY29yZS10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtYXV0b2NvbXBsZXRlLXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1iYWRnZS10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtYm90dG9tLXNoZWV0LXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1idXR0b24tdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LWJ1dHRvbi10b2dnbGUtdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LWNhcmQtdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LWNoZWNrYm94LXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1jaGlwcy10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtdGFibGUtdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LWRhdGVwaWNrZXItdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LWRpYWxvZy10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtZGl2aWRlci10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtZXhwYW5zaW9uLXBhbmVsLXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1mb3JtLWZpZWxkLXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1ncmlkLWxpc3QtdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LWljb24tdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LWlucHV0LXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1saXN0LXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1tZW51LXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1wYWdpbmF0b3ItdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LXByb2dyZXNzLWJhci10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtcHJvZ3Jlc3Mtc3Bpbm5lci10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtcmFkaW8tdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LXNlbGVjdC10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtc2lkZW5hdi10aGVtZSgkdGhlbWUpO1xuICBAaW5jbHVkZSBtYXQtc2xpZGUtdG9nZ2xlLXRoZW1lKCR0aGVtZSk7XG4gIEBpbmNsdWRlIG1hdC1zbGlkZXItdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LXN0ZXBwZXItdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LXNvcnQtdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LXRhYnMtdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LXRvb2xiYXItdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LXRvb2x0aXAtdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LXRyZWUtdGhlbWUoJHRoZW1lKTtcbiAgQGluY2x1ZGUgbWF0LXNuYWNrLWJhci10aGVtZSgkdGhlbWUpO1xufVxuIiwiQGltcG9ydCAnfkBhbmd1bGFyL21hdGVyaWFsL3RoZW1pbmcnO1xuOmhvc3Qge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIHRvcDogMDtcbiAgICByaWdodDogMDtcbiAgICBib3R0b206IDA7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbWF0LWNvbG9yKG1hdC1wYWxldHRlKCRtYXQtZ3JleSwgMzAwKSk7XG59XG5cbi5zcGxhc2hzY3JlZW4tbG9nbyB7XG4gICAgd2lkdGg6IDE0NHB4O1xuICAgIGhlaWdodDogMTQ0cHg7XG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbn1cblxuLnNwbGFzaHNjcmVlbi10ZXh0IHtcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIycHg7XG4gICAgcGFkZGluZy1sZWZ0OiAxNnB4O1xuICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7XG4gICAgcGFkZGluZy1ib3R0b206IDE2cHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuIl19 */"

/***/ }),

/***/ "./src/app/modules/editor/components/splashscreen/splashscreen.component.ts":
/*!**********************************************************************************!*\
  !*** ./src/app/modules/editor/components/splashscreen/splashscreen.component.ts ***!
  \**********************************************************************************/
/*! exports provided: SplashScreenComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplashScreenComponent", function() { return SplashScreenComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");


var SplashScreenComponent = /** @class */ (function () {
    function SplashScreenComponent() {
    }
    SplashScreenComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-splashscreen',
            template: __webpack_require__(/*! ./splashscreen.component.html */ "./src/app/modules/editor/components/splashscreen/splashscreen.component.html"),
            styles: [__webpack_require__(/*! ./splashscreen.component.scss */ "./src/app/modules/editor/components/splashscreen/splashscreen.component.scss")],
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        })
    ], SplashScreenComponent);
    return SplashScreenComponent;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/splitter/splitter.component.html":
/*!****************************************************************************!*\
  !*** ./src/app/modules/editor/components/splitter/splitter.component.html ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div></div>\n"

/***/ }),

/***/ "./src/app/modules/editor/components/splitter/splitter.component.scss":
/*!****************************************************************************!*\
  !*** ./src/app/modules/editor/components/splitter/splitter.component.scss ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ":host {\n  position: absolute;\n  z-index: 100; }\n\n:host(.splt-vertical) {\n  position: absolute;\n  z-index: 100;\n  top: 0;\n  bottom: 0;\n  width: 4px;\n  cursor: col-resize; }\n\n:host(.splt-horizontal) {\n  position: absolute;\n  z-index: 100;\n  left: 0;\n  right: 0;\n  height: 4px;\n  cursor: row-resize; }\n\n:host(.splt-edge-left) {\n  position: absolute;\n  z-index: 100;\n  left: 0; }\n\n:host(.splt-edge-right) {\n  position: absolute;\n  z-index: 100;\n  right: 0; }\n\n:host(.splt-edge-top) {\n  position: absolute;\n  z-index: 100;\n  top: 0; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL3NwbGl0dGVyL3NwbGl0dGVyLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBO0VBQ0ksbUJBQWtCO0VBQ2xCLGFBQVksRUFDZjs7QUFFRDtFQUNJLG1CQUFrQjtFQUNsQixhQUFZO0VBQ1osT0FBTTtFQUNOLFVBQVM7RUFDVCxXQVhlO0VBWWYsbUJBQWtCLEVBQ3JCOztBQUVEO0VBQ0ksbUJBQWtCO0VBQ2xCLGFBQVk7RUFDWixRQUFPO0VBQ1AsU0FBUTtFQUNSLFlBcEJlO0VBcUJmLG1CQUFrQixFQUNyQjs7QUFFRDtFQUNJLG1CQUFrQjtFQUNsQixhQUFZO0VBQ1osUUFBTyxFQUNWOztBQUVEO0VBQ0ksbUJBQWtCO0VBQ2xCLGFBQVk7RUFDWixTQUFRLEVBQ1g7O0FBRUQ7RUFDSSxtQkFBa0I7RUFDbEIsYUFBWTtFQUNaLE9BQU0sRUFDVCIsImZpbGUiOiJzcmMvYXBwL21vZHVsZXMvZWRpdG9yL2NvbXBvbmVudHMvc3BsaXR0ZXIvc3BsaXR0ZXIuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIkc3BsaXR0ZXJXaWR0aDogNHB4O1xuOmhvc3Qge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB6LWluZGV4OiAxMDA7XG59XG5cbjpob3N0KC5zcGx0LXZlcnRpY2FsKSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6IDEwMDtcbiAgICB0b3A6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIHdpZHRoOiAkc3BsaXR0ZXJXaWR0aDtcbiAgICBjdXJzb3I6IGNvbC1yZXNpemU7XG59XG5cbjpob3N0KC5zcGx0LWhvcml6b250YWwpIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgei1pbmRleDogMTAwO1xuICAgIGxlZnQ6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgaGVpZ2h0OiAkc3BsaXR0ZXJXaWR0aDtcbiAgICBjdXJzb3I6IHJvdy1yZXNpemU7XG59XG5cbjpob3N0KC5zcGx0LWVkZ2UtbGVmdCkge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB6LWluZGV4OiAxMDA7XG4gICAgbGVmdDogMDtcbn1cblxuOmhvc3QoLnNwbHQtZWRnZS1yaWdodCkge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB6LWluZGV4OiAxMDA7XG4gICAgcmlnaHQ6IDA7XG59XG5cbjpob3N0KC5zcGx0LWVkZ2UtdG9wKSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHotaW5kZXg6IDEwMDtcbiAgICB0b3A6IDA7XG59XG4iXX0= */"

/***/ }),

/***/ "./src/app/modules/editor/components/splitter/splitter.component.ts":
/*!**************************************************************************!*\
  !*** ./src/app/modules/editor/components/splitter/splitter.component.ts ***!
  \**************************************************************************/
/*! exports provided: SplitterComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplitterComponent", function() { return SplitterComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_scripts_dragger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/dragger */ "./src/app/modules/editor/scripts/dragger/index.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_3__);




var SplitterComponent = /** @class */ (function () {
    function SplitterComponent(elementRef) {
        this.elementRef = elementRef;
        this.split = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.backgroundColor = '';
        this.isHovering = false;
        this.isDragging = false;
    }
    SplitterComponent.prototype.ngOnInit = function () {
        var _this = this;
        if (this.min === undefined || this.min <= 0) {
            this.min = 100;
        }
        if (this.persistId) {
            this.persistKey = "$$splitter::" + this.persistId;
        }
        this.orientation = this.edge === 'left' || this.edge === 'right' ? 'vertical' : 'horizontal';
        this.spltHorizontal = this.orientation === 'horizontal';
        this.spltVertical = this.orientation === 'vertical';
        this.spltEdgeLeft = this.edge === 'left';
        this.spltEdgeRight = this.edge === 'right';
        var getParentFn = function () { return jquery__WEBPACK_IMPORTED_MODULE_3__(_this.elementRef.nativeElement).parent(); };
        if (this.orientation === 'vertical') {
            this.sizeGetterFn = function () { return getParentFn().width(); };
            this.sizeSetterFn = function (size) {
                getParentFn().width(size);
                _this.split.emit(size);
            };
        }
        else {
            this.sizeGetterFn = function () { return getParentFn().height(); };
            this.sizeSetterFn = function (size) {
                getParentFn().height(size);
                _this.split.emit(size);
            };
        }
        if (this.persistKey in localStorage) {
            this.setSize(Number(localStorage[this.persistKey]));
        }
    };
    SplitterComponent.prototype.setSize = function (size) {
        if (this.persistKey) {
            localStorage[this.persistKey] = size;
        }
        this.sizeSetterFn(size);
    };
    SplitterComponent.prototype.onMouseDown = function (event) {
        var _this = this;
        var downSize = this.sizeGetterFn();
        event.preventDefault();
        this.isDragging = true;
        this.showSplitter();
        // tslint:disable-next-line: no-unused-expression
        new app_modules_editor_scripts_dragger__WEBPACK_IMPORTED_MODULE_2__["Dragger"]({
            downX: event.clientX,
            downY: event.clientY,
            direction: this.orientation === 'vertical' ? 'horizontal' : 'vertical',
            draggingCursor: this.orientation === 'vertical' ? 'col-resize' : 'row-resize',
            onBeginDragFn: function () {
                _this.isDragging = true;
                _this.showSplitter();
            },
            onDragFn: function (_, p) {
                var sign = _this.edge === 'left' || _this.edge === 'top' ? -1 : 1;
                var d = _this.orientation === 'vertical' ? p.x : p.y;
                _this.setSize(Math.max(_this.min, downSize + sign * d));
            },
            onDropFn: function () {
                _this.isDragging = false;
                _this.hideSplitter();
            },
        });
    };
    SplitterComponent.prototype.onMouseEnter = function () {
        this.isHovering = true;
        this.showSplitter();
    };
    SplitterComponent.prototype.onMouseLeave = function () {
        this.isHovering = false;
        this.hideSplitter();
    };
    SplitterComponent.prototype.showSplitter = function () {
        if (this.isDragging || this.isHovering) {
            this.backgroundColor = 'rgba(0, 0, 0, 0.1)';
        }
    };
    SplitterComponent.prototype.hideSplitter = function () {
        if (!this.isDragging && !this.isHovering) {
            this.backgroundColor = 'transparent';
        }
    };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], SplitterComponent.prototype, "edge", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Number)
    ], SplitterComponent.prototype, "min", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], SplitterComponent.prototype, "persistId", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], SplitterComponent.prototype, "split", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"])('class.splt-horizontal'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Boolean)
    ], SplitterComponent.prototype, "spltHorizontal", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"])('class.splt-vertical'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Boolean)
    ], SplitterComponent.prototype, "spltVertical", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"])('class.splt-edge-left'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Boolean)
    ], SplitterComponent.prototype, "spltEdgeLeft", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"])('class.splt-edge-right'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Boolean)
    ], SplitterComponent.prototype, "spltEdgeRight", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"])('style.backgroundColor'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], SplitterComponent.prototype, "backgroundColor", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('mousedown', ['$event']),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [MouseEvent]),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], SplitterComponent.prototype, "onMouseDown", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('mouseenter'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", []),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], SplitterComponent.prototype, "onMouseEnter", null);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"])('mouseleave'),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Function),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", []),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:returntype", void 0)
    ], SplitterComponent.prototype, "onMouseLeave", null);
    SplitterComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-splitter',
            template: __webpack_require__(/*! ./splitter.component.html */ "./src/app/modules/editor/components/splitter/splitter.component.html"),
            styles: [__webpack_require__(/*! ./splitter.component.scss */ "./src/app/modules/editor/components/splitter/splitter.component.scss")],
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]])
    ], SplitterComponent);
    return SplitterComponent;
}());



/***/ }),

/***/ "./src/app/modules/editor/components/toolbar/toolbar.component.html":
/*!**************************************************************************!*\
  !*** ./src/app/modules/editor/components/toolbar/toolbar.component.html ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<ng-container *ngIf=\"(this.toolbarData$ | async) as toolbarData\">\n  <div fxLayout=\"row\"\n    fxLayoutAlign=\"center center\"\n    *ngIf=\"(this.themeState$ | async) as state\"\n    [class.dark-to-light-primary]=\"state.prevThemeType === 'dark' && state.currThemeType === 'light' && !state.currIsActionMode\"\n\n    [class.light-to-dark-primary]=\"state.prevThemeType === 'light' && state.currThemeType === 'dark' && !state.currIsActionMode\"\n\n    [class.dark-to-light-accent]=\"state.prevThemeType === 'dark' && state.currThemeType === 'light' && state.currIsActionMode\"\n\n    [class.light-to-dark-accent]=\"state.prevThemeType === 'light' && state.currThemeType === 'dark' && state.currIsActionMode\"\n\n    [class.action-mode-on-to-off-dark]=\"state.hasActionModeBeenEnabled && !state.currIsActionMode && state.currThemeType === 'dark'\"\n\n    [class.action-mode-off-to-on-dark]=\"state.currIsActionMode && state.currThemeType === 'dark'\"\n    [class.action-mode-on-to-off-light]=\"state.hasActionModeBeenEnabled && !state.currIsActionMode && state.currThemeType === 'light'\"\n\n    [class.action-mode-off-to-on-light]=\"state.currIsActionMode && state.currThemeType === 'light'\"\n    class=\"toolbar mat-elevation-z2\">\n\n    <ng-container *ngIf=\"{\n      showActionMode: toolbarData.shouldShowActionMode(),\n      numSubPaths: toolbarData.getNumSubPaths(),\n      numSegments: toolbarData.getNumSegments(),\n      numPoints: toolbarData.getNumPoints(),\n      toolbarTitle: toolbarData.getToolbarTitle(),\n      toolbarSubtitle: toolbarData.getToolbarSubtitle(),\n      showAddPoints: toolbarData.getNumSubPaths() > 0 || toolbarData.getNumSegments() > 0 || !toolbarData.isSelectionMode(),\n      showSplitSubPaths: toolbarData.getNumSubPaths() > 0 || toolbarData.getNumSegments() > 0 || !toolbarData.isSelectionMode(),\n      showPairSubPaths: toolbarData.shouldShowPairSubPaths(),\n      showReverseSubPaths: toolbarData.getNumSubPaths() === 1,\n      showShiftSubPath: toolbarData.shouldShowShiftSubPath(),\n      showSetFirstPosition: toolbarData.shouldShowSetFirstPosition(),\n      showDeleteSubPaths: toolbarData.getNumSplitSubPaths() > 0,\n      showDeleteSegments: toolbarData.getNumSegments() > 0,\n      showDeletePoints: toolbarData.getNumSplitPoints() > 0,\n      showSplitInHalf: toolbarData.shouldShowSplitInHalf(),\n      showAutoFix: toolbarData.shouldShowAutoFix()\n    } as data\">\n\n      <!-- Shape Shifter logo. -->\n      <mat-icon *ngIf=\"!data.showActionMode\"\n        class=\"toolbar-logo\"\n        svgIcon=\"shapeshifter\">\n      </mat-icon>\n\n      <!-- Action mode close button. -->\n      <button mat-icon-button\n        *ngIf=\"data.showActionMode\"\n        class=\"action-mode-close-icon\"\n        (click)=\"onCloseActionModeClick($event)\">\n        <mat-icon>{{ toolbarData.isSelectionMode() ? 'arrow_back' : 'close' }}</mat-icon>\n      </button>\n\n      <!-- Toolbar text. -->\n      <div fxLayout=\"column\">\n        <span class=\"toolbar-title\">{{ data.toolbarTitle }}</span>\n        <span *ngIf=\"data.toolbarSubtitle\"\n          class=\"toolbar-subtitle\">\n          {{ data.toolbarSubtitle }}\n        </span>\n      </div>\n\n      <span fxFlex=\"1 1 auto\"></span>\n\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        (click)=\"onAutoFixClick($event)\"\n        matTooltip=\"Auto fix\"\n        matTooltipShowDelay=\"500\"\n        *ngIf=\"data.showAutoFix\"\n        matTooltipPosition=\"below\">\n        <mat-icon svgIcon=\"autofix\"></mat-icon>\n      </button>\n\n      <!-- SubPath mode. -->\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        matTooltip=\"Add points (A)\"\n        matTooltipPosition=\"below\"\n        *ngIf=\"data.showAddPoints\"\n        matTooltipShowDelay=\"500\"\n        (click)=\"onAddPointsClick($event)\"\n        [class.activated]=\"toolbarData.isAddPointsMode()\">\n        <mat-icon>add_circle_outline</mat-icon>\n      </button>\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        matTooltip=\"Split subpaths (S)\"\n        matTooltipPosition=\"below\"\n        *ngIf=\"data.showSplitSubPaths\"\n        matTooltipShowDelay=\"500\"\n        (click)=\"onSplitSubPathsClick($event)\"\n        [class.activated]=\"toolbarData.isSplitSubPathsMode()\">\n        <mat-icon>content_cut</mat-icon>\n      </button>\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        matTooltip=\"Pair subpaths (D)\"\n        matTooltipPosition=\"below\"\n        *ngIf=\"data.showPairSubPaths\"\n        matTooltipShowDelay=\"500\"\n        (click)=\"onPairSubPathsClick($event)\"\n        [class.activated]=\"toolbarData.isPairSubPathsMode()\">\n        <mat-icon>compare_arrows</mat-icon>\n      </button>\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        matTooltip=\"Reverse points (R)\"\n        matTooltipPosition=\"below\"\n        *ngIf=\"data.showReverseSubPaths\"\n        matTooltipShowDelay=\"500\"\n        (click)=\"onReversePointsClick($event)\"\n        [disabled]=\"!toolbarData.isSelectionMode()\">\n        <mat-icon svgIcon=\"reverse\"></mat-icon>\n      </button>\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        matTooltip=\"Shift back points (B)\"\n        matTooltipPosition=\"below\"\n        *ngIf=\"data.showShiftSubPath\"\n        matTooltipShowDelay=\"500\"\n        (click)=\"onShiftBackPointsClick($event)\"\n        [disabled]=\"!toolbarData.isSelectionMode()\">\n        <mat-icon>skip_previous</mat-icon>\n      </button>\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        matTooltip=\"Shift forward points (F)\"\n        matTooltipPosition=\"below\"\n        *ngIf=\"data.showShiftSubPath\"\n        matTooltipShowDelay=\"500\"\n        (click)=\"onShiftForwardPointsClick($event)\"\n        [disabled]=\"!toolbarData.isSelectionMode()\">\n        <mat-icon>skip_next</mat-icon>\n      </button>\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        matTooltipPosition=\"below\"\n        matTooltip=\"Delete subpath{{data.numSubPaths === 1 ? '' : 's'}}\"\n        matTooltipShowDelay=\"500\"\n        *ngIf=\"data.showDeleteSubPaths\"\n        (click)=\"onDeleteSubPathsClick($event)\">\n        <mat-icon>delete</mat-icon>\n      </button>\n\n      <!-- Segment mode. -->\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        matTooltipPosition=\"below\"\n        matTooltip=\"Delete segment{{data.numSegments === 1 ? '' : 's'}}\"\n        matTooltipShowDelay=\"500\"\n        *ngIf=\"data.showDeleteSegments\"\n        (click)=\"onDeleteSegmentsClick($event)\">\n        <mat-icon>delete</mat-icon>\n      </button>\n\n      <!-- Point mode. -->\n      <button mat-icon-button\n        matTooltip=\"Add point (A)\"\n        matTooltipPosition=\"below\"\n        matTooltipShowDelay=\"500\"\n        *ngIf=\"data.showSplitInHalf\"\n        (mouseenter)=\"onSplitInHalfHoverEvent(true)\"\n        (mouseleave)=\"onSplitInHalfHoverEvent(false)\"\n        (click)=\"onSplitInHalfClick($event)\">\n        <mat-icon>add_circle_outline</mat-icon>\n      </button>\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        matTooltip=\"Set first point (F)\"\n        matTooltipPosition=\"below\"\n        matTooltipShowDelay=\"500\"\n        *ngIf=\"data.showSetFirstPosition\"\n        (click)=\"onSetFirstPositionClick($event)\">\n        <mat-icon>looks_one</mat-icon>\n      </button>\n      <button mat-icon-button\n        class=\"toolbar-action-button\"\n        matTooltipPosition=\"below\"\n        matTooltip=\"Delete point{{data.numPoints === 1 ? '' : 's'}}\"\n        matTooltipShowDelay=\"500\"\n        *ngIf=\"data.showDeletePoints\"\n        (click)=\"onDeletePointsClick($event)\">\n        <mat-icon>delete</mat-icon>\n      </button>\n\n      <!-- Overflow menu buttons. -->\n      <button class=\"toolbar-action-button\"\n        mat-icon-button\n        (click)=\"$event.stopPropagation()\"\n        [matMenuTriggerFor]=\"overflowMenu\">\n        <mat-icon>more_vert</mat-icon>\n      </button>\n      <mat-menu #overflowMenu=\"matMenu\">\n        <div mat-menu-item\n          (click)=\"this.darkTheme = !this.darkTheme\">\n          <mat-slide-toggle (click)=\"this.darkTheme = !this.darkTheme; $event.stopPropagation()\"\n            [(ngModel)]=\"darkTheme\"></mat-slide-toggle>\n          <span>Dark theme</span>\n        </div>\n        <a href=\"http://www.androiddesignpatterns.com/2016/11/introduction-to-icon-animation-techniques.html\"\n          target=\"_blank\"\n          class=\"toolbar-overflow-link-item\">\n          <button mat-menu-item\n            (click)=\"this.onGettingStartedClick()\">\n            <mat-icon>info</mat-icon>\n            <span>Getting started</span>\n          </button>\n        </a>\n        <a href=\"https://github.com/alexjlockwood/ShapeShifter\"\n          target=\"_blank\"\n          class=\"toolbar-overflow-link-item\">\n          <button mat-menu-item\n            (click)=\"this.onContributeClick()\">\n            <mat-icon style=\"line-height: 1\"\n              svgIcon=\"contribute\"></mat-icon>\n            <span>Contribute</span>\n          </button>\n        </a>\n        <a href=\"https://github.com/alexjlockwood/ShapeShifter/issues\"\n          target=\"_blank\"\n          class=\"toolbar-overflow-link-item\">\n          <button mat-menu-item\n            (click)=\"this.onSendFeedbackClick()\">\n            <mat-icon>bug_report</mat-icon>\n            <span>Send feedback</span>\n          </button>\n        </a>\n        <a href=\"{{ this.isBeta() ? 'https://shapeshifter.design' : 'https://beta.shapeshifter.design' }}\"\n          target=\"_blank\"\n          class=\"toolbar-overflow-link-item\">\n          <button mat-menu-item>\n            <mat-icon>open_in_new</mat-icon>\n            <span>Switch to {{ this.isBeta() ? 'stable' : 'beta' }} </span>\n          </button>\n        </a>\n      </mat-menu>\n    </ng-container>\n  </div>\n</ng-container>"

/***/ }),

/***/ "./src/app/modules/editor/components/toolbar/toolbar.component.scss":
/*!**************************************************************************!*\
  !*** ./src/app/modules/editor/components/toolbar/toolbar.component.scss ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".toolbar {\n  padding: 8px 16px;\n  z-index: 1; }\n  .toolbar .toolbar-logo {\n    width: 40px;\n    height: 40px;\n    margin-right: 8px; }\n  .toolbar .toolbar-title {\n    font-size: 18px; }\n  .toolbar .toolbar-subtitle {\n    margin-top: 4px;\n    font-size: 13px; }\n  .toolbar-overflow-link-item {\n  color: inherit;\n  text-decoration: none;\n  cursor: inherit; }\n  .action-mode-close-icon {\n  margin-right: 8px; }\n  .toolbar-action-button {\n  margin-left: 16px; }\n  a button.mat-menu-item mat-icon {\n  margin-right: 20px; }\n  mat-slide-toggle {\n  margin-right: 8px; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL3Rvb2xiYXIvdG9vbGJhci5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNJLGtCQUFpQjtFQUNqQixXQUFVLEVBYWI7RUFmRDtJQUlRLFlBQVc7SUFDWCxhQUFZO0lBQ1osa0JBQWlCLEVBQ3BCO0VBUEw7SUFTUSxnQkFBZSxFQUNsQjtFQVZMO0lBWVEsZ0JBQWU7SUFDZixnQkFBZSxFQUNsQjtFQUdMO0VBRUksZUFBYztFQUNkLHNCQUFxQjtFQUNyQixnQkFBZSxFQUNsQjtFQUVEO0VBQ0ksa0JBQWlCLEVBQ3BCO0VBRUQ7RUFDSSxrQkFBaUIsRUFDcEI7RUFFRDtFQUdZLG1CQUFrQixFQUNyQjtFQUdUO0VBQ0ksa0JBQWlCLEVBQ3BCIiwiZmlsZSI6InNyYy9hcHAvbW9kdWxlcy9lZGl0b3IvY29tcG9uZW50cy90b29sYmFyL3Rvb2xiYXIuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIudG9vbGJhciB7XG4gICAgcGFkZGluZzogOHB4IDE2cHg7XG4gICAgei1pbmRleDogMTtcbiAgICAudG9vbGJhci1sb2dvIHtcbiAgICAgICAgd2lkdGg6IDQwcHg7XG4gICAgICAgIGhlaWdodDogNDBweDtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA4cHg7XG4gICAgfVxuICAgIC50b29sYmFyLXRpdGxlIHtcbiAgICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgIH1cbiAgICAudG9vbGJhci1zdWJ0aXRsZSB7XG4gICAgICAgIG1hcmdpbi10b3A6IDRweDtcbiAgICAgICAgZm9udC1zaXplOiAxM3B4O1xuICAgIH1cbn1cblxuLnRvb2xiYXItb3ZlcmZsb3ctbGluay1pdGVtIHtcbiAgICAvLyBSZW1vdmUgbGluayBkZWNvcmF0aW9ucyBmcm9tIG92ZXJmbG93IG1lbnUgaXRlbXMuXG4gICAgY29sb3I6IGluaGVyaXQ7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgIGN1cnNvcjogaW5oZXJpdDtcbn1cblxuLmFjdGlvbi1tb2RlLWNsb3NlLWljb24ge1xuICAgIG1hcmdpbi1yaWdodDogOHB4O1xufVxuXG4udG9vbGJhci1hY3Rpb24tYnV0dG9uIHtcbiAgICBtYXJnaW4tbGVmdDogMTZweDtcbn1cblxuYSB7XG4gICAgYnV0dG9uLm1hdC1tZW51LWl0ZW0ge1xuICAgICAgICBtYXQtaWNvbiB7XG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDIwcHg7XG4gICAgICAgIH1cbiAgICB9XG59XG5tYXQtc2xpZGUtdG9nZ2xlIHtcbiAgICBtYXJnaW4tcmlnaHQ6IDhweDtcbn1cbiJdfQ== */"

/***/ }),

/***/ "./src/app/modules/editor/components/toolbar/toolbar.component.ts":
/*!************************************************************************!*\
  !*** ./src/app/modules/editor/components/toolbar/toolbar.component.ts ***!
  \************************************************************************/
/*! exports provided: ToolbarComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolbarComponent", function() { return ToolbarComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_scripts_actionmode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/actionmode */ "./src/app/modules/editor/scripts/actionmode/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store/actionmode/selectors */ "./src/app/modules/editor/store/actionmode/selectors.ts");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");











var ToolbarComponent = /** @class */ (function () {
    function ToolbarComponent(actionModeService, themeService, store) {
        this.actionModeService = actionModeService;
        this.themeService = themeService;
        this.store = store;
    }
    ToolbarComponent.prototype.ngOnInit = function () {
        var hasActionModeBeenEnabled = false;
        var prevThemeType;
        var currThemeType = this.themeService.getThemeType().themeType;
        var prevIsActionMode;
        var currIsActionMode = this.actionModeService.getActionMode() !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].None;
        var toolbarState = this.store.select(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_6__["getToolbarState"]);
        this.toolbarData$ = toolbarState.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["map"])(function (_a) {
            var mode = _a.mode, fromMl = _a.fromMl, toMl = _a.toMl, selections = _a.selections, unpairedSubPath = _a.unpairedSubPath, block = _a.block;
            return new ToolbarData(mode, fromMl, toMl, selections, unpairedSubPath, block);
        }));
        this.themeState$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["combineLatest"])(toolbarState, this.themeService.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["map"])(function (t) { return t.themeType; }))).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["map"])(function (_a) {
            var mode = _a[0].mode, themeType = _a[1];
            hasActionModeBeenEnabled = hasActionModeBeenEnabled || mode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].None;
            prevThemeType = currThemeType;
            currThemeType = themeType;
            prevIsActionMode = currIsActionMode;
            currIsActionMode = mode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].None;
            return {
                hasActionModeBeenEnabled: hasActionModeBeenEnabled,
                prevThemeType: prevThemeType,
                currThemeType: currThemeType,
                prevIsActionMode: prevIsActionMode,
                currIsActionMode: currIsActionMode,
            };
        }));
    };
    Object.defineProperty(ToolbarComponent.prototype, "darkTheme", {
        get: function () {
            return this.themeService.getThemeType().themeType === 'dark';
        },
        set: function (isDark) {
            this.themeService.setTheme(isDark ? 'dark' : 'light');
        },
        enumerable: true,
        configurable: true
    });
    ToolbarComponent.prototype.onSendFeedbackClick = function (event) {
        ga('send', 'event', 'Miscellaneous', 'Send feedback click');
    };
    ToolbarComponent.prototype.onContributeClick = function (event) {
        ga('send', 'event', 'Miscellaneous', 'Contribute click');
    };
    ToolbarComponent.prototype.onGettingStartedClick = function (event) {
        ga('send', 'event', 'Miscellaneous', 'Getting started click');
    };
    ToolbarComponent.prototype.onAutoFixClick = function (event) {
        ga('send', 'event', 'Action mode', 'Auto fix click');
        event.stopPropagation();
        this.actionModeService.autoFix();
    };
    ToolbarComponent.prototype.onCloseActionModeClick = function (event) {
        event.stopPropagation();
        this.actionModeService.closeActionMode();
    };
    ToolbarComponent.prototype.onAddPointsClick = function (event) {
        ga('send', 'event', 'Action mode', 'Add points');
        event.stopPropagation();
        this.actionModeService.toggleSplitCommandsMode();
    };
    ToolbarComponent.prototype.onSplitSubPathsClick = function (event) {
        ga('send', 'event', 'Action mode', 'Split sub paths');
        event.stopPropagation();
        this.actionModeService.toggleSplitSubPathsMode();
    };
    ToolbarComponent.prototype.onPairSubPathsClick = function (event) {
        ga('send', 'event', 'Action mode', 'Pair sub paths');
        event.stopPropagation();
        this.actionModeService.togglePairSubPathsMode();
    };
    ToolbarComponent.prototype.onReversePointsClick = function (event) {
        event.stopPropagation();
        this.actionModeService.reverseSelectedSubPaths();
    };
    ToolbarComponent.prototype.onShiftBackPointsClick = function (event) {
        event.stopPropagation();
        this.actionModeService.shiftBackSelectedSubPaths();
    };
    ToolbarComponent.prototype.onShiftForwardPointsClick = function (event) {
        event.stopPropagation();
        this.actionModeService.shiftForwardSelectedSubPaths();
    };
    ToolbarComponent.prototype.onDeleteSubPathsClick = function (event) {
        event.stopPropagation();
        this.actionModeService.deleteSelectedActionModeModels();
    };
    ToolbarComponent.prototype.onDeleteSegmentsClick = function (event) {
        event.stopPropagation();
        this.actionModeService.deleteSelectedActionModeModels();
    };
    ToolbarComponent.prototype.onSetFirstPositionClick = function (event) {
        event.stopPropagation();
        this.actionModeService.shiftPointToFront();
    };
    ToolbarComponent.prototype.onSplitInHalfHoverEvent = function (isHovering) {
        if (isHovering) {
            this.actionModeService.splitInHalfHover();
        }
        else {
            this.actionModeService.clearHover();
        }
    };
    ToolbarComponent.prototype.onSplitInHalfClick = function (event) {
        event.stopPropagation();
        this.actionModeService.splitSelectedPointInHalf();
    };
    ToolbarComponent.prototype.onDeletePointsClick = function (event) {
        event.stopPropagation();
        this.actionModeService.deleteSelectedActionModeModels();
    };
    ToolbarComponent.prototype.isBeta = function () {
        return environments_environment__WEBPACK_IMPORTED_MODULE_7__["environment"].beta;
    };
    ToolbarComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-toolbar',
            template: __webpack_require__(/*! ./toolbar.component.html */ "./src/app/modules/editor/components/toolbar/toolbar.component.html"),
            styles: [__webpack_require__(/*! ./toolbar.component.scss */ "./src/app/modules/editor/components/toolbar/toolbar.component.scss")],
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_services__WEBPACK_IMPORTED_MODULE_4__["ActionModeService"],
            app_modules_editor_services__WEBPACK_IMPORTED_MODULE_4__["ThemeService"],
            app_modules_editor_store__WEBPACK_IMPORTED_MODULE_5__["Store"]])
    ], ToolbarComponent);
    return ToolbarComponent;
}());

var ToolbarData = /** @class */ (function () {
    function ToolbarData(mode, startMorphableLayer, endMorphableLayer, selections, unpair, block) {
        this.mode = mode;
        this.selections = selections;
        this.block = block;
        this.subPaths = [];
        this.segments = [];
        this.points = [];
        // Precondition: assume all selections are for the same canvas type
        if (!selections.length) {
            return;
        }
        var canvasType = selections[0].source;
        var morphableLayer = canvasType === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From ? startMorphableLayer : endMorphableLayer;
        if (!morphableLayer) {
            return;
        }
        var activePath = morphableLayer.pathData;
        this.isFilled = morphableLayer.isFilled();
        this.isStroked = morphableLayer.isStroked();
        this.subPaths = selections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].SubPath; }).map(function (s) { return s.subIdx; });
        this.segments = selections
            .filter(function (s) {
            var subIdx = s.subIdx, cmdIdx = s.cmdIdx;
            return (s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Segment &&
                morphableLayer.isFilled() &&
                activePath.getCommand(subIdx, cmdIdx).isSplitSegment());
        })
            .map(function (s) {
            var subIdx = s.subIdx, cmdIdx = s.cmdIdx;
            return { subIdx: subIdx, cmdIdx: cmdIdx };
        });
        this.points = selections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Point; }).map(function (s) {
            var subIdx = s.subIdx, cmdIdx = s.cmdIdx;
            return { subIdx: subIdx, cmdIdx: cmdIdx };
        });
        this.numSplitSubPaths = lodash__WEBPACK_IMPORTED_MODULE_8__["sumBy"](this.subPaths, function (subIdx) {
            return activePath.getSubPath(subIdx).isUnsplittable() ? 1 : 0;
        });
        this.numSplitPoints = lodash__WEBPACK_IMPORTED_MODULE_8__["sumBy"](this.points, function (s) {
            var subIdx = s.subIdx, cmdIdx = s.cmdIdx;
            return activePath.getCommand(subIdx, cmdIdx).isSplitPoint() ? 1 : 0;
        });
        this.showSetFirstPosition =
            this.points.length === 1 &&
                this.points[0].cmdIdx &&
                activePath.getSubPath(this.points[0].subIdx).isClosed();
        this.showShiftSubPath =
            this.subPaths.length > 0 && activePath.getSubPath(this.subPaths[0]).isClosed();
        this.showSplitInHalf = this.points.length === 1 && !!this.points[0].cmdIdx;
        if (this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].PairSubPaths) {
            if (unpair) {
                this.unpairedSubPathSource = unpair.source;
            }
        }
        this.showPairSubPaths =
            startMorphableLayer.pathData.getSubPaths().length === 1 &&
                endMorphableLayer.pathData.getSubPaths().length === 1
                ? false
                : this.getNumSubPaths() === 1 || this.getNumSegments() > 0 || !this.isSelectionMode();
    }
    ToolbarData.prototype.getNumSelections = function () {
        return this.subPaths.length + this.segments.length + this.points.length;
    };
    ToolbarData.prototype.getNumSubPaths = function () {
        return this.subPaths.length;
    };
    ToolbarData.prototype.getNumSegments = function () {
        return this.segments.length;
    };
    ToolbarData.prototype.getNumPoints = function () {
        return this.points.length;
    };
    ToolbarData.prototype.getToolbarTitle = function () {
        if (this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitCommands) {
            return 'Add points';
        }
        if (this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths) {
            return 'Split subpaths';
        }
        if (this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].PairSubPaths) {
            return 'Pair subpaths';
        }
        var numSubPaths = this.getNumSubPaths();
        var subStr = numSubPaths + " subpath" + (numSubPaths === 1 ? '' : 's');
        var numSegments = this.getNumSegments();
        var segStr = numSegments + " segment" + (numSegments === 1 ? '' : 's');
        var numPoints = this.getNumPoints();
        var ptStr = numPoints + " point" + (numPoints === 1 ? '' : 's');
        if (numSubPaths > 0) {
            return subStr + " selected";
        }
        else if (numSegments > 0) {
            return segStr + " selected";
        }
        else if (numPoints > 0) {
            return ptStr + " selected";
        }
        else if (this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection) {
            return 'Edit path morphing animation';
        }
        return 'Shape Shifter';
    };
    ToolbarData.prototype.getToolbarSubtitle = function () {
        if (this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitCommands) {
            return 'Click along the edge of a subpath to add a point';
        }
        else if (this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths) {
            if (this.isFilled) {
                return 'Draw a line across a subpath to split it into 2';
            }
            else if (this.isStroked) {
                return 'Click along the edge of a subpath to split it into 2';
            }
        }
        else if (this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].PairSubPaths) {
            if (this.unpairedSubPathSource) {
                var toSourceDir = this.unpairedSubPathSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From ? 'right' : 'left';
                return "Pair the selected subpath with a corresponding subpath on the " + toSourceDir;
            }
            return 'Select a subpath';
        }
        else if (this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection) {
            var _a = app_modules_editor_scripts_actionmode__WEBPACK_IMPORTED_MODULE_3__["ActionModeUtil"].checkPathsCompatible(this.block), areCompatible = _a.areCompatible, errorPath = _a.errorPath, numPointsMissing_1 = _a.numPointsMissing;
            if (!areCompatible) {
                var createSubtitleFn = function (direction) {
                    if (numPointsMissing_1 === 1) {
                        return "Add 1 point to the highlighted subpath on the " + direction;
                    }
                    else {
                        return "Add " + numPointsMissing_1 + " points to the highlighted subpath on the " + direction;
                    }
                };
                if (errorPath === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From) {
                    return createSubtitleFn('left');
                }
                else if (errorPath === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].To) {
                    return createSubtitleFn('right');
                }
                // This should never happen, but return empty string just to be safe.
                return '';
            }
            if (!this.getNumSubPaths() && !this.getNumSegments() && !this.getNumPoints()) {
                return 'Select something below to edit its properties';
            }
        }
        return '';
    };
    ToolbarData.prototype.shouldShowActionMode = function () {
        return this.mode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].None;
    };
    ToolbarData.prototype.shouldShowPairSubPaths = function () {
        return this.showPairSubPaths;
    };
    ToolbarData.prototype.getNumSplitSubPaths = function () {
        return this.numSplitSubPaths || 0;
    };
    ToolbarData.prototype.getNumSplitPoints = function () {
        return this.numSplitPoints || 0;
    };
    ToolbarData.prototype.shouldShowSetFirstPosition = function () {
        return this.showSetFirstPosition || false;
    };
    ToolbarData.prototype.shouldShowShiftSubPath = function () {
        return this.showShiftSubPath || false;
    };
    ToolbarData.prototype.shouldShowSplitInHalf = function () {
        return this.showSplitInHalf || false;
    };
    ToolbarData.prototype.isSelectionMode = function () {
        return this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].None || this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection;
    };
    ToolbarData.prototype.isAddPointsMode = function () {
        return this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitCommands;
    };
    ToolbarData.prototype.isSplitSubPathsMode = function () {
        return this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths;
    };
    ToolbarData.prototype.isPairSubPathsMode = function () {
        return this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].PairSubPaths;
    };
    ToolbarData.prototype.shouldShowAutoFix = function () {
        return this.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection && !this.getNumSelections();
    };
    return ToolbarData;
}());


/***/ }),

/***/ "./src/app/modules/editor/components/toolpanel/toolpanel.component.html":
/*!******************************************************************************!*\
  !*** ./src/app/modules/editor/components/toolpanel/toolpanel.component.html ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div *ngIf=\"(this.model$ | async) as model\"\n  class=\"tool-panel mat-elevation-z4\"\n  fxLayout=\"column\"\n  fxFlex>\n  <button class=\"tool-button\"\n    matTooltip=\"Select\"\n    matTooltipPosition=\"right\"\n    matTooltipShowDelay=\"500\"\n    [class.is-checked]=\"model.isDefaultClick\"\n    (click)=\"onDefaultClick($event)\">\n    <mat-icon svgIcon=\"tool_select\"></mat-icon>\n  </button>\n  <button class=\"tool-button\"\n    matTooltip=\"Rotate\"\n    matTooltipPosition=\"right\"\n    matTooltipShowDelay=\"500\"\n    [class.is-checked]=\"model.isRotateItemsChecked\"\n    [disabled]=\"!model.isRotateItemsEnabled\"\n    (click)=\"onRotateItemsClick($event)\">\n    <mat-icon>crop_rotate</mat-icon>\n  </button>\n  <button class=\"tool-button\"\n    matTooltip=\"Transform\"\n    matTooltipPosition=\"right\"\n    matTooltipShowDelay=\"500\"\n    [class.is-checked]=\"model.isTransformPathsChecked\"\n    [disabled]=\"!model.isTransformPathsEnabled\"\n    (click)=\"onTransformPathsClick($event)\">\n    <mat-icon>transform</mat-icon>\n  </button>\n  <button class=\"tool-button\"\n    matTooltip=\"Pencil\"\n    matTooltipPosition=\"right\"\n    matTooltipShowDelay=\"500\"\n    [class.is-checked]=\"model.toolMode === this.TOOL_MODE_PENCIL\"\n    (click)=\"onPencilClick($event)\">\n    <mat-icon svgIcon=\"tool_pencil\"></mat-icon>\n  </button>\n  <button class=\"tool-button\"\n    matTooltip=\"Vector\"\n    matTooltipPosition=\"right\"\n    matTooltipShowDelay=\"500\"\n    [class.is-checked]=\"model.isEditPathChecked\"\n    (click)=\"onEditPathClick($event)\">\n    <mat-icon svgIcon=\"tool_vector\"></mat-icon>\n  </button>\n  <button class=\"tool-button\"\n    matTooltip=\"Oval\"\n    matTooltipPosition=\"right\"\n    matTooltipShowDelay=\"500\"\n    [class.is-checked]=\"model.toolMode === this.TOOL_MODE_ELLIPSE\"\n    (click)=\"onEllipseClick($event)\">\n    <mat-icon svgIcon=\"tool_ellipse\"></mat-icon>\n  </button>\n  <button class=\"tool-button\"\n    matTooltip=\"Rectangle\"\n    matTooltipPosition=\"right\"\n    matTooltipShowDelay=\"500\"\n    [class.is-checked]=\"model.toolMode === this.TOOL_MODE_RECTANGLE\"\n    (click)=\"onRectangleClick($event)\">\n    <mat-icon svgIcon=\"tool_rectangle\"></mat-icon>\n  </button>\n  <!-- TODO: set the tooltip delay back to 500 once we have a better way of telling the user about zooming out -->\n  <button class=\"tool-button\"\n    matTooltip=\"Zoom (hold {{ this.isMac() ? 'option' : 'alt' }} to zoom out)\"\n    matTooltipPosition=\"right\"\n    matTooltipShowDelay=\"0\"\n    [class.is-checked]=\"model.toolMode === this.TOOL_MODE_ZOOMPAN\"\n    (click)=\"onZoomPanClick($event)\">\n    <mat-icon>zoom_in</mat-icon>\n  </button>\n</div>"

/***/ }),

/***/ "./src/app/modules/editor/components/toolpanel/toolpanel.component.scss":
/*!******************************************************************************!*\
  !*** ./src/app/modules/editor/components/toolpanel/toolpanel.component.scss ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".tool-panel {\n  background-color: #eeeeee;\n  position: relative; }\n  .tool-panel .tool-button {\n    margin: 4px; }\n  .tool-panel .tool-button:hover {\n      cursor: pointer; }\n  .tool-panel .tool-button.is-checked {\n      background-color: #d0d0d0; }\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9TaGFwZVNoaWZ0ZXIvc3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL3Rvb2xwYW5lbC90b29scGFuZWwuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFFRSwwQkFBeUI7RUFDekIsbUJBQWtCLEVBWW5CO0VBZkQ7SUFNSSxZQUFXLEVBUVo7RUFkSDtNQVFNLGdCQUFlLEVBQ2hCO0VBVEw7TUFZTSwwQkFBeUIsRUFDMUIiLCJmaWxlIjoic3JjL2FwcC9tb2R1bGVzL2VkaXRvci9jb21wb25lbnRzL3Rvb2xwYW5lbC90b29scGFuZWwuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIudG9vbC1wYW5lbCB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBpbnRvIGEgdGhlbWVkIENTUyBmaWxlXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWVlZWU7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuICAudG9vbC1idXR0b24ge1xuICAgIG1hcmdpbjogNHB4O1xuICAgICY6aG92ZXIge1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbiAgICAmLmlzLWNoZWNrZWQge1xuICAgICAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgaW50byBhIHRoZW1lZCBDU1MgZmlsZVxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2QwZDBkMDtcbiAgICB9XG4gIH1cbn1cblxuIl19 */"

/***/ }),

/***/ "./src/app/modules/editor/components/toolpanel/toolpanel.component.ts":
/*!****************************************************************************!*\
  !*** ./src/app/modules/editor/components/toolpanel/toolpanel.component.ts ***!
  \****************************************************************************/
/*! exports provided: ToolPanelComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolPanelComponent", function() { return ToolPanelComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_services__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/services */ "./src/app/modules/editor/services/index.ts");




var ToolPanelComponent = /** @class */ (function () {
    function ToolPanelComponent(ps) {
        this.ps = ps;
        this.TOOL_MODE_PENCIL = app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].Pencil;
        this.TOOL_MODE_ELLIPSE = app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].Ellipse;
        this.TOOL_MODE_RECTANGLE = app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].Rectangle;
        this.TOOL_MODE_ZOOMPAN = app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].ZoomPan;
    }
    ToolPanelComponent.prototype.ngOnInit = function () {
        this.model$ = this.ps.observeToolPanelState();
    };
    ToolPanelComponent.prototype.onDefaultClick = function (event) {
        this.ps.enterDefaultMode();
        event.stopPropagation();
    };
    ToolPanelComponent.prototype.onRotateItemsClick = function (event) {
        this.ps.enterRotateItemsMode();
        event.stopPropagation();
    };
    ToolPanelComponent.prototype.onTransformPathsClick = function (event) {
        this.ps.enterTransformPathsMode();
        event.stopPropagation();
    };
    ToolPanelComponent.prototype.onPencilClick = function (event) {
        this.ps.enterPencilMode();
        event.stopPropagation();
    };
    ToolPanelComponent.prototype.onEditPathClick = function (event) {
        this.ps.enterEditPathMode();
        event.stopPropagation();
    };
    ToolPanelComponent.prototype.onEllipseClick = function (event) {
        this.ps.enterCreateEllipseMode();
        event.stopPropagation();
    };
    ToolPanelComponent.prototype.onRectangleClick = function (event) {
        this.ps.enterCreateRectangleMode();
        event.stopPropagation();
    };
    ToolPanelComponent.prototype.onZoomPanClick = function (event) {
        this.ps.setToolMode(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].ZoomPan);
        event.stopPropagation();
    };
    ToolPanelComponent.prototype.isMac = function () {
        return app_modules_editor_services__WEBPACK_IMPORTED_MODULE_3__["ShortcutService"].isMac();
    };
    ToolPanelComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-toolpanel',
            template: __webpack_require__(/*! ./toolpanel.component.html */ "./src/app/modules/editor/components/toolpanel/toolpanel.component.html"),
            styles: [__webpack_require__(/*! ./toolpanel.component.scss */ "./src/app/modules/editor/components/toolpanel/toolpanel.component.scss")],
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_services__WEBPACK_IMPORTED_MODULE_3__["PaperService"]])
    ], ToolPanelComponent);
    return ToolPanelComponent;
}());



/***/ }),

/***/ "./src/app/modules/editor/editor.module.ts":
/*!*************************************************!*\
  !*** ./src/app/modules/editor/editor.module.ts ***!
  \*************************************************/
/*! exports provided: EditorModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditorModule", function() { return EditorModule; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm5/http.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_flex_layout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/flex-layout */ "./node_modules/@angular/flex-layout/esm5/flex-layout.es5.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm5/platform-browser.js");
/* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm5/animations.js");
/* harmony import */ var _angular_service_worker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/service-worker */ "./node_modules/@angular/service-worker/fesm5/service-worker.js");
/* harmony import */ var app_modules_editor_components_canvas__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/modules/editor/components/canvas */ "./src/app/modules/editor/components/canvas/index.ts");
/* harmony import */ var app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/modules/editor/components/dialogs */ "./src/app/modules/editor/components/dialogs/index.ts");
/* harmony import */ var app_modules_editor_components_layertimeline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/modules/editor/components/layertimeline */ "./src/app/modules/editor/components/layertimeline/index.ts");
/* harmony import */ var app_modules_editor_components_playback__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/modules/editor/components/playback */ "./src/app/modules/editor/components/playback/index.ts");
/* harmony import */ var app_modules_editor_components_propertyinput__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/modules/editor/components/propertyinput */ "./src/app/modules/editor/components/propertyinput/index.ts");
/* harmony import */ var app_modules_editor_components_root_droptarget_directive__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/modules/editor/components/root/droptarget.directive */ "./src/app/modules/editor/components/root/droptarget.directive.ts");
/* harmony import */ var app_modules_editor_components_root_root_component__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/modules/editor/components/root/root.component */ "./src/app/modules/editor/components/root/root.component.ts");
/* harmony import */ var app_modules_editor_components_scrollgroup_scrollgroup_directive__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! app/modules/editor/components/scrollgroup/scrollgroup.directive */ "./src/app/modules/editor/components/scrollgroup/scrollgroup.directive.ts");
/* harmony import */ var app_modules_editor_components_splashscreen_splashscreen_component__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! app/modules/editor/components/splashscreen/splashscreen.component */ "./src/app/modules/editor/components/splashscreen/splashscreen.component.ts");
/* harmony import */ var app_modules_editor_components_splitter_splitter_component__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! app/modules/editor/components/splitter/splitter.component */ "./src/app/modules/editor/components/splitter/splitter.component.ts");
/* harmony import */ var app_modules_editor_components_toolbar_toolbar_component__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! app/modules/editor/components/toolbar/toolbar.component */ "./src/app/modules/editor/components/toolbar/toolbar.component.ts");
/* harmony import */ var app_modules_editor_components_toolpanel_toolpanel_component__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! app/modules/editor/components/toolpanel/toolpanel.component */ "./src/app/modules/editor/components/toolpanel/toolpanel.component.ts");
/* harmony import */ var app_modules_editor_scripts_bugsnag__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! app/modules/editor/scripts/bugsnag */ "./src/app/modules/editor/scripts/bugsnag/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
























var EditorModule = /** @class */ (function () {
    function EditorModule(matIconRegistry, sanitizer) {
        this.sanitizer = sanitizer;
        matIconRegistry
            // Logo.
            .addSvgIcon('shapeshifter', this.trustUrl('assets/shapeshifter.svg'))
            // Icons.
            .addSvgIcon('addlayer', this.trustUrl('assets/icons/addlayer.svg'))
            .addSvgIcon('autofix', this.trustUrl('assets/icons/autofix.svg'))
            .addSvgIcon('contribute', this.trustUrl('assets/icons/contribute.svg'))
            .addSvgIcon('reverse', this.trustUrl('assets/icons/reverse.svg'))
            .addSvgIcon('animation', this.trustUrl('assets/icons/animation.svg'))
            .addSvgIcon('collection', this.trustUrl('assets/icons/collection.svg'))
            .addSvgIcon('animationblock', this.trustUrl('assets/icons/animationblock.svg'))
            .addSvgIcon('mask', this.trustUrl('assets/icons/clippathlayer.svg'))
            .addSvgIcon('group', this.trustUrl('assets/icons/grouplayer.svg'))
            .addSvgIcon('path', this.trustUrl('assets/icons/pathlayer.svg'))
            .addSvgIcon('vector', this.trustUrl('assets/icons/vectorlayer.svg'))
            // Tools.
            .addSvgIcon('tool_select', this.trustUrl('assets/tools/tool_select.svg'))
            .addSvgIcon('tool_pencil', this.trustUrl('assets/tools/tool_pencil.svg'))
            .addSvgIcon('tool_vector', this.trustUrl('assets/tools/tool_vector.svg'))
            .addSvgIcon('tool_ellipse', this.trustUrl('assets/tools/tool_ellipse.svg'))
            .addSvgIcon('tool_rectangle', this.trustUrl('assets/tools/tool_rectangle.svg'))
            .addSvgIcon('tool_zoompan', this.trustUrl('assets/tools/tool_zoompan.svg'));
    }
    EditorModule.prototype.trustUrl = function (url) {
        return this.sanitizer.bypassSecurityTrustResourceUrl(url);
    };
    EditorModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"])({
            declarations: [
                app_modules_editor_components_canvas__WEBPACK_IMPORTED_MODULE_9__["CanvasComponent"],
                app_modules_editor_components_canvas__WEBPACK_IMPORTED_MODULE_9__["CanvasContainerDirective"],
                app_modules_editor_components_canvas__WEBPACK_IMPORTED_MODULE_9__["CanvasLayersDirective"],
                app_modules_editor_components_canvas__WEBPACK_IMPORTED_MODULE_9__["CanvasOverlayDirective"],
                app_modules_editor_components_canvas__WEBPACK_IMPORTED_MODULE_9__["CanvasPaperDirective"],
                app_modules_editor_components_canvas__WEBPACK_IMPORTED_MODULE_9__["CanvasRulerDirective"],
                app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_10__["ConfirmDialogComponent"],
                app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_10__["DemoDialogComponent"],
                app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_10__["DropFilesDialogComponent"],
                app_modules_editor_components_root_droptarget_directive__WEBPACK_IMPORTED_MODULE_14__["DropTargetDirective"],
                app_modules_editor_components_layertimeline__WEBPACK_IMPORTED_MODULE_11__["LayerListTreeComponent"],
                app_modules_editor_components_layertimeline__WEBPACK_IMPORTED_MODULE_11__["LayerTimelineComponent"],
                app_modules_editor_components_layertimeline__WEBPACK_IMPORTED_MODULE_11__["LayerTimelineGridDirective"],
                app_modules_editor_components_playback__WEBPACK_IMPORTED_MODULE_12__["PlaybackComponent"],
                app_modules_editor_components_propertyinput__WEBPACK_IMPORTED_MODULE_13__["PropertyInputComponent"],
                app_modules_editor_components_root_root_component__WEBPACK_IMPORTED_MODULE_15__["RootComponent"],
                app_modules_editor_components_scrollgroup_scrollgroup_directive__WEBPACK_IMPORTED_MODULE_16__["ScrollGroupDirective"],
                app_modules_editor_components_splashscreen_splashscreen_component__WEBPACK_IMPORTED_MODULE_17__["SplashScreenComponent"],
                app_modules_editor_components_splitter_splitter_component__WEBPACK_IMPORTED_MODULE_18__["SplitterComponent"],
                app_modules_editor_components_layertimeline__WEBPACK_IMPORTED_MODULE_11__["TimelineAnimationRowComponent"],
                app_modules_editor_components_toolbar_toolbar_component__WEBPACK_IMPORTED_MODULE_19__["ToolbarComponent"],
                app_modules_editor_components_toolpanel_toolpanel_component__WEBPACK_IMPORTED_MODULE_20__["ToolPanelComponent"],
            ],
            imports: [
                _angular_platform_browser__WEBPACK_IMPORTED_MODULE_6__["BrowserModule"],
                _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["BrowserAnimationsModule"],
                _angular_flex_layout__WEBPACK_IMPORTED_MODULE_3__["FlexLayoutModule"],
                _angular_forms__WEBPACK_IMPORTED_MODULE_4__["FormsModule"],
                _angular_common_http__WEBPACK_IMPORTED_MODULE_1__["HttpClientModule"],
                _angular_service_worker__WEBPACK_IMPORTED_MODULE_8__["ServiceWorkerModule"].register('/ngsw-worker.js', { enabled: environments_environment__WEBPACK_IMPORTED_MODULE_23__["environment"].production }),
                app_modules_editor_store__WEBPACK_IMPORTED_MODULE_22__["StoreModule"].forRoot(app_modules_editor_store__WEBPACK_IMPORTED_MODULE_22__["reducers"], { metaReducers: app_modules_editor_store__WEBPACK_IMPORTED_MODULE_22__["metaReducers"] }),
                // Angular material components.
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatButtonModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatDialogModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatIconModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatInputModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatMenuModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatOptionModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatRadioModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatSlideToggleModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatSnackBarModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatToolbarModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatTooltipModule"],
            ],
            providers: [{ provide: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ErrorHandler"], useFactory: app_modules_editor_scripts_bugsnag__WEBPACK_IMPORTED_MODULE_21__["errorHandlerFactory"] }],
            entryComponents: [app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_10__["ConfirmDialogComponent"], app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_10__["DemoDialogComponent"], app_modules_editor_components_dialogs__WEBPACK_IMPORTED_MODULE_10__["DropFilesDialogComponent"]],
            bootstrap: [app_modules_editor_components_root_root_component__WEBPACK_IMPORTED_MODULE_15__["RootComponent"]],
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_material__WEBPACK_IMPORTED_MODULE_5__["MatIconRegistry"], _angular_platform_browser__WEBPACK_IMPORTED_MODULE_6__["DomSanitizer"]])
    ], EditorModule);
    return EditorModule;
}());



/***/ }),

/***/ "./src/app/modules/editor/model/actionmode/index.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/model/actionmode/index.ts ***!
  \**********************************************************/
/*! exports provided: ActionMode, ActionSource, HoverType, SelectionType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./src/app/modules/editor/model/actionmode/types.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActionMode", function() { return _types__WEBPACK_IMPORTED_MODULE_0__["ActionMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActionSource", function() { return _types__WEBPACK_IMPORTED_MODULE_0__["ActionSource"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HoverType", function() { return _types__WEBPACK_IMPORTED_MODULE_0__["HoverType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectionType", function() { return _types__WEBPACK_IMPORTED_MODULE_0__["SelectionType"]; });




/***/ }),

/***/ "./src/app/modules/editor/model/actionmode/types.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/model/actionmode/types.ts ***!
  \**********************************************************/
/*! exports provided: SelectionType, ActionMode, ActionSource, HoverType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionType", function() { return SelectionType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionMode", function() { return ActionMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionSource", function() { return ActionSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HoverType", function() { return HoverType; });
/**
 * Describes the different types of selection events.
 */
var SelectionType;
(function (SelectionType) {
    // The user selected an entire subpath.
    SelectionType[SelectionType["SubPath"] = 1] = "SubPath";
    // The user selected an individual segment in a subpath.
    SelectionType[SelectionType["Segment"] = 2] = "Segment";
    // The user selected an individual point in a subpath.
    SelectionType[SelectionType["Point"] = 3] = "Point";
})(SelectionType || (SelectionType = {}));
/**
 * Different shape shifter modes.
 */
var ActionMode;
(function (ActionMode) {
    ActionMode[ActionMode["None"] = 1] = "None";
    ActionMode[ActionMode["Selection"] = 2] = "Selection";
    ActionMode[ActionMode["SplitCommands"] = 3] = "SplitCommands";
    ActionMode[ActionMode["PairSubPaths"] = 4] = "PairSubPaths";
    ActionMode[ActionMode["SplitSubPaths"] = 5] = "SplitSubPaths";
})(ActionMode || (ActionMode = {}));
/**
 * Different action sources.
 */
var ActionSource;
(function (ActionSource) {
    ActionSource[ActionSource["From"] = 1] = "From";
    ActionSource[ActionSource["Animated"] = 2] = "Animated";
    ActionSource[ActionSource["To"] = 3] = "To";
})(ActionSource || (ActionSource = {}));
/**
 * Describes the different types of hover events.
 */
var HoverType;
(function (HoverType) {
    HoverType[HoverType["SubPath"] = 1] = "SubPath";
    HoverType[HoverType["Segment"] = 2] = "Segment";
    HoverType[HoverType["Point"] = 3] = "Point";
    HoverType[HoverType["Split"] = 4] = "Split";
    HoverType[HoverType["Unsplit"] = 5] = "Unsplit";
    HoverType[HoverType["Reverse"] = 6] = "Reverse";
    HoverType[HoverType["ShiftBack"] = 7] = "ShiftBack";
    HoverType[HoverType["ShiftForward"] = 8] = "ShiftForward";
    HoverType[HoverType["SetFirstPosition"] = 9] = "SetFirstPosition";
})(HoverType || (HoverType = {}));


/***/ }),

/***/ "./src/app/modules/editor/model/interpolators/BezierEasing.ts":
/*!********************************************************************!*\
  !*** ./src/app/modules/editor/model/interpolators/BezierEasing.ts ***!
  \********************************************************************/
/*! exports provided: create */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var isFloat32ArraySupported = typeof Float32Array === 'function';
function A(aA1, aA2) {
    return 1 - 3 * aA2 + 3 * aA1;
}
function B(aA1, aA2) {
    return 3 * aA2 - 6 * aA1;
}
function C(aA1) {
    return 3 * aA1;
}
/** Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2. */
function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
/** Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2. */
function getSlope(aT, aA1, aA2) {
    return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX;
    var currentT;
    var i = 0;
    do {
        currentT = aA + (aB - aA) / 2;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0) {
            aB = currentT;
        }
        else {
            aA = currentT;
        }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; i++) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0) {
            return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
}
function create(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
    }
    // Precompute samples table
    var sampleValues = isFloat32ArraySupported
        ? new Float32Array(kSplineTableSize)
        : new Array(kSplineTableSize);
    if (mX1 !== mY1 || mX2 !== mY2) {
        for (var i = 0; i < kSplineTableSize; i++) {
            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
        }
    }
    function getTForX(aX) {
        var intervalStart = 0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; currentSample++) {
            intervalStart += kSampleStepSize;
        }
        currentSample--;
        // Interpolate to provide an initial guess for t
        var dist = (aX - sampleValues[currentSample]) /
            (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        }
        else if (initialSlope === 0) {
            return guessForT;
        }
        else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
    }
    return function (x) {
        if (mX1 === mY1 && mX2 === mY2) {
            return x; // Linear.
        }
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
            return 0;
        }
        if (x === 1) {
            return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
    };
}


/***/ }),

/***/ "./src/app/modules/editor/model/interpolators/Interpolator.ts":
/*!********************************************************************!*\
  !*** ./src/app/modules/editor/model/interpolators/Interpolator.ts ***!
  \********************************************************************/
/*! exports provided: INTERPOLATORS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INTERPOLATORS", function() { return INTERPOLATORS; });
/* harmony import */ var _BezierEasing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BezierEasing */ "./src/app/modules/editor/model/interpolators/BezierEasing.ts");

var FAST_OUT_SLOW_IN_EASING = _BezierEasing__WEBPACK_IMPORTED_MODULE_0__["create"](0.4, 0, 0.2, 1);
var FAST_OUT_LINEAR_IN_EASING = _BezierEasing__WEBPACK_IMPORTED_MODULE_0__["create"](0.4, 0, 1, 1);
var LINEAR_OUT_SLOW_IN_EASING = _BezierEasing__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0.2, 1);
var INTERPOLATORS = [
    {
        value: 'FAST_OUT_SLOW_IN',
        label: 'Fast out, slow in',
        androidRef: '@android:interpolator/fast_out_slow_in',
        interpolateFn: function (f) { return FAST_OUT_SLOW_IN_EASING(f); },
        webRef: 'cubic-bezier(0.4, 0, 0.2, 1)',
    },
    {
        value: 'FAST_OUT_LINEAR_IN',
        label: 'Fast out, linear in',
        androidRef: '@android:interpolator/fast_out_linear_in',
        interpolateFn: function (f) { return FAST_OUT_LINEAR_IN_EASING(f); },
        webRef: 'cubic-bezier(0.4, 0, 1, 1)',
    },
    {
        value: 'LINEAR_OUT_SLOW_IN',
        label: 'Linear out, slow in',
        androidRef: '@android:interpolator/linear_out_slow_in',
        interpolateFn: function (f) { return LINEAR_OUT_SLOW_IN_EASING(f); },
        webRef: 'cubic-bezier(0, 0, 0.2, 1)',
    },
    {
        value: 'ACCELERATE_DECELERATE',
        label: 'Accelerate/decelerate',
        androidRef: '@android:anim/accelerate_decelerate_interpolator',
        interpolateFn: function (f) { return Math.cos((f + 1) * Math.PI) / 2.0 + 0.5; },
        webRef: 'cubic-bezier(0.455, 0.03, 0.515, 0.955)',
    },
    {
        value: 'ACCELERATE',
        label: 'Accelerate',
        androidRef: '@android:anim/accelerate_interpolator',
        interpolateFn: function (f) { return f * f; },
        webRef: 'cubic-bezier(0.55, 0.085, 0.68, 0.53)',
    },
    {
        value: 'DECELERATE',
        label: 'Decelerate',
        androidRef: '@android:anim/decelerate_interpolator',
        interpolateFn: function (f) { return 1 - (1 - f) * (1 - f); },
        webRef: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
    },
    {
        value: 'LINEAR',
        label: 'Linear',
        androidRef: '@android:anim/linear_interpolator',
        interpolateFn: function (f) { return f; },
        webRef: 'linear',
    },
    {
        value: 'ANTICIPATE',
        label: 'Anticipate',
        androidRef: '@android:anim/anticipate_interpolator',
        interpolateFn: function (f) { return f * f * ((2 + 1) * f - 2); },
        webRef: 'cubic-bezier(0.4, 0, 0.2, 1)',
    },
    {
        value: 'OVERSHOOT',
        label: 'Overshoot',
        androidRef: '@android:anim/overshoot_interpolator',
        interpolateFn: function (f) { return (f - 1) * (f - 1) * ((2 + 1) * (f - 1) + 2) + 1; },
        webRef: 'cubic-bezier(0.4, 0, 0.2, 1)',
    },
    {
        value: 'BOUNCE',
        label: 'Bounce',
        androidRef: '@android:anim/bounce_interpolator',
        interpolateFn: function (f) {
            var bounceFn = function (t) { return t * t * 8; };
            f *= 1.1226;
            if (f < 0.3535) {
                return bounceFn(f);
            }
            else if (f < 0.7408) {
                return bounceFn(f - 0.54719) + 0.7;
            }
            else if (f < 0.9644) {
                return bounceFn(f - 0.8526) + 0.9;
            }
            else {
                return bounceFn(f - 1.0435) + 0.95;
            }
        },
        webRef: 'cubic-bezier(0.4, 0, 0.2, 1)',
    },
    {
        value: 'ANTICIPATE_OVERSHOOT',
        label: 'Anticipate overshoot',
        androidRef: '@android:anim/anticipate_overshoot_interpolator',
        interpolateFn: function (f) {
            var a = function (t, s) {
                return t * t * ((s + 1) * t - s);
            };
            var o = function (t, s) {
                return t * t * ((s + 1) * t + s);
            };
            if (f < 0.5) {
                return 0.5 * a(f * 2, 2 * 1.5);
            }
            else {
                return 0.5 * (o(f * 2 - 2, 2 * 1.5) + 2);
            }
        },
        webRef: 'cubic-bezier(0.4, 0, 0.2, 1)',
    },
];


/***/ }),

/***/ "./src/app/modules/editor/model/interpolators/index.ts":
/*!*************************************************************!*\
  !*** ./src/app/modules/editor/model/interpolators/index.ts ***!
  \*************************************************************/
/*! exports provided: INTERPOLATORS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Interpolator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Interpolator */ "./src/app/modules/editor/model/interpolators/Interpolator.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "INTERPOLATORS", function() { return _Interpolator__WEBPACK_IMPORTED_MODULE_0__["INTERPOLATORS"]; });




/***/ }),

/***/ "./src/app/modules/editor/model/layers/Layer.ts":
/*!******************************************************!*\
  !*** ./src/app/modules/editor/model/layers/Layer.ts ***!
  \******************************************************/
/*! exports provided: Layer, VectorLayer, GroupLayer, ClipPathLayer, PathLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layer", function() { return Layer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorLayer", function() { return VectorLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GroupLayer", function() { return GroupLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClipPathLayer", function() { return ClipPathLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PathLayer", function() { return PathLayer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/properties */ "./src/app/modules/editor/model/properties/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);




/**
 * Interface that is shared by all vector drawable layer models below.
 */
var Layer = /** @class */ (function () {
    function Layer(obj) {
        this.id = obj.id || lodash__WEBPACK_IMPORTED_MODULE_3__["uniqueId"]();
        this.name = obj.name || '';
        this.children = (obj.children || []).map(function (child) { return load(child); });
    }
    /**
     * Returns the first descendent layer with the specified id.
     */
    Layer.prototype.findLayerById = function (id) {
        if (this.id === id) {
            return this;
        }
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            var layer = child.findLayerById(id);
            if (layer) {
                return layer;
            }
        }
        return undefined;
    };
    /**
     * Returns the first descendent layer with the specified name.
     */
    Layer.prototype.findLayerByName = function (name) {
        if (this.name === name) {
            return this;
        }
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            var layer = child.findLayerByName(name);
            if (layer) {
                return layer;
            }
        }
        return undefined;
    };
    /**
     * Walks the layer tree, executing beforeFunc on each node using a
     * preorder traversal.
     */
    Layer.prototype.walk = function (beforeFn) {
        var visitFn = function (layer) {
            beforeFn(layer);
            layer.children.forEach(function (l) { return visitFn(l); });
        };
        visitFn(this);
    };
    /**
     * Returns the JSON representation of this layer.
     */
    Layer.prototype.toJSON = function () {
        return {
            id: this.id,
            name: this.name,
            type: this.type,
        };
    };
    Layer = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["Property"].register(new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NameProperty"]('name')),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Object])
    ], Layer);
    return Layer;
}());

function load(obj) {
    if (obj instanceof Layer) {
        return obj;
    }
    if (obj.type === 'vector') {
        return new VectorLayer(obj);
    }
    if (obj.type === 'group') {
        return new GroupLayer(obj);
    }
    if (obj.type === 'path') {
        return new PathLayer(obj);
    }
    if (obj.type === 'mask') {
        return new ClipPathLayer(obj);
    }
    console.error('Attempt to load layer with invalid object: ', obj);
    throw new Error('Attempt to load layer with invalid object');
}
var VECTOR_DEFAULTS = {
    canvasColor: '',
    alpha: 1,
};
/**
 * Model object that mirrors the VectorDrawable's '<vector>' element.
 */
var VectorLayer = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](VectorLayer, _super);
    function VectorLayer(obj) {
        if (obj === void 0) { obj = { children: [], name: 'vector' }; }
        var _this = _super.call(this, obj) || this;
        // @Override
        _this.type = 'vector';
        var setterFn = function (num, def) { return (lodash__WEBPACK_IMPORTED_MODULE_3__["isNil"](num) ? def : num); };
        _this.canvasColor = obj.canvasColor || VECTOR_DEFAULTS.canvasColor;
        _this.width = setterFn(obj.width, 24);
        _this.height = setterFn(obj.height, 24);
        _this.alpha = setterFn(obj.alpha, VECTOR_DEFAULTS.alpha);
        return _this;
    }
    VectorLayer_1 = VectorLayer;
    Object.defineProperty(VectorLayer.prototype, "bounds", {
        // @Override
        get: function () {
            return { l: 0, t: 0, r: this.width, b: this.height };
        },
        enumerable: true,
        configurable: true
    });
    // @Override
    VectorLayer.prototype.clone = function () {
        var clone = new VectorLayer_1(this);
        clone.children = this.children.slice();
        return clone;
    };
    // @Override
    VectorLayer.prototype.deepClone = function () {
        var clone = this.clone();
        clone.children = this.children.map(function (c) { return c.deepClone(); });
        return clone;
    };
    // @Override
    VectorLayer.prototype.toJSON = function () {
        var obj = Object.assign(_super.prototype.toJSON.call(this), {
            canvasColor: this.canvasColor,
            width: this.width,
            height: this.height,
            alpha: this.alpha,
            children: this.children.map(function (child) { return child.toJSON(); }),
        });
        Object.entries(VECTOR_DEFAULTS).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            if (obj[key] === value) {
                delete obj[key];
            }
        });
        return obj;
    };
    var VectorLayer_1;
    VectorLayer = VectorLayer_1 = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["Property"].register(new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["ColorProperty"]('canvasColor'), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('width', { isAnimatable: false, min: 1, isInteger: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('height', { isAnimatable: false, min: 1, isInteger: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["FractionProperty"]('alpha', { isAnimatable: true })),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Object])
    ], VectorLayer);
    return VectorLayer;
}(Layer));

var GROUP_DEFAULTS = {
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    pivotX: 0,
    pivotY: 0,
    translateX: 0,
    translateY: 0,
};
/**
 * Model object that mirrors the VectorDrawable's '<group>' element.
 */
var GroupLayer = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](GroupLayer, _super);
    function GroupLayer(obj) {
        var _this = _super.call(this, obj) || this;
        // @Override
        _this.type = 'group';
        var setterFn = function (num, def) { return (lodash__WEBPACK_IMPORTED_MODULE_3__["isNil"](num) ? def : num); };
        _this.pivotX = setterFn(obj.pivotX, GROUP_DEFAULTS.pivotX);
        _this.pivotY = setterFn(obj.pivotY, GROUP_DEFAULTS.pivotY);
        _this.rotation = setterFn(obj.rotation, GROUP_DEFAULTS.rotation);
        _this.scaleX = setterFn(obj.scaleX, GROUP_DEFAULTS.scaleX);
        _this.scaleY = setterFn(obj.scaleY, GROUP_DEFAULTS.scaleY);
        _this.translateX = setterFn(obj.translateX, GROUP_DEFAULTS.translateX);
        _this.translateY = setterFn(obj.translateY, GROUP_DEFAULTS.translateY);
        return _this;
    }
    GroupLayer_1 = GroupLayer;
    Object.defineProperty(GroupLayer.prototype, "bounds", {
        // @Override
        get: function () {
            var bounds;
            this.children.forEach(function (child) {
                var childBounds = child.bounds;
                if (!childBounds) {
                    return;
                }
                if (bounds) {
                    bounds.l = Math.min(childBounds.l, bounds.l);
                    bounds.t = Math.min(childBounds.t, bounds.t);
                    bounds.r = Math.max(childBounds.r, bounds.r);
                    bounds.b = Math.max(childBounds.b, bounds.b);
                }
                else {
                    bounds = tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, childBounds);
                }
            });
            if (!bounds) {
                return undefined;
            }
            bounds.l -= this.pivotX;
            bounds.t -= this.pivotY;
            bounds.r -= this.pivotX;
            bounds.b -= this.pivotY;
            var transforms = [
                app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["Matrix"].scaling(this.scaleX, this.scaleY),
                app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["Matrix"].rotation(this.rotation),
                app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["Matrix"].translation(this.translateX, this.translateY),
            ];
            var topLeft = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].transformPoint.apply(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"], [{ x: bounds.l, y: bounds.t }].concat(transforms));
            var bottomRight = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].transformPoint.apply(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"], [{ x: bounds.r, y: bounds.b }].concat(transforms));
            return {
                l: topLeft.x + this.pivotX,
                t: topLeft.y + this.pivotY,
                r: bottomRight.x + this.pivotX,
                b: bottomRight.y + this.pivotY,
            };
        },
        enumerable: true,
        configurable: true
    });
    // @Override
    GroupLayer.prototype.clone = function () {
        var clone = new GroupLayer_1(this);
        clone.children = this.children.slice();
        return clone;
    };
    // @Override
    GroupLayer.prototype.deepClone = function () {
        var clone = this.clone();
        clone.children = this.children.map(function (c) { return c.deepClone(); });
        return clone;
    };
    // @Override
    GroupLayer.prototype.toJSON = function () {
        var obj = Object.assign(_super.prototype.toJSON.call(this), {
            rotation: this.rotation,
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            pivotX: this.pivotX,
            pivotY: this.pivotY,
            translateX: this.translateX,
            translateY: this.translateY,
            children: this.children.map(function (child) { return child.toJSON(); }),
        });
        Object.entries(GROUP_DEFAULTS).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            if (obj[key] === value) {
                delete obj[key];
            }
        });
        return obj;
    };
    var GroupLayer_1;
    GroupLayer = GroupLayer_1 = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["Property"].register(new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('rotation', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('scaleX', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('scaleY', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('pivotX', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('pivotY', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('translateX', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('translateY', { isAnimatable: true })),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Object])
    ], GroupLayer);
    return GroupLayer;
}(Layer));

/**
 * Model object that mirrors the VectorDrawable's '<clip-path>' element.
 */
var ClipPathLayer = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ClipPathLayer, _super);
    function ClipPathLayer(obj) {
        var _this = _super.call(this, obj) || this;
        // @Override
        _this.type = 'mask';
        _this.pathData = obj.pathData;
        return _this;
    }
    ClipPathLayer_1 = ClipPathLayer;
    Object.defineProperty(ClipPathLayer.prototype, "bounds", {
        // @Override
        get: function () {
            return this.pathData ? this.pathData.getBoundingBox() : undefined;
        },
        enumerable: true,
        configurable: true
    });
    // @Override
    ClipPathLayer.prototype.clone = function () {
        return new ClipPathLayer_1(this);
    };
    // @Override
    ClipPathLayer.prototype.deepClone = function () {
        return this.clone();
    };
    // @Override
    ClipPathLayer.prototype.toJSON = function () {
        return Object.assign(_super.prototype.toJSON.call(this), {
            pathData: this.pathData ? this.pathData.getPathString() : '',
        });
    };
    ClipPathLayer.prototype.isStroked = function () {
        // TODO: this may be the case for Android... but does this limit what web/iOS devs can do?
        return false;
    };
    ClipPathLayer.prototype.isFilled = function () {
        return true;
    };
    var ClipPathLayer_1;
    ClipPathLayer = ClipPathLayer_1 = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["Property"].register(new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["PathProperty"]('pathData', { isAnimatable: true })),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Object])
    ], ClipPathLayer);
    return ClipPathLayer;
}(Layer));

var ENUM_LINECAP_OPTIONS = [
    { value: 'butt', label: 'Butt' },
    { value: 'square', label: 'Square' },
    { value: 'round', label: 'Round' },
];
var ENUM_LINEJOIN_OPTIONS = [
    { value: 'miter', label: 'Miter' },
    { value: 'round', label: 'Round' },
    { value: 'bevel', label: 'Bevel' },
];
var ENUM_FILLTYPE_OPTIONS = [
    { value: 'nonZero', label: 'nonZero' },
    { value: 'evenOdd', label: 'evenOdd' },
];
var PATH_DEFAULTS = {
    fillColor: '',
    fillAlpha: 1,
    strokeColor: '',
    strokeAlpha: 1,
    strokeWidth: 0,
    strokeLinecap: 'butt',
    strokeLinejoin: 'miter',
    strokeMiterLimit: 4,
    trimPathStart: 0,
    trimPathEnd: 1,
    trimPathOffset: 0,
    fillType: 'nonZero',
};
/**
 * Model object that mirrors the VectorDrawable's '<path>' element.
 */
var PathLayer = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](PathLayer, _super);
    function PathLayer(obj) {
        var _this = _super.call(this, obj) || this;
        // @Override
        _this.type = 'path';
        var setterFn = function (num, def) { return (lodash__WEBPACK_IMPORTED_MODULE_3__["isNil"](num) ? def : num); };
        _this.pathData = obj.pathData;
        _this.fillColor = obj.fillColor || PATH_DEFAULTS.fillColor;
        _this.fillAlpha = setterFn(obj.fillAlpha, PATH_DEFAULTS.fillAlpha);
        _this.strokeColor = obj.strokeColor || PATH_DEFAULTS.strokeColor;
        _this.strokeAlpha = setterFn(obj.strokeAlpha, PATH_DEFAULTS.strokeAlpha);
        _this.strokeWidth = setterFn(obj.strokeWidth, PATH_DEFAULTS.strokeWidth);
        _this.strokeLinecap = obj.strokeLinecap || PATH_DEFAULTS.strokeLinecap;
        _this.strokeLinejoin = obj.strokeLinejoin || PATH_DEFAULTS.strokeLinejoin;
        _this.strokeMiterLimit = setterFn(obj.strokeMiterLimit, PATH_DEFAULTS.strokeMiterLimit);
        _this.trimPathStart = setterFn(obj.trimPathStart, PATH_DEFAULTS.trimPathStart);
        _this.trimPathEnd = setterFn(obj.trimPathEnd, PATH_DEFAULTS.trimPathEnd);
        _this.trimPathOffset = setterFn(obj.trimPathOffset, PATH_DEFAULTS.trimPathOffset);
        _this.fillType = obj.fillType || PATH_DEFAULTS.fillType;
        return _this;
    }
    PathLayer_1 = PathLayer;
    Object.defineProperty(PathLayer.prototype, "bounds", {
        // @Override
        get: function () {
            return this.pathData ? this.pathData.getBoundingBox() : undefined;
        },
        enumerable: true,
        configurable: true
    });
    // @Override
    PathLayer.prototype.clone = function () {
        return new PathLayer_1(this);
    };
    // @Override
    PathLayer.prototype.deepClone = function () {
        return this.clone();
    };
    // @Override
    PathLayer.prototype.toJSON = function () {
        var obj = Object.assign(_super.prototype.toJSON.call(this), {
            pathData: this.pathData ? this.pathData.getPathString() : '',
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            strokeColor: this.strokeColor,
            strokeAlpha: this.strokeAlpha,
            strokeWidth: this.strokeWidth,
            strokeLinecap: this.strokeLinecap,
            strokeLinejoin: this.strokeLinejoin,
            strokeMiterLimit: this.strokeMiterLimit,
            trimPathStart: this.trimPathStart,
            trimPathEnd: this.trimPathEnd,
            trimPathOffset: this.trimPathOffset,
            fillType: this.fillType,
        });
        Object.entries(PATH_DEFAULTS).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            if (obj[key] === value) {
                delete obj[key];
            }
        });
        return obj;
    };
    PathLayer.prototype.isStroked = function () {
        return !!this.strokeColor;
    };
    PathLayer.prototype.isFilled = function () {
        return !!this.fillColor;
    };
    var PathLayer_1;
    PathLayer = PathLayer_1 = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["Property"].register(new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["PathProperty"]('pathData', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["ColorProperty"]('fillColor', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["FractionProperty"]('fillAlpha', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["ColorProperty"]('strokeColor', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["FractionProperty"]('strokeAlpha', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('strokeWidth', { min: 0, isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["EnumProperty"]('strokeLinecap', ENUM_LINECAP_OPTIONS), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["EnumProperty"]('strokeLinejoin', ENUM_LINEJOIN_OPTIONS), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('strokeMiterLimit', { min: 1 }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["FractionProperty"]('trimPathStart', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["FractionProperty"]('trimPathEnd', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["FractionProperty"]('trimPathOffset', { isAnimatable: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["EnumProperty"]('fillType', ENUM_FILLTYPE_OPTIONS)) // TODO: need to fix enum properties so they store/return strings instead of options?
        ,
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Object])
    ], PathLayer);
    return PathLayer;
}(Layer));



/***/ }),

/***/ "./src/app/modules/editor/model/layers/LayerUtil.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/model/layers/LayerUtil.ts ***!
  \**********************************************************/
/*! exports provided: getCanvasTransformForLayer, getCanvasTransformsForGroupLayer, adjustViewports, mergeVectorLayers, addLayers, removeLayers, updateLayer, replaceLayer, runPreorderTraversal, findLayerByName, findParent, findNextSibling, findPreviousSibling, getUniqueLayerName, getUniqueName, toStrokeDashArray, toStrokeDashOffset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCanvasTransformForLayer", function() { return getCanvasTransformForLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCanvasTransformsForGroupLayer", function() { return getCanvasTransformsForGroupLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjustViewports", function() { return adjustViewports; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeVectorLayers", function() { return mergeVectorLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLayers", function() { return addLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeLayers", function() { return removeLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateLayer", function() { return updateLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceLayer", function() { return replaceLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runPreorderTraversal", function() { return runPreorderTraversal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findLayerByName", function() { return findLayerByName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findParent", function() { return findParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNextSibling", function() { return findNextSibling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findPreviousSibling", function() { return findPreviousSibling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUniqueLayerName", function() { return getUniqueLayerName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUniqueName", function() { return getUniqueName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStrokeDashArray", function() { return toStrokeDashArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStrokeDashOffset", function() { return toStrokeDashOffset; });
/* harmony import */ var app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/paths */ "./src/app/modules/editor/model/paths/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Layer */ "./src/app/modules/editor/model/layers/Layer.ts");





var IS_DEV_BUILD = !environments_environment__WEBPACK_IMPORTED_MODULE_2__["environment"].production;
/**
 * Returns a single flattened transform matrix that can be used to perform canvas
 * transform operations. The resulting matrix will transform path coordinates to
 * canvas drawing coordinates. The inverse of the matrix will transform canvas
 * drawing coordinates back to path coordinates.
 */
function getCanvasTransformForLayer(root, layerId) {
    return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["Matrix"].flatten(getCanvasTransformsForLayer(root, layerId));
}
/**
 * Returns a list of parent transforms for the specified layer ID. The transforms
 * are returned in top-down order (i.e. the transform for the layer's
 * immediate parent will be the very last matrix in the returned list).
 */
function getCanvasTransformsForLayer(root, layerId) {
    return (function recurseFn(parents, current) {
        if (current.id === layerId) {
            return lodash__WEBPACK_IMPORTED_MODULE_3__["flatMap"](parents, function (l) {
                return l instanceof _Layer__WEBPACK_IMPORTED_MODULE_4__["GroupLayer"] ? getCanvasTransformsForGroupLayer(l) : [];
            });
        }
        for (var _i = 0, _a = current.children; _i < _a.length; _i++) {
            var child = _a[_i];
            var transforms = recurseFn(parents.concat([current]), child);
            if (transforms) {
                return transforms;
            }
        }
        return undefined;
    })([], root);
}
/**
 * Returns a list of matrix transforms for a given group layer.
 */
function getCanvasTransformsForGroupLayer(l) {
    // First negative pivot, then scale, then rotation, then translation, then pivot.
    // When drawing a path, the transforms are applied at the bottom up, which
    // is why the order appears to be reversed below.
    return [
        app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["Matrix"].translation(l.pivotX, l.pivotY),
        app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["Matrix"].translation(l.translateX, l.translateY),
        app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["Matrix"].rotation(l.rotation),
        app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["Matrix"].scaling(l.scaleX, l.scaleY),
        app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["Matrix"].translation(-l.pivotX, -l.pivotY),
    ];
}
/**
 * Makes two vector layers with possibly different viewports compatible with each other.
 */
function adjustViewports(vl1, vl2) {
    if (!vl1 || !vl2) {
        return { vl1: vl1, vl2: vl2 };
    }
    vl1 = vl1.deepClone();
    vl2 = vl2.deepClone();
    var w1 = vl1.width, h1 = vl1.height;
    var w2 = vl2.width, h2 = vl2.height;
    var isMaxDimenFn = function (n) { return Math.max(w1, h1, w2, h2, n) === n; };
    var scale1 = 1;
    var scale2 = 1;
    if (isMaxDimenFn(w1)) {
        scale2 = w1 / w2;
    }
    else if (isMaxDimenFn(h1)) {
        scale2 = h1 / h2;
    }
    else if (isMaxDimenFn(w2)) {
        scale1 = w2 / w1;
    }
    else {
        scale1 = h2 / h1;
    }
    if (isMaxDimenFn(w1) || isMaxDimenFn(h1)) {
        w1 = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].round(w1);
        h1 = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].round(h1);
        w2 = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].round(w2 * scale2);
        h2 = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].round(h2 * scale2);
    }
    else {
        w1 = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].round(w1 * scale1);
        h1 = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].round(h1 * scale1);
        w2 = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].round(w2);
        h2 = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].round(h2);
    }
    var tx1 = 0;
    var ty1 = 0;
    var tx2 = 0;
    var ty2 = 0;
    if (w1 > w2) {
        tx2 = (w1 - w2) / 2;
    }
    else if (w1 < w2) {
        tx1 = (w2 - w1) / 2;
    }
    else if (h1 > h2) {
        ty2 = (h1 - h2) / 2;
    }
    else if (h1 < h2) {
        ty1 = (h2 - h1) / 2;
    }
    var transformLayerFn = function (vl, scale, tx, ty) {
        var transforms = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["Matrix"].flatten([app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["Matrix"].scaling(scale, scale), app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["Matrix"].translation(tx, ty)]);
        (function recurseFn(layer) {
            if (layer instanceof _Layer__WEBPACK_IMPORTED_MODULE_4__["PathLayer"] || layer instanceof _Layer__WEBPACK_IMPORTED_MODULE_4__["ClipPathLayer"]) {
                if (layer instanceof _Layer__WEBPACK_IMPORTED_MODULE_4__["PathLayer"] && layer.isStroked()) {
                    layer.strokeWidth *= scale;
                }
                if (layer.pathData) {
                    layer.pathData = new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_0__["Path"](layer.pathData.getCommands().map(function (cmd) {
                        return cmd
                            .mutate()
                            .transform(transforms)
                            .build();
                    }));
                }
                return;
            }
            if (layer instanceof _Layer__WEBPACK_IMPORTED_MODULE_4__["GroupLayer"]) {
                var l = layer;
                l.translateX *= scale;
                l.translateY *= scale;
                l.pivotX *= scale;
                l.pivotY *= scale;
            }
            layer.children.forEach(function (l) { return recurseFn(l); });
        })(vl);
    };
    transformLayerFn(vl1, scale1, tx1, ty1);
    transformLayerFn(vl2, scale2, tx2, ty2);
    var newWidth = Math.max(w1, w2);
    var newHeight = Math.max(h1, h2);
    vl1.width = newWidth;
    vl2.width = newWidth;
    vl1.height = newHeight;
    vl2.height = newHeight;
    return { vl1: vl1, vl2: vl2 };
}
function mergeVectorLayers(vl1, vl2) {
    var _a = adjustViewports(vl1, vl2), newVl1 = _a.vl1, newVl2 = _a.vl2;
    var vl = setLayerChildren(newVl1, newVl1.children.concat(newVl2.children));
    if (!newVl1.children.length) {
        // Only replace the vector layer's alpha if there are no children
        // being displayed to the user. This is pretty much the best
        // we can do.
        vl.alpha = newVl2.alpha;
    }
    return vl;
}
/**
 * Adds a list of children to a parent layer in a vector layer tree.
 * @param root the root vector layer
 * @param addedLayerParentId the parent layer in which to add the given layers
 * @param startingChildIndex the index to start adding the layers
 * @param addedLayers the layers to add
 */
function addLayers(root, addedLayerParentId, startingChildIndex) {
    var addedLayers = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        addedLayers[_i - 3] = arguments[_i];
    }
    return (function recurseFn(curr) {
        if (curr.id === addedLayerParentId) {
            // If we have reached the added layer's parent, then
            // clone the parent, insert the new layer into its list
            // of children, and return the new parent node.
            var children = curr.children.slice();
            children.splice.apply(children, [startingChildIndex, 0].concat(addedLayers));
            return setLayerChildren(curr, children);
        }
        for (var i = 0; i < curr.children.length; i++) {
            var clonedChild = recurseFn(curr.children[i]);
            if (clonedChild) {
                // Then clone the current layer, insert the cloned child
                // into its list of children, and return the cloned current layer.
                var children = curr.children.slice();
                children[i] = clonedChild;
                return setLayerChildren(curr, children);
            }
        }
        return undefined;
    })(root);
}
function removeLayers(layer) {
    var removedLayerIds = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        removedLayerIds[_i - 1] = arguments[_i];
    }
    var layerIds = new Set(removedLayerIds);
    return (function recurseFn(curr) {
        if (layerIds.has(curr.id)) {
            return undefined;
        }
        var children = curr.children.map(recurseFn).filter(function (l) { return !!l; });
        return setLayerChildren(curr, children);
    })(layer);
}
function updateLayer(vl, layer) {
    return replaceLayer(vl, layer.id, layer);
}
function replaceLayer(vl, layerId, replacement) {
    if (IS_DEV_BUILD && !vl.findLayerById(layerId)) {
        console.warn('Attempt to replace a layer that does not exist in the tree');
    }
    return (function recurseFn(curr) {
        return curr.id === layerId
            ? replacement
            : setLayerChildren(curr, curr.children.map(function (child) { return recurseFn(child); }));
    })(vl);
}
function runPreorderTraversal(layer) {
    // Add the layers as we iterate the tree to ensure they are properly sorted.
    var layers = [];
    (function recurseFn(l) {
        layers.push(l);
        l.children.forEach(recurseFn);
    })(layer);
    return layers;
}
function findLayerByName(layers, layerName) {
    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
        var layer = layers_1[_i];
        var target = layer.findLayerByName(layerName);
        if (target) {
            return target;
        }
    }
    return undefined;
}
function findParent(vl, layerId) {
    return (function recurseFn(curr, parent) {
        if (curr.id === layerId) {
            return parent;
        }
        for (var _i = 0, _a = curr.children; _i < _a.length; _i++) {
            var child = _a[_i];
            var p = recurseFn(child, curr);
            if (p) {
                return p;
            }
        }
        return undefined;
    })(vl);
}
function findNextSibling(vl, layerId) {
    return findSibling(layerId, findParent(vl, layerId), 1);
}
function findPreviousSibling(vl, layerId) {
    return findSibling(layerId, findParent(vl, layerId), -1);
}
function findSibling(layerId, parent, offset) {
    if (!parent || !parent.children) {
        return undefined;
    }
    var index = lodash__WEBPACK_IMPORTED_MODULE_3__["findIndex"](parent.children, function (c) { return c.id === layerId; });
    if (index < 0) {
        return undefined;
    }
    index += offset;
    if (index < 0 || parent.children.length <= index) {
        return undefined;
    }
    return parent.children[index];
}
function getUniqueLayerName(layers, prefix) {
    return getUniqueName(prefix, function (name) { return findLayerByName(layers, name); });
}
function getUniqueName(prefix, objectByNameFn) {
    if (prefix === void 0) { prefix = ''; }
    if (objectByNameFn === void 0) { objectByNameFn = function (s) { return undefined; }; }
    var n = 0;
    var nameFn = function () { return prefix + (n ? "_" + n : ''); };
    while (true) {
        var o = objectByNameFn(nameFn());
        if (!o) {
            break;
        }
        n++;
    }
    return nameFn();
}
/**
 * Returns a cloned layer with the specified list of children layers.
 */
function setLayerChildren(layer, children) {
    var clone = layer.clone();
    clone.children = children;
    return clone;
}
function toStrokeDashArray(trimPathStart, trimPathEnd, trimPathOffset, pathLength, 
// TODO: remove this eventually... it is used to fix a canvas bug (that I am probably not handling correctly)
marginOfError) {
    if (marginOfError === void 0) { marginOfError = 0; }
    // Calculate the visible fraction of the trimmed path. If trimPathStart
    // is greater than trimPathEnd, then the result should be the combined
    // length of the two line segments: [trimPathStart,1] and [0,trimPathEnd].
    var shownFraction = trimPathEnd - trimPathStart;
    if (trimPathStart > trimPathEnd) {
        shownFraction += 1;
    }
    // Calculate the dash array. The first array element is the length of
    // the trimmed path and the second element is the gap, which is the
    // difference in length between the total path length and the visible
    // trimmed path length.
    return [shownFraction * pathLength, (1 - shownFraction + marginOfError) * pathLength];
}
function toStrokeDashOffset(trimPathStart, trimPathEnd, trimPathOffset, pathLength) {
    // The amount to offset the path is equal to the trimPathStart plus
    // trimPathOffset. We mod the result because the trimmed path
    // should wrap around once it reaches 1.
    return pathLength * (1 - ((trimPathStart + trimPathOffset) % 1));
}


/***/ }),

/***/ "./src/app/modules/editor/model/layers/index.ts":
/*!******************************************************!*\
  !*** ./src/app/modules/editor/model/layers/index.ts ***!
  \******************************************************/
/*! exports provided: LayerUtil, Layer, ClipPathLayer, VectorLayer, GroupLayer, PathLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LayerUtil */ "./src/app/modules/editor/model/layers/LayerUtil.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "LayerUtil", function() { return _LayerUtil__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _Layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Layer */ "./src/app/modules/editor/model/layers/Layer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Layer", function() { return _Layer__WEBPACK_IMPORTED_MODULE_1__["Layer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClipPathLayer", function() { return _Layer__WEBPACK_IMPORTED_MODULE_1__["ClipPathLayer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VectorLayer", function() { return _Layer__WEBPACK_IMPORTED_MODULE_1__["VectorLayer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupLayer", function() { return _Layer__WEBPACK_IMPORTED_MODULE_1__["GroupLayer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PathLayer", function() { return _Layer__WEBPACK_IMPORTED_MODULE_1__["PathLayer"]; });






/***/ }),

/***/ "./src/app/modules/editor/model/paper/CursorType.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/model/paper/CursorType.ts ***!
  \**********************************************************/
/*! exports provided: CursorType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CursorType", function() { return CursorType; });
// These names correspond to CSS class names declared in the root component.
var CursorType;
(function (CursorType) {
    CursorType["Default"] = "default";
    CursorType["Pointer"] = "pointer";
    CursorType["PointSelect"] = "point-select";
    CursorType["Crosshair"] = "crosshair";
    CursorType["Pen"] = "pen";
    CursorType["PenAdd"] = "pen-add";
    CursorType["PenClose"] = "pen-close";
    CursorType["Pencil"] = "pencil";
    CursorType["Resize0"] = "resize0";
    CursorType["Resize45"] = "resize45";
    CursorType["Resize90"] = "resize90";
    CursorType["Resize135"] = "resize135";
    CursorType["Rotate0"] = "rotate0";
    CursorType["Rotate45"] = "rotate45";
    CursorType["Rotate90"] = "rotate90";
    CursorType["Rotate135"] = "rotate135";
    CursorType["Rotate180"] = "rotate180";
    CursorType["Rotate225"] = "rotate225";
    CursorType["Rotate270"] = "rotate270";
    CursorType["Rotate315"] = "rotate315";
    CursorType["ZoomIn"] = "zoom-in";
    CursorType["ZoomOut"] = "zoom-out";
    CursorType["Grab"] = "grab";
    CursorType["Grabbing"] = "grabbing";
})(CursorType || (CursorType = {}));


/***/ }),

/***/ "./src/app/modules/editor/model/paper/ToolMode.ts":
/*!********************************************************!*\
  !*** ./src/app/modules/editor/model/paper/ToolMode.ts ***!
  \********************************************************/
/*! exports provided: ToolMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolMode", function() { return ToolMode; });
var ToolMode;
(function (ToolMode) {
    ToolMode["Default"] = "Default";
    ToolMode["Pencil"] = "Pencil";
    ToolMode["Ellipse"] = "Ellipse";
    ToolMode["Rectangle"] = "Rectangle";
    ToolMode["ZoomPan"] = "ZoomPan";
})(ToolMode || (ToolMode = {}));


/***/ }),

/***/ "./src/app/modules/editor/model/paper/index.ts":
/*!*****************************************************!*\
  !*** ./src/app/modules/editor/model/paper/index.ts ***!
  \*****************************************************/
/*! exports provided: ToolMode, CursorType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ToolMode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ToolMode */ "./src/app/modules/editor/model/paper/ToolMode.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ToolMode", function() { return _ToolMode__WEBPACK_IMPORTED_MODULE_0__["ToolMode"]; });

/* harmony import */ var _CursorType__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CursorType */ "./src/app/modules/editor/model/paper/CursorType.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CursorType", function() { return _CursorType__WEBPACK_IMPORTED_MODULE_1__["CursorType"]; });





/***/ }),

/***/ "./src/app/modules/editor/model/paths/Command.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/model/paths/Command.ts ***!
  \*******************************************************/
/*! exports provided: Command, CommandBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Command", function() { return Command; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CommandBuilder", function() { return CommandBuilder; });
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);


/**
 * Represents an individual SVG command. These are the essential building blocks
 * of all Paths and SubPath objects.
 */
var Command = /** @class */ (function () {
    function Command(_type, _points, _isSplitPoint, _id, _isSplitSegment) {
        if (_isSplitPoint === void 0) { _isSplitPoint = false; }
        if (_id === void 0) { _id = lodash__WEBPACK_IMPORTED_MODULE_1__["uniqueId"](); }
        if (_isSplitSegment === void 0) { _isSplitSegment = false; }
        this._type = _type;
        this._points = _points;
        this._isSplitPoint = _isSplitPoint;
        this._id = _id;
        this._isSplitSegment = _isSplitSegment;
        if (_type === undefined) {
            throw new Error('Attempt to set an undefined svgChar');
        }
    }
    Object.defineProperty(Command.prototype, "id", {
        /**
         * Returns the unique ID for this command.
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Command.prototype, "type", {
        /**
         * Returns the SVG character for this command.
         */
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Command.prototype, "points", {
        /**
         * Returns the points for this command.
         */
        get: function () {
            return this._points;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns true iff the command was created as a result of being split.
     * Only split commands are able to be editted and deleted via the inspector/canvas.
     */
    Command.prototype.isSplitPoint = function () {
        return this._isSplitPoint;
    };
    /**
     * Returns true iff the command was created as a result of a subpath split.
     */
    Command.prototype.isSplitSegment = function () {
        return this._isSplitSegment;
    };
    Object.defineProperty(Command.prototype, "start", {
        /**
         * Returns the command's starting point. The starting point for the first
         * command of the first subpath will be undefined.
         */
        get: function () {
            return lodash__WEBPACK_IMPORTED_MODULE_1__["first"](this._points);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Command.prototype, "end", {
        /**
         * Returns the command's ending point.
         */
        get: function () {
            return lodash__WEBPACK_IMPORTED_MODULE_1__["last"](this._points);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns true iff this command can be converted into a new command
     * that is morphable with the specified SVG command type.
     */
    Command.prototype.canConvertTo = function (targetChar) {
        var ch = targetChar;
        if (this._type === 'M' || ch === 'M' || this._type === ch) {
            return false;
        }
        switch (this._type) {
            case 'L':
                return ch === 'Q' || ch === 'C';
            case 'Z':
                return ch === 'L' || ch === 'Q' || ch === 'C';
            case 'Q': {
                var uniquePoints = lodash__WEBPACK_IMPORTED_MODULE_1__["uniqWith"](this._points, app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].arePointsEqual);
                return ch === 'C' || (ch === 'L' && uniquePoints.length <= 2);
            }
            case 'C': {
                var uniquePoints = lodash__WEBPACK_IMPORTED_MODULE_1__["uniqWith"](this._points, app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].arePointsEqual);
                return ch === 'L' && uniquePoints.length <= 2;
            }
        }
        return false;
    };
    /**
     * Returns a builder to construct a mutated Command.
     */
    Command.prototype.mutate = function () {
        return new CommandBuilder(this._type, this._points.slice(), this.isSplitPoint(), this._id, this._isSplitSegment);
    };
    Command.prototype.toString = function () {
        if (this._type === 'Z') {
            return "" + this._type;
        }
        else {
            var p = lodash__WEBPACK_IMPORTED_MODULE_1__["last"](this._points);
            var x = lodash__WEBPACK_IMPORTED_MODULE_1__["round"](p.x, 3);
            var y = lodash__WEBPACK_IMPORTED_MODULE_1__["round"](p.y, 3);
            return this._type + " " + x + ", " + y;
        }
    };
    return Command;
}());

var CommandBuilder = /** @class */ (function () {
    function CommandBuilder(svgChar, points, isSplitPoint, id, isSplitSegment) {
        if (isSplitPoint === void 0) { isSplitPoint = false; }
        if (id === void 0) { id = ''; }
        if (isSplitSegment === void 0) { isSplitSegment = false; }
        this.svgChar = svgChar;
        this.points = points;
        this.isSplitPoint = isSplitPoint;
        this.id = id;
        this.isSplitSegment = isSplitSegment;
        this.matrix = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["Matrix"].identity();
    }
    CommandBuilder.prototype.setSvgChar = function (svgChar) {
        this.svgChar = svgChar;
        return this;
    };
    CommandBuilder.prototype.setId = function (id) {
        this.id = id;
        return this;
    };
    CommandBuilder.prototype.setPoints = function () {
        var points = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            points[_i] = arguments[_i];
        }
        this.points = points;
        return this;
    };
    CommandBuilder.prototype.toggleSplitPoint = function () {
        return this.setIsSplitPoint(!this.isSplitPoint);
    };
    CommandBuilder.prototype.setIsSplitPoint = function (isSplitPoint) {
        this.isSplitPoint = isSplitPoint;
        return this;
    };
    CommandBuilder.prototype.setIsSplitSegment = function (isSplitSegment) {
        this.isSplitSegment = isSplitSegment;
        return this;
    };
    CommandBuilder.prototype.transform = function (transform) {
        this.matrix = transform.dot(this.matrix);
        return this;
    };
    CommandBuilder.prototype.reverse = function () {
        if (this.svgChar !== 'M' || this.points[0]) {
            // The first move command of an SVG path has an undefined
            // starting point, so no change is required in that case.
            this.points.reverse();
        }
        return this;
    };
    CommandBuilder.prototype.build = function () {
        var _this = this;
        return new Command(this.svgChar, this.points.map(function (p) { return (p ? app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].transformPoint(p, _this.matrix) : p); }), this.isSplitPoint, this.id || lodash__WEBPACK_IMPORTED_MODULE_1__["uniqueId"](), this.isSplitSegment);
    };
    return CommandBuilder;
}());



/***/ }),

/***/ "./src/app/modules/editor/model/paths/CommandState.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/model/paths/CommandState.ts ***!
  \************************************************************/
/*! exports provided: CommandState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CommandState", function() { return CommandState; });
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _calculators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./calculators */ "./src/app/modules/editor/model/paths/calculators/index.ts");



/**
 * Container class that encapsulates a Command's underlying state.
 */
var CommandState = /** @class */ (function () {
    function CommandState(
    // The original un-mutated command.
    backingCommand, 
    // A command state object wraps around the initial SVG command and outputs
    // a list of transformed commands resulting from splits, unsplits,
    // conversions, etc. If the initial SVG command hasn't been modified,
    // then a list containing the initial SVG command is returned.
    commands, 
    // The list of mutations describes how the initial backing command
    // has since been modified. Since the command state always holds a
    // reference to its initial backing command, these modifications
    // can be reversed simply by removing mutations from the list.
    mutations, 
    // The transformation matricies used to transform this command state object.
    transform, 
    // The calculator that will do all of the math-y stuff for us.
    calculator, 
    // The lower bound T value (may be > 0 for split subpaths).
    minT, 
    // The upper bound T value (may be < 1 for split subpaths).
    maxT, 
    // When a filled subpath is split, we assign a 'split command id' to the two
    // lines that are created (so that during unsplit operations we can identify
    // which segments were added together).
    splitSegmentId, 
    // The parent command state object (i.e. the one that created the new split segment).
    parentCommandState) {
        if (commands === void 0) { commands = [backingCommand]; }
        if (mutations === void 0) { mutations = [
            {
                id: backingCommand.id,
                t: 1,
                svgChar: backingCommand.type,
            },
        ]; }
        if (transform === void 0) { transform = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["Matrix"].identity(); }
        if (calculator === void 0) { calculator = Object(_calculators__WEBPACK_IMPORTED_MODULE_2__["newCalculator"])(backingCommand); }
        if (minT === void 0) { minT = 0; }
        if (maxT === void 0) { maxT = 1; }
        if (splitSegmentId === void 0) { splitSegmentId = ''; }
        this.backingCommand = backingCommand;
        this.commands = commands;
        this.mutations = mutations;
        this.transform = transform;
        this.calculator = calculator;
        this.minT = minT;
        this.maxT = maxT;
        this.splitSegmentId = splitSegmentId;
        this.parentCommandState = parentCommandState;
    }
    CommandState.prototype.getBackingId = function () {
        return this.backingCommand.id;
    };
    CommandState.prototype.getCommands = function () {
        return this.commands;
    };
    CommandState.prototype.getBoundingBox = function () {
        return this.calculator.getBoundingBox();
    };
    CommandState.prototype.intersects = function (line) {
        var _this = this;
        return this.calculator.intersects(line).filter(function (t) { return _this.minT < t && t <= _this.maxT; });
    };
    CommandState.prototype.getIdAtIndex = function (splitIdx) {
        return this.mutations[splitIdx].id;
    };
    CommandState.prototype.getPathLength = function () {
        return this.calculator.getPathLength();
    };
    CommandState.prototype.getPointAtLength = function (distance) {
        return this.calculator.getPointAtLength(distance);
    };
    CommandState.prototype.project = function (point) {
        var projection = this.calculator.project(point);
        if (!projection) {
            return undefined;
        }
        var projT = projection.t;
        if (projT < this.minT || this.maxT < projT) {
            // If this happens, then the projection is being mapped to some other
            // split command segment.
            // TODO: recompute the projection so that it properly returned the correct value...
            // console.warn('Failed to compute projection for CommandState');
            return undefined;
        }
        // Count the number of t values that are less than the projection.
        var splitIdx = lodash__WEBPACK_IMPORTED_MODULE_1__["sumBy"](this.mutations, function (m) { return (m.t < projection.t ? 1 : 0); });
        var tempSplits = [this.minT].concat(this.mutations.map(function (m) { return m.t; }));
        var startSplit = tempSplits[splitIdx];
        var endSplit = tempSplits[splitIdx + 1];
        // Update the t value so that it is in relation to the client-visible subIdx and cmdIdx.
        projection.t =
            startSplit === endSplit ? 0 : (projection.t - startSplit) / (endSplit - startSplit);
        return { projection: projection, splitIdx: splitIdx };
    };
    /**
     * Slices the command state object into two parts. Useful for subpath splitting.
     */
    CommandState.prototype.slice = function (splitIdx) {
        var left = this.mutate()
            .sliceLeft(splitIdx)
            .build();
        var right;
        if (this.isSplitAtIndex(splitIdx)) {
            right = this.mutate()
                .sliceRight(splitIdx)
                .build();
        }
        return { left: left, right: right };
    };
    /**
     * Merges two previously sliced command state objects into one.
     */
    CommandState.prototype.merge = function (cs) {
        if (this.getBackingId() !== cs.getBackingId()) {
            throw new Error('Attempt to merge command state objects with unequal backing IDs');
        }
        if (this.minT < cs.minT) {
            console.warn('Merging command states out of order', this, cs);
        }
        return this.mutate()
            .setMutations(cs.mutations.slice(0, cs.mutations.length - 1).concat(this.mutations))
            .setMinT(cs.minT)
            .build();
    };
    /**
     * Returns true iff the command at the specified index is split.
     */
    CommandState.prototype.isSplitAtIndex = function (splitIdx) {
        return splitIdx !== this.mutations.length - 1;
    };
    CommandState.prototype.getSplitSegmentId = function () {
        return this.splitSegmentId;
    };
    CommandState.prototype.getParentCommandState = function () {
        return this.parentCommandState;
    };
    CommandState.prototype.mutate = function () {
        return new CommandStateMutator(this.backingCommand, this.mutations.slice(), this.transform, this.calculator, this.minT, this.maxT, this.splitSegmentId, this.parentCommandState);
    };
    return CommandState;
}());

/**
 * A builder class for creating new mutated CommandState objects.
 */
var CommandStateMutator = /** @class */ (function () {
    function CommandStateMutator(backingCommand, mutations, matrix, calculator, minT, maxT, splitSegmentId, parentCommandState) {
        this.backingCommand = backingCommand;
        this.mutations = mutations;
        this.matrix = matrix;
        this.calculator = calculator;
        this.minT = minT;
        this.maxT = maxT;
        this.splitSegmentId = splitSegmentId;
        this.parentCommandState = parentCommandState;
    }
    /**
     * Slices this command state object at the specified index, discarding
     * anything to the right.
     */
    CommandStateMutator.prototype.sliceLeft = function (splitIdx) {
        this.mutations = this.mutations.slice(0, splitIdx + 1).map(function (m) { return lodash__WEBPACK_IMPORTED_MODULE_1__["clone"](m); });
        this.maxT = lodash__WEBPACK_IMPORTED_MODULE_1__["last"](this.mutations).t;
        return this;
    };
    /**
     * Slices this command state object at the specified index, discarding
     * anything to the left.
     */
    CommandStateMutator.prototype.sliceRight = function (splitIdx) {
        this.minT = this.mutations[splitIdx].t;
        this.mutations = this.mutations.slice(splitIdx + 1).map(function (m) { return lodash__WEBPACK_IMPORTED_MODULE_1__["clone"](m); });
        return this;
    };
    CommandStateMutator.prototype.setMutations = function (mutations) {
        this.mutations = mutations.slice();
        return this;
    };
    CommandStateMutator.prototype.setMinT = function (minT) {
        this.minT = minT;
        return this;
    };
    /**
     * Sets this command state object as a split segment with a unique ID.
     * The parent state object represents the origin command state.
     */
    CommandStateMutator.prototype.setSplitSegmentInfo = function (parentCommandState, id) {
        this.splitSegmentId = id;
        this.parentCommandState = parentCommandState;
        return this;
    };
    /**
     * Reverses the information stored by this command state object.
     */
    CommandStateMutator.prototype.reverse = function () {
        var _this = this;
        this.backingCommand = this.backingCommand
            .mutate()
            .reverse()
            .build();
        this.calculator = Object(_calculators__WEBPACK_IMPORTED_MODULE_2__["newCalculator"])(this.backingCommand);
        var lastMutation = this.mutations.pop();
        this.mutations = this.mutations
            .map(function (m) {
            var id = m.id, svgChar = m.svgChar;
            return { id: id, svgChar: svgChar, t: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].lerp(_this.maxT, _this.minT, m.t) };
        })
            .reverse();
        this.mutations.push(lastMutation);
        return this;
    };
    /**
     * Inserts the provided t values at the specified split index. The t values
     * are linearly interpolated between the split values at splitIdx and
     * splitIdx + 1 to ensure the split is done in relation to the mutated command.
     */
    CommandStateMutator.prototype.splitAtIndex = function (splitIdx, ts) {
        var tempSplits = [this.minT].concat(this.mutations.map(function (m) { return m.t; }));
        var startSplit = tempSplits[splitIdx];
        var endSplit = tempSplits[splitIdx + 1];
        return this.split(ts.map(function (t) { return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].lerp(startSplit, endSplit, t); }));
    };
    /**
     * Same as splitAtIndex() except the command is split into two approximately
     * equal parts.
     */
    CommandStateMutator.prototype.splitInHalfAtIndex = function (splitIdx) {
        var tempSplits = [this.minT].concat(this.mutations.map(function (m) { return m.t; }));
        var startSplit = tempSplits[splitIdx];
        var endSplit = tempSplits[splitIdx + 1];
        var distance = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].lerp(startSplit, endSplit, 0.5);
        return this.split([this.calculator.findTimeByDistance(distance)]);
    };
    CommandStateMutator.prototype.split = function (ts) {
        if (!ts.length || this.backingCommand.type === 'M') {
            return this;
        }
        var currSplits = this.mutations.map(function (m) { return m.t; });
        var currSvgChars = this.mutations.map(function (m) { return m.svgChar; });
        for (var _i = 0, ts_1 = ts; _i < ts_1.length; _i++) {
            var t = ts_1[_i];
            var id = lodash__WEBPACK_IMPORTED_MODULE_1__["uniqueId"]();
            var svgChar = currSvgChars[lodash__WEBPACK_IMPORTED_MODULE_1__["sortedIndex"](currSplits, t)];
            var mutation = { id: id, t: t, svgChar: svgChar };
            var insertionIdx = lodash__WEBPACK_IMPORTED_MODULE_1__["sortedIndexBy"](this.mutations, mutation, function (m) { return m.t; });
            this.mutations.splice(insertionIdx, 0, { id: id, t: t, svgChar: svgChar });
        }
        for (var i = 0; i < this.mutations.length - 1; i++) {
            var mutation = this.mutations[i];
            if (mutation.svgChar === 'Z') {
                // Force convert the split closepath command into a line.
                var id = mutation.id, t = mutation.t;
                this.mutations[i] = { id: id, t: t, svgChar: 'L' };
            }
        }
        return this;
    };
    /**
     * Unsplits the command at the specified split index.
     */
    CommandStateMutator.prototype.unsplitAtIndex = function (splitIdx) {
        if (!this.isSplitAtIndex(splitIdx)) {
            console.warn('Ignoring attempt to unsplit a non-split command', this);
            return this;
        }
        this.mutations.splice(splitIdx, 1);
        return this;
    };
    /**
     * Returns true iff the command at the specified index is split.
     */
    CommandStateMutator.prototype.isSplitAtIndex = function (splitIdx) {
        return splitIdx !== this.mutations.length - 1;
    };
    /**
     * Converts the command at the specified split index.
     */
    CommandStateMutator.prototype.convertAtIndex = function (splitIdx, svgChar) {
        var _a = this.mutations[splitIdx], id = _a.id, t = _a.t;
        this.mutations[splitIdx] = { id: id, t: t, svgChar: svgChar };
        return this;
    };
    /**
     * Unconverts all conversions previously performed on this
     * command state object.
     */
    CommandStateMutator.prototype.unconvertSubpath = function () {
        var _this = this;
        var backingSvgChar = this.backingCommand.type;
        this.mutations = this.mutations.map(function (mutation, i) {
            var svgChar = backingSvgChar;
            if (backingSvgChar === 'Z' && i !== _this.mutations.length - 1) {
                // Force convert the split closepath command back into a line.
                svgChar = 'L';
            }
            var id = mutation.id, t = mutation.t;
            return { id: id, t: t, svgChar: svgChar };
        });
        return this;
    };
    /**
     * Converts closepath commands to lines. This method irreversibly builds
     * a new backing command to use.
     */
    CommandStateMutator.prototype.forceConvertClosepathsToLines = function () {
        if (this.backingCommand.type === 'Z') {
            this.backingCommand = this.calculator.convert('L').toCommand();
            this.calculator = Object(_calculators__WEBPACK_IMPORTED_MODULE_2__["newCalculator"])(this.backingCommand);
            this.mutations = this.mutations.map(function (m) {
                var id = m.id, t = m.t, svgChar = m.svgChar;
                var newSvgChar = svgChar === 'Z' ? 'L' : svgChar;
                return { id: id, t: t, svgChar: newSvgChar };
            });
        }
        return this;
    };
    /**
     * Adds transforms to this command state object using the
     * specified transformation matrices.
     */
    CommandStateMutator.prototype.transform = function (transform) {
        this.matrix = transform.dot(this.matrix);
        this.calculator = Object(_calculators__WEBPACK_IMPORTED_MODULE_2__["newCalculator"])(this.backingCommand
            .mutate()
            .transform(this.matrix)
            .build());
        return this;
    };
    /**
     * Reverts this command state object back to its original state.
     */
    CommandStateMutator.prototype.revert = function () {
        this.mutations = [
            {
                id: lodash__WEBPACK_IMPORTED_MODULE_1__["last"](this.mutations).id,
                t: lodash__WEBPACK_IMPORTED_MODULE_1__["last"](this.mutations).t,
                svgChar: this.backingCommand.type,
            },
        ];
        this.matrix = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["Matrix"].identity();
        this.calculator = Object(_calculators__WEBPACK_IMPORTED_MODULE_2__["newCalculator"])(this.backingCommand);
        return this;
    };
    /**
     * Builds a new command state object.
     */
    CommandStateMutator.prototype.build = function () {
        // TODO: this could be more efficient (avoid recreating commands unnecessarily)
        var builtCommands = [];
        var prevT = this.minT;
        for (var i = 0; i < this.mutations.length; i++) {
            var currT = this.mutations[i].t;
            var isSplitSegment = this.mutations[i].svgChar !== 'M' && !!this.parentCommandState;
            builtCommands.push(this.calculator
                .split(prevT, currT)
                .convert(this.mutations[i].svgChar)
                .toCommand()
                .mutate()
                .setId(this.mutations[i].id)
                .setIsSplitPoint(i !== this.mutations.length - 1)
                .setIsSplitSegment(isSplitSegment)
                .build());
            prevT = currT;
        }
        return new CommandState(this.backingCommand, builtCommands, this.mutations, this.matrix, this.calculator, this.minT, this.maxT, this.splitSegmentId, this.parentCommandState);
    };
    return CommandStateMutator;
}());


/***/ }),

/***/ "./src/app/modules/editor/model/paths/Path.ts":
/*!****************************************************!*\
  !*** ./src/app/modules/editor/model/paths/Path.ts ***!
  \****************************************************/
/*! exports provided: Path, PathMutator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PathMutator", function() { return PathMutator; });
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Command */ "./src/app/modules/editor/model/paths/Command.ts");
/* harmony import */ var _CommandState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CommandState */ "./src/app/modules/editor/model/paths/CommandState.ts");
/* harmony import */ var _PathParser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PathParser */ "./src/app/modules/editor/model/paths/PathParser.ts");
/* harmony import */ var _PathState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PathState */ "./src/app/modules/editor/model/paths/PathState.ts");
/* harmony import */ var _SubPathState__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SubPathState */ "./src/app/modules/editor/model/paths/SubPathState.ts");








/**
 * A compound path that contains all of the information associated with a
 * PathLayer's pathData attribute.
 */
var Path = /** @class */ (function () {
    function Path(obj) {
        this.ps = typeof obj === 'string' || Array.isArray(obj) ? new _PathState__WEBPACK_IMPORTED_MODULE_6__["PathState"](obj) : obj;
        if (!environments_environment__WEBPACK_IMPORTED_MODULE_1__["environment"].production) {
            // Don't initialize variables lazily for dev builds (to avoid
            // ngrx-store-freeze crashes).
            this.getPathString();
            var allIds_1 = this.getCommands().map(function (c) { return c.id; });
            var uniqueIds = new Set(allIds_1);
            var numCommands = allIds_1.length;
            if (uniqueIds.size !== numCommands) {
                var dumpInfo = this.getSubPaths().map(function (s, subIdx) {
                    return s.getCommands().map(function (c, cmdIdx) {
                        return {
                            subIdx: subIdx,
                            cmdIdx: cmdIdx,
                            id: c.id,
                            isDup: allIds_1.filter(function (id) { return id === c.id; }).length > 1,
                        };
                    });
                });
                console.warn('duplicate IDs found!', this, lodash__WEBPACK_IMPORTED_MODULE_2__["flatten"](dumpInfo));
            }
        }
    }
    /**
     * Returns the path's SVG path string.
     */
    Path.prototype.getPathString = function () {
        if (this.pathString === undefined) {
            this.pathString = _PathParser__WEBPACK_IMPORTED_MODULE_5__["commandsToString"](this.getCommands());
        }
        return this.pathString;
    };
    /**
     * Returns the list of SubPaths in this path.
     */
    Path.prototype.getSubPaths = function () {
        return this.ps.subPaths;
    };
    /**
     * Returns the subpath at the specified index.
     */
    Path.prototype.getSubPath = function (subIdx) {
        var numSubPaths = this.getSubPaths().length;
        if (subIdx < 0 || numSubPaths <= subIdx) {
            console.error(this);
            throw new Error("Subpath index out of bounds: " + ("subIdx=" + subIdx + " numSubPaths=" + numSubPaths));
        }
        return this.getSubPaths()[subIdx];
    };
    /**
     * Returns the list of Commands in this path.
     */
    Path.prototype.getCommands = function () {
        return this.ps.commands;
    };
    /**
     * Returns the command at the specified index.
     */
    Path.prototype.getCommand = function (subIdx, cmdIdx) {
        var subPath = this.getSubPath(subIdx);
        var numCommands = subPath.getCommands().length;
        if (cmdIdx < 0 || numCommands <= cmdIdx) {
            console.error(this);
            throw new Error("Command index out of bounds: " +
                ("subIdx=" + subIdx + " cmdIdx=" + cmdIdx + ", numCommands=" + numCommands));
        }
        return subPath.getCommands()[cmdIdx];
    };
    /**
     * Returns the length of the path.
     */
    Path.prototype.getPathLength = function () {
        return this.ps.getPathLength();
    };
    /**
     * Returns the length of the subpath.
     */
    Path.prototype.getSubPathLength = function (subIdx) {
        return this.ps.getSubPathLength(subIdx);
    };
    /**
     * Returns the point at the given length along the path.
     */
    Path.prototype.getPointAtLength = function (distance) {
        return this.ps.getPointAtLength(distance);
    };
    /**
     * Returns true iff this path is morphable with the specified path.
     */
    Path.prototype.isMorphableWith = function (path) {
        var cmds1 = this.getCommands();
        var cmds2 = path.getCommands();
        return cmds1.length === cmds2.length && cmds1.every(function (cmd1, i) { return cmd1.type === cmds2[i].type; });
    };
    /**
     * Calculates the point on this path that is closest to the specified point argument.
     * Returns undefined if no point is found.
     */
    Path.prototype.project = function (point, restrictToSubIdx) {
        return this.ps.project(point, restrictToSubIdx);
    };
    /**
     * Performs a hit test on the path and returns a HitResult.
     */
    Path.prototype.hitTest = function (point, opts) {
        return this.ps.hitTest(point, opts);
    };
    /**
     * Returns the pole of inaccessibility for the specified subpath index.
     */
    Path.prototype.getPoleOfInaccessibility = function (subIdx) {
        return this.ps.getPoleOfInaccessibility(subIdx);
    };
    /**
     * Returns the bounding box for this path.
     */
    Path.prototype.getBoundingBox = function () {
        return this.ps.getBoundingBox();
    };
    /**
     * Returns true iff the subpath at the specified index is clockwise.
     */
    Path.prototype.isClockwise = function (subIdx) {
        return this.ps.isClockwise(subIdx);
    };
    /**
     * Returns true iff the path is closed.
     */
    Path.prototype.isClosed = function () {
        return this.getSubPaths().every(function (s) { return s.isClosed(); });
    };
    /**
     * Transforms the path using the specified transform matrix.
     */
    Path.prototype.transform = function (transform) {
        return this.mutate()
            .transform(transform)
            .build()
            .clone();
    };
    /**
     * Creates a builder that can create a mutated Path object.
     */
    Path.prototype.mutate = function () {
        return new PathMutator(this.ps);
    };
    /**
     * Returns a cloned instance of this path. Any existing path state will be cleared.
     */
    Path.prototype.clone = function () {
        return new Path(this.getPathString());
    };
    /**
     * Returns a Path representing its initial unmutated state.
     */
    Path.prototype.revert = function () {
        return this.mutate()
            .revert()
            .build();
    };
    return Path;
}());

var ENABLE_LOGS = !environments_environment__WEBPACK_IMPORTED_MODULE_1__["environment"].production && false;
/**
 * A builder class for creating mutated Path objects.
 */
var PathMutator = /** @class */ (function () {
    function PathMutator(ps) {
        this.subPathStateMap = ps.subPathStateMap.slice();
        this.subPathOrdering = ps.subPathOrdering.slice();
        this.numCollapsingSubPaths = ps.numCollapsingSubPaths;
    }
    /**
     * Reverses the order of the points in the sub path at the specified index.
     */
    PathMutator.prototype.reverseSubPath = function (subIdx) {
        LOG('reverseSubPath', subIdx);
        this.setSubPathStateLeaf(subIdx, this.findSubPathStateLeaf(subIdx)
            .mutate()
            .reverse()
            .build());
        return this;
    };
    /**
     * Shifts back the order of the points in the sub path at the specified index.
     */
    PathMutator.prototype.shiftSubPathBack = function (subIdx, numShifts) {
        if (numShifts === void 0) { numShifts = 1; }
        LOG('shiftSubPathBack', subIdx, numShifts);
        return this.findSubPathStateLeaf(subIdx).isReversed()
            ? this.shift(subIdx, function (o, n) { return (o + numShifts) % (n - 1); })
            : this.shift(subIdx, function (o, n) { return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].floorMod(o - numShifts, n - 1); });
    };
    /**
     * Shifts forward the order of the points in the sub path at the specified index.
     */
    PathMutator.prototype.shiftSubPathForward = function (subIdx, numShifts) {
        if (numShifts === void 0) { numShifts = 1; }
        LOG('shiftSubPathForward', subIdx, numShifts);
        return this.findSubPathStateLeaf(subIdx).isReversed()
            ? this.shift(subIdx, function (o, n) { return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].floorMod(o - numShifts, n - 1); })
            : this.shift(subIdx, function (o, n) { return (o + numShifts) % (n - 1); });
    };
    PathMutator.prototype.shift = function (subIdx, calcOffsetFn) {
        var sps = this.findSubPathStateLeaf(subIdx);
        var numCmdsInSubPath = lodash__WEBPACK_IMPORTED_MODULE_2__["sumBy"](sps.getCommandStates(), function (cs) { return cs.getCommands().length; });
        if (numCmdsInSubPath <= 1) {
            return this;
        }
        var firstCmd = sps.getCommandStates()[0].getCommands()[0];
        var lastCmd = lodash__WEBPACK_IMPORTED_MODULE_2__["last"](lodash__WEBPACK_IMPORTED_MODULE_2__["last"](sps.getCommandStates()).getCommands());
        if (!app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].arePointsEqual(firstCmd.end, lastCmd.end)) {
            // TODO: in some cases there may be rounding errors that cause a closed subpath
            // to show up as non-closed. is there anything we can do to alleviate this?
            console.warn('Ignoring attempt to shift a non-closed subpath');
            return this;
        }
        this.setSubPathStateLeaf(subIdx, sps
            .mutate()
            .setShiftOffset(calcOffsetFn(sps.getShiftOffset(), numCmdsInSubPath))
            .build());
        return this;
    };
    /**
     * Splits the command using the specified t values.
     */
    PathMutator.prototype.splitCommand = function (subIdx, cmdIdx) {
        var ts = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            ts[_i - 2] = arguments[_i];
        }
        LOG('splitCommand', subIdx, cmdIdx, ts);
        if (!ts.length) {
            throw new Error('Must specify at least one t value');
        }
        var _a = this.findReversedAndShiftedInternalIndices(subIdx, cmdIdx), targetCs = _a.targetCs, csIdx = _a.csIdx, splitIdx = _a.splitIdx;
        var shiftOffset = this.getUpdatedShiftOffsetsAfterSplit(subIdx, csIdx, splitIdx, ts.length);
        var sps = this.findSubPathStateLeaf(subIdx);
        if (sps.isReversed()) {
            ts = ts.map(function (t) { return 1 - t; });
        }
        this.setSubPathStateLeaf(subIdx, this.findSubPathStateLeaf(subIdx)
            .mutate()
            .setShiftOffset(shiftOffset)
            .setCommandState(csIdx, targetCs
            .mutate()
            .splitAtIndex(splitIdx, ts)
            .build())
            .build());
        return this;
    };
    /**
     * Splits the command into two approximately equal parts.
     */
    PathMutator.prototype.splitCommandInHalf = function (subIdx, cmdIdx) {
        LOG('splitCommandInHalf', subIdx, cmdIdx);
        var _a = this.findReversedAndShiftedInternalIndices(subIdx, cmdIdx), targetCs = _a.targetCs, csIdx = _a.csIdx, splitIdx = _a.splitIdx;
        var shiftOffset = this.getUpdatedShiftOffsetsAfterSplit(subIdx, csIdx, splitIdx, 1);
        this.setSubPathStateLeaf(subIdx, this.findSubPathStateLeaf(subIdx)
            .mutate()
            .setShiftOffset(shiftOffset)
            .setCommandState(csIdx, targetCs
            .mutate()
            .splitInHalfAtIndex(splitIdx)
            .build())
            .build());
        return this;
    };
    // If 0 <= position <= shiftOffset, then that means we need to increase the
    // shift offset to account for the new split points that are about to be inserted.
    // Note that this method assumes all splits will occur within the same cmdIdx
    // command. This means that the shift offset will only ever increase by either
    // 'numShifts' or '0', since it will be impossible for splits to be added on
    // both sides of the shift pivot. We could fix that, but it's a lot of
    // complicated indexing and I don't think the user will ever need to do this anyway.
    PathMutator.prototype.getUpdatedShiftOffsetsAfterSplit = function (subIdx, csIdx, splitIdx, numSplits) {
        var sps = this.findSubPathStateLeaf(subIdx);
        var shiftOffset = sps.getShiftOffset();
        var position = splitIdx;
        for (var i = 0; i < csIdx; i++) {
            position += sps.getCommandStates()[i].getCommands().length;
        }
        if (shiftOffset && position <= shiftOffset) {
            return shiftOffset + numSplits;
        }
        return shiftOffset;
    };
    /**
     * Un-splits the path at the specified index. Returns a new path object.
     */
    PathMutator.prototype.unsplitCommand = function (subIdx, cmdIdx) {
        LOG('unsplitCommand', subIdx, cmdIdx);
        var _a = this.findReversedAndShiftedInternalIndices(subIdx, cmdIdx), targetCs = _a.targetCs, csIdx = _a.csIdx, splitIdx = _a.splitIdx;
        var isSubPathReversed = this.findSubPathStateLeaf(subIdx).isReversed();
        this.setSubPathStateLeaf(subIdx, this.findSubPathStateLeaf(subIdx)
            .mutate()
            .setCommandState(csIdx, targetCs
            .mutate()
            .unsplitAtIndex(isSubPathReversed ? splitIdx - 1 : splitIdx)
            .build())
            .build());
        var sps = this.findSubPathStateLeaf(subIdx);
        var shiftOffset = sps.getShiftOffset();
        var position = splitIdx;
        for (var i = 0; i < csIdx; i++) {
            position += sps.getCommandStates()[i].getCommands().length;
        }
        if (shiftOffset && position <= shiftOffset) {
            // Subtract the shift offset by 1 to ensure that the unsplit operation
            // doesn't alter the positions of the path points.
            this.setSubPathStateLeaf(subIdx, this.findSubPathStateLeaf(subIdx)
                .mutate()
                .setShiftOffset(shiftOffset - 1)
                .build());
        }
        return this;
    };
    /**
     * Convert the path at the specified index. Returns a new path object.
     */
    PathMutator.prototype.convertCommand = function (subIdx, cmdIdx, svgChar) {
        var _a = this.findReversedAndShiftedInternalIndices(subIdx, cmdIdx), targetCs = _a.targetCs, csIdx = _a.csIdx, splitIdx = _a.splitIdx;
        this.setSubPathStateLeaf(subIdx, this.findSubPathStateLeaf(subIdx)
            .mutate()
            .setCommandState(csIdx, targetCs
            .mutate()
            .convertAtIndex(splitIdx, svgChar)
            .build())
            .build());
        return this;
    };
    /**
     * Reverts any conversions previously performed in the specified sub path.
     */
    PathMutator.prototype.unconvertSubPath = function (subIdx) {
        var sps = this.findSubPathStateLeaf(subIdx);
        var css = sps.getCommandStates().map(function (cs, csIdx) {
            return csIdx === 0
                ? cs
                : cs
                    .mutate()
                    .unconvertSubpath()
                    .build();
        });
        this.setSubPathStateLeaf(subIdx, sps
            .mutate()
            .setCommandStates(css)
            .build());
        return this;
    };
    /**
     * Transforms the path using the specified transformation matrix.
     */
    PathMutator.prototype.transform = function (transform) {
        var spss = Object(_SubPathState__WEBPACK_IMPORTED_MODULE_7__["flattenSubPathStates"])(this.subPathStateMap);
        for (var spsIdx = 0; spsIdx < spss.length; spsIdx++) {
            var sps = spss[spsIdx];
            var css = sps.getCommandStates();
            var subIdx = this.subPathOrdering.indexOf(spsIdx);
            this.setSubPathStateLeaf(subIdx, sps
                .mutate()
                .setCommandStates(css.map(function (cs) {
                return cs
                    .mutate()
                    .transform(transform)
                    .build();
            }))
                .build());
        }
        return this;
    };
    /**
     * Moves a subpath from one index to another. Returns a new path object.
     */
    PathMutator.prototype.moveSubPath = function (fromSubIdx, toSubIdx) {
        LOG('moveSubPath', fromSubIdx, toSubIdx);
        this.subPathOrdering.splice(toSubIdx, 0, this.subPathOrdering.splice(fromSubIdx, 1)[0]);
        return this;
    };
    /**
     * Splits a stroked sub path using the specified indices.
     * A 'moveTo' command will be inserted after the command at 'cmdIdx'.
     */
    PathMutator.prototype.splitStrokedSubPath = function (subIdx, cmdIdx) {
        LOG('splitStrokedSubPath', subIdx, cmdIdx);
        var sps = this.findSubPathStateLeaf(subIdx);
        var css = reverseAndShiftCommandStates(sps.getCommandStates(), sps.isReversed(), sps.getShiftOffset());
        var _a = this.findInternalIndices(css, cmdIdx), csIdx = _a.csIdx, splitIdx = _a.splitIdx;
        var startCommandStates = [];
        var endCommandStates = [];
        for (var i = 0; i < css.length; i++) {
            if (i < csIdx) {
                startCommandStates.push(css[i]);
            }
            else if (csIdx < i) {
                endCommandStates.push(css[i]);
            }
            else {
                var splitPoint = css[i].getCommands()[splitIdx].end;
                var _b = css[i].slice(splitIdx), left = _b.left, right = _b.right;
                startCommandStates.push(left);
                var endMoveCs = new _CommandState__WEBPACK_IMPORTED_MODULE_4__["CommandState"](new _Command__WEBPACK_IMPORTED_MODULE_3__["Command"]('M', [splitPoint, splitPoint]));
                if (sps.isReversed()) {
                    endMoveCs = endMoveCs
                        .mutate()
                        .reverse()
                        .build();
                }
                endCommandStates.push(endMoveCs);
                if (right) {
                    endCommandStates.push(right);
                }
            }
        }
        var splitSubPaths = [
            new _SubPathState__WEBPACK_IMPORTED_MODULE_7__["SubPathState"](startCommandStates),
            new _SubPathState__WEBPACK_IMPORTED_MODULE_7__["SubPathState"](endCommandStates),
        ];
        this.setSubPathStateLeaf(subIdx, sps
            .mutate()
            .setSplitSubPaths(splitSubPaths)
            .build());
        this.subPathOrdering.push(this.subPathOrdering.length);
        return this;
    };
    /**
     * Deletes the stroked subpath at the specified index. The subpath's sibling
     * will be deleted as well.
     */
    PathMutator.prototype.deleteStrokedSubPath = function (subIdx) {
        LOG('unsplitStrokedSubPath', subIdx);
        var parent = this.findSubPathStateParent(subIdx);
        var splitId = lodash__WEBPACK_IMPORTED_MODULE_2__["last"](lodash__WEBPACK_IMPORTED_MODULE_2__["last"](parent.getSplitSubPaths()[0].getCommandStates()).getCommands())
            .id;
        var mutator = parent.mutate().setSplitSubPaths([]);
        this.deleteSpsSplitPoint(parent.getCommandStates(), splitId, mutator);
        this.subPathStateMap = this.replaceSubPathStateNode(parent, function (states, i) { return (states[i] = mutator.build()); });
        this.updateOrderingAfterUnsplitSubPath(subIdx);
        return this;
    };
    /**
     * Splits a filled subpath using the specified indices.
     *
     * Consider the following filled subpath:
     *
     * 2-------------------3
     * |                   |
     * |                   |
     * |                   |
     * 1                   4
     * |                   |
     * |                   |
     * |                   |
     * 0-------------------5
     *
     * Splitting the filled subpath with startCmdIdx=1 and endCmdIdx=4
     * results in the following split subpaths:
     *
     * xxxxxxxxxxxxxxxxxxxxx    1-------->>>--------2
     * x                   x    |                   |
     * x                   x    ↑                   ↓
     * x                   x    |                   |
     * 1-------->>>--------2    0--------<<<--------3
     * |                   |    x                   x
     * ↑                   ↓    x                   x
     * |                   |    x                   x
     * 0--------<<<--------3    xxxxxxxxxxxxxxxxxxxxx
     */
    PathMutator.prototype.splitFilledSubPath = function (subIdx, startCmdIdx, endCmdIdx) {
        var _this = this;
        LOG('splitFilledSubPath', subIdx, startCmdIdx, endCmdIdx);
        var targetSps = this.findSubPathStateLeaf(subIdx);
        var targetCss = reverseAndShiftCommandStates(targetSps.getCommandStates(), targetSps.isReversed(), targetSps.getShiftOffset());
        var findTargetSplitIdxs = function () {
            var s = _this.findInternalIndices(targetCss, startCmdIdx);
            var e = _this.findInternalIndices(targetCss, endCmdIdx);
            if (s.csIdx > e.csIdx || (s.csIdx === e.csIdx && s.splitIdx > e.csIdx)) {
                // Make sure the start index appears before the end index in the path.
                var temp = s;
                s = e;
                e = temp;
            }
            return {
                startCsIdx: s.csIdx,
                startSplitIdx: s.splitIdx,
                endCsIdx: e.csIdx,
                endSplitIdx: e.splitIdx,
            };
        };
        // firstLeft: left portion of the 1st split segment (used in the 1st split path).
        // secondLeft: left portion of the 2nd split segment (used in the 2nd split path).
        // firstRight: right portion of the 1st split segment (used in the 2nd split path).
        // secondRight: right portion of the 2nd split segment (used in the 1st split path).
        var _a = findTargetSplitIdxs(), startCsIdx = _a.startCsIdx, startSplitIdx = _a.startSplitIdx, endCsIdx = _a.endCsIdx, endSplitIdx = _a.endSplitIdx;
        var _b = targetCss[startCsIdx].slice(startSplitIdx), firstLeft = _b.left, firstRight = _b.right;
        var _c = targetCss[endCsIdx].slice(endSplitIdx), secondLeft = _c.left, secondRight = _c.right;
        var startSplitCmd = firstLeft.getCommands()[startSplitIdx];
        var startSplitPoint = startSplitCmd.end;
        var endSplitCmd = secondLeft.getCommands()[endSplitIdx];
        var endSplitPoint = endSplitCmd.end;
        // Give both line segments the same unique ID so that we can later identify which
        // split segments were added together during the deletion phase.
        var splitSegmentId = lodash__WEBPACK_IMPORTED_MODULE_2__["uniqueId"]();
        var endLine = new _CommandState__WEBPACK_IMPORTED_MODULE_4__["CommandState"](new _Command__WEBPACK_IMPORTED_MODULE_3__["Command"]('L', [endSplitPoint, startSplitPoint]))
            .mutate()
            .setSplitSegmentInfo(secondLeft, splitSegmentId)
            .build();
        var startLine = new _CommandState__WEBPACK_IMPORTED_MODULE_4__["CommandState"](new _Command__WEBPACK_IMPORTED_MODULE_3__["Command"]('L', [startSplitPoint, endSplitPoint]))
            .mutate()
            .setSplitSegmentInfo(firstLeft, splitSegmentId)
            .build();
        var startCommandStates = [];
        for (var i = 0; i < targetCss.length; i++) {
            if (i < startCsIdx || endCsIdx < i) {
                startCommandStates.push(targetCss[i]);
            }
            else if (i === startCsIdx) {
                startCommandStates.push(firstLeft);
                startCommandStates.push(startLine);
            }
            else if (i === endCsIdx && secondRight) {
                startCommandStates.push(secondRight);
            }
        }
        var endCommandStates = [];
        for (var i = 0; i < targetCss.length; i++) {
            if (i === startCsIdx) {
                endCommandStates.push(new _CommandState__WEBPACK_IMPORTED_MODULE_4__["CommandState"](new _Command__WEBPACK_IMPORTED_MODULE_3__["Command"]('M', [startSplitPoint, startSplitPoint]))
                    .mutate()
                    // The move command identifies the beginning of a new split segment,
                    // so we'll mark it with the parent state as well (we'll need this
                    // information later on if the segment is deleted). Note that unlike
                    // the two segments above, we don't need to specify an ID here.
                    .setSplitSegmentInfo(firstLeft, '')
                    .build());
                if (firstRight) {
                    endCommandStates.push(firstRight);
                }
            }
            else if (startCsIdx < i && i < endCsIdx) {
                endCommandStates.push(targetCss[i]);
            }
            else if (i === endCsIdx) {
                endCommandStates.push(secondLeft);
                endCommandStates.push(endLine);
            }
        }
        var splitSubPaths = [
            new _SubPathState__WEBPACK_IMPORTED_MODULE_7__["SubPathState"](startCommandStates),
            new _SubPathState__WEBPACK_IMPORTED_MODULE_7__["SubPathState"](endCommandStates),
        ];
        var newStates = [];
        var parent = this.findSubPathStateParent(subIdx);
        // Find the backing IDs for each parent command state that is a split segment.
        var parentSplitBackingIds = lodash__WEBPACK_IMPORTED_MODULE_2__((parent ? parent.getCommandStates() : []))
            .filter(function (cs) { return !!cs.getSplitSegmentId(); })
            .map(function (cs) { return cs.getBackingId(); })
            .value();
        // Find the backing IDs for each sibling command state that is a split segment,
        // not including split segments that were inherited from the parent.
        var siblingSplitBackingIds = lodash__WEBPACK_IMPORTED_MODULE_2__(targetSps.getCommandStates())
            .filter(function (cs) { return !!cs.getSplitSegmentId() && !parentSplitBackingIds.includes(cs.getBackingId()); })
            .map(function (cs) { return cs.getBackingId(); })
            .value();
        // Checking for the existence of 'firstRight' and 'secondRight' ensures that
        // paths connected to the end point of a deleted split segment will still be kept.
        if (this.subPathStateMap.includes(targetSps) ||
            (firstRight && siblingSplitBackingIds.includes(firstLeft.getBackingId())) ||
            (secondRight && siblingSplitBackingIds.includes(secondLeft.getBackingId()))) {
            // If we are at the first level of the tree or if one of the new
            // split edges is a split segment, then add a new level to the tree.
            // If the already existing split segment is deleted, we want to
            // delete the split segment we are creating right now as well.
            newStates.push(targetSps
                .mutate()
                .setSplitSubPaths(splitSubPaths)
                .build());
        }
        else {
            // Otherwise insert the sub paths in the current level of the tree.
            newStates.push.apply(newStates, splitSubPaths);
        }
        // Insert the new SubPathStates into the tree.
        this.subPathStateMap = this.replaceSubPathStateNode(targetSps, function (states, i) {
            return states.splice.apply(states, [i, 1].concat(newStates));
        });
        this.subPathOrdering.push(this.subPathOrdering.length);
        return this;
    };
    /**
     * Deletes the filled subpath at the specified index. All adjacent sibling subpaths
     * will be deleted as well (i.e. subpaths that share the same split segment ID).
     */
    PathMutator.prototype.deleteFilledSubPath = function (subIdx) {
        var _this = this;
        LOG('deleteFilledSubPath', subIdx);
        var targetCss = this.findSubPathStateLeaf(subIdx).getCommandStates();
        // Get the list of parent split segment IDs.
        var parentSplitSegIds = lodash__WEBPACK_IMPORTED_MODULE_2__(this.findSubPathStateParent(subIdx).getCommandStates())
            .map(function (cs) { return cs.getSplitSegmentId(); })
            .compact()
            .uniq()
            .value();
        // Get the list of sibling split segment IDs, not including split segment
        // IDs inherited from the parent.
        var siblingSplitSegIds = lodash__WEBPACK_IMPORTED_MODULE_2__(targetCss)
            .map(function (cs) { return cs.getSplitSegmentId(); })
            .compact()
            .uniq()
            .difference(parentSplitSegIds)
            .value();
        siblingSplitSegIds.forEach(function (id) {
            var targetCs = lodash__WEBPACK_IMPORTED_MODULE_2__["find"](targetCss, function (cs) { return cs.getSplitSegmentId() === id; });
            var deletedSubIdxs = _this.calculateDeletedSubIdxs(subIdx, targetCs);
            _this.deleteFilledSubPathSegmentInternal(subIdx, targetCs);
            subIdx -= lodash__WEBPACK_IMPORTED_MODULE_2__["sumBy"](deletedSubIdxs, function (idx) { return (idx <= subIdx ? 1 : 0); });
        });
        return this;
    };
    /**
     * Deletes the subpath split segment with the specified indices.
     */
    PathMutator.prototype.deleteFilledSubPathSegment = function (subIdx, cmdIdx) {
        LOG('deleteSubPathSplitSegment', subIdx, cmdIdx);
        var targetCs = this.findReversedAndShiftedInternalIndices(subIdx, cmdIdx).targetCs;
        this.deleteFilledSubPathSegmentInternal(subIdx, targetCs);
        return this;
    };
    /**
     * Deletes the subpath split segment with the specified index. The two subpaths
     * that share the split segment ID will be merged into a single subpath.
     */
    PathMutator.prototype.deleteFilledSubPathSegmentInternal = function (subIdx, targetCs) {
        // Get the SubPathState ID of the node representing the subpath with index 'subIdx'.
        var targetSpsId = this.findSubPathStateLeaf(subIdx).getId();
        // Get the split segment ID of the target command state object.
        var targetSplitSegId = targetCs.getSplitSegmentId();
        var psps = this.findSplitSegmentParentNode(targetSplitSegId);
        var pssps = psps.getSplitSubPaths();
        var pcss = psps.getCommandStates();
        // Find the first index of the split sub path containing the target.
        var splitSubPathIdx1 = lodash__WEBPACK_IMPORTED_MODULE_2__["findIndex"](pssps, function (sps) {
            return sps.getCommandStates().some(function (cs) { return cs.getSplitSegmentId() === targetSplitSegId; });
        });
        // Find the second index of the split sub path containing the target.
        var splitSubPathIdx2 = lodash__WEBPACK_IMPORTED_MODULE_2__["findLastIndex"](pssps, function (sps) {
            return sps.getCommandStates().some(function (cs) { return cs.getSplitSegmentId() === targetSplitSegId; });
        });
        var deletedSubIdxs = this.calculateDeletedSubIdxs(subIdx, targetCs);
        var splitCss1 = pssps[splitSubPathIdx1].getCommandStates();
        var splitCss2 = pssps[splitSubPathIdx2].getCommandStates();
        var updatedSplitSubPaths = [];
        if (pssps.length > 2) {
            // In addition to deleting the split segment, we will also have to merge its
            // two adjacent sub paths together into one.
            var parentBackingId2_1 = lodash__WEBPACK_IMPORTED_MODULE_2__["last"](splitCss2)
                .getParentCommandState()
                .getBackingId();
            var parentBackingCmd2_1 = lodash__WEBPACK_IMPORTED_MODULE_2__["find"](pcss, function (c) { return parentBackingId2_1 === c.getBackingId(); });
            var newCss = [];
            var cs = void 0;
            var i = 0;
            for (; i < splitCss1.length; i++) {
                cs = splitCss1[i];
                if (splitCss1[i + 1].getSplitSegmentId() === targetSplitSegId) {
                    // Iterate until we reach the location of the first split.
                    break;
                }
                newCss.push(cs);
            }
            var parentBackingCmdIdx1 = i;
            if (cs.getBackingId() === splitCss2[1].getBackingId()) {
                newCss.push(splitCss2[1].merge(cs));
            }
            else {
                newCss.push(cs);
                newCss.push(splitCss2[1]);
            }
            cs = undefined;
            for (i = 2; i < splitCss2.length - 1; i++) {
                cs = splitCss2[i];
                if (splitCss2[i + 1].getSplitSegmentId() === targetSplitSegId) {
                    // Iterate until we reach the location of the second split.
                    break;
                }
                newCss.push(cs);
            }
            i = lodash__WEBPACK_IMPORTED_MODULE_2__["findIndex"](splitCss1, function (c) { return c.getBackingId() === parentBackingCmd2_1.getBackingId(); });
            if (i >= 0) {
                if (cs) {
                    if (splitCss1[i].getBackingId() === cs.getBackingId()) {
                        // If the split created a new point, then merge the left/right commands
                        // together to reconstruct the previous state.
                        newCss.push(splitCss1[i].merge(cs));
                    }
                    else if (cs) {
                        // If the split was done at an existing point, then simply push the next
                        // command state onto the list.
                        newCss.push(cs);
                    }
                }
            }
            else {
                i = parentBackingCmdIdx1 + 1;
                if (cs) {
                    newCss.push(cs);
                }
            }
            for (i = i + 1; i < splitCss1.length; i++) {
                newCss.push(splitCss1[i]);
            }
            var splits = pssps.slice();
            splits[splitSubPathIdx1] = new _SubPathState__WEBPACK_IMPORTED_MODULE_7__["SubPathState"](newCss.slice())
                .mutate()
                .setId(targetSpsId)
                .build();
            splits.splice(splitSubPathIdx2, 1);
            updatedSplitSubPaths = splits;
        }
        var mutator = psps.mutate().setSplitSubPaths(updatedSplitSubPaths);
        var firstSplitSegId = lodash__WEBPACK_IMPORTED_MODULE_2__["last"](splitCss2[0].getParentCommandState().getCommands()).id;
        var secondSplitSegId = lodash__WEBPACK_IMPORTED_MODULE_2__["last"](lodash__WEBPACK_IMPORTED_MODULE_2__["last"](splitCss2)
            .getParentCommandState()
            .getCommands()).id;
        for (var _i = 0, _a = [firstSplitSegId, secondSplitSegId]; _i < _a.length; _i++) {
            var id = _a[_i];
            this.deleteSpsSplitPoint(pcss, id, mutator);
        }
        this.subPathStateMap = this.replaceSubPathStateNode(psps, function (states, i) { return (states[i] = mutator.build()); });
        for (var _b = 0, deletedSubIdxs_1 = deletedSubIdxs; _b < deletedSubIdxs_1.length; _b++) {
            var idx = deletedSubIdxs_1[_b];
            this.updateOrderingAfterUnsplitSubPath(idx);
        }
        return this;
    };
    /**
     * Calculates the sub path indices that will be removed after unsplitting subIdx.
     * targetCs is the command state object containing the split segment in question.
     */
    PathMutator.prototype.calculateDeletedSubIdxs = function (subIdx, targetCs) {
        var _this = this;
        var splitSegId = targetCs.getSplitSegmentId();
        var psps = this.findSplitSegmentParentNode(splitSegId);
        var pssps = psps.getSplitSubPaths();
        var splitSubPathIdx1 = lodash__WEBPACK_IMPORTED_MODULE_2__["findIndex"](pssps, function (sps) {
            return sps.getCommandStates().some(function (cs) { return cs.getSplitSegmentId() === splitSegId; });
        });
        var splitSubPathIdx2 = lodash__WEBPACK_IMPORTED_MODULE_2__["findLastIndex"](pssps, function (sps) {
            return sps.getCommandStates().some(function (cs) { return cs.getSplitSegmentId() === splitSegId; });
        });
        var pssp1 = pssps[splitSubPathIdx1];
        var pssp2 = pssps[splitSubPathIdx2];
        var deletedSps = Object(_SubPathState__WEBPACK_IMPORTED_MODULE_7__["flattenSubPathStates"])([pssp1]).concat(Object(_SubPathState__WEBPACK_IMPORTED_MODULE_7__["flattenSubPathStates"])([pssp2]));
        var spss = Object(_SubPathState__WEBPACK_IMPORTED_MODULE_7__["flattenSubPathStates"])(this.subPathStateMap);
        return deletedSps
            .slice(1)
            .map(function (sps) { return _this.subPathOrdering[spss.indexOf(sps)]; })
            .sort(function (a, b) { return b - a; });
    };
    PathMutator.prototype.deleteSpsSplitPoint = function (css, splitCmdId, mutator) {
        var csIdx = 0, splitIdx = -1;
        var _loop_1 = function () {
            var cs = css[csIdx];
            var csIds = cs.getCommands().map(function (unused, idx) { return cs.getIdAtIndex(idx); });
            splitIdx = csIds.indexOf(splitCmdId);
            if (splitIdx >= 0) {
                return "break";
            }
        };
        for (; csIdx < css.length; csIdx++) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
        if (splitIdx >= 0 && css[csIdx].isSplitAtIndex(splitIdx)) {
            // Delete the split point that created the sub path.
            var unsplitCs = css[csIdx]
                .mutate()
                .unsplitAtIndex(splitIdx)
                .build();
            mutator.setCommandState(csIdx, unsplitCs);
        }
    };
    PathMutator.prototype.updateOrderingAfterUnsplitSubPath = function (subIdx) {
        var spsIdx = this.subPathOrdering[subIdx];
        this.subPathOrdering.splice(subIdx, 1);
        // tslint:disable-next-line: prefer-for-of
        for (var i = 0; i < this.subPathOrdering.length; i++) {
            if (spsIdx < this.subPathOrdering[i]) {
                this.subPathOrdering[i]--;
            }
        }
    };
    /**
     * Adds a collapsing subpath to the path.
     */
    PathMutator.prototype.addCollapsingSubPath = function (point, numCommands) {
        var prevCmd = lodash__WEBPACK_IMPORTED_MODULE_2__["last"](this.buildOrderedCommands());
        var css = [new _CommandState__WEBPACK_IMPORTED_MODULE_4__["CommandState"](new _Command__WEBPACK_IMPORTED_MODULE_3__["Command"]('M', [prevCmd.end, point]))];
        for (var i = 1; i < numCommands; i++) {
            css.push(new _CommandState__WEBPACK_IMPORTED_MODULE_4__["CommandState"](new _Command__WEBPACK_IMPORTED_MODULE_3__["Command"]('L', [point, point])));
        }
        this.subPathStateMap.push(new _SubPathState__WEBPACK_IMPORTED_MODULE_7__["SubPathState"](css));
        this.subPathOrdering.push(this.subPathOrdering.length);
        this.numCollapsingSubPaths++;
        return this;
    };
    /**
     * Deletes all collapsing subpaths from the path.
     */
    PathMutator.prototype.deleteCollapsingSubPaths = function () {
        var numSubPathsBeforeDelete = this.subPathOrdering.length;
        var spsIdxToSubIdxMap = [];
        for (var spsIdx = 0; spsIdx < numSubPathsBeforeDelete; spsIdx++) {
            spsIdxToSubIdxMap.push(this.subPathOrdering.indexOf(spsIdx));
        }
        var numCollapsingSubPathsBeforeDelete = this.numCollapsingSubPaths;
        var numSubPathsAfterDelete = numSubPathsBeforeDelete - numCollapsingSubPathsBeforeDelete;
        function deleteCollapsingSubPathInfoFn(arr) {
            arr.splice(numSubPathsAfterDelete, numCollapsingSubPathsBeforeDelete);
        }
        for (var i = 0; i < numCollapsingSubPathsBeforeDelete; i++) {
            this.subPathStateMap.pop();
        }
        deleteCollapsingSubPathInfoFn(spsIdxToSubIdxMap);
        this.subPathOrdering = [];
        for (var subIdx = 0; subIdx < numSubPathsBeforeDelete; subIdx++) {
            for (var i = 0; i < spsIdxToSubIdxMap.length; i++) {
                if (spsIdxToSubIdxMap[i] === subIdx) {
                    this.subPathOrdering.push(i);
                    break;
                }
            }
        }
        this.numCollapsingSubPaths = 0;
        return this;
    };
    /**
     * Returns the initial starting state of this path.
     */
    PathMutator.prototype.revert = function () {
        this.deleteCollapsingSubPaths();
        this.subPathStateMap = this.subPathStateMap.map(function (sps) { return sps.revert(); });
        this.subPathOrdering = this.subPathStateMap.map(function (unused, i) { return i; });
        return this;
    };
    /**
     * Builds a new mutated path.
     */
    PathMutator.prototype.build = function () {
        return new Path(new _PathState__WEBPACK_IMPORTED_MODULE_6__["PathState"](this.buildOrderedCommands(), this.subPathStateMap, this.subPathOrdering, this.numCollapsingSubPaths));
    };
    PathMutator.prototype.buildOrderedCommands = function () {
        var _this = this;
        var spsCmds = Object(_SubPathState__WEBPACK_IMPORTED_MODULE_7__["flattenSubPathStates"])(this.subPathStateMap).map(function (sps) {
            return reverseAndShiftCommands(sps);
        });
        var orderedSubPathCmds = this.subPathOrdering.map(function (unused, subIdx) { return spsCmds[_this.subPathOrdering[subIdx]]; });
        return lodash__WEBPACK_IMPORTED_MODULE_2__(orderedSubPathCmds)
            .map(function (cmds, subIdx) {
            var moveCmd = cmds[0];
            if (subIdx === 0 && moveCmd.start) {
                cmds[0] = moveCmd
                    .mutate()
                    .setPoints(undefined, moveCmd.end)
                    .build();
            }
            else if (subIdx !== 0) {
                var start = lodash__WEBPACK_IMPORTED_MODULE_2__["last"](orderedSubPathCmds[subIdx - 1]).end;
                cmds[0] = moveCmd
                    .mutate()
                    .setPoints(start, moveCmd.end)
                    .build();
            }
            return cmds;
        })
            .flatMap(function (cmds) { return cmds; })
            .value();
    };
    /**
     * Returns the leaf node at the specified subpath index.
     */
    PathMutator.prototype.findSubPathStateLeaf = function (subIdx) {
        return Object(_SubPathState__WEBPACK_IMPORTED_MODULE_7__["flattenSubPathStates"])(this.subPathStateMap)[this.subPathOrdering[subIdx]];
    };
    /**
     * Replaces the leaf node at the specified subpath index.
     */
    PathMutator.prototype.setSubPathStateLeaf = function (subIdx, newState) {
        this.subPathStateMap = this.replaceSubPathStateNode(this.findSubPathStateLeaf(subIdx), function (states, i) { return (states[i] = newState); });
    };
    /**
     * Returns the immediate parent of the leaf node at the specified subpath index.
     */
    PathMutator.prototype.findSubPathStateParent = function (subIdx) {
        var subPathStateParents = [];
        (function recurseFn(currentLevel, parent) {
            currentLevel.forEach(function (state) {
                if (!state.getSplitSubPaths().length) {
                    subPathStateParents.push(parent);
                    return;
                }
                recurseFn(state.getSplitSubPaths(), state);
            });
        })(this.subPathStateMap);
        return subPathStateParents[this.subPathOrdering[subIdx]];
    };
    /**
     * Returns the command state indices associated with the specified command index.
     * The targetCs is the command state object that contains the command. The csIdx
     * is the index in the sub path state's list of command state objects that points
     * to targetCs. The splitIdx is the index into the targetCs pointing to the command.
     * This method should only be used during sub path splitting. All other methods should
     * use the findReversedAndShiftedInternalIndices() method below.
     */
    PathMutator.prototype.findInternalIndices = function (css, cmdIdx) {
        var counter = 0;
        var csIdx = 0;
        for (var _i = 0, css_1 = css; _i < css_1.length; _i++) {
            var targetCs = css_1[_i];
            if (counter + targetCs.getCommands().length > cmdIdx) {
                return { targetCs: targetCs, csIdx: csIdx, splitIdx: cmdIdx - counter };
            }
            counter += targetCs.getCommands().length;
            csIdx++;
        }
        throw new Error('Error retrieving command mutation');
    };
    /**
     * Same as above, except this method first takes reversals and shift offsets
     * into account.
     */
    PathMutator.prototype.findReversedAndShiftedInternalIndices = function (subIdx, cmdIdx) {
        var sps = this.findSubPathStateLeaf(subIdx);
        var css = sps.getCommandStates();
        var numCommandsInSubPath = lodash__WEBPACK_IMPORTED_MODULE_2__["sumBy"](css, function (cs) { return cs.getCommands().length; });
        if (cmdIdx && sps.isReversed()) {
            cmdIdx = numCommandsInSubPath - cmdIdx;
        }
        cmdIdx += sps.getShiftOffset();
        if (cmdIdx >= numCommandsInSubPath) {
            // Note that subtracting (numCommandsInSubPath - 1) is intentional here
            // (as opposed to subtracting numCommandsInSubPath).
            cmdIdx -= numCommandsInSubPath - 1;
        }
        return this.findInternalIndices(css, cmdIdx);
    };
    /**
     * Replaces a node in the sub path state map. Note that this function uses
     * object equality to determine the location of the node in the tree.
     */
    PathMutator.prototype.replaceSubPathStateNode = function (nodeToReplace, replaceNodeFn) {
        return (function recurseFn(states) {
            if (!states.length) {
                return undefined;
            }
            for (var i = 0; i < states.length; i++) {
                var currentState = states[i];
                if (currentState === nodeToReplace) {
                    replaceNodeFn(states, i);
                    return states;
                }
                var recurseStates = recurseFn(currentState.getSplitSubPaths().slice());
                if (recurseStates) {
                    states[i] = currentState
                        .mutate()
                        .setSplitSubPaths(recurseStates)
                        .build();
                    return states;
                }
            }
            // Return undefined to signal that the parent was not found.
            return undefined;
        })(this.subPathStateMap.slice());
    };
    /**
     * Finds the first node in the tree that contains the specified split segment ID.
     */
    PathMutator.prototype.findSplitSegmentParentNode = function (splitSegId) {
        return (function recurseFn() {
            var states = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                states[_i] = arguments[_i];
            }
            for (var _a = 0, states_1 = states; _a < states_1.length; _a++) {
                var state = states_1[_a];
                for (var _b = 0, _c = state.getSplitSubPaths(); _b < _c.length; _b++) {
                    var sps = _c[_b];
                    if (sps.getCommandStates().some(function (cs) { return cs.getSplitSegmentId() === splitSegId; })) {
                        return state;
                    }
                    var parent_1 = recurseFn(sps);
                    if (parent_1) {
                        return parent_1;
                    }
                }
            }
            return undefined;
        }).apply(void 0, this.subPathStateMap);
    };
    return PathMutator;
}());

/**
 * Returns a list of shifted and reversed command state objects. Used during
 * subpath splitting when creating new children split subpaths.
 */
function reverseAndShiftCommandStates(css, isReversed, shiftOffset) {
    // If the last command is a 'Z', replace it with a line before we shift.
    // TODO: replacing the 'Z' messes up certain stroke-linejoin values
    var newCss = css.slice();
    newCss[newCss.length - 1] = lodash__WEBPACK_IMPORTED_MODULE_2__["last"](css)
        .mutate()
        .forceConvertClosepathsToLines()
        .build();
    return shiftCommandStates(reverseCommandStates(newCss, isReversed), isReversed, shiftOffset);
}
/**
 * Returns a list of reversed command state objects.
 */
function reverseCommandStates(css, isReversed) {
    if (isReversed) {
        var revCss = [
            new _CommandState__WEBPACK_IMPORTED_MODULE_4__["CommandState"](new _Command__WEBPACK_IMPORTED_MODULE_3__["Command"]('M', [css[0].getCommands()[0].start, lodash__WEBPACK_IMPORTED_MODULE_2__["last"](lodash__WEBPACK_IMPORTED_MODULE_2__["last"](css).getCommands()).end])),
        ];
        for (var i = css.length - 1; i > 0; i--) {
            revCss.push(css[i]
                .mutate()
                .reverse()
                .build());
        }
        css = revCss;
    }
    return css;
}
/**
 * Returns a list of shifted command state objects.
 */
function shiftCommandStates(css, isReversed, shiftOffset) {
    if (!shiftOffset || css.length === 1) {
        return css;
    }
    var numCommands = lodash__WEBPACK_IMPORTED_MODULE_2__["sumBy"](css, function (cs) { return cs.getCommands().length; });
    if (isReversed) {
        shiftOffset *= -1;
        shiftOffset += numCommands - 1;
    }
    var newCss = [];
    var counter = 0;
    var targetCsIdx;
    var targetSplitIdx;
    var targetCs;
    for (var i = 0; i < css.length; i++) {
        var cs = css[i];
        var size = cs.getCommands().length;
        if (counter + size <= shiftOffset) {
            counter += size;
            continue;
        }
        targetCs = cs;
        targetCsIdx = i;
        targetSplitIdx = shiftOffset - counter;
        break;
    }
    newCss.push(new _CommandState__WEBPACK_IMPORTED_MODULE_4__["CommandState"](new _Command__WEBPACK_IMPORTED_MODULE_3__["Command"]('M', [css[0].getCommands()[0].start, targetCs.getCommands()[targetSplitIdx].end])));
    var _a = targetCs.slice(targetSplitIdx), left = _a.left, right = _a.right;
    if (right) {
        newCss.push(right);
    }
    for (var i = targetCsIdx + 1; i < css.length; i++) {
        newCss.push(css[i]);
    }
    for (var i = 1; i < targetCsIdx; i++) {
        newCss.push(css[i]);
    }
    newCss.push(left);
    return newCss;
}
/**
 * Returns a list of reversed and shifted commands.
 */
function reverseAndShiftCommands(subPathState) {
    return shiftCommands(subPathState, reverseCommands(subPathState));
}
/**
 * Returns a list of reversed commands.
 */
function reverseCommands(subPathState) {
    var _a;
    var subPathCss = subPathState.getCommandStates();
    var hasOneCmd = subPathCss.length === 1 && subPathCss[0].getCommands().length === 1;
    if (hasOneCmd || !subPathState.isReversed()) {
        // Nothing to do in these two cases.
        return lodash__WEBPACK_IMPORTED_MODULE_2__["flatMap"](subPathCss, function (cm) { return cm.getCommands(); });
    }
    // Extract the commands from our command mutation map.
    var cmds = lodash__WEBPACK_IMPORTED_MODULE_2__["flatMap"](subPathCss, function (cm) {
        // Consider a segment A ---- B ---- C with AB split and
        // BC non-split. When reversed, we want the user to see
        // C ---- B ---- A w/ CB split and BA non-split.
        var cmCmds = cm.getCommands().slice();
        if (cmCmds[0].type === 'M') {
            return cmCmds;
        }
        cmCmds[0] = cmCmds[0]
            .mutate()
            .toggleSplitPoint()
            .build();
        cmCmds[cmCmds.length - 1] = cmCmds[cmCmds.length - 1]
            .mutate()
            .toggleSplitPoint()
            .build();
        return cmCmds;
    });
    // If the last command is a 'Z', replace it with a line before we reverse.
    // TODO: replacing the 'Z' messes up certain stroke-linejoin values
    var lastCmd = lodash__WEBPACK_IMPORTED_MODULE_2__["last"](cmds);
    if (lastCmd.type === 'Z') {
        cmds[cmds.length - 1] = (_a = lastCmd
            .mutate()
            .setSvgChar('L')).setPoints.apply(_a, lastCmd.points).build();
    }
    // Reverse the commands.
    var newCmds = [];
    for (var i = cmds.length - 1; i > 0; i--) {
        newCmds.push(cmds[i]
            .mutate()
            .reverse()
            .build());
    }
    newCmds.unshift(cmds[0]
        .mutate()
        .setPoints(cmds[0].start, newCmds[0].start)
        .build());
    return newCmds;
}
/**
 * Returns a list of shifted commands.
 */
function shiftCommands(subPathState, cmds) {
    var _a;
    var shiftOffset = subPathState.getShiftOffset();
    if (!shiftOffset ||
        cmds.length === 1 ||
        !app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].arePointsEqual(lodash__WEBPACK_IMPORTED_MODULE_2__["first"](cmds).end, lodash__WEBPACK_IMPORTED_MODULE_2__["last"](cmds).end)) {
        // If there is no shift offset, the sub path is one command long,
        // or if the sub path is not closed, then do nothing.
        return cmds;
    }
    var numCommands = cmds.length;
    if (subPathState.isReversed()) {
        shiftOffset *= -1;
        shiftOffset += numCommands - 1;
    }
    // If the last command is a 'Z', replace it with a line before we shift.
    var lastCmd = lodash__WEBPACK_IMPORTED_MODULE_2__["last"](cmds);
    if (lastCmd.type === 'Z') {
        // TODO: replacing the 'Z' messes up certain stroke-linejoin values
        cmds[numCommands - 1] = (_a = lastCmd
            .mutate()
            .setSvgChar('L')).setPoints.apply(_a, lastCmd.points).build();
    }
    var newCmds = [];
    // Handle these case separately cause they are annoying and I'm sick of edge cases.
    if (shiftOffset === 1) {
        newCmds.push(cmds[0]
            .mutate()
            .setPoints(cmds[0].start, cmds[1].end)
            .build());
        for (var i = 2; i < cmds.length; i++) {
            newCmds.push(cmds[i]);
        }
        newCmds.push(cmds[1]);
        return newCmds;
    }
    else if (shiftOffset === numCommands - 1) {
        newCmds.push(cmds[0]
            .mutate()
            .setPoints(cmds[0].start, cmds[numCommands - 2].end)
            .build());
        newCmds.push(lodash__WEBPACK_IMPORTED_MODULE_2__["last"](cmds));
        for (var i = 1; i < cmds.length - 1; i++) {
            newCmds.push(cmds[i]);
        }
        return newCmds;
    }
    // Shift the sequence of commands. After the shift, the original move
    // command will be at index 'numCommands - shiftOffset'.
    for (var i = 0; i < numCommands; i++) {
        newCmds.push(cmds[(i + shiftOffset) % numCommands]);
    }
    // The first start point will either be undefined,
    // or the end point of the previous sub path.
    var prevMoveCmd = newCmds.splice(numCommands - shiftOffset, 1)[0];
    newCmds.push(newCmds.shift());
    newCmds.unshift(cmds[0]
        .mutate()
        .setPoints(prevMoveCmd.start, lodash__WEBPACK_IMPORTED_MODULE_2__["last"](newCmds).end)
        .build());
    return newCmds;
}
function LOG() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (ENABLE_LOGS) {
        var obj = args[0], objs = args.slice(1);
        // tslint:disable-next-line: no-console
        console.info.apply(console, [obj].concat(objs));
    }
}


/***/ }),

/***/ "./src/app/modules/editor/model/paths/PathParser.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/model/paths/PathParser.ts ***!
  \**********************************************************/
/*! exports provided: parseCommands, commandsToString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCommands", function() { return parseCommands; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commandsToString", function() { return commandsToString; });
/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Command */ "./src/app/modules/editor/model/paths/Command.ts");

/**
 * Takes an SVG path string (i.e. the text specified in the path's 'd' attribute) and returns
 * list of Commands that represent the SVG path's individual sequence of instructions.
 * Arcs are converted to bezier curves because they make life too complicated. :D
 */
function parseCommands(pathData) {
    if (!pathData) {
        pathData = '';
    }
    pathData = pathData.trim();
    var start = 0;
    var end = 1;
    var nodes = [];
    while (end < pathData.length) {
        end = nextStart(pathData, end);
        var s = pathData.substring(start, end).trim();
        if (s.length > 0) {
            var val = getFloats(s);
            nodes.push({ type: s.charAt(0), params: val });
        }
        start = end;
        end++;
    }
    if (end - start === 1 && start < pathData.length) {
        nodes.push({ type: pathData.charAt(start), params: [] });
    }
    var current = [0, 0, 0, 0, 0, 0];
    var previousCommand = 'm';
    var builder = new CommandsBuilder();
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var n = nodes_1[_i];
        addCommand(builder, current, previousCommand, n.type, n.params);
        previousCommand = n.type;
    }
    return builder.toCommands();
}
function nextStart(s, end) {
    while (end < s.length) {
        var c = s.charAt(end);
        // Note that 'e' or 'E' are not valid path commands, but could be used for floating
        // point numbers' scientific notation. Therefore, when searching for the next command,
        // we should ignore 'e' and 'E'.
        if ((('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')) && c !== 'E' && c !== 'e') {
            return end;
        }
        end++;
    }
    return end;
}
var ExtractFloatResult = /** @class */ (function () {
    function ExtractFloatResult() {
        this.mEndPosition = 0;
        this.mEndWithNegOrDot = false;
    }
    return ExtractFloatResult;
}());
function getFloats(s) {
    if (s.charAt(0) === 'z' || s.charAt(0) === 'Z') {
        return [];
    }
    var results = [];
    var startPosition = 1;
    var endPosition;
    var result = new ExtractFloatResult();
    var totalLength = s.length;
    while (startPosition < totalLength) {
        extract(s, startPosition, result);
        endPosition = result.mEndPosition;
        if (startPosition < endPosition) {
            results.push(parseFloat(s.substring(startPosition, endPosition)));
        }
        if (result.mEndWithNegOrDot) {
            startPosition = endPosition;
        }
        else {
            startPosition = endPosition + 1;
        }
    }
    return results;
}
/**
 * Calculate the position of the next comma or space or negative sign
 *
 * @param {string} s the string to search
 * @param {number} start the position to start searching
 * @param {ExtractFloatResult} result the result of the extraction, including the position of the the starting position
 * of next number, whether it is ending with a '-'.
 */
function extract(s, start, result) {
    var currentIndex = start;
    var foundSeparator = false;
    result.mEndWithNegOrDot = false;
    var secondDot = false;
    var isExponential = false;
    for (; currentIndex < s.length; currentIndex++) {
        var isPrevExponential = isExponential;
        isExponential = false;
        var currentChar = s.charAt(currentIndex);
        switch (currentChar) {
            case ' ':
            case ',':
                foundSeparator = true;
                break;
            case '-':
                if (currentIndex !== start && !isPrevExponential) {
                    foundSeparator = true;
                    result.mEndWithNegOrDot = true;
                }
                break;
            case '.':
                if (!secondDot) {
                    secondDot = true;
                }
                else {
                    foundSeparator = true;
                    result.mEndWithNegOrDot = true;
                }
                break;
            case 'e':
            case 'E':
                isExponential = true;
                break;
        }
        if (foundSeparator) {
            break;
        }
    }
    result.mEndPosition = currentIndex;
}
function addCommand(path, current, prevCmd, cmd, val) {
    var increment = 2;
    var currentX = current[0], currentY = current[1], ctrlPointX = current[2], ctrlPointY = current[3], currentSegmentStartX = current[4], currentSegmentStartY = current[5];
    var reflectiveCtrlPointX;
    var reflectiveCtrlPointY;
    switch (cmd) {
        case 'z':
        case 'Z':
            path.close();
            currentX = currentSegmentStartX;
            currentY = currentSegmentStartY;
            ctrlPointX = currentSegmentStartX;
            ctrlPointY = currentSegmentStartY;
            break;
        case 'm':
        case 'M':
        case 'l':
        case 'L':
        case 't':
        case 'T':
            increment = 2;
            break;
        case 'h':
        case 'H':
        case 'v':
        case 'V':
            increment = 1;
            break;
        case 'c':
        case 'C':
            increment = 6;
            break;
        case 's':
        case 'S':
        case 'q':
        case 'Q':
            increment = 4;
            break;
        case 'a':
        case 'A':
            increment = 7;
            break;
    }
    for (var k = 0; k < val.length; k += increment) {
        switch (cmd) {
            case 'm':
                currentX += val[k];
                currentY += val[k + 1];
                if (k > 0) {
                    path.rLineTo(val[k], val[k + 1]);
                }
                else {
                    path.rMoveTo(val[k], val[k + 1]);
                    currentSegmentStartX = currentX;
                    currentSegmentStartY = currentY;
                }
                break;
            case 'M':
                currentX = val[k];
                currentY = val[k + 1];
                if (k > 0) {
                    path.lineTo(val[k], val[k + 1]);
                }
                else {
                    path.moveTo(val[k], val[k + 1]);
                    currentSegmentStartX = currentX;
                    currentSegmentStartY = currentY;
                }
                break;
            case 'l':
                path.rLineTo(val[k], val[k + 1]);
                currentX += val[k];
                currentY += val[k + 1];
                break;
            case 'L':
                path.lineTo(val[k], val[k + 1]);
                currentX = val[k];
                currentY = val[k + 1];
                break;
            case 'h':
                path.rLineTo(val[k], 0);
                currentX += val[k];
                break;
            case 'H':
                path.lineTo(val[k], currentY);
                currentX = val[k];
                break;
            case 'v':
                path.rLineTo(0, val[k]);
                currentY += val[k];
                break;
            case 'V':
                path.lineTo(currentX, val[k]);
                currentY = val[k];
                break;
            case 'c':
                path.rCubicTo(val[k], val[k + 1], val[k + 2], val[k + 3], val[k + 4], val[k + 5]);
                ctrlPointX = currentX + val[k + 2];
                ctrlPointY = currentY + val[k + 3];
                currentX += val[k + 4];
                currentY += val[k + 5];
                break;
            case 'C':
                path.cubicTo(val[k], val[k + 1], val[k + 2], val[k + 3], val[k + 4], val[k + 5]);
                currentX = val[k + 4];
                currentY = val[k + 5];
                ctrlPointX = val[k + 2];
                ctrlPointY = val[k + 3];
                break;
            case 's':
                reflectiveCtrlPointX = 0;
                reflectiveCtrlPointY = 0;
                if (prevCmd === 'c' || prevCmd === 's' || prevCmd === 'C' || prevCmd === 'S') {
                    reflectiveCtrlPointX = currentX - ctrlPointX;
                    reflectiveCtrlPointY = currentY - ctrlPointY;
                }
                path.rCubicTo(reflectiveCtrlPointX, reflectiveCtrlPointY, val[k], val[k + 1], val[k + 2], val[k + 3]);
                ctrlPointX = currentX + val[k];
                ctrlPointY = currentY + val[k + 1];
                currentX += val[k + 2];
                currentY += val[k + 3];
                break;
            case 'S':
                reflectiveCtrlPointX = currentX;
                reflectiveCtrlPointY = currentY;
                if (prevCmd === 'c' || prevCmd === 's' || prevCmd === 'C' || prevCmd === 'S') {
                    reflectiveCtrlPointX = 2 * currentX - ctrlPointX;
                    reflectiveCtrlPointY = 2 * currentY - ctrlPointY;
                }
                path.cubicTo(reflectiveCtrlPointX, reflectiveCtrlPointY, val[k], val[k + 1], val[k + 2], val[k + 3]);
                ctrlPointX = val[k];
                ctrlPointY = val[k + 1];
                currentX = val[k + 2];
                currentY = val[k + 3];
                break;
            case 'q':
                path.rQuadTo(val[k], val[k + 1], val[k + 2], val[k + 3]);
                ctrlPointX = currentX + val[k];
                ctrlPointY = currentY + val[k + 1];
                currentX += val[k + 2];
                currentY += val[k + 3];
                break;
            case 'Q':
                path.quadTo(val[k], val[k + 1], val[k + 2], val[k + 3]);
                ctrlPointX = val[k];
                ctrlPointY = val[k + 1];
                currentX = val[k + 2];
                currentY = val[k + 3];
                break;
            case 't':
                reflectiveCtrlPointX = 0;
                reflectiveCtrlPointY = 0;
                if (prevCmd === 'q' || prevCmd === 't' || prevCmd === 'Q' || prevCmd === 'T') {
                    reflectiveCtrlPointX = currentX - ctrlPointX;
                    reflectiveCtrlPointY = currentY - ctrlPointY;
                }
                path.rQuadTo(reflectiveCtrlPointX, reflectiveCtrlPointY, val[k], val[k + 1]);
                ctrlPointX = currentX + reflectiveCtrlPointX;
                ctrlPointY = currentY + reflectiveCtrlPointY;
                currentX += val[k];
                currentY += val[k + 1];
                break;
            case 'T':
                reflectiveCtrlPointX = currentX;
                reflectiveCtrlPointY = currentY;
                if (prevCmd === 'q' || prevCmd === 't' || prevCmd === 'Q' || prevCmd === 'T') {
                    reflectiveCtrlPointX = 2 * currentX - ctrlPointX;
                    reflectiveCtrlPointY = 2 * currentY - ctrlPointY;
                }
                path.quadTo(reflectiveCtrlPointX, reflectiveCtrlPointY, val[k], val[k + 1]);
                ctrlPointX = reflectiveCtrlPointX;
                ctrlPointY = reflectiveCtrlPointY;
                currentX = val[k];
                currentY = val[k + 1];
                break;
            case 'a':
                drawArc(path, currentX, currentY, val[k + 5] + currentX, val[k + 6] + currentY, val[k], val[k + 1], val[k + 2], val[k + 3] !== 0, val[k + 4] !== 0);
                currentX += val[k + 5];
                currentY += val[k + 6];
                ctrlPointX = currentX;
                ctrlPointY = currentY;
                break;
            case 'A':
                drawArc(path, currentX, currentY, val[k + 5], val[k + 6], val[k], val[k + 1], val[k + 2], val[k + 3] !== 0, val[k + 4] !== 0);
                currentX = val[k + 5];
                currentY = val[k + 6];
                ctrlPointX = currentX;
                ctrlPointY = currentY;
                break;
        }
        prevCmd = cmd;
    }
    current[0] = currentX;
    current[1] = currentY;
    current[2] = ctrlPointX;
    current[3] = ctrlPointY;
    current[4] = currentSegmentStartX;
    current[5] = currentSegmentStartY;
}
function drawArc(p, x0, y0, x1, y1, a, b, theta, isMoreThanHalf, isPositiveArc) {
    var thetaD = (theta * Math.PI) / 180;
    var cosTheta = Math.cos(thetaD);
    var sinTheta = Math.sin(thetaD);
    var x0p = (x0 * cosTheta + y0 * sinTheta) / a;
    var y0p = (-x0 * sinTheta + y0 * cosTheta) / b;
    var x1p = (x1 * cosTheta + y1 * sinTheta) / a;
    var y1p = (-x1 * sinTheta + y1 * cosTheta) / b;
    var dx = x0p - x1p;
    var dy = y0p - y1p;
    var xm = (x0p + x1p) / 2;
    var ym = (y0p + y1p) / 2;
    var dsq = dx * dx + dy * dy;
    if (dsq === 0.0) {
        return;
    }
    var disc = 1.0 / dsq - 1.0 / 4.0;
    if (disc < 0.0) {
        var adjust = Math.sqrt(dsq) / 1.99999;
        drawArc(p, x0, y0, x1, y1, a * adjust, b * adjust, theta, isMoreThanHalf, isPositiveArc);
        return;
    }
    var s = Math.sqrt(disc);
    var sdx = s * dx;
    var sdy = s * dy;
    var cx;
    var cy;
    if (isMoreThanHalf === isPositiveArc) {
        cx = xm - sdy;
        cy = ym + sdx;
    }
    else {
        cx = xm + sdy;
        cy = ym - sdx;
    }
    var eta0 = Math.atan2(y0p - cy, x0p - cx);
    var eta1 = Math.atan2(y1p - cy, x1p - cx);
    var sweep = eta1 - eta0;
    if (isPositiveArc !== sweep >= 0) {
        if (sweep > 0) {
            sweep -= 2 * Math.PI;
        }
        else {
            sweep += 2 * Math.PI;
        }
    }
    cx *= a;
    cy *= b;
    var tcx = cx;
    cx = cx * cosTheta - cy * sinTheta;
    cy = tcx * sinTheta + cy * cosTheta;
    arcToBezier(p, cx, cy, a, b, x0, y0, thetaD, eta0, sweep);
}
/**
 * Converts an arc to cubic Bezier segments and records them in p.
 *
 * @param {CommandsBuilder} p The target for the cubic Bezier segments
 * @param {number} cx The x coordinate center of the ellipse
 * @param {number} cy The y coordinate center of the ellipse
 * @param {number} a The radius of the ellipse in the horizontal direction
 * @param {number} b The radius of the ellipse in the vertical direction
 * @param {number} e1x E(eta1) x coordinate of the starting point of the arc
 * @param {number} e1y E(eta2) y coordinate of the starting point of the arc
 * @param {number} theta The angle that the ellipse bounding rectangle makes with horizontal plane
 * @param {number} start The start angle of the arc on the ellipse
 * @param {number} sweep The angle (positive or negative) of the sweep of the arc on the ellipse
 */
function arcToBezier(p, cx, cy, a, b, e1x, e1y, theta, start, sweep) {
    var numSegments = Math.trunc(Math.ceil(Math.abs((sweep * 4) / Math.PI)));
    var eta1 = start;
    var cosTheta = Math.cos(theta);
    var sinTheta = Math.sin(theta);
    var cosEta1 = Math.cos(eta1);
    var sinEta1 = Math.sin(eta1);
    var ep1x = -a * cosTheta * sinEta1 - b * sinTheta * cosEta1;
    var ep1y = -a * sinTheta * sinEta1 + b * cosTheta * cosEta1;
    var anglePerSegment = sweep / numSegments;
    for (var i = 0; i < numSegments; i++) {
        var eta2 = eta1 + anglePerSegment;
        var sinEta2 = Math.sin(eta2);
        var cosEta2 = Math.cos(eta2);
        var e2x = cx + a * cosTheta * cosEta2 - b * sinTheta * sinEta2;
        var e2y = cy + a * sinTheta * cosEta2 + b * cosTheta * sinEta2;
        var ep2x = -a * cosTheta * sinEta2 - b * sinTheta * cosEta2;
        var ep2y = -a * sinTheta * sinEta2 + b * cosTheta * cosEta2;
        var tanDiff2 = Math.tan((eta2 - eta1) / 2);
        var alpha = (Math.sin(eta2 - eta1) * (Math.sqrt(4 + 3 * tanDiff2 * tanDiff2) - 1)) / 3;
        var q1x = e1x + alpha * ep1x;
        var q1y = e1y + alpha * ep1y;
        var q2x = e2x - alpha * ep2x;
        var q2y = e2y - alpha * ep2y;
        p.cubicTo(q1x, q1y, q2x, q2y, e2x, e2y);
        eta1 = eta2;
        e1x = e2x;
        e1y = e2y;
        ep1x = ep2x;
        ep1y = ep2y;
    }
}
var CommandsBuilder = /** @class */ (function () {
    function CommandsBuilder() {
        this.commands = [];
        this.currentSegmentStartX = 0;
        this.currentSegmentStartY = 0;
        this.currentX = 0;
        this.currentY = 0;
    }
    CommandsBuilder.prototype.rMoveTo = function (ri0, ri1) {
        var i0 = this.currentX + ri0;
        var i1 = this.currentY + ri1;
        this.moveTo(i0, i1);
    };
    CommandsBuilder.prototype.moveTo = function (i0, i1) {
        var start = this.commands.length ? { x: this.currentX, y: this.currentY } : undefined;
        var end = { x: i0, y: i1 };
        this.commands.push(newMove(start, end));
        this.currentSegmentStartX = i0;
        this.currentSegmentStartY = i1;
        this.currentX = i0;
        this.currentY = i1;
    };
    CommandsBuilder.prototype.rLineTo = function (ri0, ri1) {
        var i0 = this.currentX + ri0;
        var i1 = this.currentY + ri1;
        this.lineTo(i0, i1);
    };
    CommandsBuilder.prototype.lineTo = function (i0, i1) {
        var start = { x: this.currentX, y: this.currentY };
        var end = { x: i0, y: i1 };
        this.commands.push(newLine(start, end));
        this.currentX = i0;
        this.currentY = i1;
    };
    CommandsBuilder.prototype.rQuadTo = function (ri0, ri1, ri2, ri3) {
        var i0 = this.currentX + ri0;
        var i1 = this.currentY + ri1;
        var i2 = this.currentX + ri2;
        var i3 = this.currentY + ri3;
        this.quadTo(i0, i1, i2, i3);
    };
    CommandsBuilder.prototype.quadTo = function (i0, i1, i2, i3) {
        var start = { x: this.currentX, y: this.currentY };
        var cp = { x: i0, y: i1 };
        var end = { x: i2, y: i3 };
        this.commands.push(newQuadraticCurve(start, cp, end));
        this.currentX = i2;
        this.currentY = i3;
    };
    CommandsBuilder.prototype.rCubicTo = function (ri0, ri1, ri2, ri3, ri4, ri5) {
        var i0 = this.currentX + ri0;
        var i1 = this.currentY + ri1;
        var i2 = this.currentX + ri2;
        var i3 = this.currentY + ri3;
        var i4 = this.currentX + ri4;
        var i5 = this.currentY + ri5;
        this.cubicTo(i0, i1, i2, i3, i4, i5);
    };
    CommandsBuilder.prototype.cubicTo = function (i0, i1, i2, i3, i4, i5) {
        var start = { x: this.currentX, y: this.currentY };
        var cp1 = { x: i0, y: i1 };
        var cp2 = { x: i2, y: i3 };
        var end = { x: i4, y: i5 };
        this.commands.push(newBezierCurve(start, cp1, cp2, end));
        this.currentX = i4;
        this.currentY = i5;
    };
    CommandsBuilder.prototype.close = function () {
        var start = { x: this.currentX, y: this.currentY };
        var end = { x: this.currentSegmentStartX, y: this.currentSegmentStartY };
        this.commands.push(newClosePath(start, end));
        this.currentX = this.currentSegmentStartX;
        this.currentY = this.currentSegmentStartY;
    };
    CommandsBuilder.prototype.toCommands = function () {
        return this.commands;
    };
    return CommandsBuilder;
}());
/** Takes an list of Commands and converts them back into a SVG path string. */
function commandsToString(commands) {
    var tokens = [];
    commands.forEach(function (cmd) {
        tokens.push(cmd.type);
        var isClosePathCommand = cmd.type === 'Z';
        var pointsToNumberListFunc = function () {
            var points = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                points[_i] = arguments[_i];
            }
            return points.reduce(function (list, p) { return list.concat([p.x, p.y]); }, []);
        };
        var args = pointsToNumberListFunc.apply(void 0, (isClosePathCommand ? [] : cmd.points.slice(1)));
        tokens.splice.apply(tokens, [tokens.length, 0].concat(args.map(function (n) { return Number(n.toFixed(3)).toString(); })));
    });
    return tokens.join(' ');
}
function newMove(start, end) {
    return new _Command__WEBPACK_IMPORTED_MODULE_0__["Command"]('M', [start, end]);
}
function newLine(start, end) {
    return new _Command__WEBPACK_IMPORTED_MODULE_0__["Command"]('L', [start, end]);
}
function newQuadraticCurve(start, cp, end) {
    return new _Command__WEBPACK_IMPORTED_MODULE_0__["Command"]('Q', [start, cp, end]);
}
function newBezierCurve(start, cp1, cp2, end) {
    return new _Command__WEBPACK_IMPORTED_MODULE_0__["Command"]('C', [start, cp1, cp2, end]);
}
function newClosePath(start, end) {
    return new _Command__WEBPACK_IMPORTED_MODULE_0__["Command"]('Z', [start, end]);
}


/***/ }),

/***/ "./src/app/modules/editor/model/paths/PathState.ts":
/*!*********************************************************!*\
  !*** ./src/app/modules/editor/model/paths/PathState.ts ***!
  \*********************************************************/
/*! exports provided: PathState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PathState", function() { return PathState; });
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var polylabel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! polylabel */ "./node_modules/polylabel/polylabel.js");
/* harmony import */ var polylabel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(polylabel__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _CommandState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CommandState */ "./src/app/modules/editor/model/paths/CommandState.ts");
/* harmony import */ var _PathParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PathParser */ "./src/app/modules/editor/model/paths/PathParser.ts");
/* harmony import */ var _SubPath__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SubPath */ "./src/app/modules/editor/model/paths/SubPath.ts");
/* harmony import */ var _SubPathState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SubPathState */ "./src/app/modules/editor/model/paths/SubPathState.ts");







/**
 * Container class that encapsulates a Path's underlying state.
 */
var PathState = /** @class */ (function () {
    function PathState(obj, 
    // Maps internal spsIdx indices to SubPathState objects. The last 'numCollapsingSubPaths'
    // indices hold references to the collapsing sub paths.
    subPathStateMap, 
    // Maps client-visible subIdx values to their positions in the subPathStateMap.
    subPathOrdering, 
    // The number of collapsing subpaths appended to the end of the subPathStateMap.
    numCollapsingSubPaths) {
        if (numCollapsingSubPaths === void 0) { numCollapsingSubPaths = 0; }
        var _this = this;
        this.subPathStateMap = subPathStateMap;
        this.subPathOrdering = subPathOrdering;
        this.numCollapsingSubPaths = numCollapsingSubPaths;
        var commands = typeof obj === 'string' ? _PathParser__WEBPACK_IMPORTED_MODULE_4__["parseCommands"](obj) : obj;
        var subPaths = Object(_SubPath__WEBPACK_IMPORTED_MODULE_5__["createSubPaths"])(commands);
        this.subPathStateMap =
            subPathStateMap ||
                subPaths.map(function (s) { return new _SubPathState__WEBPACK_IMPORTED_MODULE_6__["SubPathState"](s.getCommands().map(function (c) { return new _CommandState__WEBPACK_IMPORTED_MODULE_3__["CommandState"](c); })); });
        this.subPathOrdering = subPathOrdering || subPaths.map(function (unused, i) { return i; });
        this.subPaths = subPaths.map(function (subPath, subIdx) {
            var cmds = subPath.getCommands().map(function (cmd, cmdIdx) {
                var _a = _this.findCommandStateInfo(subIdx, cmdIdx), cs = _a.cs, splitIdx = _a.splitIdx;
                return cmd
                    .mutate()
                    .setId(cs.getIdAtIndex(splitIdx))
                    .build();
            });
            var spsIdx = _this.subPathOrdering[subIdx];
            var isCollapsing = _this.subPathOrdering.length - _this.numCollapsingSubPaths <= spsIdx;
            var sps = _this.findSubPathState(subIdx);
            var isSplit = isSubPathSplit(_this.subPathStateMap, spsIdx);
            var isUnsplittable = !_this.subPathStateMap.includes(sps);
            return subPath
                .mutate()
                .setId(sps.getId())
                .setCommands(cmds)
                .setIsCollapsing(isCollapsing)
                .setIsReversed(sps.isReversed())
                .setShiftOffset(sps.getShiftOffset())
                .setIsSplit(isSplit)
                .setIsUnsplittable(isUnsplittable)
                .build();
        });
        this.commands = lodash__WEBPACK_IMPORTED_MODULE_1__["flatMap"](this.subPaths, function (subPath) { return subPath.getCommands(); });
    }
    PathState.prototype.getPathLength = function () {
        var length = 0;
        for (var i = 0; i < this.subPathStateMap.length; i++) {
            length += this.getSubPathLength(i);
        }
        return length;
    };
    PathState.prototype.getSubPathLength = function (subIdx) {
        var sps = this.findSubPathState(subIdx);
        return lodash__WEBPACK_IMPORTED_MODULE_1__["sumBy"](sps.getCommandStates(), function (cs) { return cs.getPathLength(); });
    };
    PathState.prototype.getPointAtLength = function (distance) {
        var _this = this;
        var spss = this.subPathStateMap.map(function (unused, i) { return _this.findSubPathState(i); });
        var length = 0;
        for (var _i = 0, spss_1 = spss; _i < spss_1.length; _i++) {
            var sps = spss_1[_i];
            for (var _a = 0, _b = sps.getCommandStates(); _a < _b.length; _a++) {
                var cs = _b[_a];
                var len = cs.getPathLength();
                if (length <= distance && distance < length + len) {
                    return cs.getPointAtLength(distance - length);
                }
                length += len;
            }
        }
        return undefined;
    };
    PathState.prototype.project = function (point, restrictToSubIdx) {
        var _this = this;
        var minProjectionResultInfo = lodash__WEBPACK_IMPORTED_MODULE_1__(this.subPaths)
            .map(function (subPath, subIdx) { return ({ subPath: subPath, subIdx: subIdx }); })
            .filter(function (_a) {
            var subPath = _a.subPath, subIdx = _a.subIdx;
            return !subPath.isCollapsing() &&
                (restrictToSubIdx === undefined || restrictToSubIdx === subIdx);
        })
            .map(function (obj) {
            var subIdx = obj.subIdx;
            var sps = _this.findSubPathState(subIdx);
            return sps.getCommandStates().map(function (cs, csIdx) {
                var csProjection = cs.project(point);
                if (csProjection && sps.isReversed()) {
                    var t = csProjection.projection.t;
                    csProjection.projection.t = 1 - t;
                }
                return {
                    spsIdx: _this.subPathOrdering[subIdx],
                    csIdx: csIdx,
                    splitIdx: csProjection ? csProjection.splitIdx : 0,
                    projection: csProjection ? csProjection.projection : undefined,
                };
            });
        })
            .flatMap(function (projections) { return projections; })
            .filter(function (obj) { return !!obj.projection; })
            // Reverse so that commands drawn with higher z-orders are preferred.
            .reverse()
            .reduce(function (prev, curr) {
            return prev && prev.projection.d < curr.projection.d ? prev : curr;
        }, undefined);
        if (!minProjectionResultInfo) {
            return undefined;
        }
        var spsIdx = minProjectionResultInfo.spsIdx, splitIdx = minProjectionResultInfo.splitIdx, projection = minProjectionResultInfo.projection;
        var cmdIdx = this.toCmdIdx(spsIdx, minProjectionResultInfo.csIdx, splitIdx);
        return { projection: projection, subIdx: this.subPathOrdering.indexOf(spsIdx), cmdIdx: cmdIdx };
    };
    PathState.prototype.hitTest = function (point, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var endPointHits = [];
        var segmentHits = [];
        var shapeHits = [];
        var defaultRestrictToSubIdx = this.subPaths.map(function (unused, i) { return i; });
        var restrictToSubIdxSet = new Set(opts.restrictToSubIdx || defaultRestrictToSubIdx);
        if (opts.isPointInRangeFn) {
            endPointHits.push.apply(endPointHits, lodash__WEBPACK_IMPORTED_MODULE_1__(this.subPaths)
                .map(function (subPath, subIdx) { return ({ subPath: subPath, subIdx: subIdx }); })
                .filter(function (obj) {
                var subPath = obj.subPath, subIdx = obj.subIdx;
                return !subPath.isCollapsing() && restrictToSubIdxSet.has(subIdx);
            })
                .map(function (obj) {
                var subPath = obj.subPath, subIdx = obj.subIdx;
                return subPath.getCommands().map(function (cmd, cmdIdx) {
                    var _a = cmd.end, x = _a.x, y = _a.y;
                    var d = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].distance(cmd.end, point);
                    var t = 1;
                    var projection = { x: x, y: y, d: d, t: t };
                    return { subIdx: subIdx, cmdIdx: cmdIdx, projection: projection, cmd: cmd };
                });
            })
                .flatMap(function (pointInfos) { return pointInfos; })
                .filter(function (pointInfo) { return opts.isPointInRangeFn(pointInfo.projection.d, pointInfo.cmd); })
                .map(function (pointInfo) {
                var subIdx = pointInfo.subIdx, cmdIdx = pointInfo.cmdIdx, projection = pointInfo.projection;
                return { subIdx: subIdx, cmdIdx: cmdIdx, projection: projection };
            })
                .value());
        }
        if (opts.isSegmentInRangeFn) {
            // TODO: also check to see if the hit occurred at a stroke-linejoin vertex
            // TODO: take stroke width scaling into account as well?
            segmentHits.push.apply(segmentHits, lodash__WEBPACK_IMPORTED_MODULE_1__(this.subPaths)
                .map(function (subPath, subIdx) { return ({ subPath: subPath, subIdx: subIdx }); })
                .filter(function (obj) {
                var subPath = obj.subPath, subIdx = obj.subIdx;
                return !subPath.isCollapsing() && restrictToSubIdxSet.has(subIdx);
            })
                .flatMap(function (obj) {
                var subIdx = obj.subIdx;
                var spsIdx = _this.subPathOrdering[subIdx];
                var sps = _this.findSubPathState(subIdx);
                // We iterate by csIdx here to improve performance (since cmdIdx
                // values can be split points).
                return lodash__WEBPACK_IMPORTED_MODULE_1__["flatMap"](sps.getCommandStates(), function (cs, csIdx) {
                    var projectionWithSplitIdx = cs.project(point);
                    if (!projectionWithSplitIdx) {
                        return [];
                    }
                    var projection = projectionWithSplitIdx.projection, splitIdx = projectionWithSplitIdx.splitIdx;
                    if (sps.isReversed()) {
                        projection.t = 1 - projection.t;
                    }
                    var cmdIdx = _this.toCmdIdx(spsIdx, csIdx, splitIdx);
                    return [{ subIdx: subIdx, cmdIdx: cmdIdx, projection: projection }];
                });
            })
                .filter(function (obj) {
                var cmd = _this.subPaths[obj.subIdx].getCommands()[obj.cmdIdx];
                return opts.isSegmentInRangeFn(obj.projection.d, cmd);
            })
                .value());
        }
        if (opts.findShapesInRange) {
            shapeHits.push.apply(shapeHits, lodash__WEBPACK_IMPORTED_MODULE_1__(this.subPaths)
                .map(function (subPath, subIdx) { return ({ subPath: subPath, subIdx: subIdx }); })
                .filter(function (obj) {
                var subPath = obj.subPath, subIdx = obj.subIdx;
                return subPath.isClosed() && !subPath.isCollapsing() && restrictToSubIdxSet.has(subIdx);
            })
                .flatMap(function (obj) {
                var subIdx = obj.subIdx;
                var css = _this.findSubPathState(subIdx).getCommandStates();
                var bounds = createBoundingBox(css);
                if (!containsPoint(bounds, point)) {
                    // Nothing to see here. Check the next subpath.
                    return [];
                }
                // The point is inside the subpath's bounding box, so next, we will
                // use the 'even-odd rule' to determine if the filled path has been hit.
                // We create a line from the mouse point to a point we know that is not
                // inside the path (in this case, we use a coordinate outside the path's
                // bounded box). A hit has occured if and only if the number of
                // intersections between the line and the path is odd.
                var line = { p1: point, p2: { x: bounds.r + 1, y: bounds.b + 1 } };
                var intersectionResults = css.map(function (cs) { return cs.intersects(line); });
                var numIntersections = lodash__WEBPACK_IMPORTED_MODULE_1__["sumBy"](intersectionResults, function (ts) { return ts.length; });
                if (numIntersections % 2 === 0) {
                    // Nothing to see here. Check the next subpath.
                    return [];
                }
                return [{ subIdx: subIdx }];
            })
                .value());
        }
        var isEndPointHit = !!endPointHits.length;
        var isSegmentHit = !!segmentHits.length;
        var isShapeHit = !!shapeHits.length;
        var isHit = isEndPointHit || isSegmentHit || isShapeHit;
        return {
            isHit: isHit,
            isEndPointHit: isEndPointHit,
            isSegmentHit: isSegmentHit,
            isShapeHit: isShapeHit,
            endPointHits: endPointHits,
            segmentHits: segmentHits,
            shapeHits: shapeHits,
        };
    };
    // TODO: move this math stuff into the calculators module
    // TODO: approximate bezier curves by splitting them up into line segments
    // TODO: write tests for this stuff
    PathState.prototype.getPoleOfInaccessibility = function (subIdx) {
        var subPathCmds = this.subPaths[subIdx].getCommands();
        if (subPathCmds.length === 1) {
            var end = subPathCmds[0].end;
            return { x: end.x, y: end.y };
        }
        var cmds = subPathCmds.slice(1);
        var polygon = lodash__WEBPACK_IMPORTED_MODULE_1__["flatMap"](cmds, function (cmd) {
            var _a = cmd.start, p1x = _a.x, p1y = _a.y;
            var _b = cmd.end, p2x = _b.x, p2y = _b.y;
            return [[p1x, p1y], [p2x, p2y]];
        });
        if (cmds.length && !this.subPaths[subIdx].isClosed()) {
            var _a = cmds[0].start, p1x = _a.x, p1y = _a.y;
            var _b = lodash__WEBPACK_IMPORTED_MODULE_1__["last"](cmds).end, p2x = _b.x, p2y = _b.y;
            polygon.push.apply(polygon, [[p1x, p1y], [p2x, p2y]]);
        }
        var pole = polylabel__WEBPACK_IMPORTED_MODULE_2___default()([polygon]);
        return { x: pole[0], y: pole[1] };
    };
    // TODO: cache this?
    PathState.prototype.getBoundingBox = function () {
        var css = lodash__WEBPACK_IMPORTED_MODULE_1__["flatMap"](this.subPathStateMap, function (sps) { return sps.getCommandStates(); });
        return createBoundingBox(css);
    };
    PathState.prototype.isClockwise = function (subIdx) {
        var cmds = this.subPaths[subIdx].getCommands();
        return lodash__WEBPACK_IMPORTED_MODULE_1__["sumBy"](cmds, function (cmd) { return getArea(cmd); }) >= 0;
    };
    PathState.prototype.findSubPathState = function (subIdx) {
        return Object(_SubPathState__WEBPACK_IMPORTED_MODULE_6__["findSubPathState"])(this.subPathStateMap, this.subPathOrdering[subIdx]);
    };
    PathState.prototype.findCommandStateInfo = function (subIdx, cmdIdx) {
        var sps = this.findSubPathState(subIdx);
        var numCommandsInSubPath = lodash__WEBPACK_IMPORTED_MODULE_1__["sumBy"](sps.getCommandStates(), function (cs) { return cs.getCommands().length; });
        if (cmdIdx && sps.isReversed()) {
            cmdIdx = numCommandsInSubPath - cmdIdx;
        }
        cmdIdx += sps.getShiftOffset();
        if (cmdIdx >= numCommandsInSubPath) {
            // Note that subtracting numCommandsInSubPath is intentional here
            // (as opposed to subtracting numCommandsInSubPath - 1).
            cmdIdx -= numCommandsInSubPath;
        }
        var counter = 0;
        for (var _i = 0, _a = sps.getCommandStates(); _i < _a.length; _i++) {
            var cs = _a[_i];
            if (counter + cs.getCommands().length > cmdIdx) {
                return { sps: sps, cs: cs, splitIdx: cmdIdx - counter };
            }
            counter += cs.getCommands().length;
        }
        throw new Error('Error retrieving command mutation');
    };
    PathState.prototype.toCmdIdx = function (spsIdx, csIdx, splitIdx) {
        var sps = this.findSubPathState(this.subPathOrdering.indexOf(spsIdx));
        var commandStates = sps.getCommandStates();
        var numCmds = lodash__WEBPACK_IMPORTED_MODULE_1__["sumBy"](commandStates, function (cs) { return cs.getCommands().length; });
        var cmdIdx = splitIdx + lodash__WEBPACK_IMPORTED_MODULE_1__["sum"](commandStates.map(function (cs, i) { return (i < csIdx ? cs.getCommands().length : 0); }));
        var shiftOffset = sps.getShiftOffset();
        if (sps.isReversed()) {
            cmdIdx = numCmds - cmdIdx;
            shiftOffset *= -1;
            shiftOffset += numCmds - 1;
        }
        if (shiftOffset) {
            cmdIdx += numCmds - shiftOffset - 1;
            if (cmdIdx >= numCmds) {
                cmdIdx = cmdIdx - numCmds + 1;
            }
        }
        return cmdIdx;
    };
    return PathState;
}());

// TODO: cache this?
function createBoundingBox(css) {
    var bounds = { l: Infinity, t: Infinity, r: -Infinity, b: -Infinity };
    var expandBoundsFn = function (x, y) {
        if (isNaN(x) || isNaN(y)) {
            return;
        }
        bounds.l = Math.min(x, bounds.l);
        bounds.t = Math.min(y, bounds.t);
        bounds.r = Math.max(x, bounds.r);
        bounds.b = Math.max(y, bounds.b);
    };
    var expandBoundsForCommandMutationFn = function (cs) {
        var bbox = cs.getBoundingBox();
        expandBoundsFn(bbox.x.min, bbox.y.min);
        expandBoundsFn(bbox.x.max, bbox.y.min);
        expandBoundsFn(bbox.x.min, bbox.y.max);
        expandBoundsFn(bbox.x.max, bbox.y.max);
    };
    css.forEach(function (cs) { return expandBoundsForCommandMutationFn(cs); });
    return bounds;
}
function isSubPathSplit(map, spsIdx) {
    return !!Object(_SubPathState__WEBPACK_IMPORTED_MODULE_6__["findSubPathState"])(map, spsIdx).getSplitSubPaths().length;
}
function containsPoint(rect, p) {
    return rect.l <= p.x && p.x < rect.r && rect.t <= p.y && p.y < rect.b;
}
function getArea(cmd) {
    if (cmd.type === 'M') {
        return 0;
    }
    var _a = cmd.start, x0 = _a.x, y0 = _a.y;
    var _b = cmd.end, x3 = _b.x, y3 = _b.y;
    var area = 0;
    switch (cmd.type) {
        case 'L':
        case 'Z':
            area = (x3 - x0) * (y3 - y0);
            break;
        case 'Q':
        case 'C':
            var x1 = void 0;
            var y1 = void 0;
            var x2 = void 0;
            var y2 = void 0;
            if (cmd.type === 'Q') {
                var cp = cmd.points[1];
                x1 = x0 + (2 / 3) * (cp.x - x0);
                y1 = y0 + (2 / 3) * (cp.y - y0);
                x2 = x3 + (2 / 3) * (cp.x - x3);
                y2 = y3 + (2 / 3) * (cp.y - y3);
            }
            else {
                x1 = cmd.points[1].x;
                y1 = cmd.points[1].y;
                x2 = cmd.points[2].x;
                y2 = cmd.points[2].y;
            }
            area =
                (3 *
                    ((y3 - y0) * (x1 + x2) -
                        (x3 - x0) * (y1 + y2) +
                        y1 * (x0 - x2) -
                        x1 * (y0 - y2) +
                        y3 * (x2 + x0 / 3) -
                        x3 * (y2 + y0 / 3))) /
                    20;
            break;
    }
    return area;
}


/***/ }),

/***/ "./src/app/modules/editor/model/paths/PathUtil.ts":
/*!********************************************************!*\
  !*** ./src/app/modules/editor/model/paths/PathUtil.ts ***!
  \********************************************************/
/*! exports provided: interpolate, sortPathOps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return interpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortPathOps", function() { return sortPathOps; });
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Command */ "./src/app/modules/editor/model/paths/Command.ts");
/* harmony import */ var _Path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Path */ "./src/app/modules/editor/model/paths/Path.ts");



/**
 * Interpolates between a start and end path using the specified fraction.
 *
 * TODO: make it possible to create 'stateless' paths (to save memory on animation frames).
 */
function interpolate(start, end, fraction) {
    if (!start.isMorphableWith(end)) {
        throw new Error('Attempt to interpolate two unmorphable paths');
    }
    var newCommands = [];
    start.getCommands().forEach(function (startCmd, i) {
        var endCmd = end.getCommands()[i];
        var points = [];
        for (var j = 0; j < startCmd.points.length; j++) {
            var p1 = startCmd.points[j];
            var p2 = endCmd.points[j];
            if (p1 && p2) {
                // The 'start' point of the first Move command in a path
                // will be undefined. Skip it.
                var px = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].lerp(p1.x, p2.x, fraction);
                var py = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].lerp(p1.y, p2.y, fraction);
                points.push({ x: px, y: py });
            }
            else {
                points.push(undefined);
            }
        }
        // TODO: avoid re-generating unique ids on each animation frame.
        newCommands.push(new _Command__WEBPACK_IMPORTED_MODULE_1__["Command"](startCmd.type, points));
    });
    return new _Path__WEBPACK_IMPORTED_MODULE_2__["Path"](newCommands);
}
/**
 * Sorts a list of path ops in descending order.
 */
function sortPathOps(ops) {
    return ops.sort(function (_a, _b) {
        var s1 = _a.subIdx, c1 = _a.cmdIdx;
        var s2 = _b.subIdx, c2 = _b.cmdIdx;
        // Perform higher index splits first so that we don't alter the
        // indices of the lower index split operations.
        return s1 !== s2 ? s2 - s1 : c2 - c1;
    });
}


/***/ }),

/***/ "./src/app/modules/editor/model/paths/SubPath.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/model/paths/SubPath.ts ***!
  \*******************************************************/
/*! exports provided: SubPath, createSubPaths, SubPathBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubPath", function() { return SubPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSubPaths", function() { return createSubPaths; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubPathBuilder", function() { return SubPathBuilder; });
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);


/**
 * Represents a string of Commands, beginning with a 'moveTo' command and ending
 * with either a 'closepath' command or the next 'moveTo' command.
 */
var SubPath = /** @class */ (function () {
    function SubPath(commands, id, isCollapsing_, isReversed_, shiftOffset, isSplit_, isUnsplittable_) {
        if (id === void 0) { id = lodash__WEBPACK_IMPORTED_MODULE_1__["uniqueId"](); }
        if (isCollapsing_ === void 0) { isCollapsing_ = false; }
        if (isReversed_ === void 0) { isReversed_ = false; }
        if (shiftOffset === void 0) { shiftOffset = 0; }
        if (isSplit_ === void 0) { isSplit_ = false; }
        if (isUnsplittable_ === void 0) { isUnsplittable_ = false; }
        this.commands = commands;
        this.id = id;
        this.isCollapsing_ = isCollapsing_;
        this.isReversed_ = isReversed_;
        this.shiftOffset = shiftOffset;
        this.isSplit_ = isSplit_;
        this.isUnsplittable_ = isUnsplittable_;
    }
    /**
     * Returns a unique ID for this subpath.
     */
    SubPath.prototype.getId = function () {
        return this.id;
    };
    /**
     * The list of commands in this subpath.
     */
    SubPath.prototype.getCommands = function () {
        return this.commands;
    };
    /**
     * Returns true iff this sub path was created to collapse to a single point.
     */
    SubPath.prototype.isCollapsing = function () {
        return this.isCollapsing_;
    };
    /**
     * Returns true iff this sub path has been reversed.
     */
    SubPath.prototype.isReversed = function () {
        return this.isReversed_;
    };
    /**
     * Returns the shift offset of this sub path.
     */
    SubPath.prototype.getShiftOffset = function () {
        return this.shiftOffset;
    };
    /**
     * Returns true iff this sub path was created as a result of a split.
     */
    SubPath.prototype.isSplit = function () {
        return this.isSplit_;
    };
    /**
     * Returns true iff this sub path can be unsplit.
     */
    SubPath.prototype.isUnsplittable = function () {
        return this.isUnsplittable_;
    };
    /**
     * Returns true iff the sub path's start point is equal to its end point.
     */
    SubPath.prototype.isClosed = function () {
        var start = lodash__WEBPACK_IMPORTED_MODULE_1__["first"](this.getCommands()).end;
        var end = lodash__WEBPACK_IMPORTED_MODULE_1__["last"](this.getCommands()).end;
        return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].arePointsEqual(start, end);
    };
    /**
     * Returns a builder to construct a mutated SubPath.
     */
    SubPath.prototype.mutate = function () {
        return new SubPathBuilder(this.commands, this.id, this.isCollapsing_, this.isReversed_, this.shiftOffset, this.isSplit_, this.isUnsplittable_);
    };
    return SubPath;
}());

function createSubPaths(commands) {
    if (!commands.length || commands[0].type !== 'M') {
        // TODO: is this case actually possible? should we insert 'M 0 0' instead?
        return [];
    }
    var currentCmdList = [];
    var lastSeenMove;
    var subPathCmds = [];
    for (var _i = 0, commands_1 = commands; _i < commands_1.length; _i++) {
        var cmd = commands_1[_i];
        if (cmd.type === 'M') {
            lastSeenMove = cmd;
            if (currentCmdList.length) {
                subPathCmds.push(new SubPath(currentCmdList));
                currentCmdList = [];
            }
            else {
                currentCmdList.push(cmd);
            }
            continue;
        }
        if (!currentCmdList.length) {
            currentCmdList.push(lastSeenMove
                .mutate()
                .setId(lodash__WEBPACK_IMPORTED_MODULE_1__["uniqueId"]())
                .build());
        }
        currentCmdList.push(cmd);
        if (cmd.type === 'Z') {
            subPathCmds.push(new SubPath(currentCmdList));
            currentCmdList = [];
        }
    }
    if (currentCmdList.length) {
        subPathCmds.push(new SubPath(currentCmdList));
    }
    return subPathCmds;
}
var SubPathBuilder = /** @class */ (function () {
    function SubPathBuilder(commands, id, isCollapsing, isReversed, shiftOffset, isSplit, isUnsplittable) {
        this.commands = commands;
        this.id = id;
        this.isCollapsing = isCollapsing;
        this.isReversed = isReversed;
        this.shiftOffset = shiftOffset;
        this.isSplit = isSplit;
        this.isUnsplittable = isUnsplittable;
    }
    SubPathBuilder.prototype.setCommands = function (commands) {
        this.commands = commands;
        return this;
    };
    SubPathBuilder.prototype.setId = function (id) {
        this.id = id;
        return this;
    };
    SubPathBuilder.prototype.setIsCollapsing = function (isCollapsing) {
        this.isCollapsing = isCollapsing;
        return this;
    };
    SubPathBuilder.prototype.setIsReversed = function (isReversed) {
        this.isReversed = isReversed;
        return this;
    };
    SubPathBuilder.prototype.setShiftOffset = function (shiftOffset) {
        this.shiftOffset = shiftOffset;
        return this;
    };
    SubPathBuilder.prototype.setIsSplit = function (isSplit) {
        this.isSplit = isSplit;
        return this;
    };
    SubPathBuilder.prototype.setIsUnsplittable = function (isUnsplittable) {
        this.isUnsplittable = isUnsplittable;
        return this;
    };
    SubPathBuilder.prototype.build = function () {
        return new SubPath(this.commands.slice(), this.id, this.isCollapsing, this.isReversed, this.shiftOffset, this.isSplit, this.isUnsplittable);
    };
    return SubPathBuilder;
}());



/***/ }),

/***/ "./src/app/modules/editor/model/paths/SubPathState.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/model/paths/SubPathState.ts ***!
  \************************************************************/
/*! exports provided: SubPathState, SubPathStateMutator, findSubPathState, flattenSubPathStates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubPathState", function() { return SubPathState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubPathStateMutator", function() { return SubPathStateMutator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findSubPathState", function() { return findSubPathState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flattenSubPathStates", function() { return flattenSubPathStates; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Container class that encapsulates a SubPath's underlying state.
 */
var SubPathState = /** @class */ (function () {
    function SubPathState(commandStates, isReversed_, shiftOffset, id, 
    // Either empty if this sub path is not split, or an array
    // containing this sub path's split children.
    splitSubPaths) {
        if (isReversed_ === void 0) { isReversed_ = false; }
        if (shiftOffset === void 0) { shiftOffset = 0; }
        if (id === void 0) { id = lodash__WEBPACK_IMPORTED_MODULE_0__["uniqueId"](); }
        if (splitSubPaths === void 0) { splitSubPaths = []; }
        this.commandStates = commandStates;
        this.isReversed_ = isReversed_;
        this.shiftOffset = shiftOffset;
        this.id = id;
        this.splitSubPaths = splitSubPaths;
    }
    SubPathState.prototype.getId = function () {
        return this.id;
    };
    SubPathState.prototype.getCommandStates = function () {
        return this.commandStates;
    };
    SubPathState.prototype.isReversed = function () {
        return this.isReversed_;
    };
    SubPathState.prototype.getShiftOffset = function () {
        return this.shiftOffset;
    };
    SubPathState.prototype.getSplitSubPaths = function () {
        return this.splitSubPaths;
    };
    SubPathState.prototype.revert = function () {
        return this.mutate()
            .revert()
            .build();
    };
    SubPathState.prototype.clone = function () {
        return this.mutate().build();
    };
    SubPathState.prototype.mutate = function () {
        return new SubPathStateMutator(this.commandStates.slice(), this.isReversed_, this.shiftOffset, this.id, this.splitSubPaths.slice());
    };
    return SubPathState;
}());

/**
 * Builder class for creating new SubPathState objects.
 */
var SubPathStateMutator = /** @class */ (function () {
    function SubPathStateMutator(commandStates, isReversed, shiftOffset, id, splitSubPaths) {
        this.commandStates = commandStates;
        this.isReversed = isReversed;
        this.shiftOffset = shiftOffset;
        this.id = id;
        this.splitSubPaths = splitSubPaths;
    }
    SubPathStateMutator.prototype.setCommandStates = function (commandStates) {
        this.commandStates = commandStates.slice();
        return this;
    };
    SubPathStateMutator.prototype.setCommandState = function (index, commandState) {
        if (!this.commandStates || this.commandStates.length <= index) {
            throw new Error('Attempt to set a CommandState object using an invalid index');
        }
        this.commandStates[index] = commandState;
        return this;
    };
    SubPathStateMutator.prototype.reverse = function () {
        return this.setIsReversed(!this.isReversed);
    };
    SubPathStateMutator.prototype.setIsReversed = function (isReversed) {
        this.isReversed = isReversed;
        return this;
    };
    SubPathStateMutator.prototype.setShiftOffset = function (shiftOffset) {
        this.shiftOffset = shiftOffset;
        return this;
    };
    SubPathStateMutator.prototype.setSplitSubPaths = function (splitSubPaths) {
        this.splitSubPaths = splitSubPaths.slice();
        return this;
    };
    SubPathStateMutator.prototype.setId = function (id) {
        this.id = id;
        return this;
    };
    SubPathStateMutator.prototype.revert = function () {
        this.commandStates = this.commandStates.map(function (cs) {
            return cs
                .mutate()
                .revert()
                .build();
        });
        this.isReversed = false;
        this.shiftOffset = 0;
        this.splitSubPaths = [];
        return this;
    };
    SubPathStateMutator.prototype.build = function () {
        return new SubPathState(this.commandStates, this.isReversed, this.shiftOffset, this.id, this.splitSubPaths);
    };
    return SubPathStateMutator;
}());

function findSubPathState(map, spsIdx) {
    return flattenSubPathStates(map)[spsIdx];
}
function flattenSubPathStates(map) {
    var subPathStates = [];
    (function recurseFn(currentLevel) {
        currentLevel.forEach(function (state) {
            if (!state.getSplitSubPaths().length) {
                subPathStates.push(state);
                return;
            }
            recurseFn(state.getSplitSubPaths());
        });
    })(map);
    return subPathStates;
}


/***/ }),

/***/ "./src/app/modules/editor/model/paths/calculators/BezierCalculator.ts":
/*!****************************************************************************!*\
  !*** ./src/app/modules/editor/model/paths/calculators/BezierCalculator.ts ***!
  \****************************************************************************/
/*! exports provided: BezierCalculator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BezierCalculator", function() { return BezierCalculator; });
/* harmony import */ var app_modules_editor_model_paths_Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/paths/Command */ "./src/app/modules/editor/model/paths/Command.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bezier-js */ "./node_modules/bezier-js/index.js");
/* harmony import */ var bezier_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bezier_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _LineCalculator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LineCalculator */ "./src/app/modules/editor/model/paths/calculators/LineCalculator.ts");
/* harmony import */ var _PointCalculator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PointCalculator */ "./src/app/modules/editor/model/paths/calculators/PointCalculator.ts");







/**
 * A simple typed wrapper class around the amazing bezier-js library.
 */
var BezierCalculator = /** @class */ (function () {
    function BezierCalculator(id, svgChar) {
        var points = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            points[_i - 2] = arguments[_i];
        }
        this.id = id;
        this.svgChar = svgChar;
        this.points = points;
        // Don't initialize variables lazily for dev builds (to avoid
        // ngrx-store-freeze crashes).
        if (!environments_environment__WEBPACK_IMPORTED_MODULE_3__["environment"].production) {
            this.getPathLength();
            this.getBoundingBox();
        }
    }
    Object.defineProperty(BezierCalculator.prototype, "bezierJs", {
        get: function () {
            if (this.bezierJs_ === undefined) {
                this.bezierJs_ = new bezier_js__WEBPACK_IMPORTED_MODULE_2__(this.points);
            }
            return this.bezierJs_;
        },
        enumerable: true,
        configurable: true
    });
    BezierCalculator.prototype.getPointAtLength = function (distance) {
        return this.bezierJs.get(this.findTimeByDistance(distance / this.getPathLength()));
    };
    BezierCalculator.prototype.getPathLength = function () {
        if (this.length === undefined) {
            this.length = this.bezierJs.length();
        }
        return this.length;
    };
    BezierCalculator.prototype.project = function (point) {
        // Create a new bezier curve for dev builds to avoid ngrx-store-freeze crashes.
        var bezierJs = !environments_environment__WEBPACK_IMPORTED_MODULE_3__["environment"].production ? new bezier_js__WEBPACK_IMPORTED_MODULE_2__(this.points) : this.bezierJs;
        var _a = bezierJs.project(point), x = _a.x, y = _a.y, t = _a.t, d = _a.d;
        return { x: x, y: y, t: t, d: d };
    };
    BezierCalculator.prototype.split = function (t1, t2) {
        if (t1 === t2) {
            return new _PointCalculator__WEBPACK_IMPORTED_MODULE_6__["PointCalculator"](this.id, this.svgChar, this.bezierJs.get(t1));
        }
        var points = this.bezierJs.split(t1, t2).points;
        var uniquePoints = lodash__WEBPACK_IMPORTED_MODULE_4__["uniqWith"](points, app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].arePointsEqual);
        if (uniquePoints.length === 2) {
            return new _LineCalculator__WEBPACK_IMPORTED_MODULE_5__["LineCalculator"](this.id, this.svgChar, lodash__WEBPACK_IMPORTED_MODULE_4__["first"](points), lodash__WEBPACK_IMPORTED_MODULE_4__["last"](points));
        }
        return new (BezierCalculator.bind.apply(BezierCalculator, [void 0, this.id, this.svgChar].concat(points)))();
    };
    BezierCalculator.prototype.convert = function (svgChar) {
        if (svgChar === undefined) {
            throw new Error('Attempt to convert an undefined svgChar');
        }
        if (this.svgChar === 'Q' && svgChar === 'C') {
            var qcp0 = this.points[0];
            var qcp1 = this.points[1];
            var qcp2 = this.points[2];
            var ccp0 = qcp0;
            var ccp1 = {
                x: qcp0.x + (2 / 3) * (qcp1.x - qcp0.x),
                y: qcp0.y + (2 / 3) * (qcp1.y - qcp0.y),
            };
            var ccp2 = {
                x: qcp2.x + (2 / 3) * (qcp1.x - qcp2.x),
                y: qcp2.y + (2 / 3) * (qcp1.y - qcp2.y),
            };
            var ccp3 = qcp2;
            return new BezierCalculator(this.id, svgChar, ccp0, ccp1, ccp2, ccp3);
        }
        return new (BezierCalculator.bind.apply(BezierCalculator, [void 0, this.id, svgChar].concat(this.points)))();
    };
    BezierCalculator.prototype.findTimeByDistance = function (distance) {
        if (distance < 0 || distance > 1) {
            console.warn('distance must be a number between 0 and 1.');
        }
        if (distance === 0 || distance === 1) {
            return distance;
        }
        var originalDistance = distance;
        var epsilon = 0.001;
        var maxDepth = -100;
        var lowToHighRatio = distance / (1 - distance);
        var step = -2;
        while (step > maxDepth) {
            var split = this.bezierJs.split(distance);
            var low = split.left.length();
            var high = split.right.length();
            var diff = low - lowToHighRatio * high;
            if (Math.abs(diff) < epsilon) {
                // We found a satisfactory midpoint t value.
                break;
            }
            // Jump half the t-distance in the direction of the bias.
            step = step - 1;
            distance += (diff > 0 ? -1 : 1) * Math.pow(2, step);
        }
        if (step === maxDepth) {
            // TODO: handle degenerate curves!!!!!
            console.warn('Could not find the midpoint for: ', this.svgChar + " " + this.points.toString());
            return originalDistance;
        }
        return distance;
    };
    BezierCalculator.prototype.toCommand = function () {
        return new app_modules_editor_model_paths_Command__WEBPACK_IMPORTED_MODULE_0__["CommandBuilder"](this.svgChar, this.points.slice()).setId(this.id).build();
    };
    BezierCalculator.prototype.getBoundingBox = function () {
        if (this.bbox === undefined) {
            var bbox = this.bezierJs.bbox();
            this.bbox = {
                x: { min: bbox.x.min, max: bbox.x.max },
                y: { min: bbox.y.min, max: bbox.y.max },
            };
        }
        return this.bbox;
    };
    BezierCalculator.prototype.intersects = function (line) {
        if (app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].arePointsEqual(lodash__WEBPACK_IMPORTED_MODULE_4__["first"](this.points), lodash__WEBPACK_IMPORTED_MODULE_4__["last"](this.points))) {
            // Points can't be intersected.
            return [];
        }
        return this.bezierJs.intersects(line);
    };
    return BezierCalculator;
}());



/***/ }),

/***/ "./src/app/modules/editor/model/paths/calculators/Calculator.ts":
/*!**********************************************************************!*\
  !*** ./src/app/modules/editor/model/paths/calculators/Calculator.ts ***!
  \**********************************************************************/
/*! exports provided: newCalculator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newCalculator", function() { return newCalculator; });
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _BezierCalculator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BezierCalculator */ "./src/app/modules/editor/model/paths/calculators/BezierCalculator.ts");
/* harmony import */ var _LineCalculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LineCalculator */ "./src/app/modules/editor/model/paths/calculators/LineCalculator.ts");
/* harmony import */ var _MoveCalculator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MoveCalculator */ "./src/app/modules/editor/model/paths/calculators/MoveCalculator.ts");
/* harmony import */ var _PointCalculator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PointCalculator */ "./src/app/modules/editor/model/paths/calculators/PointCalculator.ts");






function newCalculator(cmd) {
    var points = cmd.points;
    if (cmd.type === 'M') {
        return new _MoveCalculator__WEBPACK_IMPORTED_MODULE_4__["MoveCalculator"](cmd.id, points[0], points[1]);
    }
    var uniquePoints = lodash__WEBPACK_IMPORTED_MODULE_1__["uniqWith"](points, app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].arePointsEqual);
    if (uniquePoints.length === 1) {
        return new _PointCalculator__WEBPACK_IMPORTED_MODULE_5__["PointCalculator"](cmd.id, cmd.type, points[0]);
    }
    if (cmd.type === 'L' || cmd.type === 'Z' || uniquePoints.length === 2) {
        return new _LineCalculator__WEBPACK_IMPORTED_MODULE_3__["LineCalculator"](cmd.id, cmd.type, lodash__WEBPACK_IMPORTED_MODULE_1__["first"](points), lodash__WEBPACK_IMPORTED_MODULE_1__["last"](points));
    }
    if (cmd.type === 'Q') {
        return new _BezierCalculator__WEBPACK_IMPORTED_MODULE_2__["BezierCalculator"](cmd.id, cmd.type, points[0], points[1], points[2]);
    }
    if (cmd.type === 'C') {
        var pts = cmd.points;
        return new _BezierCalculator__WEBPACK_IMPORTED_MODULE_2__["BezierCalculator"](cmd.id, cmd.type, pts[0], pts[1], pts[2], pts[3]);
    }
    throw new Error('Invalid command type: ' + cmd.type);
}


/***/ }),

/***/ "./src/app/modules/editor/model/paths/calculators/LineCalculator.ts":
/*!**************************************************************************!*\
  !*** ./src/app/modules/editor/model/paths/calculators/LineCalculator.ts ***!
  \**************************************************************************/
/*! exports provided: LineCalculator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCalculator", function() { return LineCalculator; });
/* harmony import */ var app_modules_editor_model_paths_Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/paths/Command */ "./src/app/modules/editor/model/paths/Command.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _PointCalculator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PointCalculator */ "./src/app/modules/editor/model/paths/calculators/PointCalculator.ts");




var ROUNDING_PRECISION = 10;
var LineCalculator = /** @class */ (function () {
    function LineCalculator(id, svgChar, p1, p2) {
        this.id = id;
        this.svgChar = svgChar;
        this.p1 = p1;
        this.p2 = p2;
    }
    LineCalculator.prototype.getPathLength = function () {
        return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].distance(this.p1, this.p2);
    };
    LineCalculator.prototype.getPointAtLength = function (distance) {
        var t = distance / this.getPathLength();
        var _a = this.p1, x1 = _a.x, y1 = _a.y;
        var _b = this.p2, x2 = _b.x, y2 = _b.y;
        return {
            x: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(x1, x2, t),
            y: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(y1, y2, t),
        };
    };
    LineCalculator.prototype.project = function (_a) {
        var x = _a.x, y = _a.y;
        var _b = this.p1, x1 = _b.x, y1 = _b.y;
        var _c = this.p2, x2 = _c.x, y2 = _c.y;
        var a = x2 - x1;
        var b = y2 - y1;
        var dot = (x - x1) * a + (y - y1) * b;
        var lenSq = round(a * a + b * b);
        var param = lenSq === 0 ? -1 : round(dot / lenSq);
        var xx;
        var yy;
        if (param < 0) {
            xx = x1;
            yy = y1;
        }
        else if (param > 1) {
            xx = x2;
            yy = y2;
        }
        else {
            xx = x1 + param * a;
            yy = y1 + param * b;
        }
        var dx = x - xx;
        var dy = y - yy;
        var dd = Math.sqrt(dx * dx + dy * dy);
        var dt;
        var rx1 = round(x1);
        var rx2 = round(x2);
        var ry1 = round(y1);
        var ry2 = round(y2);
        if (rx2 !== rx1) {
            dt = (xx - x1) / (x2 - x1);
        }
        else if (ry2 !== ry1) {
            dt = (yy - y1) / (y2 - y1);
        }
        else {
            dt = 0.5;
        }
        return { x: round(xx), y: round(yy), d: round(dd), t: round(dt) };
    };
    LineCalculator.prototype.split = function (t1, t2) {
        var _a = this.p1, x1 = _a.x, y1 = _a.y;
        var _b = this.p2, x2 = _b.x, y2 = _b.y;
        var p1 = { x: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(x1, x2, t1), y: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(y1, y2, t1) };
        var p2 = { x: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(x1, x2, t2), y: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(y1, y2, t2) };
        if (app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].arePointsEqual(p1, p2)) {
            return new _PointCalculator__WEBPACK_IMPORTED_MODULE_3__["PointCalculator"](this.id, this.svgChar, p1);
        }
        return new LineCalculator(this.id, this.svgChar, p1, p2);
    };
    LineCalculator.prototype.convert = function (svgChar) {
        return new LineCalculator(this.id, svgChar, this.p1, this.p2);
    };
    LineCalculator.prototype.findTimeByDistance = function (distance) {
        return distance;
    };
    LineCalculator.prototype.toCommand = function () {
        var points;
        switch (this.svgChar) {
            case 'L':
            case 'Z':
                points = [this.p1, this.p2];
                break;
            case 'Q':
                var cp = {
                    x: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(this.p1.x, this.p2.x, 0.5),
                    y: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(this.p1.y, this.p2.y, 0.5),
                };
                points = [this.p1, cp, this.p2];
                break;
            case 'C':
                var cp1 = {
                    x: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(this.p1.x, this.p2.x, 1 / 3),
                    y: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(this.p1.y, this.p2.y, 1 / 3),
                };
                var cp2 = {
                    x: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(this.p1.x, this.p2.x, 2 / 3),
                    y: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(this.p1.y, this.p2.y, 2 / 3),
                };
                points = [this.p1, cp1, cp2, this.p2];
                break;
            default:
                throw new Error('Invalid command type: ' + this.svgChar);
        }
        return new app_modules_editor_model_paths_Command__WEBPACK_IMPORTED_MODULE_0__["CommandBuilder"](this.svgChar, points).setId(this.id).build();
    };
    LineCalculator.prototype.getBoundingBox = function () {
        var minx = Math.min(this.p1.x, this.p2.x);
        var miny = Math.min(this.p1.y, this.p2.y);
        var maxx = Math.max(this.p1.x, this.p2.x);
        var maxy = Math.max(this.p1.y, this.p2.y);
        return { x: { min: minx, max: maxx }, y: { min: miny, max: maxy } };
    };
    LineCalculator.prototype.intersects = function (line) {
        if (app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].arePointsEqual(this.p1, this.p2)) {
            // Points can't be intersected.
            return [];
        }
        // Check to see if the line from (a,b) to (c,d) intersects
        // with the line from (p,q) to (r,s).
        var _a = this.p1, a = _a.x, b = _a.y;
        var _b = this.p2, c = _b.x, d = _b.y;
        var _c = line.p1, p = _c.x, q = _c.y, _d = line.p2, r = _d.x, s = _d.y;
        var det = round((c - a) * (s - q) - (r - p) * (d - b));
        if (det === 0) {
            // Then the two lines are parallel. In our case it is fine to
            // return an empty list, even though the lines may technically
            // be collinear.
            return [];
        }
        else {
            var t = round(((s - q) * (r - a) + (p - r) * (s - b)) / det);
            var u = round(((b - d) * (r - a) + (c - a) * (s - b)) / det);
            return 0 <= t && t <= 1 && (0 <= u && u <= 1) ? [t] : [];
        }
    };
    return LineCalculator;
}());

function round(num) {
    return lodash__WEBPACK_IMPORTED_MODULE_2__["round"](num, ROUNDING_PRECISION);
}


/***/ }),

/***/ "./src/app/modules/editor/model/paths/calculators/MoveCalculator.ts":
/*!**************************************************************************!*\
  !*** ./src/app/modules/editor/model/paths/calculators/MoveCalculator.ts ***!
  \**************************************************************************/
/*! exports provided: MoveCalculator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MoveCalculator", function() { return MoveCalculator; });
/* harmony import */ var app_modules_editor_model_paths_Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/paths/Command */ "./src/app/modules/editor/model/paths/Command.ts");

var MoveCalculator = /** @class */ (function () {
    function MoveCalculator(id, startPoint, endPoint) {
        this.id = id;
        this.startPoint = startPoint;
        this.endPoint = endPoint;
    }
    MoveCalculator.prototype.getPathLength = function () {
        return 0;
    };
    MoveCalculator.prototype.project = function (point) {
        return undefined;
    };
    MoveCalculator.prototype.getPointAtLength = function (distance) {
        return this.endPoint;
    };
    MoveCalculator.prototype.split = function (t1, t2) {
        return this;
    };
    MoveCalculator.prototype.convert = function (svgChar) {
        return this;
    };
    MoveCalculator.prototype.findTimeByDistance = function (distance) {
        return distance;
    };
    MoveCalculator.prototype.toCommand = function () {
        return new app_modules_editor_model_paths_Command__WEBPACK_IMPORTED_MODULE_0__["CommandBuilder"]('M', [this.startPoint, this.endPoint]).setId(this.id).build();
    };
    MoveCalculator.prototype.getBoundingBox = function () {
        var x = { min: NaN, max: NaN };
        var y = { min: NaN, max: NaN };
        return { x: x, y: y };
    };
    MoveCalculator.prototype.intersects = function (line) {
        return [];
    };
    return MoveCalculator;
}());



/***/ }),

/***/ "./src/app/modules/editor/model/paths/calculators/PointCalculator.ts":
/*!***************************************************************************!*\
  !*** ./src/app/modules/editor/model/paths/calculators/PointCalculator.ts ***!
  \***************************************************************************/
/*! exports provided: PointCalculator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCalculator", function() { return PointCalculator; });
/* harmony import */ var app_modules_editor_model_paths_Command__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/paths/Command */ "./src/app/modules/editor/model/paths/Command.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");


var PointCalculator = /** @class */ (function () {
    function PointCalculator(id, svgChar, point) {
        this.id = id;
        this.svgChar = svgChar;
        this.point = point;
    }
    PointCalculator.prototype.getPathLength = function () {
        return 0;
    };
    PointCalculator.prototype.getPointAtLength = function (distance) {
        return this.point;
    };
    PointCalculator.prototype.project = function (point) {
        var x = this.point.x;
        var y = this.point.y;
        var t = 0.5;
        var d = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].distance(this.point, point);
        return { x: x, y: y, t: t, d: d };
    };
    PointCalculator.prototype.split = function (t1, t2) {
        return new PointCalculator(this.id, this.svgChar, this.point);
    };
    PointCalculator.prototype.convert = function (svgChar) {
        return new PointCalculator(this.id, svgChar, this.point);
    };
    PointCalculator.prototype.findTimeByDistance = function (distance) {
        return distance;
    };
    PointCalculator.prototype.toCommand = function () {
        var points;
        switch (this.svgChar) {
            case 'L':
            case 'Z':
                points = [this.point, this.point];
                break;
            case 'Q':
                points = [this.point, this.point, this.point];
                break;
            case 'C':
                points = [this.point, this.point, this.point, this.point];
                break;
            default:
                throw new Error('Invalid command type: ' + this.svgChar);
        }
        return new app_modules_editor_model_paths_Command__WEBPACK_IMPORTED_MODULE_0__["CommandBuilder"](this.svgChar, points).setId(this.id).build();
    };
    PointCalculator.prototype.getBoundingBox = function () {
        var x = { min: this.point.x, max: this.point.x };
        var y = { min: this.point.y, max: this.point.y };
        return { x: x, y: y };
    };
    PointCalculator.prototype.intersects = function (line) {
        return [];
    };
    return PointCalculator;
}());



/***/ }),

/***/ "./src/app/modules/editor/model/paths/calculators/index.ts":
/*!*****************************************************************!*\
  !*** ./src/app/modules/editor/model/paths/calculators/index.ts ***!
  \*****************************************************************/
/*! exports provided: newCalculator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Calculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Calculator */ "./src/app/modules/editor/model/paths/calculators/Calculator.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "newCalculator", function() { return _Calculator__WEBPACK_IMPORTED_MODULE_0__["newCalculator"]; });




/***/ }),

/***/ "./src/app/modules/editor/model/paths/index.ts":
/*!*****************************************************!*\
  !*** ./src/app/modules/editor/model/paths/index.ts ***!
  \*****************************************************/
/*! exports provided: PathUtil, Path, PathMutator, SubPath, Command */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _PathUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PathUtil */ "./src/app/modules/editor/model/paths/PathUtil.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "PathUtil", function() { return _PathUtil__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _Path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Path */ "./src/app/modules/editor/model/paths/Path.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return _Path__WEBPACK_IMPORTED_MODULE_1__["Path"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PathMutator", function() { return _Path__WEBPACK_IMPORTED_MODULE_1__["PathMutator"]; });

/* harmony import */ var _SubPath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SubPath */ "./src/app/modules/editor/model/paths/SubPath.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SubPath", function() { return _SubPath__WEBPACK_IMPORTED_MODULE_2__["SubPath"]; });

/* harmony import */ var _Command__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Command */ "./src/app/modules/editor/model/paths/Command.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Command", function() { return _Command__WEBPACK_IMPORTED_MODULE_3__["Command"]; });








/***/ }),

/***/ "./src/app/modules/editor/model/properties/ColorProperty.ts":
/*!******************************************************************!*\
  !*** ./src/app/modules/editor/model/properties/ColorProperty.ts ***!
  \******************************************************************/
/*! exports provided: ColorProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorProperty", function() { return ColorProperty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Property__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Property */ "./src/app/modules/editor/model/properties/Property.ts");




var ColorProperty = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ColorProperty, _super);
    function ColorProperty() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // @Override
    ColorProperty.prototype.setEditableValue = function (model, propertyName, value) {
        if (!value) {
            model[propertyName] = undefined;
            return;
        }
        var processedValue = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["ColorUtil"].parseAndroidColor(value);
        if (!processedValue) {
            processedValue = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["ColorUtil"].parseAndroidColor(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["ColorUtil"].svgToAndroidColor(value));
        }
        model[propertyName] = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["ColorUtil"].toAndroidString(processedValue);
    };
    // @Override
    ColorProperty.prototype.interpolateValue = function (start, end, f) {
        if (!start || !end) {
            return undefined;
        }
        var s = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["ColorUtil"].parseAndroidColor(start);
        var e = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["ColorUtil"].parseAndroidColor(end);
        return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["ColorUtil"].toAndroidString({
            r: lodash__WEBPACK_IMPORTED_MODULE_2__["clamp"](Math.round(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(s.r, e.r, f)), 0, 0xff),
            g: lodash__WEBPACK_IMPORTED_MODULE_2__["clamp"](Math.round(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(s.g, e.g, f)), 0, 0xff),
            b: lodash__WEBPACK_IMPORTED_MODULE_2__["clamp"](Math.round(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(s.b, e.b, f)), 0, 0xff),
            a: lodash__WEBPACK_IMPORTED_MODULE_2__["clamp"](Math.round(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(s.a, e.a, f)), 0, 0xff),
        });
    };
    // @Override
    ColorProperty.prototype.getAnimatorValueType = function () {
        return 'colorType';
    };
    // @Override
    ColorProperty.prototype.getTypeName = function () {
        return 'ColorProperty';
    };
    return ColorProperty;
}(_Property__WEBPACK_IMPORTED_MODULE_3__["Property"]));



/***/ }),

/***/ "./src/app/modules/editor/model/properties/EnumProperty.ts":
/*!*****************************************************************!*\
  !*** ./src/app/modules/editor/model/properties/EnumProperty.ts ***!
  \*****************************************************************/
/*! exports provided: EnumProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnumProperty", function() { return EnumProperty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Property__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Property */ "./src/app/modules/editor/model/properties/Property.ts");



var EnumProperty = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](EnumProperty, _super);
    function EnumProperty(name, options) {
        var _this = _super.call(this, name) || this;
        _this.options = options;
        return _this;
    }
    // @Override
    EnumProperty.prototype.displayValueForValue = function (value) {
        return lodash__WEBPACK_IMPORTED_MODULE_1__["find"](this.options, function (o) { return o.value === value; }).label;
    };
    // @Override
    EnumProperty.prototype.getTypeName = function () {
        return 'EnumProperty';
    };
    return EnumProperty;
}(_Property__WEBPACK_IMPORTED_MODULE_2__["Property"]));



/***/ }),

/***/ "./src/app/modules/editor/model/properties/FractionProperty.ts":
/*!*********************************************************************!*\
  !*** ./src/app/modules/editor/model/properties/FractionProperty.ts ***!
  \*********************************************************************/
/*! exports provided: FractionProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FractionProperty", function() { return FractionProperty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _NumberProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NumberProperty */ "./src/app/modules/editor/model/properties/NumberProperty.ts");


var FractionProperty = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](FractionProperty, _super);
    function FractionProperty(name, config) {
        if (config === void 0) { config = {}; }
        return _super.call(this, name, {
            isAnimatable: config.isAnimatable,
            min: 0,
            max: 1,
            isInteger: false,
        }) || this;
    }
    // @Override
    FractionProperty.prototype.getAnimatorValueType = function () {
        return 'floatType';
    };
    // @Override
    FractionProperty.prototype.getTypeName = function () {
        return 'FractionProperty';
    };
    return FractionProperty;
}(_NumberProperty__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]));



/***/ }),

/***/ "./src/app/modules/editor/model/properties/NameProperty.ts":
/*!*****************************************************************!*\
  !*** ./src/app/modules/editor/model/properties/NameProperty.ts ***!
  \*****************************************************************/
/*! exports provided: NameProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NameProperty", function() { return NameProperty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _Property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Property */ "./src/app/modules/editor/model/properties/Property.ts");


var NameProperty = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](NameProperty, _super);
    function NameProperty() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NameProperty.sanitize = function (value) {
        if (value === void 0) { value = ''; }
        return value
            .toLowerCase()
            .replace(/^\s+|\s+$/g, '')
            .replace(/[\s-]+/g, '_')
            .replace(/[^\w_]+/g, '');
    };
    // @Override
    NameProperty.prototype.setEditableValue = function (model, propertyName, value) {
        model[propertyName] = NameProperty.sanitize(value);
    };
    // @Override
    NameProperty.prototype.getTypeName = function () {
        return 'NameProperty';
    };
    return NameProperty;
}(_Property__WEBPACK_IMPORTED_MODULE_1__["Property"]));



/***/ }),

/***/ "./src/app/modules/editor/model/properties/NumberProperty.ts":
/*!*******************************************************************!*\
  !*** ./src/app/modules/editor/model/properties/NumberProperty.ts ***!
  \*******************************************************************/
/*! exports provided: NumberProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberProperty", function() { return NumberProperty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Property__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Property */ "./src/app/modules/editor/model/properties/Property.ts");




var NumberProperty = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](NumberProperty, _super);
    function NumberProperty(name, config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, name, config) || this;
        _this.min = config.min === undefined ? -Infinity : config.min;
        _this.max = config.max === undefined ? Infinity : config.max;
        _this.isInteger = !!config.isInteger;
        return _this;
    }
    // @Override
    NumberProperty.prototype.setEditableValue = function (model, propertyName, value) {
        if (typeof value !== 'number') {
            value = parseFloat(value);
        }
        if (isNaN(value)) {
            return;
        }
        value = lodash__WEBPACK_IMPORTED_MODULE_2__["clamp"](value, this.min, this.max);
        if (this.isInteger) {
            value = Math.floor(value);
        }
        model[propertyName] = value;
    };
    // @Override
    NumberProperty.prototype.setter = function (model, propertyName, value) {
        if (typeof value === 'string') {
            value = Number(value);
        }
        if (typeof value === 'number') {
            if (!isNaN(value)) {
                value = lodash__WEBPACK_IMPORTED_MODULE_2__["clamp"](value, this.min, this.max);
                if (this.isInteger) {
                    value = Math.floor(value);
                }
            }
        }
        model[propertyName + "_"] = value;
    };
    // @Override
    NumberProperty.prototype.interpolateValue = function (start, end, fraction) {
        return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].lerp(start, end, fraction);
    };
    // @Override
    NumberProperty.prototype.displayValueForValue = function (value) {
        if (typeof value === 'number') {
            return (Number.isInteger(value)
                ? value.toString()
                : Number(value.toFixed(3)).toString()).replace(/-/g, '\u2212');
        }
        return value;
    };
    // @Override
    NumberProperty.prototype.getAnimatorValueType = function () {
        return 'floatType';
    };
    // @Override
    NumberProperty.prototype.getTypeName = function () {
        return 'NumberProperty';
    };
    return NumberProperty;
}(_Property__WEBPACK_IMPORTED_MODULE_3__["Property"]));



/***/ }),

/***/ "./src/app/modules/editor/model/properties/PathProperty.ts":
/*!*****************************************************************!*\
  !*** ./src/app/modules/editor/model/properties/PathProperty.ts ***!
  \*****************************************************************/
/*! exports provided: PathProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PathProperty", function() { return PathProperty; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paths */ "./src/app/modules/editor/model/paths/index.ts");
/* harmony import */ var _Property__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Property */ "./src/app/modules/editor/model/properties/Property.ts");



var PathProperty = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](PathProperty, _super);
    function PathProperty() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // @Override
    PathProperty.prototype.setEditableValue = function (model, propertyName, value) {
        var path;
        try {
            path = new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"](value);
        }
        catch (e) {
            // An error will be thrown if the user attempts to enter an invalid path,
            // which will occur frequently if they type the path out by hand.
            return;
        }
        model[propertyName] = path;
    };
    // @Override
    PathProperty.prototype.getEditableValue = function (model, propertyName) {
        return model[propertyName] ? model[propertyName].getPathString() : '';
    };
    // @Override
    PathProperty.prototype.getter = function (model, propertyName) {
        return model[propertyName + "_"];
    };
    // @Override
    PathProperty.prototype.setter = function (model, propertyName, value) {
        if (!value) {
            model[propertyName + "_"] = undefined;
            return;
        }
        model[propertyName + "_"] = typeof value === 'string' ? new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"](value) : value;
    };
    // @Override
    PathProperty.prototype.displayValueForValue = function (value) {
        return value ? value.getPathString() : '';
    };
    // @Override
    PathProperty.prototype.interpolateValue = function (start, end, fraction) {
        if (!start || !end || !start.isMorphableWith(end) || !fraction) {
            return start;
        }
        if (fraction === 1) {
            return end;
        }
        return app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["PathUtil"].interpolate(start, end, fraction);
    };
    // @Override
    PathProperty.prototype.cloneValue = function (value) {
        return value ? value.mutate().build() : undefined;
    };
    // @Override
    PathProperty.prototype.getAnimatorValueType = function () {
        return 'pathType';
    };
    // @Override
    PathProperty.prototype.getTypeName = function () {
        return 'PathProperty';
    };
    return PathProperty;
}(_Property__WEBPACK_IMPORTED_MODULE_2__["Property"]));



/***/ }),

/***/ "./src/app/modules/editor/model/properties/Property.ts":
/*!*************************************************************!*\
  !*** ./src/app/modules/editor/model/properties/Property.ts ***!
  \*************************************************************/
/*! exports provided: Property */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Property", function() { return Property; });
/**
 * A property is used to decorate a model object so that it can be inspected
 * and/or animated. T is the value type that is stored inside the model object.
 *
 * Model objects decorated with a property are given the following:
 *
 * - A getter/setter that can be accessed using the property's name.
 * - An 'inspectableProperties' object mapping string property names
 *   to their corresponding inspectable property objects.
 * - An 'animatableProperties' object mapping string property names
 *   to their corresponding animatable property objects.
 */
var Property = /** @class */ (function () {
    function Property(propertyName, config) {
        if (config === void 0) { config = {}; }
        this.propertyName = propertyName;
        this.isAnimatable = !!config.isAnimatable;
    }
    /**
     * Builds a decorator factory for the specified properties.
     */
    Property.register = function () {
        var props = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            props[_i] = arguments[_i];
        }
        return function (cls) {
            props.forEach(function (prop) {
                // Create's a property with the specified property name.
                Object.defineProperty(cls.prototype, prop.propertyName, {
                    get: function () {
                        return prop.getter(this, prop.propertyName);
                    },
                    set: function (value) {
                        prop.setter(this, prop.propertyName, value);
                    },
                });
            });
            var animatableProperties = new Map();
            if (cls.prototype.animatableProperties) {
                animatableProperties = new Map(cls.prototype.animatableProperties);
            }
            var inspectableProperties = new Map();
            if (cls.prototype.inspectableProperties) {
                inspectableProperties = new Map(cls.prototype.inspectableProperties);
            }
            props.forEach(function (prop) {
                if (prop.isAnimatable) {
                    animatableProperties.set(prop.propertyName, prop);
                }
                inspectableProperties.set(prop.propertyName, prop);
            });
            Object.defineProperty(cls.prototype, 'animatableProperties', {
                get: function () { return new Map(animatableProperties); },
            });
            Object.defineProperty(cls.prototype, 'inspectableProperties', {
                get: function () { return new Map(inspectableProperties); },
            });
        };
    };
    Property.prototype.getEditableValue = function (model, propertyName) {
        return model[propertyName];
    };
    Property.prototype.setEditableValue = function (model, propertyName, value) {
        model[propertyName] = value;
    };
    Property.prototype.getter = function (model, propertyName) {
        return model[propertyName + "_"];
    };
    Property.prototype.setter = function (model, propertyName, value) {
        model[propertyName + "_"] = value;
    };
    Property.prototype.displayValueForValue = function (value) {
        return value;
    };
    /**
     * Returns an interpolated value between start and end using the specified fraction.
     * This method does not modify the property's internal state, but rather
     * returns a newly created object.
     */
    Property.prototype.interpolateValue = function (start, end, fraction) {
        return start;
    };
    /**
     * Returns a cloned instance of the value.
     */
    Property.prototype.cloneValue = function (value) {
        return value;
    };
    /**
     * Returns the animator value type for used in Android AnimatedVectorDrawable files.
     */
    Property.prototype.getAnimatorValueType = function () {
        return '';
    };
    return Property;
}());



/***/ }),

/***/ "./src/app/modules/editor/model/properties/index.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/model/properties/index.ts ***!
  \**********************************************************/
/*! exports provided: ColorProperty, FractionProperty, NameProperty, NumberProperty, PathProperty, Property, EnumProperty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ColorProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorProperty */ "./src/app/modules/editor/model/properties/ColorProperty.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorProperty", function() { return _ColorProperty__WEBPACK_IMPORTED_MODULE_0__["ColorProperty"]; });

/* harmony import */ var _FractionProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FractionProperty */ "./src/app/modules/editor/model/properties/FractionProperty.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FractionProperty", function() { return _FractionProperty__WEBPACK_IMPORTED_MODULE_1__["FractionProperty"]; });

/* harmony import */ var _NameProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NameProperty */ "./src/app/modules/editor/model/properties/NameProperty.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NameProperty", function() { return _NameProperty__WEBPACK_IMPORTED_MODULE_2__["NameProperty"]; });

/* harmony import */ var _NumberProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NumberProperty */ "./src/app/modules/editor/model/properties/NumberProperty.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NumberProperty", function() { return _NumberProperty__WEBPACK_IMPORTED_MODULE_3__["NumberProperty"]; });

/* harmony import */ var _PathProperty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PathProperty */ "./src/app/modules/editor/model/properties/PathProperty.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PathProperty", function() { return _PathProperty__WEBPACK_IMPORTED_MODULE_4__["PathProperty"]; });

/* harmony import */ var _Property__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Property */ "./src/app/modules/editor/model/properties/Property.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Property", function() { return _Property__WEBPACK_IMPORTED_MODULE_5__["Property"]; });

/* harmony import */ var _EnumProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EnumProperty */ "./src/app/modules/editor/model/properties/EnumProperty.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EnumProperty", function() { return _EnumProperty__WEBPACK_IMPORTED_MODULE_6__["EnumProperty"]; });










/***/ }),

/***/ "./src/app/modules/editor/model/timeline/Animation.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/model/timeline/Animation.ts ***!
  \************************************************************/
/*! exports provided: Animation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return Animation; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/properties */ "./src/app/modules/editor/model/properties/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _AnimationBlock__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AnimationBlock */ "./src/app/modules/editor/model/timeline/AnimationBlock.ts");




/**
 * An animation represents a collection of layer property tweens for a VectorLayer.
 * An animation has an ID and a duration, as well as a list of AnimationBlocks that
 * each target a single layer in the vector. An animation is structured as an
 * AnimatedVectorDrawable, with the targets being AnimationBlocks.
 */
var Animation = /** @class */ (function () {
    function Animation(obj) {
        if (obj === void 0) { obj = {}; }
        this.id = obj.id || lodash__WEBPACK_IMPORTED_MODULE_2__["uniqueId"]();
        this.name = obj.name || 'anim';
        this.blocks = (obj.blocks || []).map(function (block) { return _AnimationBlock__WEBPACK_IMPORTED_MODULE_3__["AnimationBlock"].from(block); });
        this.duration = obj.duration || 300;
    }
    Animation_1 = Animation;
    Animation.prototype.clone = function () {
        var clone = new Animation_1(this);
        clone.blocks = clone.blocks.slice();
        return clone;
    };
    Animation.prototype.toJSON = function () {
        return {
            id: this.id,
            name: this.name,
            duration: this.duration,
            blocks: this.blocks.map(function (block) { return block.toJSON(); }),
        };
    };
    var Animation_1;
    Animation = Animation_1 = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["Property"].register(new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NameProperty"]('name'), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_1__["NumberProperty"]('duration', { min: 100, max: 60000 })),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Object])
    ], Animation);
    return Animation;
}());



/***/ }),

/***/ "./src/app/modules/editor/model/timeline/AnimationBlock.ts":
/*!*****************************************************************!*\
  !*** ./src/app/modules/editor/model/timeline/AnimationBlock.ts ***!
  \*****************************************************************/
/*! exports provided: AnimationBlock, PathAnimationBlock, ColorAnimationBlock, NumberAnimationBlock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationBlock", function() { return AnimationBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PathAnimationBlock", function() { return PathAnimationBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorAnimationBlock", function() { return ColorAnimationBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberAnimationBlock", function() { return NumberAnimationBlock; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_interpolators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/interpolators */ "./src/app/modules/editor/model/interpolators/index.ts");
/* harmony import */ var app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/properties */ "./src/app/modules/editor/model/properties/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);




/**
 * An animation block is an individual layer property tween (property animation).
 */
var AnimationBlock = /** @class */ (function () {
    function AnimationBlock(obj) {
        this.id = obj.id || lodash__WEBPACK_IMPORTED_MODULE_3__["uniqueId"]();
        this.layerId = obj.layerId;
        this.propertyName = obj.propertyName;
        this.startTime = obj.startTime || 0;
        this.endTime = obj.endTime || 100;
        if (this.startTime > this.endTime) {
            // TODO: don't let this happen (usually results in behavior that seems weird to users)
            var tmp = this.endTime;
            this.endTime = this.startTime;
            this.startTime = tmp;
        }
        // TODO: use the correct default interpolator for import svg/avd/property input
        this.interpolator = obj.interpolator || app_modules_editor_model_interpolators__WEBPACK_IMPORTED_MODULE_1__["INTERPOLATORS"][0].value;
        this.fromValue = obj.fromValue;
        this.toValue = obj.toValue;
        this.type = obj.type;
    }
    AnimationBlock_1 = AnimationBlock;
    AnimationBlock.from = function (obj) {
        switch (obj.type) {
            case 'path':
                return new PathAnimationBlock(obj);
            case 'color':
                return new ColorAnimationBlock(obj);
            case 'number':
                return new NumberAnimationBlock(obj);
            default:
                throw new Error('invalid block type: ' + obj.type);
        }
    };
    AnimationBlock.prototype.toJSON = function () {
        return {
            id: this.id,
            layerId: this.layerId,
            propertyName: this.propertyName,
            startTime: this.startTime,
            endTime: this.endTime,
            interpolator: this.interpolator,
            type: this.type,
            fromValue: this.fromValue,
            toValue: this.toValue,
        };
    };
    AnimationBlock.prototype.clone = function () {
        return AnimationBlock_1.from(this);
    };
    var AnimationBlock_1;
    AnimationBlock = AnimationBlock_1 = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["Property"].register(new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["NumberProperty"]('startTime', { min: 0, isInteger: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["NumberProperty"]('endTime', { min: 0, isInteger: true }), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["EnumProperty"]('interpolator', app_modules_editor_model_interpolators__WEBPACK_IMPORTED_MODULE_1__["INTERPOLATORS"])),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [Object])
    ], AnimationBlock);
    return AnimationBlock;
}());

/**
 * An animation block that animates the 'pathData' property.
 */
var PathAnimationBlock = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](PathAnimationBlock, _super);
    function PathAnimationBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // @Override
    PathAnimationBlock.prototype.toJSON = function () {
        return Object.assign(_super.prototype.toJSON.call(this), {
            fromValue: this.fromValue ? this.fromValue.getPathString() : '',
            toValue: this.toValue ? this.toValue.getPathString() : '',
        });
    };
    // @Override
    PathAnimationBlock.prototype.isAnimatable = function () {
        return !!this.fromValue && !!this.toValue && this.fromValue.isMorphableWith(this.toValue);
    };
    PathAnimationBlock = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["Property"].register(new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["PathProperty"]('fromValue'), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["PathProperty"]('toValue'))
    ], PathAnimationBlock);
    return PathAnimationBlock;
}(AnimationBlock));

/**
 * An animation block that animates a color property.
 */
var ColorAnimationBlock = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ColorAnimationBlock, _super);
    function ColorAnimationBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // @Override
    ColorAnimationBlock.prototype.isAnimatable = function () {
        // TODO should this be more specific (i.e. check if valid color values?)
        return !!this.fromValue && !!this.toValue;
    };
    ColorAnimationBlock = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["Property"].register(new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["ColorProperty"]('fromValue'), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["ColorProperty"]('toValue'))
    ], ColorAnimationBlock);
    return ColorAnimationBlock;
}(AnimationBlock));

/**
 * An animation block that animates a number property.
 */
var NumberAnimationBlock = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](NumberAnimationBlock, _super);
    function NumberAnimationBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // @Override
    NumberAnimationBlock.prototype.isAnimatable = function () {
        return lodash__WEBPACK_IMPORTED_MODULE_3__["isFinite"](this.fromValue) && lodash__WEBPACK_IMPORTED_MODULE_3__["isFinite"](this.toValue);
    };
    NumberAnimationBlock = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["Property"].register(new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["NumberProperty"]('fromValue'), new app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["NumberProperty"]('toValue'))
    ], NumberAnimationBlock);
    return NumberAnimationBlock;
}(AnimationBlock));



/***/ }),

/***/ "./src/app/modules/editor/model/timeline/index.ts":
/*!********************************************************!*\
  !*** ./src/app/modules/editor/model/timeline/index.ts ***!
  \********************************************************/
/*! exports provided: Animation, AnimationBlock, PathAnimationBlock, ColorAnimationBlock, NumberAnimationBlock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Animation */ "./src/app/modules/editor/model/timeline/Animation.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return _Animation__WEBPACK_IMPORTED_MODULE_0__["Animation"]; });

/* harmony import */ var _AnimationBlock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationBlock */ "./src/app/modules/editor/model/timeline/AnimationBlock.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationBlock", function() { return _AnimationBlock__WEBPACK_IMPORTED_MODULE_1__["AnimationBlock"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PathAnimationBlock", function() { return _AnimationBlock__WEBPACK_IMPORTED_MODULE_1__["PathAnimationBlock"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorAnimationBlock", function() { return _AnimationBlock__WEBPACK_IMPORTED_MODULE_1__["ColorAnimationBlock"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NumberAnimationBlock", function() { return _AnimationBlock__WEBPACK_IMPORTED_MODULE_1__["NumberAnimationBlock"]; });





/***/ }),

/***/ "./src/app/modules/editor/scripts/actionmode/ActionModeUtil.ts":
/*!*********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/actionmode/ActionModeUtil.ts ***!
  \*********************************************************************/
/*! exports provided: checkPathsCompatible */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPathsCompatible", function() { return checkPathsCompatible; });
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");

function checkPathsCompatible(block) {
    var fromValue = block.fromValue, toValue = block.toValue;
    if (block.isAnimatable()) {
        return { areCompatible: true };
    }
    var numFromSubPaths = fromValue.getSubPaths().length;
    var numToSubPaths = toValue.getSubPaths().length;
    if (numFromSubPaths !== numToSubPaths) {
        // This should never happen in the app (since collapsing subpaths will
        // be added before this can occur).
        return { areCompatible: false };
    }
    for (var i = 0; i < numFromSubPaths; i++) {
        var fromCmds = fromValue.getSubPath(i).getCommands();
        var toCmds = toValue.getSubPath(i).getCommands();
        if (fromCmds.length === toCmds.length) {
            continue;
        }
        var errorSubIdx = i;
        var errorPath = fromCmds.length < toCmds.length ? app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["ActionSource"].From : app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_0__["ActionSource"].To;
        var numPointsMissing = Math.abs(fromCmds.length - toCmds.length);
        return { areCompatible: false, errorPath: errorPath, errorSubIdx: errorSubIdx, numPointsMissing: numPointsMissing };
    }
    // This should never happen.
    return { areCompatible: false };
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/actionmode/index.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/scripts/actionmode/index.ts ***!
  \************************************************************/
/*! exports provided: ActionModeUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ActionModeUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ActionModeUtil */ "./src/app/modules/editor/scripts/actionmode/ActionModeUtil.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "ActionModeUtil", function() { return _ActionModeUtil__WEBPACK_IMPORTED_MODULE_0__; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/algorithms/AutoAwesome.ts":
/*!******************************************************************!*\
  !*** ./src/app/modules/editor/scripts/algorithms/AutoAwesome.ts ***!
  \******************************************************************/
/*! exports provided: autoFix, autoAddCollapsingSubPaths, autoConvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autoFix", function() { return autoFix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autoAddCollapsingSubPaths", function() { return autoAddCollapsingSubPaths; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autoConvert", function() { return autoConvert; });
/* harmony import */ var app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/paths */ "./src/app/modules/editor/model/paths/index.ts");
/* harmony import */ var app_modules_editor_scripts_bugsnag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/bugsnag */ "./src/app/modules/editor/scripts/bugsnag/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _NeedlemanWunsch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NeedlemanWunsch */ "./src/app/modules/editor/scripts/algorithms/NeedlemanWunsch.ts");
// TODO: test stroked paths





// POSSIBLE IMPROVEMENTS
//
// - Add additional points to both shapes first such that every segment longer than
//   a certain distance is bisected. This may help reduce a bit of noise during alignment.
// - Tweaking the placement of added points with simulated annealing.
// - Using a cost function that factors in self-intersections at the halfway mark in
//   addition to distance traveled.
// - Use triangulation and/or Volonoi topology diagram in order to more accurately morph
//   between SVGs with differing numbers of subpaths.
//
// Useful links/examples:
// - Triangulation: https://goo.gl/Ug2pj9
// - Jigsaw morphing: https://goo.gl/Za3akJ
// - Voronoi topology: https://goo.gl/VNM7Tb
// - Smoother polygon transitions: https://goo.gl/5njTsf
// - Redistricting: https://goo.gl/sMkYEM
/**
 * Takes two arbitrary paths, calculates a best-estimate alignment of the two,
 * and then inserts no-op commands into the alignment gaps to make the two paths
 * compatible with each other.
 */
function autoFix(from, to) {
    var _a, _b, _c, _d, _e, _f, _g;
    // TODO: remove this once we fix the bug below
    var origFrom = from.getPathString();
    var origTo = to.getPathString();
    try {
        _a = autoUnconvertSubPaths(from, to), from = _a[0], to = _a[1];
        _b = autoAddCollapsingSubPaths(from, to), from = _b[0], to = _b[1];
        _c = orderSubPaths(from, to), from = _c[0], to = _c[1];
        var min = Math.min(from.getSubPaths().length, to.getSubPaths().length);
        for (var subIdx = 0; subIdx < min; subIdx++) {
            // Pass the command with the larger subpath as the 'from' command.
            var numFromCmds = from.getSubPath(subIdx).getCommands().length;
            var numToCmds = to.getSubPath(subIdx).getCommands().length;
            var shouldSwap = numFromCmds < numToCmds;
            if (shouldSwap) {
                _d = [to, from], from = _d[0], to = _d[1];
            }
            _e = alignSubPath(from, to, subIdx), from = _e[0], to = _e[1];
            if (shouldSwap) {
                _f = [to, from], from = _f[0], to = _f[1];
            }
        }
        for (var subIdx = 0; subIdx < min; subIdx++) {
            _g = permuteSubPath(from, to, subIdx), from = _g[0], to = _g[1];
        }
    }
    catch (e) {
        // TODO: remove this once we determine what is causing this bug...
        console.error('autofix failed', origFrom, origTo);
        app_modules_editor_scripts_bugsnag__WEBPACK_IMPORTED_MODULE_1__["bugsnagClient"].leaveBreadcrumb('autoFix', {
            from: origFrom,
            to: origTo,
        });
        throw e;
    }
    return [from, to];
}
function autoUnconvertSubPaths(from, to) {
    return [from, to].map(function (p) {
        var pm = p.mutate();
        p.getSubPaths().forEach(function (unused, subIdx) { return pm.unconvertSubPath(subIdx); });
        return pm.build();
    });
}
function autoAddCollapsingSubPaths(from, to) {
    var deleteCollapsingSubPathsFn = function (p) {
        return p.getSubPaths().some(function (s) { return s.isCollapsing(); })
            ? p
                .mutate()
                .deleteCollapsingSubPaths()
                .build()
            : p;
    };
    from = deleteCollapsingSubPathsFn(from);
    to = deleteCollapsingSubPathsFn(to);
    var numFrom = from.getSubPaths().length;
    var numTo = to.getSubPaths().length;
    if (numFrom === numTo) {
        return [from, to];
    }
    // TODO: allow the user to specify the location of collapsing paths?
    var pm = (numFrom < numTo ? from : to).mutate();
    for (var subIdx = Math.min(numFrom, numTo); subIdx < Math.max(numFrom, numTo); subIdx++) {
        var opp = numFrom < numTo ? to : from;
        var pole = opp.getPoleOfInaccessibility(subIdx);
        pm.addCollapsingSubPath(pole, opp.getSubPath(subIdx).getCommands().length);
    }
    if (numFrom < numTo) {
        from = pm.build();
    }
    else {
        to = pm.build();
    }
    return [from, to];
}
/**
 * Reorders the subpaths in each path to minimize the distance each shape will
 * travel during the morph.
 */
function orderSubPaths(from, to) {
    var _a, _b;
    if (from.getSubPaths().length > 8 || to.getSubPaths().length > 8) {
        // Don't attempt to order paths with many subpaths.
        return [from, to];
    }
    var shouldSwap = from.getSubPaths().length < to.getSubPaths().length;
    if (shouldSwap) {
        _a = [to, from], from = _a[0], to = _a[1];
    }
    var fromSubPaths = from.getSubPaths();
    var toSubPaths = to.getSubPaths();
    var distances = fromSubPaths.map(function (f, i) {
        return toSubPaths.map(function (t, j) {
            var pole1 = from.getPoleOfInaccessibility(i);
            var pole2 = to.getPoleOfInaccessibility(j);
            return app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].distance(pole1, pole2);
        });
    });
    var min = Infinity;
    var best = [];
    (function recurseFn(arr, order) {
        if (order === void 0) { order = []; }
        if (order.length === toSubPaths.length) {
            var sum = 0;
            for (var i = 0; i < order.length; i++) {
                sum += distances[order[i]][i];
            }
            if (sum < min) {
                min = sum;
                best = order;
            }
            return;
        }
        for (var i = 0; i < arr.length; i++) {
            var cur = arr.splice(i, 1)[0];
            recurseFn(arr.slice(), order.concat([cur]));
            if (arr.length) {
                arr.splice(i, 0, cur);
            }
        }
    })(lodash__WEBPACK_IMPORTED_MODULE_3__["range"](fromSubPaths.length));
    var pm = from.mutate();
    for (var i = 0; i < best.length; i++) {
        var m = best[i];
        pm.moveSubPath(m, i);
        for (var j = i + 1; j < best.length; j++) {
            var n = best[j];
            if (n < m) {
                best[j]++;
            }
        }
    }
    from = pm.build();
    if (shouldSwap) {
        _b = [to, from], from = _b[0], to = _b[1];
    }
    return [from, to];
}
/** Aligns two paths using the Needleman-Wunsch algorithm. */
function alignSubPath(from, to, subIdx) {
    // Create and return a list of reversed and shifted from paths to test.
    // Each generated 'from path' will be aligned with the target 'to path'.
    var fromPaths = lodash__WEBPACK_IMPORTED_MODULE_3__["flatMap"]([
        from,
        from
            .mutate()
            .reverseSubPath(subIdx)
            .build(),
    ], function (p) {
        var paths = [p];
        if (p.getSubPath(subIdx).isClosed()) {
            for (var i = 1; i < p.getSubPath(subIdx).getCommands().length - 1; i++) {
                // TODO: we need to find a way to reduce the number of paths to try.
                paths.push(p
                    .mutate()
                    .shiftSubPathBack(subIdx, i)
                    .build());
            }
        }
        return paths;
    });
    // The scoring function to use to calculate the alignment. Convert-able
    // commands are considered matches. However, the farther away the points
    // are from each other, the lower the score.
    var getScoreFn = function (a, b) {
        var charA = a.type;
        var charB = b.type;
        if (charA !== charB && !a.canConvertTo(charB) && !b.canConvertTo(charA)) {
            return _NeedlemanWunsch__WEBPACK_IMPORTED_MODULE_4__["MISMATCH"];
        }
        var _a = a.end, x = _a.x, y = _a.y;
        var start = { x: x, y: y };
        var end = b.end;
        return 1 / Math.max(_NeedlemanWunsch__WEBPACK_IMPORTED_MODULE_4__["MATCH"], app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].distance(start, end));
    };
    var alignmentInfos = fromPaths.map(function (generatedFromPath) {
        var fromCmds = generatedFromPath.getSubPath(subIdx).getCommands();
        var toCmds = to.getSubPath(subIdx).getCommands();
        return {
            generatedFromPath: generatedFromPath,
            alignment: Object(_NeedlemanWunsch__WEBPACK_IMPORTED_MODULE_4__["align"])(fromCmds, toCmds, getScoreFn),
        };
    });
    // Find the alignment with the highest score.
    var alignmentInfo = alignmentInfos.reduce(function (prev, curr) {
        var prevScore = prev.alignment.score;
        var currScore = curr.alignment.score;
        return prevScore > currScore ? prev : curr;
    });
    // For each alignment, determine whether it and its neighbor is a gap.
    var processAlignmentsFn = function (alignments) {
        var nextCmdIdx = 0;
        return alignments.map(function (alignment, i) {
            var isGap = !alignment.obj;
            var isNextGap = i + 1 < alignments.length && !alignments[i + 1].obj;
            if (!isGap) {
                nextCmdIdx++;
            }
            return { isGap: isGap, isNextGap: isNextGap, nextCmdIdx: nextCmdIdx };
        });
    };
    var fromCmdInfos = processAlignmentsFn(alignmentInfo.alignment.from);
    var toCmdInfos = processAlignmentsFn(alignmentInfo.alignment.to);
    // Process each list of alignments. Each streak of gaps represents a series
    // of one or more splits we'll perform on the path.
    var createGapStreaksFn = function (cmdInfos) {
        var gapStreaks = [];
        var currentGapStreak = [];
        for (var _i = 0, cmdInfos_1 = cmdInfos; _i < cmdInfos_1.length; _i++) {
            var cmdInfo = cmdInfos_1[_i];
            if (cmdInfo.isGap) {
                currentGapStreak.push(cmdInfo);
                if (!cmdInfo.isNextGap) {
                    gapStreaks.push(currentGapStreak);
                    currentGapStreak = [];
                }
            }
        }
        return gapStreaks;
    };
    var fromGapGroups = createGapStreaksFn(fromCmdInfos);
    var toGapGroups = createGapStreaksFn(toCmdInfos);
    // Fill in the gaps by applying linear subdivide batch splits.
    var applySplitsFn = function (path, gapGroups) {
        var splitOps = [];
        var numPaths = path.getSubPath(subIdx).getCommands().length;
        var _loop_1 = function (i) {
            var gapGroup = gapGroups[i];
            // Clamp the index between 1 and numCommands - 1 to account for cases
            // where the alignment algorithm attempts to append new commands to the
            // front and back of the sequence.
            var cmdIdx = lodash__WEBPACK_IMPORTED_MODULE_3__["clamp"](lodash__WEBPACK_IMPORTED_MODULE_3__["last"](gapGroup).nextCmdIdx, 1, numPaths - 1);
            var ts = gapGroup.map(function (unused, gapIdx) { return (gapIdx + 1) / (gapGroup.length + 1); });
            splitOps.push({ subIdx: subIdx, cmdIdx: cmdIdx, ts: ts });
        };
        for (var i = gapGroups.length - 1; i >= 0; i--) {
            _loop_1(i);
        }
        app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_0__["PathUtil"].sortPathOps(splitOps);
        var mutator = path.mutate();
        for (var _i = 0, splitOps_1 = splitOps; _i < splitOps_1.length; _i++) {
            var _a = splitOps_1[_i], cmdIdx = _a.cmdIdx, ts = _a.ts;
            mutator.splitCommand.apply(mutator, [subIdx, cmdIdx].concat(ts));
        }
        return mutator.build();
    };
    var fromPathResult = applySplitsFn(alignmentInfo.generatedFromPath, fromGapGroups);
    var toPathResult = applySplitsFn(to, toGapGroups);
    // Finally, convert the commands before returning the result.
    return autoConvertSubPath(fromPathResult, toPathResult, subIdx);
}
/**
 * Takes two paths with an equal number of commands and makes them compatible
 * by converting each pair one-by-one.
 */
function autoConvert(from, to) {
    var _a, _b;
    _a = autoUnconvertSubPaths(from, to), from = _a[0], to = _a[1];
    var numFrom = from.getSubPaths().length;
    var numTo = to.getSubPaths().length;
    for (var subIdx = 0; subIdx < Math.min(numFrom, numTo); subIdx++) {
        // Only auto convert when the number of commands in both canvases
        // are equal. Otherwise we'll wait for the user to add more points.
        _b = autoConvertSubPath(from, to, subIdx), from = _b[0], to = _b[1];
    }
    return [from, to];
}
function autoConvertSubPath(from, to, subIdx) {
    var numFrom = from.getSubPath(subIdx).getCommands().length;
    var numTo = to.getSubPath(subIdx).getCommands().length;
    if (numFrom !== numTo) {
        // Only auto convert when the number of commands in both subpaths are equal.
        return [from, to];
    }
    var fromPm = from.mutate();
    var toPm = to.mutate();
    for (var cmdIdx = 0; cmdIdx < numFrom; cmdIdx++) {
        var fromCmd = from.getCommand(subIdx, cmdIdx);
        var toCmd = to.getCommand(subIdx, cmdIdx);
        if (fromCmd.type === toCmd.type) {
            continue;
        }
        if (fromCmd.canConvertTo(toCmd.type)) {
            fromPm.convertCommand(subIdx, cmdIdx, toCmd.type);
        }
        else if (toCmd.canConvertTo(fromCmd.type)) {
            toPm.convertCommand(subIdx, cmdIdx, fromCmd.type);
        }
    }
    return [fromPm.build(), toPm.build()];
}
function permuteSubPath(from, to, subIdx) {
    if (from.isClockwise(subIdx) !== to.isClockwise(subIdx)) {
        // Make sure the paths share the same direction.
        to = to
            .mutate()
            .reverseSubPath(subIdx)
            .build();
    }
    // Create and return a list of reversed and shifted from paths to test.
    // Each generated 'from path' will be aligned with the target 'to path'.
    var fromPaths = [from];
    if (from.getSubPath(subIdx).isClosed()) {
        for (var i = 1; i < from.getSubPath(subIdx).getCommands().length - 1; i++) {
            // TODO: we need to find a way to reduce the number of paths to try.
            fromPaths.push(from
                .mutate()
                .shiftSubPathBack(subIdx, i)
                .build());
        }
    }
    var bestFromPath = from;
    var min = Infinity;
    var _loop_2 = function (fromPath) {
        var fromCmds = fromPath.getSubPath(subIdx).getCommands();
        var sumOfSquares = 0;
        var toCmds = to.getSubPath(subIdx).getCommands();
        fromCmds.forEach(function (c, cmdIdx) { return (sumOfSquares += Math.pow(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].distance(c.end, toCmds[cmdIdx].end), 2)); });
        if (sumOfSquares < min) {
            min = sumOfSquares;
            bestFromPath = fromPath;
        }
    };
    for (var _i = 0, fromPaths_1 = fromPaths; _i < fromPaths_1.length; _i++) {
        var fromPath = fromPaths_1[_i];
        _loop_2(fromPath);
    }
    return [bestFromPath, to];
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/algorithms/NeedlemanWunsch.ts":
/*!**********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/algorithms/NeedlemanWunsch.ts ***!
  \**********************************************************************/
/*! exports provided: MATCH, MISMATCH, INDEL, align */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MATCH", function() { return MATCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MISMATCH", function() { return MISMATCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INDEL", function() { return INDEL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "align", function() { return align; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);

// Needleman-Wunsch scoring function constants.
var MATCH = 1;
var MISMATCH = -1;
var INDEL = 0;
/**
 * Aligns two sequences of objects using the Needleman-Wunsch algorithm.
 */
function align(from, to, scoringFn) {
    var listA = from.map(function (obj) { return ({ obj: obj }); });
    var listB = to.map(function (obj) { return ({ obj: obj }); });
    var alignedListA = [];
    var alignedListB = [];
    // Add dummy nodes at the first position of each list.
    listA.unshift(undefined);
    listB.unshift(undefined);
    var i, j;
    // Initialize the scoring matrix.
    var matrix = [];
    for (i = 0; i < listA.length; i++) {
        var row = [];
        for (j = 0; j < listB.length; j++) {
            row.push(i === 0 ? j * INDEL : j === 0 ? i * INDEL : 0);
        }
        matrix.push(row);
    }
    // Process the scoring matrix.
    for (i = 1; i < listA.length; i++) {
        for (j = 1; j < listB.length; j++) {
            var match = matrix[i - 1][j - 1] + scoringFn(listA[i].obj, listB[j].obj);
            var ins = matrix[i][j - 1] + INDEL;
            var del = matrix[i - 1][j] + INDEL;
            matrix[i][j] = Math.max(match, ins, del);
        }
    }
    // Backtracking.
    i = listA.length - 1;
    j = listB.length - 1;
    while (i > 0 || j > 0) {
        if (i > 0 &&
            j > 0 &&
            matrix[i][j] === matrix[i - 1][j - 1] + scoringFn(listA[i].obj, listB[j].obj)) {
            alignedListA.unshift(listA[i--]);
            alignedListB.unshift(listB[j--]);
        }
        else if (i > 0 && matrix[i][j] === matrix[i - 1][j] + INDEL) {
            alignedListA.unshift(listA[i--]);
            alignedListB.unshift({});
        }
        else {
            alignedListA.unshift({});
            alignedListB.unshift(listB[j--]);
        }
    }
    return {
        from: alignedListA,
        to: alignedListB,
        score: lodash__WEBPACK_IMPORTED_MODULE_0__["last"](lodash__WEBPACK_IMPORTED_MODULE_0__["last"](matrix)),
    };
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/algorithms/index.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/scripts/algorithms/index.ts ***!
  \************************************************************/
/*! exports provided: AutoAwesome */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AutoAwesome__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AutoAwesome */ "./src/app/modules/editor/scripts/algorithms/AutoAwesome.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "AutoAwesome", function() { return _AutoAwesome__WEBPACK_IMPORTED_MODULE_0__; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/animator/AnimationRenderer.ts":
/*!**********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/animator/AnimationRenderer.ts ***!
  \**********************************************************************/
/*! exports provided: AnimationRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationRenderer", function() { return AnimationRenderer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_interpolators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/interpolators */ "./src/app/modules/editor/model/interpolators/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);




var DEFAULT_LAYER_PROPERTY_STATE = {
    activeBlock: undefined,
    interpolatedValue: false,
};
/**
 * A simple class that takes a VectorLayer and an animation and outputs a new
 * rendered VectorLayer given a specific time.
 */
var AnimationRenderer = /** @class */ (function () {
    function AnimationRenderer(originalVectorLayer, activeAnimation) {
        var _this = this;
        // Keys are layerIds and values are RenderedData objects.
        this.animDataByLayer = {};
        // TODO: technically this could be more performant if we only cloned the affected layers
        this.renderedVectorLayer = originalVectorLayer.deepClone();
        var animDataByLayer = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["ModelUtil"].getOrderedBlocksByPropertyByLayer(activeAnimation);
        Object.keys(animDataByLayer).forEach(function (layerId) {
            _this.animDataByLayer[layerId] = {
                originalLayer: originalVectorLayer.findLayerById(layerId),
                renderedLayer: _this.renderedVectorLayer.findLayerById(layerId),
                orderedBlocks: animDataByLayer[layerId],
            };
        });
        this.setCurrentTime(0);
    }
    /**
     * Returns a rendered vector layer given a specific time. The time must be
     * non-negative and must be less than the animation's duration. The returned
     * vector layer should not be mutated externally, as it will be cached and
     * returned on subsequent time frames.
     */
    AnimationRenderer.prototype.setCurrentTime = function (timeMillis) {
        var _this = this;
        Object.keys(this.animDataByLayer).forEach(function (layerId) {
            var animData = _this.animDataByLayer[layerId];
            animData.cachedState = animData.cachedState || {};
            Object.keys(animData.orderedBlocks).forEach(function (propertyName) {
                var blocks = animData.orderedBlocks[propertyName];
                var _ar = tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, DEFAULT_LAYER_PROPERTY_STATE);
                // Compute the rendered value at the given time.
                var property = animData.originalLayer.animatableProperties.get(propertyName);
                var value = animData.originalLayer[propertyName];
                var _loop_1 = function (block) {
                    if (timeMillis < block.startTime) {
                        return "break";
                    }
                    if (timeMillis < block.endTime) {
                        var f = (timeMillis - block.startTime) / (block.endTime - block.startTime);
                        // TODO: this is a bit hacky... no need to perform a search every time.
                        var interpolatorFn = lodash__WEBPACK_IMPORTED_MODULE_3__["find"](app_modules_editor_model_interpolators__WEBPACK_IMPORTED_MODULE_1__["INTERPOLATORS"], function (i) { return i.value === block.interpolator; })
                            .interpolateFn;
                        value = property.interpolateValue(block.fromValue, block.toValue, interpolatorFn(f));
                        _ar.activeBlock = block;
                        _ar.interpolatedValue = true;
                        return "break";
                    }
                    value = block.toValue;
                    _ar.activeBlock = block;
                };
                for (var _i = 0, blocks_1 = blocks; _i < blocks_1.length; _i++) {
                    var block = blocks_1[_i];
                    var state_1 = _loop_1(block);
                    if (state_1 === "break")
                        break;
                }
                animData.renderedLayer[propertyName] = value;
                // Cached data.
                animData.cachedState[propertyName] =
                    animData.cachedState[propertyName] || {};
                animData.cachedState[propertyName] = _ar;
            });
        });
        return this.renderedVectorLayer;
    };
    return AnimationRenderer;
}());



/***/ }),

/***/ "./src/app/modules/editor/scripts/animator/index.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/scripts/animator/index.ts ***!
  \**********************************************************/
/*! exports provided: AnimationRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AnimationRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationRenderer */ "./src/app/modules/editor/scripts/animator/AnimationRenderer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationRenderer", function() { return _AnimationRenderer__WEBPACK_IMPORTED_MODULE_0__["AnimationRenderer"]; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/bugsnag/index.ts":
/*!*********************************************************!*\
  !*** ./src/app/modules/editor/scripts/bugsnag/index.ts ***!
  \*********************************************************/
/*! exports provided: bugsnagClient, errorHandlerFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bugsnagClient", function() { return bugsnagClient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "errorHandlerFactory", function() { return errorHandlerFactory; });
/* harmony import */ var bugsnag_angular__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bugsnag-angular */ "./node_modules/bugsnag-angular/dist/index.js");
/* harmony import */ var bugsnag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bugsnag-js */ "./node_modules/bugsnag-js/dist/bugsnag.js");
/* harmony import */ var bugsnag_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bugsnag_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var environments_version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! environments/version */ "./src/environments/version.ts");




var bugsnagClient = bugsnag_js__WEBPACK_IMPORTED_MODULE_1___default()({
    apiKey: 'd662c2c8a7e13ac94f67e81e26bf3a4e',
    appVersion: environments_version__WEBPACK_IMPORTED_MODULE_3__["version"],
    releaseStage: environments_environment__WEBPACK_IMPORTED_MODULE_2__["environment"].production ? 'production' : 'development',
    notifyReleaseStages: ['production'],
});
function errorHandlerFactory() {
    return new bugsnag_angular__WEBPACK_IMPORTED_MODULE_0__["default"](bugsnagClient);
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/common/ColorUtil.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/scripts/common/ColorUtil.ts ***!
  \************************************************************/
/*! exports provided: parseAndroidColor, toAndroidString, svgToAndroidColor, androidToCssHexColor, androidToCssRgbaColor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseAndroidColor", function() { return parseAndroidColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toAndroidString", function() { return toAndroidString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "svgToAndroidColor", function() { return svgToAndroidColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "androidToCssHexColor", function() { return androidToCssHexColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "androidToCssRgbaColor", function() { return androidToCssRgbaColor; });
/* harmony import */ var app_modules_editor_scripts_bugsnag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/bugsnag */ "./src/app/modules/editor/scripts/bugsnag/index.ts");
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tinycolor2 */ "./node_modules/tinycolor2/tinycolor.js");
/* harmony import */ var tinycolor2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tinycolor2__WEBPACK_IMPORTED_MODULE_1__);


//BHAARATA: end of my code
function parseAndroidColor(val) {
    if (typeof val !== 'string') {
        app_modules_editor_scripts_bugsnag__WEBPACK_IMPORTED_MODULE_0__["bugsnagClient"].notify(new TypeError("Argument has incorrect type (" + typeof val + "): " + val), {
            severity: 'warning',
        });
        return undefined;
    }
    val = (val || '').replace(/^\s*#?|\s*$/g, '');
    var dict = { a: 0, r: 0, g: 0, b: 0 };
    if (val.length === 3) {
        dict.a = 255;
        dict.r = parseInt(val.substring(0, 1), 16) * 17;
        dict.g = parseInt(val.substring(1, 2), 16) * 17;
        dict.b = parseInt(val.substring(2, 3), 16) * 17;
    }
    else if (val.length === 4) {
        dict.a = parseInt(val.substring(0, 1), 16) * 17;
        dict.r = parseInt(val.substring(1, 2), 16) * 17;
        dict.g = parseInt(val.substring(2, 3), 16) * 17;
        dict.b = parseInt(val.substring(3, 4), 16) * 17;
    }
    else if (val.length === 6) {
        dict.a = 255;
        dict.r = parseInt(val.substring(0, 2), 16);
        dict.g = parseInt(val.substring(2, 4), 16);
        dict.b = parseInt(val.substring(4, 6), 16);
    }
    else if (val.length === 8) {
        dict.a = parseInt(val.substring(0, 2), 16);
        dict.r = parseInt(val.substring(2, 4), 16);
        dict.g = parseInt(val.substring(4, 6), 16);
        dict.b = parseInt(val.substring(6, 8), 16);
    }
    else {
        return undefined;
    }
    return isNaN(dict.r) || isNaN(dict.g) || isNaN(dict.b) || isNaN(dict.a) ? undefined : dict;
}
function toAndroidString(dict) {
    var str = '#';
    if (dict.a !== 255) {
        str += (dict.a < 16 ? '0' : '') + dict.a.toString(16);
    }
    str +=
        (dict.r < 16 ? '0' : '') +
            dict.r.toString(16) +
            (dict.g < 16 ? '0' : '') +
            dict.g.toString(16) +
            (dict.b < 16 ? '0' : '') +
            dict.b.toString(16);
    return str;
}
function svgToAndroidColor(color) {
    if (color === 'none') {
        return undefined;
    }
    var colorInstance = tinycolor2__WEBPACK_IMPORTED_MODULE_1__(color);
    var colorHex = colorInstance.toHex();
    var alphaHex = colorInstance.toHex8().substr(6);
    return '#' + (alphaHex !== 'ff' ? alphaHex : '') + colorHex;
}
function androidToCssHexColor(androidColor, multAlpha) {
    if (multAlpha === void 0) { multAlpha = 1; }
    if (!androidColor) {
        return 'transparent';
    }
    var d = parseAndroidColor(androidColor);
    var str = '#';
    str +=
        (d.r < 16 ? '0' : '') +
            d.r.toString(16) +
            (d.g < 16 ? '0' : '') +
            d.g.toString(16) +
            (d.b < 16 ? '0' : '') +
            d.b.toString(16);
    if (d.a !== 255) {
        str += (d.a < 16 ? '0' : '') + d.a.toString(16);
    }
    return str;
}
function androidToCssRgbaColor(androidColor, multAlpha) {
    if (multAlpha === void 0) { multAlpha = 1; }
    if (!androidColor) {
        return 'transparent';
    }
    var d = parseAndroidColor(androidColor);
    return "rgba(" + d.r + "," + d.g + "," + d.b + "," + ((d.a * multAlpha) / 255).toFixed(2) + ")";
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/common/MathUtil.ts":
/*!***********************************************************!*\
  !*** ./src/app/modules/editor/scripts/common/MathUtil.ts ***!
  \***********************************************************/
/*! exports provided: floorMod, lerp, areCollinear, transformPoint, distance, arePointsEqual, round, snapVectorToAngle, isNearZero */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floorMod", function() { return floorMod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areCollinear", function() { return areCollinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformPoint", function() { return transformPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arePointsEqual", function() { return arePointsEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "snapVectorToAngle", function() { return snapVectorToAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNearZero", function() { return isNearZero; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);

/** Returns the floor modulus of the integer argument. */
function floorMod(num, maxNum) {
    return ((num % maxNum) + maxNum) % maxNum;
}
/** Linearly interpolate between a and b using time t. */
function lerp(a, b, t) {
    return a + (b - a) * t;
}
/** Returns true if the points are collinear. */
function areCollinear() {
    var points = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        points[_i] = arguments[_i];
    }
    if (points.length < 3) {
        return true;
    }
    var _a = points[0], a = _a.x, b = _a.y;
    var _b = points[1], m = _b.x, n = _b.y;
    return points.every(function (_a) {
        var x = _a.x, y = _a.y;
        // The points are collinear if the area of the triangle they form
        // is equal to (or in this case, close to) zero.
        return Math.abs(a * (n - y) + m * (y - b) + x * (b - n)) < 1e-9;
    });
}
/** Applies a list of transformation matrices to the specified point. */
function transformPoint(point) {
    var matrices = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        matrices[_i - 1] = arguments[_i];
    }
    return matrices.reduce(function (p, m) {
        // [a c e]   [p.x]
        // [b d f] * [p.y]
        // [0 0 1]   [ 1 ]
        var x = round(m.a * p.x + m.c * p.y + m.e * 1);
        var y = round(m.b * p.x + m.d * p.y + m.f * 1);
        return { x: x, y: y };
    }, point);
}
/** Calculates the distance between two points. */
function distance(p1, p2) {
    return Math.hypot(p1.x - p2.x, p1.y - p2.y);
}
/** Returns true if the two points are equal. */
function arePointsEqual(p1, p2) {
    return p1 && p2 && isNearZero(distance(p1, p2));
}
/** Rounds the number to a prespecified precision. */
function round(n) {
    return lodash__WEBPACK_IMPORTED_MODULE_0__["round"](n, 9);
}
/** Snaps a directional vector to the specified angle. */
function snapVectorToAngle(delta, snapAngleDegrees) {
    var snapAngle = (snapAngleDegrees * Math.PI) / 180;
    var angle = Math.round(Math.atan2(delta.y, delta.x) / snapAngle) * snapAngle;
    var dirx = Math.cos(angle);
    var diry = Math.sin(angle);
    var d = dirx * delta.x + diry * delta.y;
    return { x: dirx * d, y: diry * d };
}
/** Returns true iff the number is near 0. */
function isNearZero(n) {
    return round(n) === 0;
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/common/Matrix.ts":
/*!*********************************************************!*\
  !*** ./src/app/modules/editor/scripts/common/Matrix.ts ***!
  \*********************************************************/
/*! exports provided: Matrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix", function() { return Matrix; });
/* harmony import */ var _MathUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtil */ "./src/app/modules/editor/scripts/common/MathUtil.ts");

/**
 * An immutable Matrix class that uses the standard SVG transformation
 * matrix notation.
 */
var Matrix = /** @class */ (function () {
    function Matrix(a, b, c, d, e, f) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.e = e;
        this.f = f;
    }
    Matrix.identity = function () {
        return new Matrix(1, 0, 0, 1, 0, 0);
    };
    /**
     * Flattens the matrices into a single matrix by performing matrix multiplication
     * on each in left to right order.
     */
    Matrix.flatten = function (matrices) {
        return matrices.reduce(function (prev, curr) { return prev.dot(curr); }, Matrix.identity());
    };
    /**
     * Creates a scaling transformation matrix.
     */
    Matrix.scaling = function (sx, sy) {
        return new Matrix(sx, 0, 0, sy, 0, 0);
    };
    /**
     * Creates a counter clockwise rotation transformation matrix.
     */
    Matrix.rotation = function (degrees) {
        var cosr = Math.cos((degrees * Math.PI) / 180);
        var sinr = Math.sin((degrees * Math.PI) / 180);
        return new Matrix(cosr, sinr, -sinr, cosr, 0, 0);
    };
    /**
     * Creates a translation transformation matrix.
     */
    Matrix.translation = function (tx, ty) {
        return new Matrix(1, 0, 0, 1, tx, ty);
    };
    /**
     * Returns the dot product of this 2D transformation matrices with m.
     */
    Matrix.prototype.dot = function (m) {
        // [a c e]   [a' c' e']
        // [b d f] * [b' d' f']
        // [0 0 1]   [0  0  1 ]
        return new Matrix(_MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](this.a * m.a + this.c * m.b), _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](this.b * m.a + this.d * m.b), _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](this.a * m.c + this.c * m.d), _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](this.b * m.c + this.d * m.d), _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](this.a * m.e + this.c * m.f + this.e), _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](this.b * m.e + this.d * m.f + this.f));
    };
    /**
     * Returns the inverse of this transformation matrix or undefined if the
     * matrix is not invertible.
     */
    Matrix.prototype.invert = function () {
        var _a = this, a = _a.a, b = _a.b, c = _a.c, d = _a.d, e = _a.e, f = _a.f;
        var det = _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](a * d - b * c);
        if (!det) {
            return undefined;
        }
        det = 1 / det;
        return new Matrix(_MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](d * det), _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](-b * det), _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](-c * det), _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](a * det), _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"]((c * f - d * e) * det), _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"]((b * e - a * f) * det));
    };
    /**
     * Extracts the x/y scaling from the transformation matrix.
     */
    Matrix.prototype.getScaling = function () {
        var _a = this, a = _a.a, b = _a.b, c = _a.c, d = _a.d;
        var sx = (a >= 0 ? 1 : -1) * Math.hypot(a, c);
        var sy = (d >= 0 ? 1 : -1) * Math.hypot(b, d);
        return { sx: _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](sx), sy: _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](sy) };
    };
    /**
     * Extracts the rotation in degrees from the transformation matrix.
     */
    Matrix.prototype.getRotation = function () {
        return _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"]((180 / Math.PI) * Math.atan2(-this.c, this.a));
    };
    /**
     * Extracts the x/y translation from the transformation matrix.
     */
    Matrix.prototype.getTranslation = function () {
        return { tx: _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](this.e), ty: _MathUtil__WEBPACK_IMPORTED_MODULE_0__["round"](this.f) };
    };
    /**
     * Returns a single scale factor (to use for scaling a path's stroke width, etc.).
     */
    Matrix.prototype.getScaleFactor = function () {
        // Given unit vectors u0 = (0, 1) and v0 = (1, 0).
        //
        // After matrix mapping, we get u1 and v1. Let Θ be the angle between u1 and v1.
        // Then the final scale we want is:
        //
        // Math.min(|u1|sin(Θ),|v1|sin(Θ)) = |u1||v1|sin(Θ) / Math.max(|u1|,|v1|)
        //
        // If Math.max(|u1|,|v1|) = 0, that means either x or y has a scale of 0.
        //
        // For the non-skew case, which is most of the cases, matrix scale is
        // computing exactly the scale on x and y axis, and take the minimal of these two.
        //
        // For the skew case, an unit square will mapped to a parallelogram,
        // and this function will return the minimal height of the 2 bases.
        var m = new Matrix(this.a, this.b, this.c, this.d, 0, 0);
        var u0 = { x: 0, y: 1 };
        var v0 = { x: 1, y: 0 };
        var u1 = _MathUtil__WEBPACK_IMPORTED_MODULE_0__["transformPoint"](u0, m);
        var v1 = _MathUtil__WEBPACK_IMPORTED_MODULE_0__["transformPoint"](v0, m);
        var sx = Math.hypot(u1.x, u1.y);
        var sy = Math.hypot(v1.x, v1.y);
        var dotProduct = u1.y * v1.x - u1.x * v1.y;
        var maxScale = Math.max(sx, sy);
        return maxScale > 0 ? Math.abs(dotProduct) / maxScale : 0;
    };
    /**
     * Returns true if the matrix is approximately equal to this matrix.
     */
    Matrix.prototype.equals = function (m) {
        return (Math.abs(this.a - m.a) < 1e-9 &&
            Math.abs(this.b - m.b) < 1e-9 &&
            Math.abs(this.c - m.c) < 1e-9 &&
            Math.abs(this.d - m.d) < 1e-9 &&
            Math.abs(this.e - m.e) < 1e-9 &&
            Math.abs(this.f - m.f) < 1e-9);
    };
    return Matrix;
}());



/***/ }),

/***/ "./src/app/modules/editor/scripts/common/ModelUtil.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/scripts/common/ModelUtil.ts ***!
  \************************************************************/
/*! exports provided: getOrderedBlocksByPropertyByLayer, getAvailablePropertyNamesForLayer, regenerateModelIds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrderedBlocksByPropertyByLayer", function() { return getOrderedBlocksByPropertyByLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAvailablePropertyNamesForLayer", function() { return getAvailablePropertyNamesForLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "regenerateModelIds", function() { return regenerateModelIds; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Builds a map where the keys are layer IDs and the values are
 * maps of property names to their corresponding animation blocks.
 */
function getOrderedBlocksByPropertyByLayer(animation) {
    var blocksByPropertyByLayer = {};
    animation.blocks.forEach(function (block) {
        var blocksByProperty = blocksByPropertyByLayer[block.layerId];
        if (!blocksByProperty) {
            blocksByProperty = {};
            blocksByPropertyByLayer[block.layerId] = blocksByProperty;
        }
        var propertyName = block.propertyName;
        blocksByProperty[propertyName] = blocksByProperty[propertyName] || [];
        blocksByProperty[propertyName].push(block);
    });
    lodash__WEBPACK_IMPORTED_MODULE_0__["forEach"](blocksByPropertyByLayer, function (blocksByProperty) {
        lodash__WEBPACK_IMPORTED_MODULE_0__["forEach"](blocksByProperty, function (blocks) {
            blocks.sort(function (a, b) { return a.startTime - b.startTime; });
        });
    });
    return blocksByPropertyByLayer;
}
/**
 * Returns a set of property names that have not yet been animated.
 */
function getAvailablePropertyNamesForLayer(layer, animation) {
    var availablePropertyNames = new Set(layer.animatableProperties.keys());
    var blocksByPropertyByLayer = getOrderedBlocksByPropertyByLayer(animation);
    var blocksByProperty = blocksByPropertyByLayer[layer.id];
    if (blocksByProperty) {
        for (var _i = 0, _a = Object.keys(blocksByProperty); _i < _a.length; _i++) {
            var name_1 = _a[_i];
            availablePropertyNames.delete(name_1);
        }
    }
    return availablePropertyNames;
}
function regenerateModelIds(vectorLayer, animation, hiddenLayerIds) {
    // Create a map of old IDs to new IDs.
    var layerIdMap = {};
    vectorLayer.walk(function (layer) { return (layerIdMap[layer.id] = lodash__WEBPACK_IMPORTED_MODULE_0__["uniqueId"]()); });
    vectorLayer = (function recurseFn(layer) {
        var clone = layer.clone();
        clone.id = layerIdMap[clone.id];
        clone.children = clone.children.map(function (l) { return recurseFn(l); });
        return clone;
    })(vectorLayer);
    var clonedAnim = animation.clone();
    clonedAnim.id = lodash__WEBPACK_IMPORTED_MODULE_0__["uniqueId"]();
    clonedAnim.blocks = clonedAnim.blocks.map(function (block) {
        var clonedBlock = block.clone();
        clonedBlock.id = lodash__WEBPACK_IMPORTED_MODULE_0__["uniqueId"]();
        clonedBlock.layerId = layerIdMap[clonedBlock.layerId];
        return clonedBlock;
    });
    animation = clonedAnim;
    hiddenLayerIds = new Set(Array.from(hiddenLayerIds).map(function (id) { return layerIdMap[id]; }));
    return { vectorLayer: vectorLayer, animation: animation, hiddenLayerIds: hiddenLayerIds };
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/common/TransformUtil.ts":
/*!****************************************************************!*\
  !*** ./src/app/modules/editor/scripts/common/TransformUtil.ts ***!
  \****************************************************************/
/*! exports provided: distort */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distort", function() { return distort; });
// TODO: change argument types to a Quadrilateral
function distort(sourcePoints, targetPoints) {
    var a = [];
    var b = [];
    for (var i = 0, n = sourcePoints.length; i < n; ++i) {
        var s = sourcePoints[i];
        var t = targetPoints[i];
        a.push([s[0], s[1], 1, 0, 0, 0, -s[0] * t[0], -s[1] * t[0]]), b.push(t[0]);
        a.push([0, 0, 0, s[0], s[1], 1, -s[0] * t[1], -s[1] * t[1]]), b.push(t[1]);
    }
    var X = solve(a, b, true);
    // prettier-ignore
    var matrix = [
        X[0], X[3], 0, X[6],
        X[1], X[4], 0, X[7],
        0, 0, 1, 0,
        X[2], X[5], 0, 1,
    ].map(function (x) { return Math.round(x * 10e6) / 10e6; });
    // Given a 4x4 perspective transformation matrix, and a 2D point (a 2x1 vector),
    // applies the transformation matrix by converting the point to homogeneous
    // coordinates at z=0, post-multiplying, and then applying a perspective divide.
    return function (point) {
        var pt = multiply(matrix, [point[0], point[1], 0, 1]);
        return [pt[0] / pt[3], pt[1] / pt[3]];
    };
    // Post-multiply a 4x4 matrix in column-major order by a 4x1 column vector:
    // [ m0 m4 m8  m12 ]   [ v0 ]   [ x ]
    // [ m1 m5 m9  m13 ] * [ v1 ] = [ y ]
    // [ m2 m6 m10 m14 ]   [ v2 ]   [ z ]
    // [ m3 m7 m11 m15 ]   [ v3 ]   [ w ]
    function multiply(m, v) {
        // prettier-ignore
        return [
            m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3],
            m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3],
            m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3],
            m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3],
        ];
    }
}
/* Code below is copied from numeric.js */
var abs = Math.abs;
function _foreach2(x, s, k, f) {
    if (k === s.length - 1) {
        return f(x);
    }
    var i;
    var n = s[k];
    var ret = Array(n);
    for (i = n - 1; i >= 0; --i) {
        ret[i] = _foreach2(x[i], s, k + 1, f);
    }
    return ret;
}
function _dim(x) {
    var ret = [];
    while (typeof x === 'object') {
        ret.push(x.length), (x = x[0]);
    }
    return ret;
}
function dim(x) {
    var y, z;
    if (typeof x === 'object') {
        y = x[0];
        if (typeof y === 'object') {
            z = y[0];
            if (typeof z === 'object') {
                return _dim(x);
            }
            return [x.length, y.length];
        }
        return [x.length];
    }
    return [];
}
function cloneV(x) {
    var _n = x.length;
    var i;
    var ret = Array(_n);
    for (i = _n - 1; i !== -1; --i) {
        ret[i] = x[i];
    }
    return ret;
}
function clone(x) {
    return typeof x !== 'object' ? x : _foreach2(x, dim(x), 0, cloneV);
}
function LU(A, fast) {
    fast = fast || false;
    var i, j, k, absAjk, Akk, Ak, Pk, Ai, max;
    var n = A.length;
    var n1 = n - 1;
    var P = new Array(n);
    if (!fast) {
        A = clone(A);
    }
    for (k = 0; k < n; ++k) {
        Pk = k;
        Ak = A[k];
        max = abs(Ak[k]);
        for (j = k + 1; j < n; ++j) {
            absAjk = abs(A[j][k]);
            if (max < absAjk) {
                max = absAjk;
                Pk = j;
            }
        }
        P[k] = Pk;
        if (Pk !== k) {
            A[k] = A[Pk];
            A[Pk] = Ak;
            Ak = A[k];
        }
        Akk = Ak[k];
        for (i = k + 1; i < n; ++i) {
            A[i][k] /= Akk;
        }
        for (i = k + 1; i < n; ++i) {
            Ai = A[i];
            for (j = k + 1; j < n1; ++j) {
                Ai[j] -= Ai[k] * Ak[j];
                ++j;
                Ai[j] -= Ai[k] * Ak[j];
            }
            if (j === n1) {
                Ai[j] -= Ai[k] * Ak[j];
            }
        }
    }
    return {
        LU: A,
        P: P,
    };
}
function LUsolve(LUP, b) {
    var i;
    var j;
    var lu = LUP.LU;
    var n = lu.length;
    var x = clone(b);
    var P = LUP.P;
    var Pi;
    var LUi;
    var tmp;
    for (i = n - 1; i !== -1; --i) {
        x[i] = b[i];
    }
    for (i = 0; i < n; ++i) {
        Pi = P[i];
        if (P[i] !== i) {
            (tmp = x[i]), (x[i] = x[Pi]), (x[Pi] = tmp);
        }
        LUi = lu[i];
        for (j = 0; j < i; ++j) {
            x[i] -= x[j] * LUi[j];
        }
    }
    for (i = n - 1; i >= 0; --i) {
        LUi = lu[i];
        for (j = i + 1; j < n; ++j) {
            x[i] -= x[j] * LUi[j];
        }
        x[i] /= LUi[i];
    }
    return x;
}
function solve(A, b, fast) {
    return LUsolve(LU(A, fast), b);
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/common/index.ts":
/*!********************************************************!*\
  !*** ./src/app/modules/editor/scripts/common/index.ts ***!
  \********************************************************/
/*! exports provided: ColorUtil, MathUtil, ModelUtil, TransformUtil, Matrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ColorUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorUtil */ "./src/app/modules/editor/scripts/common/ColorUtil.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "ColorUtil", function() { return _ColorUtil__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _MathUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MathUtil */ "./src/app/modules/editor/scripts/common/MathUtil.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "MathUtil", function() { return _MathUtil__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _ModelUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ModelUtil */ "./src/app/modules/editor/scripts/common/ModelUtil.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "ModelUtil", function() { return _ModelUtil__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _TransformUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TransformUtil */ "./src/app/modules/editor/scripts/common/TransformUtil.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "TransformUtil", function() { return _TransformUtil__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _Matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Matrix */ "./src/app/modules/editor/scripts/common/Matrix.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Matrix", function() { return _Matrix__WEBPACK_IMPORTED_MODULE_4__["Matrix"]; });









/***/ }),

/***/ "./src/app/modules/editor/scripts/demos/index.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/scripts/demos/index.ts ***!
  \*******************************************************/
/*! exports provided: DEMO_INFOS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEMO_INFOS", function() { return DEMO_INFOS; });
var DEMO_INFOS = [
    { id: 'playtopause', title: 'Play-to-pause' },
    { id: 'searchtoclose', title: 'Search-to-close' },
    { id: 'morphinganimals', title: 'Morphing animals' },
    { id: 'visibilitystrike', title: 'Visibility strike' },
    { id: 'heartbreak', title: 'Heart break' },
];


/***/ }),

/***/ "./src/app/modules/editor/scripts/dragger/Dragger.ts":
/*!***********************************************************!*\
  !*** ./src/app/modules/editor/scripts/dragger/Dragger.ts ***!
  \***********************************************************/
/*! exports provided: Dragger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dragger", function() { return Dragger; });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);

var DRAG_SLOP_PIXELS = 4;
var Dragger = /** @class */ (function () {
    function Dragger(opts) {
        if (opts === void 0) { opts = {}; }
        var _this = this;
        this.direction = opts.direction || 'both';
        this.downX = opts.downX;
        this.downY = opts.downY;
        this.shouldSkipSlopCheck = !!opts.shouldSkipSlopCheck;
        this.onBeginDragFn = opts.onBeginDragFn || (function () { });
        this.onDragFn = opts.onDragFn || (function () { });
        this.onDropFn = opts.onDropFn || (function () { });
        this.isDragging = false;
        this.draggingScrim = undefined;
        this.draggingCursor = opts.draggingCursor || 'grabbing';
        var mouseMoveHandlerFn = function (event) {
            if (!_this.isDragging && _this.shouldBeginDragging(event)) {
                _this.isDragging = true;
                _this.draggingScrim = _this.buildDraggingScrim().appendTo(document.body);
                _this.draggingCursor = _this.draggingCursor_;
                _this.onBeginDragFn(event);
            }
            if (_this.isDragging) {
                _this.onDragFn(event, { x: event.clientX - _this.downX, y: event.clientY - _this.downY });
            }
        };
        var mouseUpHandlerFn = function (event) {
            jquery__WEBPACK_IMPORTED_MODULE_0__(window).off('mousemove', mouseMoveHandlerFn).off('mouseup', mouseUpHandlerFn);
            if (_this.isDragging) {
                _this.onDragFn(event, { x: event.clientX - _this.downX, y: event.clientY - _this.downY });
                _this.onDropFn();
                _this.draggingScrim.remove();
                _this.draggingScrim = undefined;
                _this.isDragging = false;
                event.stopPropagation();
                event.preventDefault();
                return false;
            }
            return undefined;
        };
        jquery__WEBPACK_IMPORTED_MODULE_0__(window).on('mousemove', mouseMoveHandlerFn).on('mouseup', mouseUpHandlerFn);
    }
    Dragger.prototype.shouldBeginDragging = function (mouseMoveEvent) {
        if (this.shouldSkipSlopCheck) {
            return true;
        }
        var begin = false;
        if (this.direction === 'both' || this.direction === 'horizontal') {
            begin = begin || Math.abs(mouseMoveEvent.clientX - this.downX) > DRAG_SLOP_PIXELS;
        }
        if (this.direction === 'both' || this.direction === 'vertical') {
            begin = begin || Math.abs(mouseMoveEvent.clientY - this.downY) > DRAG_SLOP_PIXELS;
        }
        return begin;
    };
    Object.defineProperty(Dragger.prototype, "draggingCursor", {
        set: function (cursor) {
            if (cursor === 'grabbing') {
                cursor = "-webkit-" + cursor;
            }
            this.draggingCursor_ = cursor;
            if (this.draggingScrim) {
                this.draggingScrim.css({ cursor: cursor });
            }
        },
        enumerable: true,
        configurable: true
    });
    Dragger.prototype.buildDraggingScrim = function () {
        return jquery__WEBPACK_IMPORTED_MODULE_0__('<div>').css({
            position: 'fixed',
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            zIndex: 9999,
        });
    };
    return Dragger;
}());



/***/ }),

/***/ "./src/app/modules/editor/scripts/dragger/index.ts":
/*!*********************************************************!*\
  !*** ./src/app/modules/editor/scripts/dragger/index.ts ***!
  \*********************************************************/
/*! exports provided: Dragger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Dragger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dragger */ "./src/app/modules/editor/scripts/dragger/Dragger.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Dragger", function() { return _Dragger__WEBPACK_IMPORTED_MODULE_0__["Dragger"]; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/export/AvdSerializer.ts":
/*!****************************************************************!*\
  !*** ./src/app/modules/editor/scripts/export/AvdSerializer.ts ***!
  \****************************************************************/
/*! exports provided: toVectorDrawableXmlString, toAnimatedVectorDrawableXmlString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toVectorDrawableXmlString", function() { return toVectorDrawableXmlString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toAnimatedVectorDrawableXmlString", function() { return toAnimatedVectorDrawableXmlString; });
/* harmony import */ var app_modules_editor_model_interpolators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/interpolators */ "./src/app/modules/editor/model/interpolators/index.ts");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/timeline */ "./src/app/modules/editor/model/timeline/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _XmlSerializer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XmlSerializer */ "./src/app/modules/editor/scripts/export/XmlSerializer.ts");





var XMLNS_NS = 'http://www.w3.org/2000/xmlns/';
var ANDROID_NS = 'http://schemas.android.com/apk/res/android';
var AAPT_NS = 'http://schemas.android.com/aapt';
/**
 * Serializes a VectorLayer to a vector drawable XML string.
 */
function toVectorDrawableXmlString(vl) {
    var xmlDoc = document.implementation.createDocument(undefined, 'vector', undefined);
    var rootNode = xmlDoc.documentElement;
    vectorLayerToXmlNode(vl, rootNode, xmlDoc);
    return serializeXmlNode(rootNode);
}
/**
 * Serializes a given VectorLayer and Animation to an animatedvector drawable XML file.
 */
function toAnimatedVectorDrawableXmlString(vl, animation) {
    var xmlDoc = document.implementation.createDocument(undefined, 'animated-vector', undefined);
    var rootNode = xmlDoc.documentElement;
    rootNode.setAttributeNS(XMLNS_NS, 'xmlns:android', ANDROID_NS);
    rootNode.setAttributeNS(XMLNS_NS, 'xmlns:aapt', AAPT_NS);
    // Create drawable node containing the vector layer.
    var vectorLayerContainerNode = xmlDoc.createElementNS(AAPT_NS, 'aapt:attr');
    vectorLayerContainerNode.setAttribute('name', 'android:drawable');
    rootNode.appendChild(vectorLayerContainerNode);
    var vectorLayerNode = xmlDoc.createElement('vector');
    vectorLayerToXmlNode(vl, vectorLayerNode, xmlDoc, false);
    vectorLayerContainerNode.appendChild(vectorLayerNode);
    // create animation nodes (one per layer)
    var animBlocksByLayer = new Map();
    animation.blocks.forEach(function (block) {
        var blocks = animBlocksByLayer.get(block.layerId) || [];
        blocks.push(block);
        animBlocksByLayer.set(block.layerId, blocks);
    });
    animBlocksByLayer.forEach(function (blocksForLayer, layerId) {
        var targetNode = xmlDoc.createElement('target');
        var layer = vl.findLayerById(layerId);
        targetNode.setAttributeNS(ANDROID_NS, 'android:name', layer.name);
        rootNode.appendChild(targetNode);
        var animationNode = xmlDoc.createElementNS(AAPT_NS, 'aapt:attr');
        animationNode.setAttribute('name', 'android:animation');
        targetNode.appendChild(animationNode);
        var blockContainerNode = animationNode;
        if (blocksForLayer.length > 1) {
            // <set> for multiple property animations on a single layer.
            blockContainerNode = xmlDoc.createElement('set');
            animationNode.appendChild(blockContainerNode);
        }
        var animatableProperties = layer.animatableProperties;
        blocksForLayer.forEach(function (block) {
            var blockNode = xmlDoc.createElement('objectAnimator');
            blockNode.setAttributeNS(ANDROID_NS, 'android:propertyName', block.propertyName);
            conditionalAttrFn(blockNode, 'android:startOffset', block.startTime, 0);
            conditionalAttrFn(blockNode, 'android:duration', block.endTime - block.startTime);
            if (block instanceof app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_2__["PathAnimationBlock"]) {
                var fromPath = block.fromValue;
                var toPath = block.toValue;
                conditionalAttrFn(blockNode, 'android:valueFrom', fromPath ? fromPath.getPathString() : '');
                conditionalAttrFn(blockNode, 'android:valueTo', toPath ? toPath.getPathString() : '');
            }
            else {
                conditionalAttrFn(blockNode, 'android:valueFrom', block.fromValue);
                conditionalAttrFn(blockNode, 'android:valueTo', block.toValue);
            }
            conditionalAttrFn(blockNode, 'android:valueType', animatableProperties.get(block.propertyName).getAnimatorValueType());
            var interpolator = lodash__WEBPACK_IMPORTED_MODULE_3__["find"](app_modules_editor_model_interpolators__WEBPACK_IMPORTED_MODULE_0__["INTERPOLATORS"], function (i) { return i.value === block.interpolator; });
            conditionalAttrFn(blockNode, 'android:interpolator', interpolator.androidRef);
            blockContainerNode.appendChild(blockNode);
        });
    });
    return serializeXmlNode(rootNode);
}
/**
 * Helper method that serializes an VectorLayer to a destinationNode in an xmlDoc.
 * The destinationNode should be a <vector> node.
 */
function vectorLayerToXmlNode(vl, destinationNode, xmlDoc, withAndroidNs) {
    if (withAndroidNs === void 0) { withAndroidNs = true; }
    if (withAndroidNs) {
        destinationNode.setAttributeNS(XMLNS_NS, 'xmlns:android', ANDROID_NS);
    }
    conditionalAttrFn(destinationNode, 'android:name', vl.name);
    destinationNode.setAttributeNS(ANDROID_NS, 'android:width', vl.width + "dp");
    destinationNode.setAttributeNS(ANDROID_NS, 'android:height', vl.height + "dp");
    destinationNode.setAttributeNS(ANDROID_NS, 'android:viewportWidth', "" + vl.width);
    destinationNode.setAttributeNS(ANDROID_NS, 'android:viewportHeight', "" + vl.height);
    conditionalAttrFn(destinationNode, 'android:alpha', vl.alpha, 1);
    walk(vl, function (layer, parentNode) {
        if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["VectorLayer"]) {
            return parentNode;
        }
        else if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["PathLayer"]) {
            var node = xmlDoc.createElement('path');
            var path = layer.pathData;
            conditionalAttrFn(node, 'android:name', layer.name);
            conditionalAttrFn(node, 'android:pathData', path ? path.getPathString() : '');
            conditionalAttrFn(node, 'android:fillColor', layer.fillColor, '');
            conditionalAttrFn(node, 'android:fillAlpha', layer.fillAlpha, 1);
            conditionalAttrFn(node, 'android:strokeColor', layer.strokeColor, '');
            conditionalAttrFn(node, 'android:strokeAlpha', layer.strokeAlpha, 1);
            conditionalAttrFn(node, 'android:strokeWidth', layer.strokeWidth, 0);
            conditionalAttrFn(node, 'android:trimPathStart', layer.trimPathStart, 0);
            conditionalAttrFn(node, 'android:trimPathEnd', layer.trimPathEnd, 1);
            conditionalAttrFn(node, 'android:trimPathOffset', layer.trimPathOffset, 0);
            conditionalAttrFn(node, 'android:strokeLineCap', layer.strokeLinecap, 'butt');
            conditionalAttrFn(node, 'android:strokeLineJoin', layer.strokeLinejoin, 'miter');
            conditionalAttrFn(node, 'android:strokeMiterLimit', layer.strokeMiterLimit, 4);
            conditionalAttrFn(node, 'android:fillType', layer.fillType, 'nonZero');
            parentNode.appendChild(node);
            return parentNode;
        }
        else if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["ClipPathLayer"]) {
            var node = xmlDoc.createElement('clip-path');
            var path = layer.pathData;
            conditionalAttrFn(node, 'android:name', layer.name);
            conditionalAttrFn(node, 'android:pathData', path ? path.getPathString() : '');
            parentNode.appendChild(node);
            return parentNode;
        }
        else if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["GroupLayer"]) {
            var node = xmlDoc.createElement('group');
            conditionalAttrFn(node, 'android:name', layer.name);
            conditionalAttrFn(node, 'android:pivotX', layer.pivotX, 0);
            conditionalAttrFn(node, 'android:pivotY', layer.pivotY, 0);
            conditionalAttrFn(node, 'android:translateX', layer.translateX, 0);
            conditionalAttrFn(node, 'android:translateY', layer.translateY, 0);
            conditionalAttrFn(node, 'android:scaleX', layer.scaleX, 1);
            conditionalAttrFn(node, 'android:scaleY', layer.scaleY, 1);
            conditionalAttrFn(node, 'android:rotation', layer.rotation, 0);
            parentNode.appendChild(node);
            return node;
        }
    }, destinationNode);
}
function conditionalAttrFn(node, attr, value, skipValue) {
    if (!lodash__WEBPACK_IMPORTED_MODULE_3__["isNil"](value) && (skipValue === undefined || value !== skipValue)) {
        node.setAttributeNS(ANDROID_NS, attr, value);
    }
}
function serializeXmlNode(xmlNode) {
    return _XmlSerializer__WEBPACK_IMPORTED_MODULE_4__["serializeToString"](xmlNode, { indent: 4, multiAttributeIndent: 4 });
}
function walk(layer, fn, context) {
    var visitFn = function (l, ctx) {
        var childCtx = fn(l, ctx);
        if (l.children) {
            l.children.forEach(function (child) { return visitFn(child, childCtx); });
        }
    };
    visitFn(layer, context);
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/export/SpriteSerializer.ts":
/*!*******************************************************************!*\
  !*** ./src/app/modules/editor/scripts/export/SpriteSerializer.ts ***!
  \*******************************************************************/
/*! exports provided: createHtml, createCss, createSvgFrames, createSvgSprite */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHtml", function() { return createHtml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCss", function() { return createCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSvgFrames", function() { return createSvgFrames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSvgSprite", function() { return createSvgSprite; });
/* harmony import */ var app_modules_editor_scripts_animator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/animator */ "./src/app/modules/editor/scripts/animator/index.ts");
/* harmony import */ var app_modules_editor_scripts_svgo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/svgo */ "./src/app/modules/editor/scripts/svgo/index.ts");
/* harmony import */ var _SvgSerializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SvgSerializer */ "./src/app/modules/editor/scripts/export/SvgSerializer.ts");



function createHtml(svgFileName, cssFileName) {
    return "<html>\n<head>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"" + cssFileName + "\"/>\n</head>\n<body>\n  <div class=\"shapeshifter play\" style=\"background-image: url(" + svgFileName + ")\"></div>\n</body>\n</html>\n";
}
function createCss(width, height, duration, numSteps) {
    return (createKeyframes(width, numSteps) +
        ("\n.shapeshifter {\n  animation-duration: " + duration + "ms;\n  animation-timing-function: steps(" + numSteps + ");\n  width: " + width + "px;\n  height: " + height + "px;\n  background-repeat: no-repeat;\n}\n.shapeshifter.play {\n  animation-name: play" + numSteps + ";\n}\n"));
}
function createKeyframes(width, numSteps) {
    return "@keyframes play" + numSteps + " {\n  0% {\n    background-position: 0px 0px;\n  }\n  100% {\n    background-position: -" + numSteps * width + "px 0px;\n  }\n}";
}
function createSvgFrames(vectorLayer, animation, numSteps) {
    var renderer = new app_modules_editor_scripts_animator__WEBPACK_IMPORTED_MODULE_0__["AnimationRenderer"](vectorLayer, animation);
    var svgs = [];
    var width = vectorLayer.width, height = vectorLayer.height;
    for (var i = 0; i <= numSteps; i++) {
        var time = (i / numSteps) * animation.duration;
        svgs.push(_SvgSerializer__WEBPACK_IMPORTED_MODULE_2__["toSvgString"](renderer.setCurrentTime(time), width, height));
    }
    return svgs;
}
function createSvgSprite(vectorLayer, animation, numSteps) {
    var renderer = new app_modules_editor_scripts_animator__WEBPACK_IMPORTED_MODULE_0__["AnimationRenderer"](vectorLayer, animation);
    var svgs = [];
    var width = vectorLayer.width, height = vectorLayer.height;
    for (var i = 0; i <= numSteps; i++) {
        var time = (i / numSteps) * animation.duration;
        var vl = renderer.setCurrentTime(time);
        svgs.push(_SvgSerializer__WEBPACK_IMPORTED_MODULE_2__["toSvgSpriteFrameString"](vl, width * i, 0, i.toString()));
    }
    var totalWidth = width * numSteps + width;
    var svg = "<svg xmlns=\"http://www.w3.org/2000/svg\" " +
        ("viewBox=\"0 0 " + totalWidth + " " + height + "\" width=\"" + totalWidth + "\" height=\"" + height + "\">\n" + svgs.join('\n') + "\n</svg>\n");
    return Object(app_modules_editor_scripts_svgo__WEBPACK_IMPORTED_MODULE_1__["optimizeSvg"])(svg, false);
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/export/SvgSerializer.ts":
/*!****************************************************************!*\
  !*** ./src/app/modules/editor/scripts/export/SvgSerializer.ts ***!
  \****************************************************************/
/*! exports provided: toSvgString, toSvgSpriteFrameString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSvgString", function() { return toSvgString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSvgSpriteFrameString", function() { return toSvgSpriteFrameString; });
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _XmlSerializer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./XmlSerializer */ "./src/app/modules/editor/scripts/export/XmlSerializer.ts");




var XMLNS_NS = 'http://www.w3.org/2000/xmlns/';
var SVG_NS = 'http://www.w3.org/2000/svg';
/**
 * Serializes an VectorLayer to a SVG string.
 */
function toSvgString(vl, width, height) {
    var xmlDoc = document.implementation.createDocument(undefined, 'svg', undefined);
    var rootNode = xmlDoc.documentElement;
    rootNode.setAttributeNS(XMLNS_NS, 'xmlns', SVG_NS);
    rootNode.setAttributeNS(undefined, 'viewBox', "0 0 " + vl.width + " " + vl.height);
    vectorLayerToSvgNode(vl, rootNode, xmlDoc);
    if (width !== undefined) {
        rootNode.setAttributeNS(undefined, 'width', width.toString());
    }
    if (height !== undefined) {
        rootNode.setAttributeNS(undefined, 'height', height.toString());
    }
    return serializeXmlNode(rootNode);
}
function toSvgSpriteFrameString(vectorLayer, translateX, translateY, frameNumber) {
    if (translateX === void 0) { translateX = 0; }
    if (translateY === void 0) { translateY = 0; }
    if (frameNumber === void 0) { frameNumber = ''; }
    var xmlDoc = document.implementation.createDocument(undefined, 'g', undefined);
    var rootNode = xmlDoc.documentElement;
    vectorLayerToSvgNode(vectorLayer, rootNode, xmlDoc, false, frameNumber);
    rootNode.setAttributeNS(undefined, 'transform', "translate(" + translateX + ", " + translateY + ")");
    return serializeXmlNode(rootNode);
}
/**
 * Helper method that serializes a VectorLayer to a destinationNode in an xmlDoc.
 * The destinationNode should be a <vector> node.
 */
function vectorLayerToSvgNode(vl, destinationNode, xmlDoc, withIds, frameNumber) {
    if (withIds === void 0) { withIds = true; }
    if (frameNumber === void 0) { frameNumber = ''; }
    // Create a map where the keys are ClipPathLayer IDs and the values
    // are their associated path data strings.
    var clipPathToPathDataMap = new Map();
    // Create a map where the keys are non-ClipPathLayer IDs and the values are
    // the in-order list of ClipPathLayers that are clipping the layer (nearest
    // ClipPathLayer appears in the list last).
    var clippedLayerToSeenClipPathsMap = new Map();
    (function recurseFn(layer) {
        layer.children
            .reduce(function (acc, curr) {
            var seenClipPaths = acc.length ? lodash__WEBPACK_IMPORTED_MODULE_2__["last"](acc).seenClipPaths.slice() : [];
            // Ignore clip paths with empty path data strings.
            if (curr instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["ClipPathLayer"] && curr.pathData && curr.pathData.getPathString()) {
                clipPathToPathDataMap.set(curr.id, curr.pathData.getPathString());
                seenClipPaths.push(curr);
            }
            return acc.concat([{ layer: curr, seenClipPaths: seenClipPaths }]);
        }, [])
            .filter(function (_a) {
            var l = _a.layer, seenClipPaths = _a.seenClipPaths;
            // Keep the entry if the key isn't a ClipPathLayer and its
            // associated list of seen clip paths isn't empty.
            return !(l instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["ClipPathLayer"]) && seenClipPaths.length > 0;
        })
            .map(function (_a) {
            var l = _a.layer, seenClipPaths = _a.seenClipPaths;
            return { layerId: l.id, seenClipPaths: seenClipPaths.map(function (_a) {
                    var id = _a.id;
                    return id;
                }) };
        })
            .forEach(function (_a) {
            var layerId = _a.layerId, seenClipPaths = _a.seenClipPaths;
            clippedLayerToSeenClipPathsMap.set(layerId, seenClipPaths);
        });
        layer.children.forEach(recurseFn);
    })(vl);
    // Create a map where the keys are non-ClipPathLayer IDs and the values are the
    // clip path names they should use when referencing the clip-path.
    var clippedLayerToClipPathNameMap = new Map();
    clippedLayerToSeenClipPathsMap.forEach(function (seenClipPaths, layerId) {
        var frameInfo = frameNumber ? "_frame" + frameNumber : '';
        var layerInfo = "_" + vl.findLayerById(layerId).name;
        var clipPathName = "clip" + frameInfo + layerInfo;
        clippedLayerToClipPathNameMap.set(layerId, clipPathName);
    });
    var shouldCreateDefs = clippedLayerToSeenClipPathsMap.size > 0;
    if (shouldCreateDefs) {
        var defsNode_1 = xmlDoc.createElement('defs');
        clippedLayerToSeenClipPathsMap.forEach(function (seenClipPaths, layerId) {
            var clipPathName = clippedLayerToClipPathNameMap.get(layerId);
            seenClipPaths.forEach(function (id, i) {
                var clipPathNode = xmlDoc.createElement('clipPath');
                conditionalAttr(clipPathNode, 'id', clipPathName + (i ? '_' + i : ''));
                var pathNode = xmlDoc.createElement('path');
                conditionalAttr(pathNode, 'd', clipPathToPathDataMap.get(id));
                if (i + 1 < seenClipPaths.length) {
                    // Build the intersection of all seen clip paths.
                    var nextClipPathName = clipPathName + '_' + (i + 1);
                    conditionalAttr(pathNode, 'clip-path', "url(#" + nextClipPathName + ")");
                }
                clipPathNode.appendChild(pathNode);
                defsNode_1.appendChild(clipPathNode);
            });
        });
        destinationNode.appendChild(defsNode_1);
    }
    var isLayerBeingClippedFn = function (layerId) { return clippedLayerToClipPathNameMap.has(layerId); };
    var maybeSetClipPathForLayerFn = function (node, layerId) {
        if (isLayerBeingClippedFn(layerId)) {
            conditionalAttr(node, 'clip-path', "url(#" + clippedLayerToClipPathNameMap.get(layerId) + ")");
        }
    };
    walk(vl, function (layer, parentNode) {
        if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["VectorLayer"]) {
            if (withIds) {
                conditionalAttr(destinationNode, 'id', vl.name, '');
            }
            conditionalAttr(destinationNode, 'opacity', vl.alpha, 1);
            return parentNode;
        }
        if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["PathLayer"]) {
            var pathData = layer.pathData;
            if (!pathData || !pathData.getPathString()) {
                return undefined;
            }
            var node = xmlDoc.createElement('path');
            if (withIds) {
                conditionalAttr(node, 'id', layer.name);
            }
            maybeSetClipPathForLayerFn(node, layer.id);
            conditionalAttr(node, 'd', pathData.getPathString());
            if (layer.fillColor) {
                conditionalAttr(node, 'fill', app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["ColorUtil"].androidToCssHexColor(layer.fillColor), '');
            }
            else {
                conditionalAttr(node, 'fill', 'none');
            }
            conditionalAttr(node, 'fill-opacity', layer.fillAlpha, 1);
            if (layer.strokeColor) {
                conditionalAttr(node, 'stroke', app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["ColorUtil"].androidToCssHexColor(layer.strokeColor), '');
            }
            conditionalAttr(node, 'stroke-opacity', layer.strokeAlpha, 1);
            conditionalAttr(node, 'stroke-width', layer.strokeWidth, 0);
            if (layer.trimPathStart !== 0 || layer.trimPathEnd !== 1 || layer.trimPathOffset !== 0) {
                var flattenedTransform = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["LayerUtil"].getCanvasTransformForLayer(vl, layer.id);
                var a = flattenedTransform.a, d = flattenedTransform.d;
                // Note that we only return the length of the first sub path due to
                // https://code.google.com/p/android/issues/detail?id=172547
                var pathLength = void 0;
                if (Math.abs(a) !== 1 || Math.abs(d) !== 1) {
                    // Then recompute the scaled path length.
                    pathLength = pathData
                        .mutate()
                        .transform(flattenedTransform)
                        .build()
                        .getSubPathLength(0);
                }
                else {
                    pathLength = pathData.getSubPathLength(0);
                }
                var strokeDashArray = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["LayerUtil"].toStrokeDashArray(layer.trimPathStart, layer.trimPathEnd, layer.trimPathOffset, pathLength).join(',');
                var strokeDashOffset = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["LayerUtil"].toStrokeDashOffset(layer.trimPathStart, layer.trimPathEnd, layer.trimPathOffset, pathLength).toString();
                conditionalAttr(node, 'stroke-dasharray', strokeDashArray);
                conditionalAttr(node, 'stroke-dashoffset', strokeDashOffset);
            }
            conditionalAttr(node, 'stroke-linecap', layer.strokeLinecap, 'butt');
            conditionalAttr(node, 'stroke-linejoin', layer.strokeLinejoin, 'miter');
            conditionalAttr(node, 'stroke-miterlimit', layer.strokeMiterLimit, 4);
            var fillRule = !layer.fillType || layer.fillType === 'nonZero' ? 'nonzero' : 'evenodd';
            conditionalAttr(node, 'fill-rule', fillRule, 'nonzero');
            parentNode.appendChild(node);
            return parentNode;
        }
        if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["GroupLayer"]) {
            var node = xmlDoc.createElement('g');
            if (withIds) {
                conditionalAttr(node, 'id', layer.name);
            }
            var transformValues = [];
            if (layer.translateX || layer.translateY) {
                transformValues.push("translate(" + layer.translateX + " " + layer.translateY + ")");
            }
            if (layer.rotation) {
                transformValues.push("rotate(" + layer.rotation + " " + layer.pivotX + " " + layer.pivotY + ")");
            }
            if (layer.scaleX !== 1 || layer.scaleY !== 1) {
                if (layer.pivotX || layer.pivotY) {
                    transformValues.push("translate(" + layer.pivotX + " " + layer.pivotY + ")");
                }
                transformValues.push("scale(" + layer.scaleX + " " + layer.scaleY + ")");
                if (layer.pivotX || layer.pivotY) {
                    transformValues.push("translate(" + -layer.pivotX + " " + -layer.pivotY + ")");
                }
            }
            var nodeToAttachToParent = node;
            if (transformValues.length) {
                node.setAttributeNS(undefined, 'transform', transformValues.join(' '));
                if (isLayerBeingClippedFn(layer.id)) {
                    // Create a wrapper node so that the clip-path is applied before the transformations.
                    var wrapperNode = xmlDoc.createElement('g');
                    wrapperNode.appendChild(node);
                    nodeToAttachToParent = wrapperNode;
                }
            }
            maybeSetClipPathForLayerFn(nodeToAttachToParent, layer.id);
            parentNode.appendChild(nodeToAttachToParent);
            return node;
        }
        return undefined;
    }, destinationNode);
}
function conditionalAttr(node, attr, value, skipValue) {
    if (!lodash__WEBPACK_IMPORTED_MODULE_2__["isNil"](value) && (skipValue === undefined || value !== skipValue)) {
        node.setAttributeNS(undefined, attr, value.toString());
    }
}
function serializeXmlNode(xmlNode) {
    return _XmlSerializer__WEBPACK_IMPORTED_MODULE_3__["serializeToString"](xmlNode, { indent: 4, multiAttributeIndent: 4 });
}
function walk(layer, fn, context) {
    var visitFn = function (l, ctx) {
        var childCtx = fn(l, ctx);
        if (l.children) {
            l.children.forEach(function (child) { return visitFn(child, childCtx); });
        }
    };
    visitFn(layer, context);
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/export/XmlSerializer.ts":
/*!****************************************************************!*\
  !*** ./src/app/modules/editor/scripts/export/XmlSerializer.ts ***!
  \****************************************************************/
/*! exports provided: serializeToString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serializeToString", function() { return serializeToString; });
function serializeToString(node, options) {
    options = options || {};
    options.rootNode = true;
    return removeInvalidCharacters(nodeTreeToXHTML(node, options));
}
function removeInvalidCharacters(content) {
    // See http://www.w3.org/TR/xml/#NT-Char for valid XML 1.0 characters.
    return content.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');
}
function serializeAttributeValue(value) {
    return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
}
function serializeTextContent(content) {
    return content
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}
function serializeAttribute(attr) {
    var value = attr.value;
    return attr.name + '="' + serializeAttributeValue(value) + '"';
}
function getTagName(node) {
    var tagName = node.tagName;
    // Aid in serializing of original HTML documents.
    if (node.namespaceURI === 'http://www.w3.org/1999/xhtml') {
        tagName = tagName.toLowerCase();
    }
    return tagName;
}
function serializeNamespace(node, options) {
    var nodeHasXmlnsAttr = Array.prototype.map
        .call(node.attributes || node.attrs, function (attr) {
        return attr.name;
    })
        .indexOf('xmlns') >= 0;
    // Serialize the namespace as an xmlns attribute whenever the element
    // doesn't already have one and the inherited namespace does not match
    // the element's namespace.
    if (!nodeHasXmlnsAttr &&
        node.namespaceURI &&
        options.isRootNode /* ||
         node.namespaceURI !== node.parentNode.namespaceURI*/) {
        return ' xmlns="' + node.namespaceURI + '"';
    }
    return '';
}
function serializeChildren(node, options) {
    return Array.prototype.map
        .call(node.childNodes, function (childNode) {
        return nodeTreeToXHTML(childNode, options);
    })
        .join('');
}
function serializeTag(node, options) {
    var output = '';
    if (options.indent && options._indentLevel) {
        output += Array(options._indentLevel * options.indent + 1).join(' ');
    }
    output += '<' + getTagName(node);
    output += serializeNamespace(node, options.isRootNode);
    var attributes = node.attributes || node.attrs;
    Array.prototype.forEach.call(attributes, function (attr) {
        if (options.multiAttributeIndent && attributes.length > 1) {
            output += '\n';
            output += Array((options._indentLevel || 0) * options.indent + options.multiAttributeIndent + 1).join(' ');
        }
        else {
            output += ' ';
        }
        output += serializeAttribute(attr);
    });
    if (node.childNodes.length > 0) {
        output += '>';
        if (options.indent) {
            output += '\n';
        }
        options.isRootNode = false;
        options._indentLevel = (options._indentLevel || 0) + 1;
        output += serializeChildren(node, options);
        --options._indentLevel;
        if (options.indent && options._indentLevel) {
            output += Array(options._indentLevel * options.indent + 1).join(' ');
        }
        output += '</' + getTagName(node) + '>';
    }
    else {
        output += '/>';
    }
    if (options.indent) {
        output += '\n';
    }
    return output;
}
function serializeText(node) {
    var text = node.nodeValue || node.value || '';
    return serializeTextContent(text);
}
function serializeComment(node) {
    return '<!--' + node.data.replace(/-/g, '&#45;') + '-->';
}
function serializeCDATA(node) {
    return '<![CDATA[' + node.nodeValue + ']]>';
}
function nodeTreeToXHTML(node, options) {
    if (node.nodeName === '#document' || node.nodeName === '#document-fragment') {
        return serializeChildren(node, options);
    }
    else {
        if (node.tagName) {
            return serializeTag(node, options);
        }
        else if (node.nodeName === '#text') {
            return serializeText(node);
        }
        else if (node.nodeName === '#comment') {
            return serializeComment(node);
        }
        else if (node.nodeName === '#cdata-section') {
            return serializeCDATA(node);
        }
    }
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/export/index.ts":
/*!********************************************************!*\
  !*** ./src/app/modules/editor/scripts/export/index.ts ***!
  \********************************************************/
/*! exports provided: AvdSerializer, SpriteSerializer, SvgSerializer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AvdSerializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AvdSerializer */ "./src/app/modules/editor/scripts/export/AvdSerializer.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "AvdSerializer", function() { return _AvdSerializer__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _SpriteSerializer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SpriteSerializer */ "./src/app/modules/editor/scripts/export/SpriteSerializer.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "SpriteSerializer", function() { return _SpriteSerializer__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _SvgSerializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SvgSerializer */ "./src/app/modules/editor/scripts/export/SvgSerializer.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "SvgSerializer", function() { return _SvgSerializer__WEBPACK_IMPORTED_MODULE_2__; });






/***/ }),

/***/ "./src/app/modules/editor/scripts/import/SvgLoader.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/scripts/import/SvgLoader.ts ***!
  \************************************************************/
/*! exports provided: loadVectorLayerFromSvgString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadVectorLayerFromSvgString", function() { return loadVectorLayerFromSvgString; });
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paths */ "./src/app/modules/editor/model/paths/index.ts");
/* harmony import */ var app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/properties */ "./src/app/modules/editor/model/properties/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_svgo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/svgo */ "./src/app/modules/editor/scripts/svgo/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_5__);






// TODO: trim ids/strings?
// TODO: check for invalid enum values
/**
 * Utility function that takes an SVG string as input and
 * returns a VectorLayer model object.
 */
function loadVectorLayerFromSvgString(svgString, doesNameExistFn) {
    return Object(app_modules_editor_scripts_svgo__WEBPACK_IMPORTED_MODULE_4__["optimizeSvg"])(svgString).then(function (optimizedSvgString) {
        return new Promise(function (resolve, reject) {
            if (!optimizedSvgString) {
                reject();
                return;
            }
            resolve(loadVectorLayerFromSvgStringInternal(optimizedSvgString, doesNameExistFn));
        });
    });
}
// TODO: give better error message when user attempts to import SVG w/o a namespace declaration
function loadVectorLayerFromSvgStringInternal(svgString, doesNameExistFn) {
    var usedIds = new Set();
    var makeFinalNodeIdFn = function (nodeId, prefix) {
        var finalName = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["LayerUtil"].getUniqueName(app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["NameProperty"].sanitize(nodeId || prefix), function (name) { return doesNameExistFn(name) || usedIds.has(name); });
        usedIds.add(finalName);
        return finalName;
    };
    var parser = new DOMParser();
    var documentElement = parser.parseFromString(svgString, 'image/svg+xml').documentElement;
    if (!isSvgNode(documentElement)) {
        return undefined;
    }
    // TODO: handle clipPaths that have children path elements with clip-path attributes
    // TODO: handle clipPaths with clipPathUnits="objectBoundingBox"
    // TODO: confirm that clipPath transforms (and any referenced transforms) are handled correctly
    var clipPathMap = lodash__WEBPACK_IMPORTED_MODULE_5__["mapValues"](buildPathInfosMap(documentElement), function (infos) {
        return infos.map(function (info) { return info.path; });
    });
    var nodeToLayerFn = function (node, transforms) {
        if (!node ||
            node.nodeType === Node.TEXT_NODE ||
            node.nodeType === Node.COMMENT_NODE ||
            node instanceof SVGDefsElement ||
            node instanceof SVGUseElement) {
            return undefined;
        }
        var nodeTransforms = getNodeTransforms(node);
        transforms = transforms.concat(nodeTransforms);
        var flattenedTransforms = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["Matrix"].flatten(transforms);
        // Get the referenced clip-path ID, if one exists.
        var refClipPathId = getReferencedClipPathId(node);
        var maybeWrapClipPathInGroupFn = function (layer) {
            if (!refClipPathId) {
                return layer;
            }
            var paths = (clipPathMap[refClipPathId] || []).map(function (p) {
                return new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"](p
                    .mutate()
                    .transform(flattenedTransforms)
                    .build()
                    .getPathString());
            });
            if (!paths.length) {
                // If the clipPath has no children, then clip the entire layer.
                paths.push(new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"]('M 0 0 Z'));
            }
            var groupChildren = paths.map(function (p) {
                return new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["ClipPathLayer"]({
                    name: makeFinalNodeIdFn(refClipPathId, 'mask'),
                    pathData: p,
                    children: [],
                });
            });
            groupChildren.push(layer);
            return new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["GroupLayer"]({
                name: makeFinalNodeIdFn('wrapper', 'group'),
                children: groupChildren,
            });
        };
        if (node instanceof SVGPathElement && node.getAttribute('d')) {
            var path = node.getAttribute('d');
            var attrMap_1 = {};
            var simpleAttrFn = function (nodeAttr, contextAttr) {
                if (node.hasAttribute(nodeAttr)) {
                    attrMap_1[contextAttr] = node.getAttribute(nodeAttr);
                }
            };
            simpleAttrFn('stroke', 'strokeColor');
            simpleAttrFn('stroke-width', 'strokeWidth');
            simpleAttrFn('stroke-linecap', 'strokeLinecap');
            simpleAttrFn('stroke-linejoin', 'strokeLinejoin');
            simpleAttrFn('stroke-miterlimit', 'strokeMiterLimit');
            simpleAttrFn('stroke-opacity', 'strokeAlpha');
            simpleAttrFn('fill', 'fillColor');
            simpleAttrFn('fill-opacity', 'fillAlpha');
            simpleAttrFn('fill-rule', 'fillType');
            // Set the default values as specified by the SVG spec. Note that some of these default
            // values are different than the default values used by VectorDrawables.
            var fillColor = 'fillColor' in attrMap_1 ? app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["ColorUtil"].svgToAndroidColor(attrMap_1['fillColor']) : '#000';
            var strokeColor = 'strokeColor' in attrMap_1 ? app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["ColorUtil"].svgToAndroidColor(attrMap_1['strokeColor']) : undefined;
            var fillAlpha = 'fillAlpha' in attrMap_1 ? Number(attrMap_1['fillAlpha']) : 1;
            var strokeWidth = 'strokeWidth' in attrMap_1 ? Number(attrMap_1['strokeWidth']) : 1;
            var strokeAlpha = 'strokeAlpha' in attrMap_1 ? Number(attrMap_1['strokeAlpha']) : 1;
            var strokeLinecap = 'strokeLinecap' in attrMap_1 ? attrMap_1['strokeLinecap'] : 'butt';
            var strokeLinejoin = 'strokeLinejoin' in attrMap_1 ? attrMap_1['strokeLinecap'] : 'miter';
            var strokeMiterLimit = 'strokeMiterLimit' in attrMap_1 ? Number(attrMap_1['strokeMiterLimit']) : 4;
            var fillRuleToFillTypeFn = function (fillRule) {
                return fillRule === 'evenodd' ? 'evenOdd' : 'nonZero';
            };
            var fillType = 'fillType' in attrMap_1 ? fillRuleToFillTypeFn(attrMap_1['fillType']) : 'nonZero';
            var pathData = new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"](path);
            if (transforms.length) {
                pathData = new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"](pathData
                    .mutate()
                    .transform(flattenedTransforms)
                    .build()
                    .getPathString());
                strokeWidth = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["MathUtil"].round(strokeWidth * flattenedTransforms.getScaleFactor());
            }
            // TODO: make best effort attempt to restore trimPath{Start,End,Offset}
            return maybeWrapClipPathInGroupFn(new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["PathLayer"]({
                id: lodash__WEBPACK_IMPORTED_MODULE_5__["uniqueId"](),
                name: makeFinalNodeIdFn(node.getAttribute('id'), 'path'),
                children: [],
                pathData: pathData,
                fillColor: fillColor,
                fillAlpha: fillAlpha,
                strokeColor: strokeColor,
                strokeAlpha: strokeAlpha,
                strokeWidth: strokeWidth,
                strokeLinecap: strokeLinecap,
                strokeLinejoin: strokeLinejoin,
                strokeMiterLimit: strokeMiterLimit,
                fillType: fillType,
            }));
        }
        // TODO: we should *not* iterate over a clip path's children here...
        if (node.childNodes) {
            var children = [];
            for (var i = 0; i < node.childNodes.length; i++) {
                var child = node.childNodes.item(i);
                var layer = nodeToLayerFn(child, transforms);
                if (layer) {
                    children.push(layer);
                }
            }
            return maybeWrapClipPathInGroupFn(new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["GroupLayer"]({
                id: lodash__WEBPACK_IMPORTED_MODULE_5__["uniqueId"](),
                name: makeFinalNodeIdFn(node.getAttribute('id'), 'group'),
                children: children,
            }));
        }
        return undefined;
    };
    var toNumberFn = function (num) { return (num === undefined ? undefined : Number(num)); };
    var width = toNumberFn(svgLengthToPx(documentElement.width) || undefined);
    var height = toNumberFn(svgLengthToPx(documentElement.height) || undefined);
    var alpha = toNumberFn(documentElement.getAttribute('opacity') || undefined);
    var rootTransforms = [];
    var viewBox = documentElement.viewBox;
    if (viewBox && (!!viewBox.baseVal.width || !!viewBox.baseVal.height)) {
        width = viewBox.baseVal.width;
        height = viewBox.baseVal.height;
        // Fake a translate transform for the viewbox.
        rootTransforms.push(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["Matrix"].translation(-viewBox.baseVal.x, -viewBox.baseVal.y));
    }
    var rootLayer = nodeToLayerFn(documentElement, rootTransforms);
    return new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["VectorLayer"]({
        id: lodash__WEBPACK_IMPORTED_MODULE_5__["uniqueId"](),
        name: makeFinalNodeIdFn(documentElement.getAttribute('id'), 'vector'),
        children: rootLayer ? rootLayer.children : undefined,
        width: width,
        height: height,
        alpha: alpha,
    });
}
function svgLengthToPx(svgLength) {
    if (!svgLength) {
        return 0;
    }
    if (svgLength.baseVal) {
        svgLength = svgLength.baseVal;
    }
    svgLength.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);
    return svgLength.valueInSpecifiedUnits;
}
function isSvgNode(node) {
    return node.nodeName === 'svg';
}
/**
 * Returns a list of transform matricies assigned to the specified node.
 */
function getNodeTransforms(node) {
    if (!node.transform) {
        return [];
    }
    var transformList = node.transform.baseVal;
    var matrices = [];
    for (var i = 0; i < transformList.numberOfItems; i++) {
        var _a = transformList.getItem(i).matrix, a = _a.a, b = _a.b, c = _a.c, d = _a.d, e = _a.e, f = _a.f;
        matrices.push(new app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["Matrix"](a, b, c, d, e, f));
    }
    return matrices;
}
/**
 * Returns the name of the referenced ID assigned to the clip-path attribute,
 * if one exists.
 */
function getReferencedClipPathId(node) {
    if (!node.getAttribute('clip-path')) {
        return undefined;
    }
    var clipPathAttr = node.getAttribute('clip-path').trim();
    if (!clipPathAttr || !clipPathAttr.startsWith('url(#')) {
        return undefined;
    }
    var endParenIndex = clipPathAttr.indexOf(')');
    if (endParenIndex !== clipPathAttr.length - 1) {
        return undefined;
    }
    return clipPathAttr.slice('url(#'.length, endParenIndex);
}
/**
 * Builds a map of clip path IDs to their corresponding clip path nodes.
 */
function buildClipPathIdMap(rootNode) {
    var clipPathIdMap = {};
    (function recurseFn(node) {
        if (node instanceof SVGClipPathElement) {
            var clipPathId = node.getAttribute('id');
            if (clipPathId) {
                clipPathIdMap[clipPathId] = node;
            }
            return;
        }
        if (node && node.childNodes) {
            for (var i = 0; i < node.childNodes.length; i++) {
                recurseFn(node.childNodes.item(i));
            }
        }
    })(rootNode);
    return clipPathIdMap;
}
/**
 * Builds a list of path info objects for the specified clip path element.
 */
function buildPathInfosForClipPath(node) {
    // TODO: make sure that transforms from parent clip-paths aren't inherited...
    var clipPathTransforms = getNodeTransforms(node).reverse();
    var pathInfos = [];
    if (node.childNodes) {
        for (var i = 0; i < node.childNodes.length; i++) {
            var childNode = node.childNodes.item(i);
            if (childNode instanceof SVGPathElement && childNode.getAttribute('d')) {
                var pathStr = childNode.getAttribute('d');
                var pathTransforms = getNodeTransforms(childNode).reverse();
                var transforms = pathTransforms.concat(clipPathTransforms);
                var refClipPathId = getReferencedClipPathId(childNode);
                pathInfos.push({
                    refClipPathId: refClipPathId,
                    path: new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"](new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"](pathStr)
                        .mutate()
                        .transform(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["Matrix"].flatten(transforms))
                        .build()
                        .getPathString()),
                });
            }
        }
    }
    return pathInfos;
}
/**
 * Builds a map of clip path IDs to their corresponding path info objects.
 */
function buildPathInfosMap(root) {
    var clipPathInfoMap = lodash__WEBPACK_IMPORTED_MODULE_5__["mapValues"](buildClipPathIdMap(root), function (n) {
        var pathInfos = buildPathInfosForClipPath(n);
        var refClipPathId = getReferencedClipPathId(n);
        return { pathInfos: pathInfos, refClipPathId: refClipPathId };
    });
    var pathInfosMap = {};
    var recurseFn = function (clipPathId) {
        if (pathInfosMap[clipPathId]) {
            // Then the path infos have already been computed.
            return;
        }
        var _a = clipPathInfoMap[clipPathId], pathInfos = _a.pathInfos, refClipPathId = _a.refClipPathId;
        if (!refClipPathId) {
            // Then simply assign the path infos to the clip path id.
            pathInfosMap[clipPathId] = pathInfos;
            return;
        }
        // Then concatenate the clip path's path info objects with its
        // referenced path info objects.
        recurseFn(refClipPathId);
        pathInfosMap[clipPathId] = pathInfos.concat(pathInfosMap[refClipPathId]);
    };
    Object.keys(clipPathInfoMap).forEach(recurseFn);
    return pathInfosMap;
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/import/VectorDrawableLoader.ts":
/*!***********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/import/VectorDrawableLoader.ts ***!
  \***********************************************************************/
/*! exports provided: loadVectorLayerFromXmlString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadVectorLayerFromXmlString", function() { return loadVectorLayerFromXmlString; });
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paths */ "./src/app/modules/editor/model/paths/index.ts");
/* harmony import */ var app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/properties */ "./src/app/modules/editor/model/properties/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_4__);





// import { INTERPOLATORS } from 'app/modules/editor/model/interpolators';
// import { AnimationBlock } from 'app/modules/editor/model/timeline';
function loadVectorLayerFromXmlString(xmlString, doesLayerNameExistFn) {
    var parser = new DOMParser();
    var doc = parser.parseFromString(xmlString, 'application/xml');
    return loadVectorLayerFromElement(doc.documentElement, doesLayerNameExistFn);
}
function loadVectorLayerFromElement(docEl, doesLayerNameExistFn) {
    if (!docEl) {
        return undefined;
    }
    var usedNames = new Set();
    var makeFinalNodeIdFn = function (value, prefix) {
        var finalName = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["LayerUtil"].getUniqueName(app_modules_editor_model_properties__WEBPACK_IMPORTED_MODULE_2__["NameProperty"].sanitize(value || prefix), function (n) { return doesLayerNameExistFn(n) || usedNames.has(n); });
        usedNames.add(finalName);
        return finalName;
    };
    var nodeToLayerDataFn = function (node) {
        if (!isElement(node)) {
            return undefined;
        }
        if (node.tagName === 'path') {
            return new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["PathLayer"]({
                id: lodash__WEBPACK_IMPORTED_MODULE_4__["uniqueId"](),
                name: makeFinalNodeIdFn(node.getAttribute('android:name'), 'path'),
                children: [],
                pathData: getPath(node),
                fillColor: getColor(node, 'fillColor', ''),
                fillAlpha: getNumber(node, 'fillAlpha', '1'),
                strokeColor: getColor(node, 'strokeColor', ''),
                strokeAlpha: getNumber(node, 'strokeAlpha', '1'),
                strokeWidth: getNumber(node, 'strokeWidth', '0'),
                strokeLinecap: get(node, 'strokeLineCap', 'butt'),
                strokeLinejoin: get(node, 'strokeLineJoin', 'miter'),
                strokeMiterLimit: getNumber(node, 'strokeMiterLimit', '4'),
                trimPathStart: getNumber(node, 'trimPathStart', '0'),
                trimPathEnd: getNumber(node, 'trimPathEnd', '1'),
                trimPathOffset: getNumber(node, 'trimPathOffset', '0'),
                fillType: get(node, 'fillType', 'nonZero'),
            });
        }
        if (node.tagName === 'clip-path') {
            return new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["ClipPathLayer"]({
                id: lodash__WEBPACK_IMPORTED_MODULE_4__["uniqueId"](),
                name: makeFinalNodeIdFn(get(node, 'name', ''), 'clip-path'),
                children: [],
                pathData: getPath(node),
            });
        }
        if (node.childNodes.length) {
            var children = Array.from(node.childNodes)
                .map(function (child) { return nodeToLayerDataFn(child); })
                .filter(function (child) { return !!child; });
            if (children && children.length) {
                return new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["GroupLayer"]({
                    id: lodash__WEBPACK_IMPORTED_MODULE_4__["uniqueId"](),
                    name: makeFinalNodeIdFn(get(node, 'name', ''), 'group'),
                    children: children,
                    pivotX: getNumber(node, 'pivotX', '0'),
                    pivotY: getNumber(node, 'pivotY', '0'),
                    rotation: getNumber(node, 'rotation', '0'),
                    scaleX: getNumber(node, 'scaleX', '1'),
                    scaleY: getNumber(node, 'scaleY', '1'),
                    translateX: getNumber(node, 'translateX', '0'),
                    translateY: getNumber(node, 'translateY', '0'),
                });
            }
        }
        return undefined;
    };
    var rootLayer = nodeToLayerDataFn(docEl);
    var name = makeFinalNodeIdFn(get(docEl, 'name', ''), 'vector');
    usedNames.add(name);
    var width = getNumber(docEl, 'viewportWidth', '24');
    var height = getNumber(docEl, 'viewportHeight', '24');
    var alpha = getNumber(docEl, 'alpha', '1');
    return new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["VectorLayer"]({
        id: lodash__WEBPACK_IMPORTED_MODULE_4__["uniqueId"](),
        name: name,
        children: rootLayer ? rootLayer.children : [],
        width: width,
        height: height,
        alpha: alpha,
    });
}
// export function loadAnimationFromXmlString(
//   xmlString: string,
//   animationName: string,
//   doesLayerNameExistFn: (name: string) => boolean) {
//   const parser = new DOMParser();
//   const avdNode = parser.parseFromString(xmlString, 'application/xml').documentElement;
//   const vl =
//     _(Array.from(avdNode.childNodes))
//       .filter(elem => {
//         return isElement(elem)
//           && elem.tagName === 'aapt:attr'
//           && elem.hasAttribute('name')
//           && elem.getAttribute('name') === 'android:drawable';
//       })
//       .map((elem: HTMLElement) => {
//         return _(Array.from(elem.childNodes))
//           .filter(e => isElement(e) && e.tagName === 'vector')
//           .map((e: HTMLElement) => loadVectorLayerFromElement(e, doesLayerNameExistFn))
//           .first();
//       })
//       .first();
//   if (!vl) {
//     return undefined;
//   }
//   const blocks =
//     _(Array.from(avdNode.childNodes))
//       .filter(e => {
//         return isElement(e)
//           && e.tagName === 'target'
//           && !!e.getAttribute('android:name');
//       })
//       .flatMap((targetElem: HTMLElement) => {
//         const targetName = targetElem.getAttribute('android:name');
//         const layerId = vl.findLayerByName(targetName).id;
//         const animElem =
//           _(Array.from(targetElem.childNodes))
//             .filter(elem => {
//               return isElement(elem)
//                 && elem.tagName === 'aapt:attr'
//                 && elem.hasAttribute('name')
//                 && elem.getAttribute('name') === 'android:animation'
//                 && elem.childNodes.length;
//             })
//             .flatMap((elem: HTMLElement) => Array.from(elem.childNodes))
//             .filter(e => isElement(e) && (e.tagName === 'set' || e.tagName === 'objectAnimator'))
//             .map((e: HTMLElement) => {
//               if (e.tagName === 'set') {
//                 // TODO: handle animator set case
//                 return undefined;
//               }
//               // Otherwise it is an object animator.
//               return e;
//             })
//             .first() as HTMLElement;
//         const animationBlocks: AnimationBlock[] = [];
//         const propertyName = get(animElem, 'propertyName');
//         const fromValue = get(animElem, 'valueFrom');
//         const toValue = get(animElem, 'valueTo');
//         // TODO: confirm difference between @android:anim and @android:interpolator
//         // TODO: @android:interpolator/linear doesn't work
//         const interpolatorRef =
//           get(animElem, 'interpolator', '@android:anim/accelerate_decelerate_interpolator');
//         const interpolator = _.find(INTERPOLATORS, i => i.androidRef === interpolatorRef).value;
//         const startTime = Number(get(animElem, 'startOffset'));
//         const endTime = startTime + Number(get(animElem, 'duration'));
//         if (get(animElem, 'valueType') === 'pathType' && propertyName === 'pathData') {
//           animationBlocks.push(AnimationBlock.from({
//             layerId,
//             propertyName,
//             fromValue: new Path(fromValue),
//             toValue: new Path(toValue),
//             startTime,
//             endTime,
//             interpolator,
//             type: 'path',
//           }));
//         } else if (propertyName === 'fillAlpha' || propertyName === 'translateX') {
//           animationBlocks.push(AnimationBlock.from({
//             layerId,
//             propertyName,
//             fromValue: Number(fromValue),
//             toValue: Number(toValue),
//             startTime,
//             endTime,
//             interpolator,
//             type: 'number',
//           }));
//         }
//         // TODO: return a list of animation blocks here
//         return animationBlocks;
//       })
//       .value();
// const avdTargetElements = avdChildElements.filter(e => e.tagName === 'target');
// avdTargetElements.forEach(e => getTargetFn(e));
// console.info(vl, avdTargetElements);
//   return undefined;
// }
function isElement(node) {
    return (node &&
        node.nodeType !== Node.TEXT_NODE &&
        node.nodeType !== Node.COMMENT_NODE &&
        lodash__WEBPACK_IMPORTED_MODULE_4__["isElement"](node));
}
function get(obj, attr, def) {
    if (def === void 0) { def = ''; }
    var androidAttr = "android:" + attr;
    return obj.hasAttribute(androidAttr) ? obj.getAttribute(androidAttr) : def;
}
function getNumber(obj, attr, def) {
    var androidAttr = "android:" + attr;
    var num = Number(obj.hasAttribute(androidAttr) ? obj.getAttribute(androidAttr) : def);
    return isFinite(num) ? num : Number(def);
}
function getPath(obj) {
    var androidAttr = 'android:pathData';
    var pathData = obj.hasAttribute(androidAttr) ? obj.getAttribute(androidAttr) : '';
    try {
        return new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"](pathData);
    }
    catch (e) {
        console.warn('Failed to import pathData: ', pathData);
        return undefined;
    }
}
function getColor(obj, attr, def) {
    if (def === void 0) { def = ''; }
    var androidAttr = "android:" + attr;
    var color = obj.hasAttribute(androidAttr) ? obj.getAttribute(androidAttr) : def;
    return !!app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["ColorUtil"].parseAndroidColor(color) ? color : def;
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/import/index.ts":
/*!********************************************************!*\
  !*** ./src/app/modules/editor/scripts/import/index.ts ***!
  \********************************************************/
/*! exports provided: SvgLoader, VectorDrawableLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SvgLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SvgLoader */ "./src/app/modules/editor/scripts/import/SvgLoader.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "SvgLoader", function() { return _SvgLoader__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _VectorDrawableLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VectorDrawableLoader */ "./src/app/modules/editor/scripts/import/VectorDrawableLoader.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "VectorDrawableLoader", function() { return _VectorDrawableLoader__WEBPACK_IMPORTED_MODULE_1__; });





/***/ }),

/***/ "./src/app/modules/editor/scripts/intervals/IntervalTree.ts":
/*!******************************************************************!*\
  !*** ./src/app/modules/editor/scripts/intervals/IntervalTree.ts ***!
  \******************************************************************/
/*! exports provided: IntervalTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntervalTree", function() { return IntervalTree; });
/**
 * A naive implementation of an interval tree with O(n) search performance.
 */
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.intervals = [];
    }
    /**
     * Note that inserted numbers are automatically rounded to the nearest integer.
     */
    IntervalTree.prototype.insert = function (low, high, data) {
        low = Math.round(low);
        high = Math.round(high);
        this.intervals.push({ low: low, high: high, data: data });
    };
    /**
     * Check if the interval (low, high) intersects with any intervals in the tree.
     * An extra predicateFn can be supplied to further filter the results.
     */
    IntervalTree.prototype.intersectsWith = function (low, high, predicateFn) {
        if (predicateFn === void 0) { predicateFn = function (data) { return true; }; }
        return this.intervals.some(function (interval) {
            return low < interval.high && interval.low < high && predicateFn(interval.data);
        });
    };
    return IntervalTree;
}());



/***/ }),

/***/ "./src/app/modules/editor/scripts/intervals/index.ts":
/*!***********************************************************!*\
  !*** ./src/app/modules/editor/scripts/intervals/index.ts ***!
  \***********************************************************/
/*! exports provided: IntervalTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _IntervalTree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IntervalTree */ "./src/app/modules/editor/scripts/intervals/IntervalTree.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IntervalTree", function() { return _IntervalTree__WEBPACK_IMPORTED_MODULE_0__["IntervalTree"]; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/mixins/DestroyableMixin.ts":
/*!*******************************************************************!*\
  !*** ./src/app/modules/editor/scripts/mixins/DestroyableMixin.ts ***!
  \*******************************************************************/
/*! exports provided: DestroyableMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DestroyableMixin", function() { return DestroyableMixin; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

function DestroyableMixin(Base) {
    if (Base === void 0) { Base = /** @class */ (function () {
        function class_1() {
        }
        return class_1;
    }()); }
    return /** @class */ (function (_super) {
        tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](class_2, _super);
        function class_2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.subscriptions = [];
            return _this;
        }
        class_2.prototype.registerSubscription = function (sub) {
            this.subscriptions.push(sub);
        };
        class_2.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (x) { return x.unsubscribe(); });
        };
        return class_2;
    }(Base));
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/mixins/index.ts":
/*!********************************************************!*\
  !*** ./src/app/modules/editor/scripts/mixins/index.ts ***!
  \********************************************************/
/*! exports provided: DestroyableMixin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DestroyableMixin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DestroyableMixin */ "./src/app/modules/editor/scripts/mixins/DestroyableMixin.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DestroyableMixin", function() { return _DestroyableMixin__WEBPACK_IMPORTED_MODULE_0__["DestroyableMixin"]; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/PaperProject.ts":
/*!**************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/PaperProject.ts ***!
  \**************************************************************/
/*! exports provided: PaperProject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PaperProject", function() { return PaperProject; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/paper/item */ "./src/app/modules/editor/scripts/paper/item/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/tool */ "./src/app/modules/editor/scripts/paper/tool/index.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/store/paper/selectors */ "./src/app/modules/editor/store/paper/selectors.ts");
/* harmony import */ var app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/store/playback/selectors */ "./src/app/modules/editor/store/playback/selectors.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_6__);







var PaperProject = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](PaperProject, _super);
    function PaperProject(canvas, ps, store) {
        var _this = _super.call(this, canvas) || this;
        _this.subscriptions = [];
        var pl = new app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_1__["PaperLayer"](ps);
        paper__WEBPACK_IMPORTED_MODULE_6__["project"].addLayer(pl);
        _this.paperLayer = pl;
        _this.masterToolPicker = new app_modules_editor_scripts_paper_tool__WEBPACK_IMPORTED_MODULE_2__["MasterToolPicker"](ps);
        _this.subscriptions.push(store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__["getToolMode"]).subscribe(function () { return _this.masterToolPicker.onToolModeChanged(); }), 
        // TODO: dont allow the user to modify the vector layer when current time > 0
        store.select(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getAnimatedVectorLayer"]).subscribe(function () { return pl.onVectorLayerChanged(); }), store.select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_3__["getSelectedLayerIds"]).subscribe(function () { return pl.onSelectedLayerIdsChanged(); }), store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__["getHoveredLayerId"]).subscribe(function () { return pl.onHoveredLayerIdChanged(); }), store.select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_3__["getHiddenLayerIds"]).subscribe(function () { return pl.onHiddenLayerIdsChanged(); }), store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__["getCreatePathInfo"]).subscribe(function (info) { return pl.setCreatePathInfo(info); }), store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__["getSplitCurveInfo"]).subscribe(function (info) { return pl.setSplitCurveInfo(info); }), store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__["getEditPathInfo"]).subscribe(function (info) { return pl.onEditPathInfoChanged(); }), store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__["getRotateItemsInfo"]).subscribe(function (info) { return pl.onRotateItemsInfoChanged(); }), store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__["getSnapGuideInfo"]).subscribe(function (info) { return pl.setSnapGuideInfo(info); }), store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__["getTooltipInfo"]).subscribe(function (info) { return pl.setTooltipInfo(info); }), store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__["getSelectionBox"]).subscribe(function (box) {
            if (box) {
                var from = new paper__WEBPACK_IMPORTED_MODULE_6__["Point"](box.from);
                var to = new paper__WEBPACK_IMPORTED_MODULE_6__["Point"](box.to);
                pl.setSelectionBox({ from: from, to: to });
            }
            else {
                pl.setSelectionBox(undefined);
            }
        }), store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_4__["getZoomPanInfo"]).subscribe(function (_a) {
            var zoom = _a.zoom, _b = _a.translation, tx = _b.tx, ty = _b.ty;
            _this.view.matrix = new paper__WEBPACK_IMPORTED_MODULE_6__["Matrix"](zoom, 0, 0, zoom, tx, ty);
        }));
        return _this;
    }
    /**
     * Sets the project's dimensions with the new VectorLayer viewport and canvas element size (in CSS pixels).
     */
    PaperProject.prototype.setDimensions = function (viewportWidth, viewportHeight, viewWidth, viewHeight) {
        // The view size represents the actual size of the canvas in CSS pixels.
        // The viewport size represents the user-visible dimensions (i.e. the default 24x24).
        this.view.viewSize = new paper__WEBPACK_IMPORTED_MODULE_6__["Size"](viewWidth, viewHeight);
        this.paperLayer.setDimensions(viewportWidth, viewportHeight, viewWidth, viewHeight);
    };
    // @Override
    PaperProject.prototype.remove = function () {
        _super.prototype.remove.call(this);
        while (this.subscriptions.length) {
            this.subscriptions.pop().unsubscribe();
        }
    };
    return PaperProject;
}(paper__WEBPACK_IMPORTED_MODULE_6__["Project"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/detector/ClickDetector.ts":
/*!************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/detector/ClickDetector.ts ***!
  \************************************************************************/
/*! exports provided: ClickDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClickDetector", function() { return ClickDetector; });
/* harmony import */ var _Handler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Handler */ "./src/app/modules/editor/scripts/paper/detector/Handler.ts");

var DOUBLE_CLICK_MIN_TIME = 40;
var DOUBLE_CLICK_TIMEOUT = 300;
/**
 * Helper class for detecting single/double click events.
 */
var ClickDetector = /** @class */ (function () {
    function ClickDetector() {
        this.handler = new _Handler__WEBPACK_IMPORTED_MODULE_0__["Handler"]();
        this.isDoubleClicking = false;
        this.deferSingleClick = false;
        this.stillDown = false;
    }
    ClickDetector.prototype.onToolEvent = function (event) {
        if (event.type === 'mousedown') {
            this.processMouseDown(event);
        }
        else if (event.type === 'mouseup') {
            this.processMouseUp(event);
        }
    };
    ClickDetector.prototype.processMouseDown = function (event) {
        var _this = this;
        var hadClickMessage = this.handler.hasPendingMessages();
        if (hadClickMessage) {
            this.handler.removePendingMessages();
        }
        var isDoubleClickFn = function (firstUp, secondDown) {
            var deltaTime = secondDown.timeStamp - firstUp.timeStamp;
            return DOUBLE_CLICK_MIN_TIME <= deltaTime && deltaTime <= DOUBLE_CLICK_TIMEOUT;
        };
        if (this.currentDownEvent &&
            this.previousUpEvent &&
            hadClickMessage &&
            isDoubleClickFn(this.previousUpEvent, event)) {
            // This is a second tap, so give a callback with the
            // first click of the double click.
            this.isDoubleClicking = true;
            this.onDoubleClick(this.currentDownEvent);
        }
        else {
            // This is the first click.
            this.handler.postDelayed(function () {
                if (_this.stillDown) {
                    // If the user's mouse is still down, do not dispatch the click
                    // event until the next mouse up event.
                    _this.deferSingleClick = true;
                }
                else {
                    // At this point we are certain that a second click is not coming,
                    // so dispatch the single click event.
                    _this.onSingleClickConfirmed(event);
                }
            }, DOUBLE_CLICK_TIMEOUT);
        }
        this.currentDownEvent = event;
        this.stillDown = true;
        this.deferSingleClick = false;
    };
    ClickDetector.prototype.processMouseUp = function (event) {
        this.onSingleClick(event);
        if (this.deferSingleClick) {
            this.onSingleClickConfirmed(event);
        }
        this.stillDown = false;
        this.previousUpEvent = event;
        this.isDoubleClicking = false;
        this.deferSingleClick = false;
    };
    ClickDetector.prototype.isDoubleClick = function () {
        return this.isDoubleClicking;
    };
    ClickDetector.prototype.onSingleClick = function (event) { };
    ClickDetector.prototype.onSingleClickConfirmed = function (event) { };
    ClickDetector.prototype.onDoubleClick = function (event) { };
    return ClickDetector;
}());



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/detector/Handler.ts":
/*!******************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/detector/Handler.ts ***!
  \******************************************************************/
/*! exports provided: Handler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Handler", function() { return Handler; });
/**
 * A Handler implements a simple asynchronous message queue. Useful for
 * actions that are inherently asynchronous, such as click events and
 * other gestures.
 */
var Handler = /** @class */ (function () {
    function Handler() {
        this.pendingMessageIds = new Set();
    }
    Handler.prototype.postDelayed = function (fn, delayMillis) {
        var _this = this;
        var id = window.setTimeout(function () {
            _this.pendingMessageIds.delete(id);
            fn();
        }, Math.max(0, delayMillis));
        this.pendingMessageIds.add(id);
    };
    Handler.prototype.hasPendingMessages = function () {
        return this.pendingMessageIds.size > 0;
    };
    Handler.prototype.removePendingMessages = function () {
        this.pendingMessageIds.forEach(function (id) { return window.clearTimeout(id); });
        this.pendingMessageIds.clear();
    };
    return Handler;
}());



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/detector/index.ts":
/*!****************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/detector/index.ts ***!
  \****************************************************************/
/*! exports provided: ClickDetector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ClickDetector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClickDetector */ "./src/app/modules/editor/scripts/paper/detector/ClickDetector.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClickDetector", function() { return _ClickDetector__WEBPACK_IMPORTED_MODULE_0__["ClickDetector"]; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/Gesture.ts":
/*!*****************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/Gesture.ts ***!
  \*****************************************************************/
/*! exports provided: Gesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gesture", function() { return Gesture; });
/**
 * A gesture represents a user interaction with the mouse or keyboard. Typically
 * a gesture is used in one of two ways:
 *
 * (1) To monitor the state of events that occurs between the initial
 *     mouse down through the final mouse up.
 *
 * (2) To monitor mouse move events and react accordingly.
 */
var Gesture = /** @class */ (function () {
    function Gesture() {
    }
    Gesture.prototype.onMouseDown = function (event) { };
    Gesture.prototype.onMouseDrag = function (event) { };
    Gesture.prototype.onMouseMove = function (event) { };
    Gesture.prototype.onMouseUp = function (event) { };
    Gesture.prototype.onKeyDown = function (event) { };
    Gesture.prototype.onKeyUp = function (event) { };
    return Gesture;
}());



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/create/EllipseGesture.ts":
/*!*******************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/create/EllipseGesture.ts ***!
  \*******************************************************************************/
/*! exports provided: EllipseGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseGesture", function() { return EllipseGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ShapeGesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShapeGesture */ "./src/app/modules/editor/scripts/paper/gesture/create/ShapeGesture.ts");



/** A gesture that creates an elliptical path. */
var EllipseGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](EllipseGesture, _super);
    function EllipseGesture() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // @Override
    EllipseGesture.prototype.newPath = function (vpBounds) {
        return new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Ellipse(vpBounds);
    };
    return EllipseGesture;
}(_ShapeGesture__WEBPACK_IMPORTED_MODULE_2__["ShapeGesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/create/PencilGesture.ts":
/*!******************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/create/PencilGesture.ts ***!
  \******************************************************************************/
/*! exports provided: PencilGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PencilGesture", function() { return PencilGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_4__);





/**
 * A gesture that draws a path.
 *
 * Preconditions:
 * - The user is in pencil mode.
 */
var PencilGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](PencilGesture, _super);
    function PencilGesture(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_4__["project"].activeLayer;
        return _this;
    }
    // @Override
    PencilGesture.prototype.onMouseDrag = function (event) {
        var vpDownPoint = this.pl.globalToLocal(event.downPoint);
        var vpMiddlePoint = this.pl.globalToLocal(event.middlePoint);
        var vpPoint = this.pl.globalToLocal(event.point);
        if (!this.vpLastPoint) {
            this.vpLastPoint = vpDownPoint;
        }
        var vpDelta = vpPoint.subtract(this.vpLastPoint);
        vpDelta.angle += 90;
        var createPathInfo = this.ps.getCreatePathInfo();
        var pencilPath = createPathInfo ? new paper__WEBPACK_IMPORTED_MODULE_4__["Path"](createPathInfo.pathData) : new paper__WEBPACK_IMPORTED_MODULE_4__["Path"]();
        pencilPath.add(vpMiddlePoint.add(vpDelta));
        this.ps.setCreatePathInfo({ pathData: pencilPath.pathData, strokeColor: '#979797' });
        this.vpLastPoint = vpPoint;
    };
    // @Override
    PencilGesture.prototype.onMouseUp = function (event) {
        if (this.vpLastPoint) {
            this.vpLastPoint = this.pl.globalToLocal(event.point);
        }
        this.finishGesture();
    };
    // @Override
    PencilGesture.prototype.onKeyDown = function (event) {
        if (event.key === 'escape') {
            this.finishGesture();
        }
    };
    PencilGesture.prototype.finishGesture = function () {
        if (this.vpLastPoint) {
            var newPath = new paper__WEBPACK_IMPORTED_MODULE_4__["Path"](this.ps.getCreatePathInfo().pathData);
            var projStartPoint = this.pl.localToGlobal(newPath.firstSegment.point);
            var projLastPoint = this.pl.localToGlobal(this.vpLastPoint);
            // If the pencil path's start and end point are within 10px of each other
            // at the end of the gesture, then we should close the path before saving
            // it to the store.
            if (projStartPoint.isClose(projLastPoint, 10)) {
                newPath.closePath(true);
            }
            newPath.smooth({ type: 'continuous' });
            var newPathLayer = app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_3__["PaperUtil"].addPathToStore(this.ps, newPath.pathData);
            this.ps.setSelectedLayerIds(new Set([newPathLayer.id]));
            this.ps.setCreatePathInfo(undefined);
        }
        this.ps.setToolMode(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["ToolMode"].Default);
    };
    return PencilGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/create/RectangleGesture.ts":
/*!*********************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/create/RectangleGesture.ts ***!
  \*********************************************************************************/
/*! exports provided: RectangleGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectangleGesture", function() { return RectangleGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ShapeGesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShapeGesture */ "./src/app/modules/editor/scripts/paper/gesture/create/ShapeGesture.ts");



/** A gesture that creates a rectangular path. */
var RectangleGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RectangleGesture, _super);
    function RectangleGesture() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // @Override
    RectangleGesture.prototype.newPath = function (vpBounds) {
        return new paper__WEBPACK_IMPORTED_MODULE_1__["Path"].Rectangle(vpBounds);
    };
    return RectangleGesture;
}(_ShapeGesture__WEBPACK_IMPORTED_MODULE_2__["ShapeGesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/create/ShapeGesture.ts":
/*!*****************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/create/ShapeGesture.ts ***!
  \*****************************************************************************/
/*! exports provided: ShapeGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGesture", function() { return ShapeGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_4__);





/** Base class for all shape-building gestures. */
var ShapeGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ShapeGesture, _super);
    function ShapeGesture(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_4__["project"].activeLayer;
        return _this;
    }
    // @Override
    ShapeGesture.prototype.onMouseDrag = function (event) {
        var vpDownPoint = this.pl.globalToLocal(event.downPoint);
        var vpPoint = this.pl.globalToLocal(event.point);
        this.vpLastDragInfo = { vpDownPoint: vpDownPoint, vpPoint: vpPoint };
        this.processEvent(event);
    };
    // @Override
    ShapeGesture.prototype.onMouseUp = function (event) {
        if (this.vpLastDragInfo) {
            var pathData = this.ps.getCreatePathInfo().pathData;
            var newPathLayer = app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_3__["PaperUtil"].addPathToStore(this.ps, pathData);
            this.ps.setSelectedLayerIds(new Set([newPathLayer.id]));
        }
        this.finishGesture();
    };
    // @Override
    ShapeGesture.prototype.onKeyDown = function (event) {
        if (event.key === 'shift' || event.key === 'alt') {
            this.processEvent(event);
        }
        else if (event.key === 'escape') {
            this.finishGesture();
        }
    };
    // @Override
    ShapeGesture.prototype.onKeyUp = function (event) {
        if (event.key === 'shift' || event.key === 'alt') {
            this.processEvent(event);
        }
    };
    ShapeGesture.prototype.processEvent = function (_a) {
        var _b = _a.modifiers, alt = _b.alt, shift = _b.shift;
        var _c = this.vpLastDragInfo, vpDownPoint = _c.vpDownPoint, vpPoint = _c.vpPoint;
        // If shift is pressed, then set the height equal to the width.
        var vpSize = new paper__WEBPACK_IMPORTED_MODULE_4__["Size"](vpPoint.x - vpDownPoint.x, shift ? vpPoint.x - vpDownPoint.x : vpPoint.y - vpDownPoint.y).multiply(alt ? 2 : 1);
        // If alt is pressed, then the initial downpoint represents the shape's center point.
        var vpTopLeft = alt
            ? vpDownPoint.subtract(new paper__WEBPACK_IMPORTED_MODULE_4__["Point"](vpSize.width / 2, vpSize.height / 2))
            : vpDownPoint;
        var pathData = this.newPath(new paper__WEBPACK_IMPORTED_MODULE_4__["Rectangle"](vpTopLeft, vpSize)).pathData;
        this.ps.setCreatePathInfo({ pathData: pathData, strokeColor: '#979797' });
    };
    ShapeGesture.prototype.finishGesture = function () {
        this.ps.setCreatePathInfo(undefined);
        this.ps.setToolMode(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["ToolMode"].Default);
    };
    return ShapeGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/create/index.ts":
/*!**********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/create/index.ts ***!
  \**********************************************************************/
/*! exports provided: RectangleGesture, EllipseGesture, PencilGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RectangleGesture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RectangleGesture */ "./src/app/modules/editor/scripts/paper/gesture/create/RectangleGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RectangleGesture", function() { return _RectangleGesture__WEBPACK_IMPORTED_MODULE_0__["RectangleGesture"]; });

/* harmony import */ var _EllipseGesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EllipseGesture */ "./src/app/modules/editor/scripts/paper/gesture/create/EllipseGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EllipseGesture", function() { return _EllipseGesture__WEBPACK_IMPORTED_MODULE_1__["EllipseGesture"]; });

/* harmony import */ var _PencilGesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PencilGesture */ "./src/app/modules/editor/scripts/paper/gesture/create/PencilGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PencilGesture", function() { return _PencilGesture__WEBPACK_IMPORTED_MODULE_2__["PencilGesture"]; });






/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/edit/BatchSelectSegmentsGesture.ts":
/*!*****************************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/edit/BatchSelectSegmentsGesture.ts ***!
  \*****************************************************************************************/
/*! exports provided: BatchSelectSegmentsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BatchSelectSegmentsGesture", function() { return BatchSelectSegmentsGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_4__);





/**
 * A gesture that selects multiple segments using a bounded box.
 *
 * Preconditions:
 * - The user is in edit path mode.
 */
var BatchSelectSegmentsGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BatchSelectSegmentsGesture, _super);
    function BatchSelectSegmentsGesture(ps, editPathId, clearEditPathAfterDraglessClick) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.editPathId = editPathId;
        _this.clearEditPathAfterDraglessClick = clearEditPathAfterDraglessClick;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_4__["project"].activeLayer;
        _this.isDragging = false;
        return _this;
    }
    // @Override
    BatchSelectSegmentsGesture.prototype.onMouseDown = function (event) {
        this.initialSelectedSegments = this.ps.getEditPathInfo().selectedSegments;
        this.updatedSelectedSegments = new Set();
        this.updateCurrentSelection(event.modifiers.command || event.modifiers.shift);
    };
    // @Override
    BatchSelectSegmentsGesture.prototype.onMouseDrag = function (event) {
        this.isDragging = true;
        this.ps.setSelectionBox({
            from: this.pl.globalToLocal(event.downPoint),
            to: this.pl.globalToLocal(event.point),
        });
        this.processToolEvent(event);
    };
    // @Override
    BatchSelectSegmentsGesture.prototype.onMouseUp = function (event) {
        if (this.isDragging) {
            this.processToolEvent(event);
        }
        else if (this.clearEditPathAfterDraglessClick) {
            this.ps.setEditPathInfo(undefined);
        }
        this.ps.setSelectionBox(undefined);
    };
    BatchSelectSegmentsGesture.prototype.processToolEvent = function (event) {
        // Calculate the bounding rectangle to use to select segments in
        // the edit path's local coordinate space.
        var editPath = this.pl.findItemByLayerId(this.editPathId);
        var rectangle = new paper__WEBPACK_IMPORTED_MODULE_4__["Rectangle"](editPath.globalToLocal(event.downPoint), editPath.globalToLocal(event.point));
        this.updatedSelectedSegments = new Set(lodash__WEBPACK_IMPORTED_MODULE_3__["flatMap"](editPath.segments, function (_a, segmentIndex) {
            var point = _a.point;
            return rectangle.contains(point) ? [segmentIndex] : [];
        }));
        this.updateCurrentSelection(event.modifiers.command || event.modifiers.shift);
    };
    // @Override
    BatchSelectSegmentsGesture.prototype.onKeyDown = function (event) {
        this.processKeyEvent(event);
    };
    // @Override
    BatchSelectSegmentsGesture.prototype.onKeyUp = function (event) {
        this.processKeyEvent(event);
    };
    BatchSelectSegmentsGesture.prototype.processKeyEvent = function (event) {
        if (event.key === 'ctrl' || event.key === 'meta' || event.key === 'shift') {
            this.updateCurrentSelection(event.modifiers.command || event.modifiers.shift);
        }
    };
    BatchSelectSegmentsGesture.prototype.updateCurrentSelection = function (toggleInitialSelections) {
        var selectedSegments = new Set(this.updatedSelectedSegments);
        if (toggleInitialSelections) {
            this.initialSelectedSegments.forEach(function (segmentIndex) {
                if (selectedSegments.has(segmentIndex)) {
                    selectedSegments.delete(segmentIndex);
                }
                else {
                    selectedSegments.add(segmentIndex);
                }
            });
        }
        var editPath = this.pl.findItemByLayerId(this.editPathId);
        this.ps.setEditPathInfo(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__["PaperUtil"].selectCurves(editPath, selectedSegments)));
    };
    return BatchSelectSegmentsGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/edit/MouldCurveGesture.ts":
/*!********************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/edit/MouldCurveGesture.ts ***!
  \********************************************************************************/
/*! exports provided: MouldCurveGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MouldCurveGesture", function() { return MouldCurveGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_3__);




/**
 * A gesture that allows the user to mould a curve by dragging a point on its path.
 *
 * Based on math from here: https://pomax.github.io/bezierinfo/#moulding
 *
 * Preconditions:
 * - The user is in edit path mode.
 * - The user hit one of the edit path's curves.
 */
var MouldCurveGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](MouldCurveGesture, _super);
    // TODO: update HoverSegmentsCurvesGesture to *not* display a split path dot when command is held down
    // TODO: handle cases where t === 0 and t === 1?
    function MouldCurveGesture(ps, editPathId, hitCurveInfo) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.editPathId = editPathId;
        _this.hitCurveInfo = hitCurveInfo;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_3__["project"].activeLayer;
        return _this;
    }
    // @Override
    MouldCurveGesture.prototype.onMouseDown = function (event) {
        var editPath = this.pl.findItemByLayerId(this.editPathId);
        var curve = editPath.curves[this.hitCurveInfo.curveIndex];
        var start = curve.segment1.point;
        var end = curve.segment2.point;
        var cp1 = start.add(curve.handle1);
        var cp2 = end.add(curve.handle2);
        var points = [start, cp1, cp2, end];
        var t = this.hitCurveInfo.time;
        var A = hull(points, t)[5];
        var B = curve.getPointAtTime(t);
        var C = lli(A, B, start, end);
        var bottom = Math.pow(t, 3) + Math.pow((1 - t), 3);
        var top = bottom - 1;
        var ratio = Math.abs(top / bottom);
        // Cache these for later use.
        this.points = points;
        this.B = B;
        this.C = C;
        this.ratio = ratio;
        this.t = t;
    };
    // @Override
    MouldCurveGesture.prototype.onMouseDrag = function (event) {
        var editPath = this.pl.findItemByLayerId(this.editPathId);
        var localDownPoint = editPath.globalToLocal(event.downPoint);
        var localDragPoint = editPath.globalToLocal(event.point);
        var _a = this, points = _a.points, B = _a.B, C = _a.C, ratio = _a.ratio, t = _a.t;
        var newB = B.add(localDragPoint.subtract(localDownPoint));
        // Preserve struts for B when repositioning.
        var hullPoints = hull(this.points, t);
        var Bl = hullPoints[7];
        var Br = hullPoints[8];
        var dbl = Bl.subtract(B);
        var dbr = Br.subtract(B);
        // Now that we know A, B, C and the AB:BC ratio, we can compute the new A' based on the desired B'.
        var newA = newB.subtract(C.subtract(newB).divide(ratio));
        // Find new point on s--c1.
        var p1 = newB.add(dbl);
        var sc1 = newA.subtract(newA.subtract(p1).divide(1 - t));
        // Find new point on c2--e.
        var p2 = newB.add(dbr);
        var sc2 = newA.add(p2.subtract(newA).divide(t));
        // Construct new c1` based on the fact that s--sc1 is s--c1 * t.
        var nc1 = points[0].add(sc1.subtract(points[0]).divide(t));
        // Construct new c2` based on the fact that e--sc2 is e--c2 * (1-t).
        var nc2 = points[3].subtract(points[3].subtract(sc2).divide(1 - t));
        var curve = editPath.curves[this.hitCurveInfo.curveIndex];
        curve.handle1 = nc1.subtract(points[0]);
        curve.handle2 = nc2.subtract(points[3]);
        app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__["PaperUtil"].replacePathInStore(this.ps, this.editPathId, editPath.pathData);
    };
    // @Override
    MouldCurveGesture.prototype.onKeyDown = function (event) {
        // TODO: react to escape key presses?
    };
    return MouldCurveGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__["Gesture"]));

// TODO: rename this...
function lli(_a, _b, _c, _d) {
    var x1 = _a.x, y1 = _a.y;
    var x2 = _b.x, y2 = _b.y;
    var x3 = _c.x, y3 = _c.y;
    var x4 = _d.x, y4 = _d.y;
    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
    var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
    var d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (d === 0) {
        return undefined;
    }
    return new paper__WEBPACK_IMPORTED_MODULE_3__["Point"](nx / d, ny / d);
}
function hull(points, t) {
    var p = points;
    var _p = [];
    var pt;
    var q = p.slice();
    // We lerp between all points at each iteration, until we have 1 point left.
    while (p.length > 1) {
        _p = [];
        for (var i = 0, l = p.length - 1; i < l; i++) {
            pt = p[i].add(p[i + 1].subtract(p[i]).multiply(t));
            q.push(pt);
            _p.push(pt);
        }
        p = _p;
    }
    return q;
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/edit/SelectDragDrawSegmentsGesture.ts":
/*!********************************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/edit/SelectDragDrawSegmentsGesture.ts ***!
  \********************************************************************************************/
/*! exports provided: SelectDragDrawSegmentsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectDragDrawSegmentsGesture", function() { return SelectDragDrawSegmentsGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_5__);






/**
 * A gesture that performs selection and drag operations on one or more path
 * segments. It also supports adding a segment to an existing path's curve,
 * as well as extending an open path by appending segments to its end points.
 *
 * Preconditions:
 * - The user is in edit path mode.
 * - The user either hit a segment, a curve, or missed entirely
 *   (the 'missed entirely' case occurs when the user is in vector
 *   mode, in which the user can create new segments by clicking
 *   on the canvas).
 */
var SelectDragDrawSegmentsGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SelectDragDrawSegmentsGesture, _super);
    function SelectDragDrawSegmentsGesture(ps, editPathId, hitSegmentInfo, hitCurveInfo) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.editPathId = editPathId;
        _this.hitSegmentInfo = hitSegmentInfo;
        _this.hitCurveInfo = hitCurveInfo;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_5__["project"].activeLayer;
        // True if we should exit edit path mode on the next mouse up event.
        _this.exitEditPathModeOnMouseUp = false;
        return _this;
    }
    /** Static factory method to use when the user's mouse down hits a segment. */
    SelectDragDrawSegmentsGesture.hitSegment = function (ps, editPathId, segmentIndex) {
        return new SelectDragDrawSegmentsGesture(ps, editPathId, { segmentIndex: segmentIndex });
    };
    /** Static factory method to use when the user's mouse down hits a curve. */
    SelectDragDrawSegmentsGesture.hitCurve = function (ps, editPathId, curveIndex, time) {
        return new SelectDragDrawSegmentsGesture(ps, editPathId, undefined, { curveIndex: curveIndex, time: time });
    };
    /** Static factory method to use when the user misses the edit path. */
    SelectDragDrawSegmentsGesture.miss = function (ps, editPathId) {
        return new SelectDragDrawSegmentsGesture(ps, editPathId);
    };
    // @Override
    SelectDragDrawSegmentsGesture.prototype.onMouseDown = function (event) {
        var fpi = this.ps.getEditPathInfo();
        var beforeSelectedSegmentIndices = fpi.selectedSegments;
        var afterSelectedSegmentIndices = new Set(beforeSelectedSegmentIndices);
        var editPath = this.pl.findItemByLayerId(this.editPathId);
        if (this.hitSegmentInfo) {
            var isEndPointFn = function (i) { return i === 0 || i === editPath.segments.length - 1; };
            var segmentIndex = this.hitSegmentInfo.segmentIndex;
            var singleSelectedSegmentIndex = beforeSelectedSegmentIndices.size
                ? beforeSelectedSegmentIndices.values().next().value
                : undefined;
            if (!editPath.closed &&
                singleSelectedSegmentIndex !== undefined &&
                isEndPointFn(segmentIndex) &&
                isEndPointFn(singleSelectedSegmentIndex) &&
                segmentIndex !== singleSelectedSegmentIndex) {
                // If the path is open, one of the end points is selected, and the
                // user clicked the other end point segment, then close the path
                // and end the gesture on the next mouse up event.
                editPath.closed = true;
                this.exitEditPathModeOnMouseUp = true;
                app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__["PaperUtil"].replacePathInStore(this.ps, this.editPathId, editPath.pathData);
            }
            if (event.modifiers.shift || event.modifiers.command) {
                // If shift or command is pressed, toggle the segment's selection state.
                if (beforeSelectedSegmentIndices.has(segmentIndex)) {
                    afterSelectedSegmentIndices.delete(segmentIndex);
                }
                else {
                    afterSelectedSegmentIndices.add(segmentIndex);
                }
            }
            else {
                // Otherwise, select the hit segment and deselect all others.
                afterSelectedSegmentIndices.clear();
                afterSelectedSegmentIndices.add(segmentIndex);
            }
        }
        else if (this.hitCurveInfo) {
            // If there is no hit segment, then create one along the curve
            // at the given location and select the new segment.
            var _a = this.hitCurveInfo, curveIndex = _a.curveIndex, time = _a.time;
            var curve = editPath.curves[curveIndex];
            var newSegment = event.modifiers.shift
                ? curve.divideAt(curve.getLocationAt(curve.length / 2))
                : curve.divideAtTime(time).segment1;
            app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__["PaperUtil"].replacePathInStore(this.ps, this.editPathId, editPath.pathData);
            afterSelectedSegmentIndices.clear();
            afterSelectedSegmentIndices.add(newSegment.index);
            this.newSplitCurveSegmentIndex = newSegment.index;
        }
        else {
            // Otherwise, we are either (1) extending an existing open path (beginning
            // at one of its selected end points), or (2) beginning to create a new path
            // from scratch.
            var localPoint = editPath.globalToLocal(event.point);
            var addedSegment = void 0;
            if (editPath.segments.length === 0) {
                addedSegment = editPath.add(localPoint);
            }
            else {
                // Note that there will always be a single selected end point segment in this case
                // (otherwise we would have used a batch select segments gesture instead).
                var singleSelectedSegmentIndex = beforeSelectedSegmentIndices.values().next().value;
                var selectedSegment = editPath.segments[singleSelectedSegmentIndex];
                addedSegment = selectedSegment.isLast()
                    ? editPath.add(localPoint)
                    : editPath.insert(0, localPoint);
                afterSelectedSegmentIndices.delete(singleSelectedSegmentIndex);
            }
            afterSelectedSegmentIndices.add(addedSegment.index);
            app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__["PaperUtil"].replacePathInStore(this.ps, this.editPathId, editPath.pathData);
        }
        this.selectedSegmentIndexToInitialLocationMap = new Map(Array.from(afterSelectedSegmentIndices).map(function (segmentIndex) {
            var point = editPath.segments[segmentIndex].point.clone();
            return [segmentIndex, point];
        }));
        this.ps.setEditPathInfo(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, fpi, app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__["PaperUtil"].selectCurves(editPath, afterSelectedSegmentIndices)));
        this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].PointSelect);
        this.ps.setCreatePathInfo(undefined);
        this.ps.setSplitCurveInfo(undefined);
    };
    // @Override
    SelectDragDrawSegmentsGesture.prototype.onMouseDrag = function (event) {
        var _this = this;
        var editPath = this.pl.findItemByLayerId(this.editPathId);
        var localDownPoint = editPath.globalToLocal(event.downPoint);
        if (!this.localLastPoint) {
            this.localLastPoint = localDownPoint;
        }
        var localPoint = editPath.globalToLocal(event.point);
        var localDownPointDelta = localPoint.subtract(localDownPoint);
        var localLastPointDelta = localPoint.subtract(this.localLastPoint);
        var localSnappedDownPointDelta = new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["MathUtil"].snapVectorToAngle(localDownPointDelta, 90));
        if (this.hitSegmentInfo || this.hitCurveInfo) {
            // A segment was created on mouse down and is still being grabbed,
            // so continue to drag the currently selected segments.
            var selectedSegmentIndices_1 = new Set(this.selectedSegmentIndexToInitialLocationMap.keys());
            var nonSelectedSegmentIndices = editPath.segments
                .map(function (s, i) { return i; })
                .filter(function (s, i) { return !selectedSegmentIndices_1.has(i); });
            this.selectedSegmentIndexToInitialLocationMap.forEach(function (initialSegmentPoint, i) {
                var segment = editPath.segments[i];
                segment.point = event.modifiers.shift
                    ? initialSegmentPoint.add(localSnappedDownPointDelta)
                    : segment.point.add(localLastPointDelta);
            });
            var draggedSegmentIndex = this.hitSegmentInfo
                ? this.hitSegmentInfo.segmentIndex
                : this.newSplitCurveSegmentIndex;
            var dragSnapPoint = editPath.localToGlobal(editPath.segments[draggedSegmentIndex].point);
            var _a = Array.from(this.selectedSegmentIndexToInitialLocationMap.values()).reduce(function (rect, p) {
                p = editPath.localToGlobal(p);
                return rect ? rect.include(p) : new paper__WEBPACK_IMPORTED_MODULE_5__["Rectangle"](p, new paper__WEBPACK_IMPORTED_MODULE_5__["Size"](0, 0));
            }, undefined), topLeft = _a.topLeft, center = _a.center, bottomRight = _a.bottomRight;
            var siblingSnapPointsTable = [
                [topLeft, center, bottomRight]
            ].concat(nonSelectedSegmentIndices.map(function (i) {
                return [editPath.localToGlobal(editPath.segments[i].point)];
            }));
            // TODO: snap this stuff like we do in the other gestures!
            var snapInfo = app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__["SnapUtil"].computeSnapInfo([dragSnapPoint], siblingSnapPointsTable);
            if (snapInfo) {
                this.ps.setSnapGuideInfo({
                    guides: snapInfo.guides.map(function (_a) {
                        var from = _a.from, to = _a.to;
                        from = _this.pl.globalToLocal(new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](from));
                        to = _this.pl.globalToLocal(new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](to));
                        return { from: from, to: to };
                    }),
                    rulers: [],
                });
            }
        }
        else {
            // Then we have just added a segment to the path in onMouseDown()
            // and should thus move the segment's handles onMouseDrag().
            // Note that there will only ever be one selected segment in this case.
            var selectedSegmentIndex = this.selectedSegmentIndexToInitialLocationMap.keys().next()
                .value;
            var selectedSegment = editPath.segments[selectedSegmentIndex];
            // TODO: dragging a handle belonging to an endpoint doesn't work! handle info is lost!
            // TODO: snap the dragged segment handle with the newly created segment
            if (event.modifiers.shift) {
                var index = selectedSegmentIndex;
                var initialSelectedSegmentPosition = this.selectedSegmentIndexToInitialLocationMap.get(index);
                var delta = localSnappedDownPointDelta;
                selectedSegment.handleIn = initialSelectedSegmentPosition.subtract(delta);
                selectedSegment.handleOut = initialSelectedSegmentPosition.add(delta);
            }
            else {
                selectedSegment.handleIn = selectedSegment.handleIn.subtract(localLastPointDelta);
                selectedSegment.handleOut = selectedSegment.handleOut.add(localLastPointDelta);
            }
        }
        this.localLastPoint = localPoint;
        app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__["PaperUtil"].replacePathInStore(this.ps, this.editPathId, editPath.pathData);
    };
    // @Override
    SelectDragDrawSegmentsGesture.prototype.onMouseUp = function (event) {
        this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Default);
        this.ps.setSnapGuideInfo(undefined);
        if (this.exitEditPathModeOnMouseUp) {
            this.ps.setEditPathInfo(undefined);
        }
    };
    return SelectDragDrawSegmentsGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_3__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/edit/SelectDragHandleGesture.ts":
/*!**************************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/edit/SelectDragHandleGesture.ts ***!
  \**************************************************************************************/
/*! exports provided: SelectDragHandleGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectDragHandleGesture", function() { return SelectDragHandleGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_3__);




/**
 * A gesture that performs selection and drag operations on a segment handle.
 *
 * Preconditions:
 * - The user is in edit path mode.
 * - The user hit a segment handle.
 */
var SelectDragHandleGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SelectDragHandleGesture, _super);
    function SelectDragHandleGesture(ps, editPathId, hitSegmentIndex, hitResultType) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.editPathId = editPathId;
        _this.hitSegmentIndex = hitSegmentIndex;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_3__["project"].activeLayer;
        _this.hitHandleType = hitResultType === 'handle-in' ? 'handleIn' : 'handleOut';
        return _this;
    }
    // @Override
    SelectDragHandleGesture.prototype.onMouseDown = function (event) {
        // Deselect all currently selected segments.
        var selectedSegments = new Set();
        var selectedHandleIn = this.hitHandleType === 'handleIn' ? this.hitSegmentIndex : undefined;
        var selectedHandleOut = this.hitHandleType === 'handleOut' ? this.hitSegmentIndex : undefined;
        this.ps.setEditPathInfo(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, this.ps.getEditPathInfo(), { selectedSegments: selectedSegments,
            selectedHandleIn: selectedHandleIn,
            selectedHandleOut: selectedHandleOut }));
        var editPath = this.pl.findItemByLayerId(this.editPathId);
        this.localDownHandle = editPath.segments[this.hitSegmentIndex][this.hitHandleType].clone();
    };
    // @Override
    SelectDragHandleGesture.prototype.onMouseDrag = function (event) {
        var editPath = this.pl.findItemByLayerId(this.editPathId);
        this.localLastDragInfo = {
            localDownPoint: editPath.globalToLocal(event.downPoint),
            localPoint: editPath.globalToLocal(event.point),
        };
        this.processEvent(event);
    };
    // @Override
    SelectDragHandleGesture.prototype.onKeyDown = function (event) {
        this.processKeyEvent(event);
    };
    // @Override
    SelectDragHandleGesture.prototype.onKeyUp = function (event) {
        this.processKeyEvent(event);
    };
    // TODO: react to 'escape' key presses
    SelectDragHandleGesture.prototype.processKeyEvent = function (event) {
        if (event.key === 'shift') {
            this.processEvent(event);
        }
    };
    SelectDragHandleGesture.prototype.processEvent = function (event) {
        if (!this.localLastDragInfo) {
            return;
        }
        // TODO: add 'straight', 'mirrored', 'disconnected', and 'asymmetric' modes (similar to Sketch)
        var _a = this.localLastDragInfo, localDownPoint = _a.localDownPoint, localPoint = _a.localPoint;
        var localHandle = this.localDownHandle.add(localPoint.subtract(localDownPoint));
        if (event.modifiers.shift) {
            // Project the handle onto the handle's original vector.
            var theta = (-(this.localDownHandle.angle - localHandle.angle) * Math.PI) / 180;
            localHandle.set(this.localDownHandle.normalize().multiply(localHandle.length * Math.cos(theta)));
        }
        var editPath = this.pl.findItemByLayerId(this.editPathId);
        editPath.segments[this.hitSegmentIndex][this.hitHandleType] = localHandle;
        app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__["PaperUtil"].replacePathInStore(this.ps, this.editPathId, editPath.pathData);
    };
    return SelectDragHandleGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/edit/ToggleSegmentHandlesGesture.ts":
/*!******************************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/edit/ToggleSegmentHandlesGesture.ts ***!
  \******************************************************************************************/
/*! exports provided: ToggleSegmentHandlesGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToggleSegmentHandlesGesture", function() { return ToggleSegmentHandlesGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_3__);




/**
 * A gesture that toggles the handles associated with a path segment.
 *
 * Preconditions:
 * - The user is in edit path mode.
 * - The gesture began with a mouse down event on top of a segment
 *   (typically this is the second mouse down of a double click).
 */
var ToggleSegmentHandlesGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ToggleSegmentHandlesGesture, _super);
    function ToggleSegmentHandlesGesture(ps, editPathId, hitSegmentIndex) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.editPathId = editPathId;
        _this.hitSegmentIndex = hitSegmentIndex;
        return _this;
    }
    // @Override
    ToggleSegmentHandlesGesture.prototype.onMouseDown = function (event) {
        var path = new paper__WEBPACK_IMPORTED_MODULE_3__["Path"](app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__["PaperUtil"].getPathFromStore(this.ps, this.editPathId));
        var segment = path.segments[this.hitSegmentIndex];
        if (segment.hasHandles()) {
            segment.clearHandles();
        }
        else {
            // TODO: polish this a bit more using the extra options argument?
            segment.smooth();
        }
        app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__["PaperUtil"].replacePathInStore(this.ps, this.editPathId, path.pathData);
    };
    return ToggleSegmentHandlesGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/edit/index.ts":
/*!********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/edit/index.ts ***!
  \********************************************************************/
/*! exports provided: BatchSelectSegmentsGesture, MouldCurveGesture, SelectDragDrawSegmentsGesture, SelectDragHandleGesture, ToggleSegmentHandlesGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BatchSelectSegmentsGesture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BatchSelectSegmentsGesture */ "./src/app/modules/editor/scripts/paper/gesture/edit/BatchSelectSegmentsGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchSelectSegmentsGesture", function() { return _BatchSelectSegmentsGesture__WEBPACK_IMPORTED_MODULE_0__["BatchSelectSegmentsGesture"]; });

/* harmony import */ var _MouldCurveGesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MouldCurveGesture */ "./src/app/modules/editor/scripts/paper/gesture/edit/MouldCurveGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MouldCurveGesture", function() { return _MouldCurveGesture__WEBPACK_IMPORTED_MODULE_1__["MouldCurveGesture"]; });

/* harmony import */ var _SelectDragDrawSegmentsGesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SelectDragDrawSegmentsGesture */ "./src/app/modules/editor/scripts/paper/gesture/edit/SelectDragDrawSegmentsGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectDragDrawSegmentsGesture", function() { return _SelectDragDrawSegmentsGesture__WEBPACK_IMPORTED_MODULE_2__["SelectDragDrawSegmentsGesture"]; });

/* harmony import */ var _SelectDragHandleGesture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SelectDragHandleGesture */ "./src/app/modules/editor/scripts/paper/gesture/edit/SelectDragHandleGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectDragHandleGesture", function() { return _SelectDragHandleGesture__WEBPACK_IMPORTED_MODULE_3__["SelectDragHandleGesture"]; });

/* harmony import */ var _ToggleSegmentHandlesGesture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ToggleSegmentHandlesGesture */ "./src/app/modules/editor/scripts/paper/gesture/edit/ToggleSegmentHandlesGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ToggleSegmentHandlesGesture", function() { return _ToggleSegmentHandlesGesture__WEBPACK_IMPORTED_MODULE_4__["ToggleSegmentHandlesGesture"]; });








/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/hover/HoverGesture.ts":
/*!****************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/hover/HoverGesture.ts ***!
  \****************************************************************************/
/*! exports provided: HoverGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HoverGesture", function() { return HoverGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var _HoverItemsGesture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HoverItemsGesture */ "./src/app/modules/editor/scripts/paper/gesture/hover/HoverItemsGesture.ts");
/* harmony import */ var _HoverSegmentsCurvesGesture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HoverSegmentsCurvesGesture */ "./src/app/modules/editor/scripts/paper/gesture/hover/HoverSegmentsCurvesGesture.ts");





/**
 * A gesture that handles mouse move hover events.
 */
var HoverGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](HoverGesture, _super);
    function HoverGesture(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.hoverItemsGesture = new _HoverItemsGesture__WEBPACK_IMPORTED_MODULE_3__["HoverItemsGesture"](_this.ps);
        _this.hoverSegmentsCurvesGesture = new _HoverSegmentsCurvesGesture__WEBPACK_IMPORTED_MODULE_4__["HoverSegmentsCurvesGesture"](_this.ps);
        return _this;
    }
    // @Override
    HoverGesture.prototype.onMouseMove = function (event) {
        var gesture = this.getCurrentGesture();
        if (gesture) {
            gesture.onMouseMove(event);
        }
    };
    // @Override
    HoverGesture.prototype.onKeyDown = function (event) {
        var gesture = this.getCurrentGesture();
        if (gesture) {
            gesture.onKeyDown(event);
        }
    };
    HoverGesture.prototype.getCurrentGesture = function () {
        if (this.ps.getToolMode() !== app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["ToolMode"].Default) {
            return undefined;
        }
        var epi = this.ps.getEditPathInfo();
        if (!epi) {
            return this.hoverItemsGesture;
        }
        if (!this.ps.getSelectedLayerIds().size) {
            // If we are in edit path mode but there is no selected layer ID, then
            // the user is using the 'vector' tool and hasn't yet started to create
            // a path. In this case we do not want to show any hovers.
            return undefined;
        }
        return this.hoverSegmentsCurvesGesture;
    };
    return HoverGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/hover/HoverItemsGesture.ts":
/*!*********************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/hover/HoverItemsGesture.ts ***!
  \*********************************************************************************/
/*! exports provided: HoverItemsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HoverItemsGesture", function() { return HoverItemsGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/paper/item */ "./src/app/modules/editor/scripts/paper/item/index.ts");




// prettier-ignore
var RESIZE_CURSOR_MAP = new Map([
    ['bottomLeft', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize45], ['leftCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize90],
    ['topLeft', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize135], ['topCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize0],
    ['topRight', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize45], ['rightCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize90],
    ['bottomRight', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize135], ['bottomCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize0],
]);
// prettier-ignore
var ROTATE_CURSOR_MAP = new Map([
    ['bottomLeft', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Rotate225], ['leftCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Rotate270],
    ['topLeft', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Rotate315], ['topCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Rotate0],
    ['topRight', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Rotate45], ['rightCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Rotate90],
    ['bottomRight', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Rotate135], ['bottomCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Rotate180],
]);
// prettier-ignore
var TRANSFORM_CURSOR_MAP = new Map([
    ['bottomLeft', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize45], ['leftCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize0],
    ['topLeft', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize135], ['topCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize90],
    ['topRight', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize45], ['rightCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize0],
    ['bottomRight', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize135], ['bottomCenter', app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Resize90],
]);
/**
 * A gesture that performs hover operations on items.
 *
 * Preconditions:
 * - The user is in default, rotate items, or transform paths mode.
 */
var HoverItemsGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](HoverItemsGesture, _super);
    function HoverItemsGesture(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        return _this;
    }
    // @Override
    HoverItemsGesture.prototype.onMouseMove = function (event) {
        this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Default);
        var selectedLayers = this.ps.getSelectedLayerIds();
        if (selectedLayers.size) {
            var rii = this.ps.getRotateItemsInfo();
            var selectionBoundSegmentsHitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_3__["HitTests"].selectionModeSegments(event.point);
            if (selectionBoundSegmentsHitResult) {
                var tpi = this.ps.getTransformPathsInfo();
                var cursorMap = rii ? ROTATE_CURSOR_MAP : tpi ? TRANSFORM_CURSOR_MAP : RESIZE_CURSOR_MAP;
                this.ps.setCursorType(cursorMap.get(selectionBoundSegmentsHitResult.item.pivotType));
                this.ps.setHoveredLayerId(undefined);
                return;
            }
            if (rii && app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_3__["HitTests"].rotateItemsPivot(event.point)) {
                this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Grab);
                this.ps.setHoveredLayerId(undefined);
                return;
            }
        }
        var hitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_3__["HitTests"].selectionMode(event.point, this.ps);
        if (hitResult && !selectedLayers.has(hitResult.hitItem.data.id)) {
            this.ps.setHoveredLayerId(hitResult.hitItem.data.id);
        }
        else {
            this.ps.setHoveredLayerId(undefined);
        }
    };
    // @Override
    HoverItemsGesture.prototype.onKeyDown = function (event) {
        switch (event.key) {
            case 'escape':
                // TODO: also do this in any other hover/pen/pencil related gestures?
                this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Default);
                this.ps.setSnapGuideInfo(undefined);
                this.ps.setRotateItemsInfo(undefined);
                this.ps.setTransformPathsInfo(undefined);
                break;
            case 'backspace':
            case 'delete':
                this.ps.deleteSelectedModels();
                break;
        }
    };
    return HoverItemsGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/hover/HoverSegmentsCurvesGesture.ts":
/*!******************************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/hover/HoverSegmentsCurvesGesture.ts ***!
  \******************************************************************************************/
/*! exports provided: HoverSegmentsCurvesGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HoverSegmentsCurvesGesture", function() { return HoverSegmentsCurvesGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/paper/item */ "./src/app/modules/editor/scripts/paper/item/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/store/batch/actions */ "./src/app/modules/editor/store/batch/actions.ts");
/* harmony import */ var app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store/layers/actions */ "./src/app/modules/editor/store/layers/actions.ts");
/* harmony import */ var app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store/paper/actions */ "./src/app/modules/editor/store/paper/actions.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_8__);









/**
 * A gesture that performs hover operations over segments and curves.
 *
 * Preconditions:
 * - The user is in edit path mode for a selected layer id.
 */
var HoverSegmentsCurvesGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](HoverSegmentsCurvesGesture, _super);
    function HoverSegmentsCurvesGesture(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_8__["project"].activeLayer;
        return _this;
    }
    // @Override
    HoverSegmentsCurvesGesture.prototype.onMouseMove = function (event) {
        this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Default);
        this.ps.setSplitCurveInfo(undefined);
        // TODO: this seems kinda hacky
        // TODO: currently necessary (if the previous gesture was the create/drag/draw segments gesture)
        this.ps.setCreatePathInfo(undefined);
        var editPathId = this.ps
            .getSelectedLayerIds()
            .values()
            .next().value;
        var editPath = this.pl.findItemByLayerId(editPathId);
        var segmentsAndHandlesHitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_3__["HitTests"].editPathModeSegmentsAndHandles(event.point);
        if (segmentsAndHandlesHitResult) {
            // If we are hovering over a segment or a handle, then show a point select
            // cursor and return.
            this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].PointSelect);
            return;
        }
        var editPathHitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_3__["HitTests"].editPathMode(event.point, editPath, {
            curves: true,
        });
        if (editPathHitResult) {
            if (editPathHitResult.type !== 'curve') {
                // If we hit the edit path but missed its segments/handles/curves,
                // then do nothing.
                return;
            }
            // Show a pen add cursor and highlight the curve the user is about to split.
            this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].PenAdd);
            var hitCurve = editPathHitResult.location.curve;
            var location_1 = event.modifiers.shift
                ? hitCurve.getLocationAt(hitCurve.length / 2)
                : editPathHitResult.location;
            var vpSplitPoint = this.localToVpPoint(editPath, location_1.point);
            var _a = this.localToVpSegment(editPath, location_1.curve.segment1), p1 = _a.point, in1 = _a.handleIn, out1 = _a.handleOut;
            var _b = this.localToVpSegment(editPath, location_1.curve.segment2), p2 = _b.point, in2 = _b.handleIn, out2 = _b.handleOut;
            this.ps.setSplitCurveInfo({
                splitPoint: vpSplitPoint,
                segment1: { point: p1, handleIn: in1, handleOut: out1 },
                segment2: { point: p2, handleIn: in2, handleOut: out2 },
            });
            return;
        }
        // Draw an 'extend path' preview curve if one of its end points
        // is selected and the path is still open.
        var singleSelectedSegmentIndex = this.findSingleSelectedEndSegmentIndex(editPath);
        if (singleSelectedSegmentIndex !== undefined) {
            this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].PenAdd);
            var vpStartSegment = this.localToVpSegment(editPath, editPath.segments[singleSelectedSegmentIndex]);
            var vpEndSegment = new paper__WEBPACK_IMPORTED_MODULE_8__["Segment"](this.pl.globalToLocal(event.point));
            var pathData = new paper__WEBPACK_IMPORTED_MODULE_8__["Path"]([vpStartSegment, vpEndSegment]).pathData;
            this.ps.setCreatePathInfo({
                pathData: pathData,
                strokeColor: '#979797',
            });
        }
    };
    /** Converts local coordinates to viewport coordinates for a point. */
    HoverSegmentsCurvesGesture.prototype.localToVpPoint = function (localItem, localPoint) {
        return localPoint ? this.pl.globalToLocal(localItem.localToGlobal(localPoint)) : undefined;
    };
    /** Converts local coordinates to viewport coordinates for a segment. */
    HoverSegmentsCurvesGesture.prototype.localToVpSegment = function (localItem, localSegment) {
        return new paper__WEBPACK_IMPORTED_MODULE_8__["Segment"](this.localToVpPoint(localItem, localSegment.point), this.localToVpHandle(localItem, localSegment.point, localSegment.handleIn), this.localToVpHandle(localItem, localSegment.point, localSegment.handleOut));
    };
    /** Converts local coordinates to viewport coordinates for a segment handle. */
    HoverSegmentsCurvesGesture.prototype.localToVpHandle = function (localItem, localPoint, localHandle) {
        var vpPoint = this.localToVpPoint(localItem, localPoint);
        var vpHandle = this.localToVpPoint(localItem, localPoint.add(localHandle));
        return vpHandle.subtract(vpPoint);
    };
    /**
     * Returns the single selected end point segment index for the given path,
     * or undefined if one doesn't exist.
     */
    HoverSegmentsCurvesGesture.prototype.findSingleSelectedEndSegmentIndex = function (path) {
        if (path.closed) {
            // Return undefined if the path is closed.
            return undefined;
        }
        var selectedSegments = this.ps.getEditPathInfo().selectedSegments;
        if (selectedSegments.size !== 1) {
            // Return undefined if there is not a single selected segment.
            return undefined;
        }
        var lastIndex = path.segments.length - 1;
        return selectedSegments.has(0) ? 0 : selectedSegments.has(lastIndex) ? lastIndex : undefined;
    };
    // @Override
    HoverSegmentsCurvesGesture.prototype.onKeyDown = function (event) {
        switch (event.key) {
            case 'escape':
                // TODO: also do this in any other hover/pen/pencil related gestures?
                this.ps.exitEditPathMode();
                break;
            case 'backspace':
            case 'delete':
                this.deleteSelectedSegmentsAndHandles();
                break;
        }
    };
    HoverSegmentsCurvesGesture.prototype.deleteSelectedSegmentsAndHandles = function () {
        var layerId = this.ps
            .getSelectedLayerIds()
            .values()
            .next().value;
        var _a = this.ps.getEditPathInfo(), selectedHandleIn = _a.selectedHandleIn, selectedHandleOut = _a.selectedHandleOut, selectedSegments = _a.selectedSegments;
        if (selectedHandleIn === undefined &&
            selectedHandleOut === undefined &&
            selectedSegments.size === 0) {
            // Do nothing if there are no selected segments/handles.
            // TODO: should we delete the layer in this case?
            return;
        }
        var editPath = this.pl.findItemByLayerId(layerId);
        for (var i = editPath.segments.length - 1; i >= 0; i--) {
            var segment = editPath.segments[i];
            if (selectedSegments.has(i)) {
                segment.remove();
                continue;
            }
            if (selectedHandleIn === i) {
                segment.handleIn = undefined;
            }
            if (selectedHandleOut === i) {
                segment.handleOut = undefined;
            }
        }
        var actions = [];
        if (editPath.segments.length === 0) {
            // Delete the layer and exit edit path mode if there are no segments remaining.
            actions.push.apply(actions, this.ps.getDeleteSelectedModelsActions());
            actions.push.apply(actions, this.ps.getExitEditPathModeActions());
        }
        else {
            actions.push.apply(actions, [new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_6__["SetVectorLayer"](app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__["PaperUtil"].getReplacePathInStoreVectorLayer(this.ps, layerId, editPath.pathData)),
                new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_7__["SetEditPathInfo"]({
                    selectedHandleIn: undefined,
                    selectedHandleOut: undefined,
                    selectedSegments: new Set(),
                    visibleHandleIns: new Set(),
                    visibleHandleOuts: new Set(),
                })].concat(this.ps.getClearEditPathModeStateActions()));
        }
        this.ps.dispatchStore(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_5__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_5__["BatchAction"], [void 0].concat(actions)))());
    };
    return HoverSegmentsCurvesGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/hover/index.ts":
/*!*********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/hover/index.ts ***!
  \*********************************************************************/
/*! exports provided: HoverGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _HoverGesture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HoverGesture */ "./src/app/modules/editor/scripts/paper/gesture/hover/HoverGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HoverGesture", function() { return _HoverGesture__WEBPACK_IMPORTED_MODULE_0__["HoverGesture"]; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/index.ts":
/*!***************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/index.ts ***!
  \***************************************************************/
/*! exports provided: Gesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Gesture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Gesture */ "./src/app/modules/editor/scripts/paper/gesture/Gesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Gesture", function() { return _Gesture__WEBPACK_IMPORTED_MODULE_0__["Gesture"]; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/rotate/RotateItemsDragPivotGesture.ts":
/*!********************************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/rotate/RotateItemsDragPivotGesture.ts ***!
  \********************************************************************************************/
/*! exports provided: RotateItemsDragPivotGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RotateItemsDragPivotGesture", function() { return RotateItemsDragPivotGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_4__);





/**
 * A gesture that performs rotation operations.
 *
 * Preconditions:
 * - The user is in default mode.
 * - One or more layers are selected.
 * - A mouse down event occurred on top of the rotate items pivot.
 */
var RotateItemsDragPivotGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RotateItemsDragPivotGesture, _super);
    function RotateItemsDragPivotGesture(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_4__["project"].activeLayer;
        return _this;
    }
    // @Override
    RotateItemsDragPivotGesture.prototype.onMouseDown = function (event) {
        var _this = this;
        this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Grabbing);
        // TODO: reuse this code with PaperLayer (filter out empty groups)
        var selectedItems = Array.from(this.ps.getSelectedLayerIds())
            .map(function (id) { return _this.pl.findItemByLayerId(id); })
            .filter(function (i) { return !(i instanceof paper__WEBPACK_IMPORTED_MODULE_4__["Group"]) || i.children.length; });
        var invertedPaperLayerMatrix = this.pl.matrix.inverted();
        var rii = this.ps.getRotateItemsInfo();
        if (rii.pivot) {
            this.vpInitialPivotPoint = new paper__WEBPACK_IMPORTED_MODULE_4__["Point"](rii.pivot);
        }
        else {
            this.vpInitialPivotPoint = app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_3__["PaperUtil"].transformRectangle(app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_3__["PaperUtil"].computeBounds(selectedItems), invertedPaperLayerMatrix).center;
        }
        this.vpDownPoint = this.pl.globalToLocal(event.downPoint);
    };
    // @Override
    RotateItemsDragPivotGesture.prototype.onMouseDrag = function (event) {
        var vpPoint = this.pl.globalToLocal(event.point);
        var pivot = this.vpInitialPivotPoint.add(vpPoint.subtract(this.vpDownPoint));
        this.ps.setRotateItemsInfo({ pivot: pivot });
    };
    // @Override
    RotateItemsDragPivotGesture.prototype.onMouseUp = function (event) {
        this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Default);
    };
    // @Override
    RotateItemsDragPivotGesture.prototype.onKeyDown = function (event) { };
    // @Override
    RotateItemsDragPivotGesture.prototype.onKeyUp = function (event) { };
    return RotateItemsDragPivotGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_2__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/rotate/RotateItemsGesture.ts":
/*!***********************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/rotate/RotateItemsGesture.ts ***!
  \***********************************************************************************/
/*! exports provided: RotateItemsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RotateItemsGesture", function() { return RotateItemsGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/paths */ "./src/app/modules/editor/model/paths/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_5__);






/**
 * A gesture that performs rotation operations.
 *
 * Preconditions:
 * - The user is in default mode.
 * - One or more layers are selected.
 * - A mouse down event occurred on a selection bounds handle.
 *
 * TODO: avoid jank at beginning of rotation (when angle is near 0)
 * TODO: make sure the 'empty group' logic we add also matches what we have in PaperLayer.ts
 * TODO: show a tool tip during rotations
 * TODO: make sure the pivot doesn't move during the initial drag
 */
var RotateItemsGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RotateItemsGesture, _super);
    function RotateItemsGesture(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_5__["project"].activeLayer;
        return _this;
    }
    // @Override
    RotateItemsGesture.prototype.onMouseDown = function (event) {
        var _this = this;
        this.ps.setHoveredLayerId(undefined);
        var scaleItems = [];
        var scaleItemsSet = new Set();
        Array.from(this.ps.getSelectedLayerIds())
            .map(function (id) { return _this.pl.findItemByLayerId(id); })
            // TODO: reuse this code with PaperLayer (filter out empty groups)
            .filter(function (i) { return !(i instanceof paper__WEBPACK_IMPORTED_MODULE_5__["Group"]) || i.children.length; })
            .forEach(function recurseFn(i) {
            if (i instanceof paper__WEBPACK_IMPORTED_MODULE_5__["Group"]) {
                i.children.forEach(recurseFn);
            }
            else if (!scaleItemsSet.has(i.data.id)) {
                scaleItemsSet.add(i.data.id);
                scaleItems.push(i);
            }
        });
        this.selectedItems = scaleItems;
        var invertedPaperLayerMatrix = this.pl.matrix.inverted();
        this.localToVpItemMatrices = this.selectedItems.map(function (item) {
            // Compute the matrices to directly transform during drag events.
            return item.globalMatrix.prepended(invertedPaperLayerMatrix).inverted();
        });
        var rii = this.ps.getRotateItemsInfo();
        if (rii.pivot) {
            this.vpPivot = new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](rii.pivot);
        }
        else {
            this.vpPivot = app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__["PaperUtil"].transformRectangle(app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_4__["PaperUtil"].computeBounds(this.selectedItems), invertedPaperLayerMatrix).center;
        }
        this.initialVectorLayer = this.ps.getVectorLayer();
        this.vpDownPoint = this.pl.globalToLocal(event.downPoint);
    };
    // @Override
    RotateItemsGesture.prototype.onMouseDrag = function (event) {
        this.vpPoint = this.pl.globalToLocal(event.point);
        this.processEvent(event);
    };
    // @Override
    RotateItemsGesture.prototype.onKeyDown = function (event) {
        this.processKeyEvent(event);
    };
    // @Override
    RotateItemsGesture.prototype.onKeyUp = function (event) {
        this.processKeyEvent(event);
    };
    RotateItemsGesture.prototype.processKeyEvent = function (event) {
        if (event.key === 'shift') {
            this.processEvent(event);
        }
    };
    // TODO: determine if we should be baking transforms into the children layers when rotating a group?
    RotateItemsGesture.prototype.processEvent = function (event) {
        var _this = this;
        if (!this.vpPoint) {
            return;
        }
        var rotationAngle = this.getRotationAngle(event);
        var newVl = this.initialVectorLayer.clone();
        this.selectedItems.forEach(function (item, index) {
            var path = item.clone();
            path.applyMatrix = true;
            var localToViewportMatrix = _this.localToVpItemMatrices[index];
            var matrix = localToViewportMatrix.clone();
            matrix.rotate(rotationAngle, _this.vpPivot);
            matrix.append(localToViewportMatrix.inverted());
            path.matrix = matrix;
            var newPl = newVl.findLayerById(item.data.id).clone();
            newPl.pathData = new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_2__["Path"](path.pathData);
            newVl = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["LayerUtil"].replaceLayer(newVl, item.data.id, newPl);
        });
        this.ps.setVectorLayer(newVl);
    };
    RotateItemsGesture.prototype.getRotationAngle = function (event) {
        var initialDelta = this.vpDownPoint.subtract(this.vpPivot);
        var initialAngle = (Math.atan2(initialDelta.y, initialDelta.x) * 180) / Math.PI;
        var delta = this.vpPoint.subtract(this.vpPivot);
        var angle = (Math.atan2(delta.y, delta.x) * 180) / Math.PI - initialAngle;
        // TODO: this doesn't round properly if the angle was previously changed
        return event.modifiers.shift ? Math.round(angle / 15) * 15 : angle;
    };
    return RotateItemsGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_3__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/rotate/index.ts":
/*!**********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/rotate/index.ts ***!
  \**********************************************************************/
/*! exports provided: RotateItemsGesture, RotateItemsDragPivotGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _RotateItemsGesture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RotateItemsGesture */ "./src/app/modules/editor/scripts/paper/gesture/rotate/RotateItemsGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RotateItemsGesture", function() { return _RotateItemsGesture__WEBPACK_IMPORTED_MODULE_0__["RotateItemsGesture"]; });

/* harmony import */ var _RotateItemsDragPivotGesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RotateItemsDragPivotGesture */ "./src/app/modules/editor/scripts/paper/gesture/rotate/RotateItemsDragPivotGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RotateItemsDragPivotGesture", function() { return _RotateItemsDragPivotGesture__WEBPACK_IMPORTED_MODULE_1__["RotateItemsDragPivotGesture"]; });





/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/scale/ScaleItemsGesture.ts":
/*!*********************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/scale/ScaleItemsGesture.ts ***!
  \*********************************************************************************/
/*! exports provided: ScaleItemsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScaleItemsGesture", function() { return ScaleItemsGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/paths */ "./src/app/modules/editor/model/paths/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_7__);








/**
 * A gesture that performs scaling operations.
 *
 * Preconditions:
 * - The user is in default mode.
 * - One or more layers are selected.
 * - A mouse down event occurred on a selection bounds handle.
 *
 * TODO: should we also scale the stroke width?
 */
var ScaleItemsGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ScaleItemsGesture, _super);
    function ScaleItemsGesture(ps, selectionBoundsRaster) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.selectionBoundsRaster = selectionBoundsRaster;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_7__["project"].activeLayer;
        return _this;
    }
    // @Override
    ScaleItemsGesture.prototype.onMouseDown = function (event) {
        var _this = this;
        this.ps.setHoveredLayerId(undefined);
        // TODO: make searches like this more efficient...
        var scaleItems = [];
        var scaleItemsSet = new Set();
        Array.from(this.ps.getSelectedLayerIds())
            .map(function (id) { return _this.pl.findItemByLayerId(id); })
            // TODO: reuse this code with PaperLayer (filter out empty groups)
            .filter(function (i) { return !(i instanceof paper__WEBPACK_IMPORTED_MODULE_7__["Group"]) || i.children.length; })
            .forEach(function recurseFn(i) {
            if (i instanceof paper__WEBPACK_IMPORTED_MODULE_7__["Group"]) {
                i.children.forEach(recurseFn);
            }
            else if (!scaleItemsSet.has(i.data.id)) {
                scaleItemsSet.add(i.data.id);
                scaleItems.push(i);
            }
        });
        this.selectedItems = scaleItems;
        this.localToVpItemMatrices = this.selectedItems.map(function (item) {
            // Compute the matrices to directly transform during drag events.
            return item.globalMatrix.prepended(_this.pl.matrix.inverted()).inverted();
        });
        var bounds = app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__["PaperUtil"].transformRectangle(app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__["PaperUtil"].computeBounds(this.selectedItems), this.pl.matrix.inverted());
        this.vpInitialPivot = bounds[this.selectionBoundsRaster.oppositePivotType];
        this.vpInitialDraggedSegment = bounds[this.selectionBoundsRaster.pivotType];
        this.vpDownPoint = bounds[this.selectionBoundsRaster.pivotType];
        this.vpPoint = this.vpDownPoint;
        this.vpInitialSize = this.vpDownPoint.subtract(this.vpInitialPivot);
        this.vpInitialCenteredSize = this.vpInitialSize.multiply(0.5);
        this.vpInitialCenter = bounds.center.clone();
        this.initialVectorLayer = this.ps.getVectorLayer();
    };
    // @Override
    ScaleItemsGesture.prototype.onMouseDrag = function (event) {
        this.vpPoint = this.pl.globalToLocal(event.point);
        var _a = this.vpPoint, x = _a.x, y = _a.y;
        this.ps.setTooltipInfo({
            point: { x: x, y: y },
            // TODO: display the current width/height of the shape
            label: lodash__WEBPACK_IMPORTED_MODULE_6__["round"](x, 1) + " \u2A2F " + lodash__WEBPACK_IMPORTED_MODULE_6__["round"](y, 1),
        });
        this.processEvent(event);
    };
    // @Override
    ScaleItemsGesture.prototype.onMouseUp = function (event) {
        // TODO: need to disable this in onKeyEvents as well?
        this.ps.setSnapGuideInfo(undefined);
        this.ps.setTooltipInfo(undefined);
    };
    // @Override
    ScaleItemsGesture.prototype.onKeyDown = function (event) {
        this.processKeyEvent(event);
    };
    // @Override
    ScaleItemsGesture.prototype.onKeyUp = function (event) {
        this.processKeyEvent(event);
    };
    ScaleItemsGesture.prototype.processKeyEvent = function (event) {
        if (event.key === 'alt' || event.key === 'shift') {
            this.processEvent(event);
        }
    };
    // TODO: make sure it is possible to scale/shrink the item when holding shift?
    ScaleItemsGesture.prototype.processEvent = function (event) {
        var _this = this;
        var projDownPoint = this.pl.localToGlobal(this.vpDownPoint);
        var projPoint = this.pl.localToGlobal(this.vpPoint);
        var projDelta = projPoint.subtract(projDownPoint);
        var newVl = this.initialVectorLayer.clone();
        newVl = this.scaleItems(newVl, projDelta, event.modifiers.alt, event.modifiers.shift);
        this.ps.setVectorLayer(newVl);
        // TODO: this could be WAY more efficient (no need to scale/snap things twice)
        // TODO: snap if shift is held and aspect ratio doesn't change?
        // TODO: first snap the widths and heights, then snap the guides
        var shouldSnap = !event.modifiers.shift;
        if (shouldSnap) {
            var snapInfo = this.buildSnapInfo();
            if (snapInfo) {
                var projSnapDelta = new paper__WEBPACK_IMPORTED_MODULE_7__["Point"](snapInfo.projSnapDelta);
                if (!projSnapDelta.isZero()) {
                    var shouldScaleAboutCenter = event.modifiers.alt;
                    var vpFixedPivot = shouldScaleAboutCenter ? this.vpInitialCenter : this.vpInitialPivot;
                    // TODO: confirm this is the correct way to fix the project snap delta?
                    if (this.vpPoint.x < vpFixedPivot.x) {
                        projSnapDelta.x *= -1;
                    }
                    if (this.vpPoint.y < vpFixedPivot.y) {
                        projSnapDelta.y *= -1;
                    }
                    newVl = this.scaleItems(newVl, projPoint.add(projSnapDelta).subtract(projDownPoint), shouldScaleAboutCenter);
                    this.ps.setVectorLayer(newVl);
                }
            }
        }
        if (shouldSnap) {
            var snapInfo = this.buildSnapInfo();
            if (snapInfo) {
                this.ps.setSnapGuideInfo({
                    guides: snapInfo.guides.map(function (g) { return _this.projToVpLine(g); }),
                    rulers: snapInfo.rulers.map(function (r) { return _this.projToVpLine(r); }),
                });
            }
            else {
                this.ps.setSnapGuideInfo(undefined);
            }
        }
        else {
            this.ps.setSnapGuideInfo(undefined);
        }
    };
    ScaleItemsGesture.prototype.scaleItems = function (newVl, projDelta, shouldScaleAboutCenter, shouldSnapDelta) {
        var _this = this;
        if (shouldSnapDelta === void 0) { shouldSnapDelta = false; }
        // Transform about the center if alt is pressed. Otherwise trasform about
        // the pivot opposite of the currently active pivot.
        var vpFixedPivot = shouldScaleAboutCenter ? this.vpInitialCenter : this.vpInitialPivot;
        var currentSize = this.vpInitialDraggedSegment
            .add(this.pl.globalToLocal(projDelta))
            .subtract(vpFixedPivot);
        var initialSize = shouldScaleAboutCenter ? this.vpInitialCenteredSize : this.vpInitialSize;
        var sx = 1;
        var sy = 1;
        if (!app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["MathUtil"].isNearZero(initialSize.x)) {
            sx = currentSize.x / initialSize.x;
        }
        if (!app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["MathUtil"].isNearZero(initialSize.y)) {
            sy = currentSize.y / initialSize.y;
        }
        if (shouldSnapDelta) {
            var signx = sx > 0 ? 1 : -1;
            var signy = sy > 0 ? 1 : -1;
            sx = sy = Math.max(Math.abs(sx), Math.abs(sy));
            sx *= signx;
            sy *= signy;
        }
        // TODO: determine if we should be baking transforms into the children layers when scaling a group?
        this.selectedItems.forEach(function (item, index) {
            var path = item.clone();
            path.applyMatrix = true;
            var localToVpMatrix = _this.localToVpItemMatrices[index];
            var matrix = localToVpMatrix.clone();
            matrix.scale(sx, sy, vpFixedPivot);
            matrix.append(localToVpMatrix.inverted());
            path.matrix = matrix;
            console.log(item.data.id);
            var newPl = newVl.findLayerById(item.data.id).clone();
            newPl.pathData = new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_2__["Path"](path.pathData);
            newVl = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["LayerUtil"].replaceLayer(newVl, item.data.id, newPl);
        });
        return newVl;
    };
    // TODO: reuse this code with SelectDragCloneItemsGesture
    ScaleItemsGesture.prototype.buildSnapInfo = function () {
        var _this = this;
        var selectedLayerIds = this.ps.getSelectedLayerIds();
        if (!selectedLayerIds.size) {
            return undefined;
        }
        var draggedItems = Array.from(selectedLayerIds).map(function (id) { return _this.pl.findItemByLayerId(id); });
        var parent = draggedItems[0].parent;
        if (!draggedItems.every(function (item) { return item.parent === parent; })) {
            // TODO: copy the behavior used in Sketch
            console.warn('All snapped items must share the same parent item.');
            return undefined;
        }
        var siblingItems = parent.children.filter(function (i) { return !draggedItems.includes(i); });
        if (!siblingItems.length) {
            return undefined;
        }
        // Perform the snap test.
        var toSnapPointsFn = function (items) {
            var _a = app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__["PaperUtil"].computeBounds(items), topLeft = _a.topLeft, center = _a.center, bottomRight = _a.bottomRight;
            return [topLeft, center, bottomRight];
        };
        // TODO: also snap-to-VectorLayer bounds (similar to the dragging gesture)
        return app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__["SnapUtil"].computeSnapInfo(toSnapPointsFn(draggedItems), siblingItems.map(function (siblingItem) { return toSnapPointsFn([siblingItem]); }), true /* snapToDimensions */);
    };
    ScaleItemsGesture.prototype.projToVpLine = function (_a) {
        var from = _a.from, to = _a.to;
        return {
            from: this.pl.globalToLocal(new paper__WEBPACK_IMPORTED_MODULE_7__["Point"](from)),
            to: this.pl.globalToLocal(new paper__WEBPACK_IMPORTED_MODULE_7__["Point"](to)),
        };
    };
    return ScaleItemsGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_4__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/scale/index.ts":
/*!*********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/scale/index.ts ***!
  \*********************************************************************/
/*! exports provided: ScaleItemsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ScaleItemsGesture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScaleItemsGesture */ "./src/app/modules/editor/scripts/paper/gesture/scale/ScaleItemsGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScaleItemsGesture", function() { return _ScaleItemsGesture__WEBPACK_IMPORTED_MODULE_0__["ScaleItemsGesture"]; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/select/BatchSelectItemsGesture.ts":
/*!****************************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/select/BatchSelectItemsGesture.ts ***!
  \****************************************************************************************/
/*! exports provided: BatchSelectItemsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BatchSelectItemsGesture", function() { return BatchSelectItemsGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_2__);



/**
 * A gesture that selects one or more items using a selection box.
 *
 * Preconditions:
 * - The user is in default mode.
 */
var BatchSelectItemsGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](BatchSelectItemsGesture, _super);
    // private initialSelectedLayers: ReadonlySet<string>;
    function BatchSelectItemsGesture(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_2__["project"].activeLayer;
        return _this;
    }
    // @Override
    BatchSelectItemsGesture.prototype.onMouseDown = function (event) {
        if (!event.modifiers.shift) {
            // A selection box implies that the gesture began with a failed hit test,
            // so deselect everything on mouse down (unless the user is holding shift).
            this.ps.setSelectedLayerIds(new Set());
        }
        // TODO: make use of this information (i.e. toggle the layers when shift is pressed)
        // this.initialSelectedLayers = this.ps.getSelectedLayerIds();
    };
    // @Override
    BatchSelectItemsGesture.prototype.onMouseDrag = function (event) {
        this.ps.setSelectionBox({
            from: this.pl.globalToLocal(event.downPoint),
            to: this.pl.globalToLocal(event.point),
        });
        this.selectItemsInSelectionBox(!event.modifiers.alt);
    };
    // @Override
    BatchSelectItemsGesture.prototype.onMouseUp = function (event) {
        this.selectItemsInSelectionBox(!event.modifiers.alt);
        this.ps.setSelectionBox(undefined);
        this.ps.setRotateItemsInfo(undefined);
        this.ps.setTransformPathsInfo(undefined);
    };
    // @Override
    BatchSelectItemsGesture.prototype.onKeyDown = function (event) {
        if (event.key === 'alt') {
            this.selectItemsInSelectionBox(false);
        }
    };
    // @Override
    BatchSelectItemsGesture.prototype.onKeyUp = function (event) {
        if (event.key === 'alt') {
            this.selectItemsInSelectionBox(true);
        }
    };
    BatchSelectItemsGesture.prototype.selectItemsInSelectionBox = function (includePartialOverlaps) {
        var box = this.ps.getSelectionBox();
        if (box) {
            var from = new paper__WEBPACK_IMPORTED_MODULE_2__["Point"](box.from);
            var to = new paper__WEBPACK_IMPORTED_MODULE_2__["Point"](box.to);
            var selectedItems = this.pl.findItemsInBounds(new paper__WEBPACK_IMPORTED_MODULE_2__["Rectangle"](from, to), includePartialOverlaps);
            this.ps.setSelectedLayerIds(new Set(selectedItems.map(function (i) { return i.data.id; })));
        }
    };
    return BatchSelectItemsGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/select/DeselectItemGesture.ts":
/*!************************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/select/DeselectItemGesture.ts ***!
  \************************************************************************************/
/*! exports provided: DeselectItemGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeselectItemGesture", function() { return DeselectItemGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");


/**
 * A gesture that deselects a single item.
 *
 * Preconditions:
 * - The user is in default mode.
 */
var DeselectItemGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](DeselectItemGesture, _super);
    function DeselectItemGesture(ps, deselectedItemId) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.deselectedItemId = deselectedItemId;
        return _this;
    }
    // @Override
    DeselectItemGesture.prototype.onMouseDown = function (event) {
        var layerIds = new Set(this.ps.getSelectedLayerIds());
        layerIds.delete(this.deselectedItemId);
        this.ps.setSelectedLayerIds(layerIds);
    };
    return DeselectItemGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/select/EditPathGesture.ts":
/*!********************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/select/EditPathGesture.ts ***!
  \********************************************************************************/
/*! exports provided: EditPathGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditPathGesture", function() { return EditPathGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_3__);




/**
 * A gesture that exits default mode and enters edit path mode.
 *
 * Preconditions:
 * - The user is in default mode.
 */
var EditPathGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](EditPathGesture, _super);
    function EditPathGesture(ps, editPathId) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.editPathId = editPathId;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_3__["project"].activeLayer;
        return _this;
    }
    // @Override
    EditPathGesture.prototype.onMouseDown = function (event) {
        var editPath = this.pl.findItemByLayerId(this.editPathId);
        this.ps.setSelectedLayerIds(new Set([this.editPathId]));
        this.ps.setEditPathInfo(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_2__["PaperUtil"].selectCurves(editPath, new Set([editPath.segments.length - 1]))));
        this.ps.setRotateItemsInfo(undefined);
        this.ps.setTransformPathsInfo(undefined);
    };
    return EditPathGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_1__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/select/SelectDragCloneItemsGesture.ts":
/*!********************************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/select/SelectDragCloneItemsGesture.ts ***!
  \********************************************************************************************/
/*! exports provided: SelectDragCloneItemsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectDragCloneItemsGesture", function() { return SelectDragCloneItemsGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_6__);







/**
 * A gesture that performs selection, move, and clone operations
 * on one or more items.
 *
 * Preconditions:
 * - The user is in default mode.
 * - The user hit an item in the previous mousedown event.
 */
var SelectDragCloneItemsGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SelectDragCloneItemsGesture, _super);
    function SelectDragCloneItemsGesture(ps, hitLayerId) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.hitLayerId = hitLayerId;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_6__["project"].activeLayer;
        _this.isDragging = false;
        return _this;
    }
    // @Override
    SelectDragCloneItemsGesture.prototype.onMouseDown = function (event) {
        // Clear the current hover layer, if it exists.
        this.ps.setHoveredLayerId(undefined);
        var selectedLayers = new Set(this.ps.getSelectedLayerIds());
        if (!event.modifiers.shift && !selectedLayers.has(this.hitLayerId)) {
            // If shift isn't pressed and the hit layer isn't already selected,
            // then clear any existing selections.
            selectedLayers.clear();
        }
        // Select the hit item.
        selectedLayers.add(this.hitLayerId);
        this.ps.setSelectedLayerIds(selectedLayers);
        // Save a copy of the initial vector layer so that we can make changes
        // to it as we drag.
        this.initialVectorLayer = this.ps.getVectorLayer();
    };
    // @Override
    SelectDragCloneItemsGesture.prototype.onMouseDrag = function (event) {
        var _this = this;
        if (!this.isDragging) {
            this.isDragging = true;
            if (event.modifiers.alt) {
                // TODO: clone the selected items
            }
            this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["CursorType"].Grabbing);
        }
        var newVl = this.initialVectorLayer.clone();
        newVl = this.dragItems(newVl, event.downPoint, event.point, event.modifiers.shift);
        this.ps.setVectorLayer(newVl);
        // TODO: this could be WAY more efficient (no need to drag/snap things twice)
        var snapInfo = this.buildSnapInfo();
        if (snapInfo) {
            var projSnapDelta = new paper__WEBPACK_IMPORTED_MODULE_6__["Point"](snapInfo.projSnapDelta);
            if (!projSnapDelta.isZero()) {
                newVl = this.dragItems(newVl, event.downPoint, event.downPoint.add(projSnapDelta));
                this.ps.setVectorLayer(newVl);
            }
            var updatedSnapInfo = this.buildSnapInfo();
            this.ps.setSnapGuideInfo({
                guides: updatedSnapInfo.guides.map(function (g) { return _this.projToVpLine(g); }),
                rulers: updatedSnapInfo.rulers.map(function (r) { return _this.projToVpLine(r); }),
            });
        }
        else {
            this.ps.setSnapGuideInfo(undefined);
        }
    };
    // TODO: dragging a parent and child simultaneously doesn't work
    SelectDragCloneItemsGesture.prototype.dragItems = function (newVl, projDownPoint, projPoint, shouldSnapDelta) {
        var _this = this;
        if (shouldSnapDelta === void 0) { shouldSnapDelta = false; }
        Array.from(this.ps.getSelectedLayerIds()).forEach(function (layerId) {
            var item = _this.pl.findItemByLayerId(layerId);
            var localDown = item.globalToLocal(projDownPoint).transform(item.matrix);
            var localCurr = item.globalToLocal(projPoint).transform(item.matrix);
            var localDelta = localCurr.subtract(localDown);
            var localFinalDelta = shouldSnapDelta
                ? new paper__WEBPACK_IMPORTED_MODULE_6__["Point"](app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["MathUtil"].snapVectorToAngle(localDelta, 90))
                : localDelta;
            newVl = dragItem(newVl, layerId, localFinalDelta);
        });
        return newVl;
    };
    // TODO: reuse this code with ScaleItemsGesture
    SelectDragCloneItemsGesture.prototype.buildSnapInfo = function () {
        var _this = this;
        var selectedLayerIds = this.ps.getSelectedLayerIds();
        if (!selectedLayerIds.size) {
            return undefined;
        }
        var draggedItems = Array.from(selectedLayerIds).map(function (id) { return _this.pl.findItemByLayerId(id); });
        var parent = draggedItems[0].parent;
        if (!draggedItems.every(function (item) { return item.parent === parent; })) {
            // TODO: copy the behavior used in Sketch
            console.warn('All snapped items must share the same parent item.');
            return undefined;
        }
        var siblingItems = parent.children.filter(function (i) { return !draggedItems.includes(i); });
        var isParentVectorLayer = parent.data.id === this.initialVectorLayer.id;
        if (!siblingItems.length && !isParentVectorLayer) {
            return undefined;
        }
        // Perform the snap test.
        var siblingSnapPointsTable = siblingItems.map(function (item) { return toSnapPoints([item]); });
        if (isParentVectorLayer) {
            var _a = this.initialVectorLayer, width = _a.width, height = _a.height;
            var topLeft = new paper__WEBPACK_IMPORTED_MODULE_6__["Point"](0, 0);
            var bottomRight = parent.localToGlobal(new paper__WEBPACK_IMPORTED_MODULE_6__["Point"](width, height));
            var center = bottomRight.divide(2);
            siblingSnapPointsTable.push([topLeft, center, bottomRight]);
        }
        return app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__["SnapUtil"].computeSnapInfo(toSnapPoints(draggedItems), siblingSnapPointsTable);
    };
    // @Override
    SelectDragCloneItemsGesture.prototype.onMouseUp = function (event) {
        this.ps.setSnapGuideInfo(undefined);
        this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["CursorType"].Default);
    };
    SelectDragCloneItemsGesture.prototype.projToVpLine = function (_a) {
        var from = _a.from, to = _a.to;
        return {
            from: this.pl.globalToLocal(new paper__WEBPACK_IMPORTED_MODULE_6__["Point"](from)),
            to: this.pl.globalToLocal(new paper__WEBPACK_IMPORTED_MODULE_6__["Point"](to)),
        };
    };
    return SelectDragCloneItemsGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_4__["Gesture"]));

// TODO: should we bake transforms into children (to be consistent with scale items gesture?)
function dragItem(newVl, layerId, localDelta) {
    var initialLayer = newVl.findLayerById(layerId);
    var x = localDelta.x, y = localDelta.y;
    if (initialLayer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["PathLayer"] || initialLayer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["ClipPathLayer"]) {
        var replacementLayer = initialLayer.clone();
        replacementLayer.pathData = initialLayer.pathData.transform(app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["Matrix"].translation(x, y));
        newVl = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["LayerUtil"].replaceLayer(newVl, layerId, replacementLayer);
    }
    else if (initialLayer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["GroupLayer"]) {
        var replacementLayer = initialLayer.clone();
        replacementLayer.translateX += x;
        replacementLayer.translateY += y;
        newVl = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["LayerUtil"].replaceLayer(newVl, layerId, replacementLayer);
    }
    return newVl;
}
function toSnapPoints(items) {
    var _a = app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__["PaperUtil"].computeBounds(items), topLeft = _a.topLeft, center = _a.center, bottomRight = _a.bottomRight;
    return [topLeft, center, bottomRight];
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/select/index.ts":
/*!**********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/select/index.ts ***!
  \**********************************************************************/
/*! exports provided: BatchSelectItemsGesture, DeselectItemGesture, EditPathGesture, SelectDragCloneItemsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BatchSelectItemsGesture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BatchSelectItemsGesture */ "./src/app/modules/editor/scripts/paper/gesture/select/BatchSelectItemsGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BatchSelectItemsGesture", function() { return _BatchSelectItemsGesture__WEBPACK_IMPORTED_MODULE_0__["BatchSelectItemsGesture"]; });

/* harmony import */ var _DeselectItemGesture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DeselectItemGesture */ "./src/app/modules/editor/scripts/paper/gesture/select/DeselectItemGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DeselectItemGesture", function() { return _DeselectItemGesture__WEBPACK_IMPORTED_MODULE_1__["DeselectItemGesture"]; });

/* harmony import */ var _EditPathGesture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditPathGesture */ "./src/app/modules/editor/scripts/paper/gesture/select/EditPathGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EditPathGesture", function() { return _EditPathGesture__WEBPACK_IMPORTED_MODULE_2__["EditPathGesture"]; });

/* harmony import */ var _SelectDragCloneItemsGesture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SelectDragCloneItemsGesture */ "./src/app/modules/editor/scripts/paper/gesture/select/SelectDragCloneItemsGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectDragCloneItemsGesture", function() { return _SelectDragCloneItemsGesture__WEBPACK_IMPORTED_MODULE_3__["SelectDragCloneItemsGesture"]; });







/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/transform/TransformPathsGesture.ts":
/*!*****************************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/transform/TransformPathsGesture.ts ***!
  \*****************************************************************************************/
/*! exports provided: TransformPathsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransformPathsGesture", function() { return TransformPathsGesture; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/paths */ "./src/app/modules/editor/model/paths/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture */ "./src/app/modules/editor/scripts/paper/gesture/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_6__);







/**
 * A gesture that performs transform operations.
 *
 * Preconditions:
 * - The user is in default mode.
 * - One or more paths are selected.
 * - A mouse down event occurred on a selection bounds handle.
 *
 * TODO: finish this
 * TODO: fix crash that can occur when 3+ points are on same axis
 * TODO: could this work with generic items (not just paths)?
 * TODO: we need to also filter out non-empty groups (see PaperLayer.ts)
 */
var TransformPathsGesture = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](TransformPathsGesture, _super);
    function TransformPathsGesture(ps, selectionBoundsRaster) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.selectionBoundsRaster = selectionBoundsRaster;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_6__["project"].activeLayer;
        return _this;
    }
    // @Override
    TransformPathsGesture.prototype.onMouseDown = function (event) {
        var _this = this;
        this.ps.setHoveredLayerId(undefined);
        this.selectedItems = Array.from(this.ps.getSelectedLayerIds()).map(function (id) { return _this.pl.findItemByLayerId(id); });
        var invertedPaperLayerMatrix = this.pl.matrix.inverted();
        this.localToVpItemMatrices = this.selectedItems.map(function (item) {
            // Compute the matrices to directly transform during drag events.
            return item.globalMatrix.prepended(invertedPaperLayerMatrix).inverted();
        });
        this.vpBounds = app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__["PaperUtil"].transformRectangle(app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_5__["PaperUtil"].computeBounds(this.selectedItems), this.pl.matrix.inverted());
        this.vpDownPoint = this.vpBounds[this.selectionBoundsRaster.pivotType];
        this.vpPoint = this.vpDownPoint;
        this.initialVectorLayer = this.ps.getVectorLayer();
    };
    // @Override
    TransformPathsGesture.prototype.onMouseDrag = function (event) {
        this.vpPoint = this.pl.globalToLocal(event.point);
        this.processEvent(event);
    };
    // @Override
    TransformPathsGesture.prototype.onKeyDown = function (event) {
        this.processKeyEvent(event);
    };
    // @Override
    TransformPathsGesture.prototype.onKeyUp = function (event) {
        this.processKeyEvent(event);
    };
    TransformPathsGesture.prototype.processKeyEvent = function (event) {
        if (event.key === 'command') {
            this.processEvent(event);
        }
    };
    TransformPathsGesture.prototype.processEvent = function (event) {
        var _this = this;
        if (!this.vpPoint) {
            return;
        }
        var sourcePoints = [
            this.vpBounds.topLeft,
            this.vpBounds.topRight,
            this.vpBounds.bottomRight,
            this.vpBounds.bottomLeft,
        ].map(function (_a) {
            var x = _a.x, y = _a.y;
            return [x, y];
        });
        var targetPoints = sourcePoints.slice();
        var vpPoint = [this.vpPoint.x, this.vpPoint.y];
        switch (this.selectionBoundsRaster.pivotType) {
            case 'topLeft':
                targetPoints[0] = vpPoint;
                break;
            case 'topRight':
                targetPoints[1] = vpPoint;
                break;
            case 'bottomRight':
                targetPoints[2] = vpPoint;
                break;
            case 'bottomLeft':
                targetPoints[3] = vpPoint;
                break;
        }
        var distortFn = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["TransformUtil"].distort(sourcePoints, targetPoints);
        var newVl = this.initialVectorLayer.clone();
        this.selectedItems.forEach(function (item, index) {
            // TODO: make this stuff works for groups as well
            var path = item.clone();
            var localToViewportMatrix = _this.localToVpItemMatrices[index];
            var pathDistortFn = function (point) {
                point = localToViewportMatrix.transform(point);
                var intermediatePoint = distortFn([point.x, point.y]);
                point = new paper__WEBPACK_IMPORTED_MODULE_6__["Point"](intermediatePoint[0], intermediatePoint[1]);
                point = localToViewportMatrix.inverted().transform(point);
                return point;
            };
            path.segments.forEach(function (segment) {
                if (segment.handleIn) {
                    segment.handleIn = pathDistortFn(segment.point.add(segment.handleIn)).subtract(segment.point);
                }
                if (segment.handleOut) {
                    segment.handleOut = pathDistortFn(segment.point.add(segment.handleOut)).subtract(segment.point);
                }
                segment.point = pathDistortFn(segment.point);
            });
            var newPl = newVl.findLayerById(item.data.id).clone();
            newPl.pathData = new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_2__["Path"](path.pathData);
            newVl = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["LayerUtil"].replaceLayer(newVl, item.data.id, newPl);
        });
        this.ps.setVectorLayer(newVl);
    };
    return TransformPathsGesture;
}(app_modules_editor_scripts_paper_gesture__WEBPACK_IMPORTED_MODULE_4__["Gesture"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/gesture/transform/index.ts":
/*!*************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/gesture/transform/index.ts ***!
  \*************************************************************************/
/*! exports provided: TransformPathsGesture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TransformPathsGesture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransformPathsGesture */ "./src/app/modules/editor/scripts/paper/gesture/transform/TransformPathsGesture.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformPathsGesture", function() { return _TransformPathsGesture__WEBPACK_IMPORTED_MODULE_0__["TransformPathsGesture"]; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/index.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/index.ts ***!
  \*******************************************************/
/*! exports provided: PaperProject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _PaperProject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PaperProject */ "./src/app/modules/editor/scripts/paper/PaperProject.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PaperProject", function() { return _PaperProject__WEBPACK_IMPORTED_MODULE_1__["PaperProject"]; });


// By default paper.js bakes matrix transformations directly into its children.
// This is usually not the behavior we want (especially for groups).
paper__WEBPACK_IMPORTED_MODULE_0__["settings"].applyMatrix = false;
// By default paper.js automatically inserts newly created items into the active layer.
// This behavior makes it harder to explicitly position things in the item hierarchy.
paper__WEBPACK_IMPORTED_MODULE_0__["settings"].insertItems = false;



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/item/EditPathRaster.ts":
/*!*********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/item/EditPathRaster.ts ***!
  \*********************************************************************/
/*! exports provided: EditPathRaster */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditPathRaster", function() { return EditPathRaster; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);


var EditPathRaster = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](EditPathRaster, _super);
    function EditPathRaster(type, segmentIndex, isSelected, center) {
        var _this = _super.call(this, type === 'segment'
            ? "/assets/paper/" + (isSelected ? 'vector-segment-selected' : 'vector-segment') + ".png"
            : "/assets/paper/" + (isSelected ? 'vector-handle-selected' : 'vector-handle') + ".png", center) || this;
        _this.type = type;
        _this.segmentIndex = segmentIndex;
        _this.isSelected = isSelected;
        return _this;
    }
    return EditPathRaster;
}(paper__WEBPACK_IMPORTED_MODULE_1__["Raster"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/item/HitTests.ts":
/*!***************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/item/HitTests.ts ***!
  \***************************************************************/
/*! exports provided: selectionMode, getSelectedLayerMap, findFirstHitResult, selectionModeSegments, rotateItemsPivot, editPathMode, editPathModeSegmentsAndHandles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectionMode", function() { return selectionMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedLayerMap", function() { return getSelectedLayerMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findFirstHitResult", function() { return findFirstHitResult; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectionModeSegments", function() { return selectionModeSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateItemsPivot", function() { return rotateItemsPivot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "editPathMode", function() { return editPathMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "editPathModeSegmentsAndHandles", function() { return editPathModeSegmentsAndHandles; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _EditPathRaster__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditPathRaster */ "./src/app/modules/editor/scripts/paper/item/EditPathRaster.ts");
/* harmony import */ var _RotateItemsPivotRaster__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RotateItemsPivotRaster */ "./src/app/modules/editor/scripts/paper/item/RotateItemsPivotRaster.ts");
/* harmony import */ var _SelectionBoundsRaster__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SelectionBoundsRaster */ "./src/app/modules/editor/scripts/paper/item/SelectionBoundsRaster.ts");






/** Performs the default default mode hit test. */
function selectionMode(projPoint, ps) {
    var pl = paper__WEBPACK_IMPORTED_MODULE_2__["project"].activeLayer;
    var children = pl.hitTestVectorLayer(projPoint).children;
    var selectionMap = getSelectedLayerMap(ps);
    return findFirstHitResult(children, selectionMap);
}
/**
 * Returns a map of layerIds to booleans. Each key-value pair indicates whether
 * the subtree rooted at layerId contains a selected layer.
 */
function getSelectedLayerMap(ps) {
    var map = new Map();
    var selectedLayers = ps.getSelectedLayerIds();
    (function containsSelectedLayerFn(layer) {
        var result = selectedLayers.has(layer.id);
        layer.children.forEach(function (c) { return (result = containsSelectedLayerFn(c) || result); });
        map.set(layer.id, result);
        return result;
    })(ps.getVectorLayer());
    return map;
}
function findFirstHitResult(hitResults, selectionMap, ignoredLayerIds) {
    if (ignoredLayerIds === void 0) { ignoredLayerIds = new Set(); }
    var firstHitResult;
    lodash__WEBPACK_IMPORTED_MODULE_1__["forEach"](hitResults, function recurseFn(hitResult) {
        if (firstHitResult) {
            return false;
        }
        var hasSelectedChildLayer = (hitResult.hitItem.children || []).some(function (c) {
            return selectionMap.get(c.data.id);
        });
        if (!hasSelectedChildLayer && !ignoredLayerIds.has(hitResult.hitItem.data.id)) {
            firstHitResult = hitResult;
            return false;
        }
        lodash__WEBPACK_IMPORTED_MODULE_1__["forEach"](hitResult.children, recurseFn);
        return true;
    });
    return firstHitResult;
}
/** Performs a hit test on the currently selected selection bound handles. */
function selectionModeSegments(projPoint) {
    var pl = paper__WEBPACK_IMPORTED_MODULE_2__["project"].activeLayer;
    return pl.hitTest(projPoint, { class: _SelectionBoundsRaster__WEBPACK_IMPORTED_MODULE_5__["SelectionBoundsRaster"] });
}
/** Performs a hit test on the rotate items pivot. */
function rotateItemsPivot(projPoint) {
    var pl = paper__WEBPACK_IMPORTED_MODULE_2__["project"].activeLayer;
    return pl.hitTest(projPoint, { class: _RotateItemsPivotRaster__WEBPACK_IMPORTED_MODULE_4__["RotateItemsPivotRaster"] });
}
/** Performs a hit test on the current edit path. */
function editPathMode(projPoint, editPath, hitOptions) {
    var _a = editPath.globalMatrix.scaling, sx = _a.x, sy = _a.y;
    var result = editPath.hitTest(editPath.globalToLocal(projPoint), tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, hitOptions, { 
        // TODO: properly calculate scale using similar method as in Matrix.ts
        // TODO: also test that this works when zoomed in/out?
        // TODO: are we correctly handling negative scales?
        tolerance: 8 / Math.max(Math.abs(sx), Math.abs(sy)), class: paper__WEBPACK_IMPORTED_MODULE_2__["Path"] }));
    return result;
}
/** Performs a hit test on the current edit path's segments and handles. */
function editPathModeSegmentsAndHandles(projPoint) {
    var pl = paper__WEBPACK_IMPORTED_MODULE_2__["project"].activeLayer;
    return pl.hitTest(projPoint, { class: _EditPathRaster__WEBPACK_IMPORTED_MODULE_3__["EditPathRaster"] });
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/item/PaperLayer.ts":
/*!*****************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/item/PaperLayer.ts ***!
  \*****************************************************************/
/*! exports provided: PaperLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PaperLayer", function() { return PaperLayer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _EditPathRaster__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EditPathRaster */ "./src/app/modules/editor/scripts/paper/item/EditPathRaster.ts");
/* harmony import */ var _RotateItemsPivotRaster__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RotateItemsPivotRaster */ "./src/app/modules/editor/scripts/paper/item/RotateItemsPivotRaster.ts");
/* harmony import */ var _SelectionBoundsRaster__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SelectionBoundsRaster */ "./src/app/modules/editor/scripts/paper/item/SelectionBoundsRaster.ts");









/**
 * The root layer used of our paper.js project. Note that this layer is
 * assigned a scale matrix that converts global project coordinates to
 * viewport coordinates.
 *
 * TODO: scaling rasters down causes their hit tolerances remain the same
 * TODO: when multiple items selected, show lightly outlined bounds for individual items?
 * TODO: explicitly set paths with no Z to closed? (i.e. M 1 1 h 6 v 6 h -6 v -6)
 * TODO: figure out if we can reduce stable bundle sizes (tree shake paper.js?)
 */
var PaperLayer = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](PaperLayer, _super);
    function PaperLayer(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.cssScaling = 1;
        _this.canvasColorRect = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"].Rectangle(new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](0, 0), new paper__WEBPACK_IMPORTED_MODULE_5__["Size"](0, 0));
        _this.canvasColorRect.guide = true;
        _this.updateChildren();
        return _this;
    }
    Object.defineProperty(PaperLayer.prototype, "vectorLayer", {
        get: function () {
            return this.ps.getVectorLayer();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PaperLayer.prototype, "selectedLayerIds", {
        get: function () {
            return this.ps.getSelectedLayerIds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PaperLayer.prototype, "hoveredLayerId", {
        get: function () {
            return this.ps.getHoveredLayerId();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PaperLayer.prototype, "hiddenLayerIds", {
        get: function () {
            return this.ps.getHiddenLayerIds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PaperLayer.prototype, "editPathInfo", {
        get: function () {
            return this.ps.getEditPathInfo();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PaperLayer.prototype, "rotateItemsInfo", {
        get: function () {
            return this.ps.getRotateItemsInfo();
        },
        enumerable: true,
        configurable: true
    });
    PaperLayer.prototype.hitTestVectorLayer = function (projPoint) {
        var _a = this.vectorLayer, vpWidth = _a.width, vpHeight = _a.height;
        var vpBounds = new paper__WEBPACK_IMPORTED_MODULE_5__["Rectangle"](0, 0, vpWidth, vpHeight);
        var vpPoint = this.vectorLayerItem.globalToLocal(projPoint);
        if (!vpBounds.contains(vpPoint)) {
            return { hitItem: undefined, children: [] };
        }
        var hitResult = (function recurseFn(item) {
            var localPoint = item.globalToLocal(projPoint).transform(item.matrix);
            var hitItem;
            var children = [];
            if (item instanceof paper__WEBPACK_IMPORTED_MODULE_5__["Path"]) {
                // TODO: figure out what to do with compound paths?
                var res = item.hitTest(localPoint, { fill: true, stroke: true });
                if (res) {
                    hitItem = res.item;
                }
            }
            else if (item instanceof paper__WEBPACK_IMPORTED_MODULE_5__["Group"]) {
                var strokeBounds = item.strokeBounds;
                if (strokeBounds.contains(localPoint)) {
                    hitItem = item;
                    children = item.children.map(recurseFn).filter(function (r) { return !!r.hitItem; });
                }
            }
            return { hitItem: hitItem, children: children };
        })(this.vectorLayerItem);
        return {
            hitItem: this.vectorLayerItem,
            children: hitResult.children,
        };
    };
    PaperLayer.prototype.setDimensions = function (viewportWidth, viewportHeight, viewWidth, viewHeight) {
        // Note that viewWidth / viewportWidth === viewHeight / viewportHeight.
        this.cssScaling = viewWidth / viewportWidth;
        this.matrix = new paper__WEBPACK_IMPORTED_MODULE_5__["Matrix"]().scale(this.cssScaling);
        this.updatePixelGridItem(viewportWidth, viewportHeight);
    };
    PaperLayer.prototype.onVectorLayerChanged = function () {
        this.updateCanvasColorShape();
        this.updateVectorLayerItem();
        this.updateEditPathItem();
        this.updateSelectionBoundsItem();
        this.updateRotateItemsPivotItem();
        this.updateHoverPathItem();
    };
    PaperLayer.prototype.onSelectedLayerIdsChanged = function () {
        this.updateSelectionBoundsItem();
        this.updateRotateItemsPivotItem();
    };
    PaperLayer.prototype.onHiddenLayerIdsChanged = function () {
        this.updateHiddenLayers();
        // TODO: should we hide selection bounds, overlays, etc. for invisible layers?
    };
    PaperLayer.prototype.onHoveredLayerIdChanged = function () {
        this.updateHoverPathItem();
    };
    PaperLayer.prototype.onEditPathInfoChanged = function () {
        this.updateEditPathItem();
        this.updateSelectionBoundsItem();
        this.updateRotateItemsPivotItem();
    };
    PaperLayer.prototype.onRotateItemsInfoChanged = function () {
        this.updateRotateItemsPivotItem();
    };
    PaperLayer.prototype.setCreatePathInfo = function (info) {
        if (this.createPathItem) {
            this.createPathItem.remove();
            this.createPathItem = undefined;
        }
        if (info) {
            this.createPathItem = newCreatePathItem(info);
            this.updateChildren();
        }
    };
    PaperLayer.prototype.setSplitCurveInfo = function (info) {
        if (this.splitCurveItem) {
            this.splitCurveItem.remove();
            this.splitCurveItem = undefined;
        }
        if (info) {
            this.splitCurveItem = newSplitCurveItem(info, this.cssScaling);
            this.updateChildren();
        }
    };
    PaperLayer.prototype.setTooltipInfo = function (info) {
        if (this.tooltipItem) {
            this.tooltipItem.remove();
            this.tooltipItem = undefined;
        }
        if (info) {
            // TODO: re-enable tooltip when ready
            // this.tooltipItem = newTooltipItem(info, this.cssScaling);
            this.updateChildren();
        }
    };
    PaperLayer.prototype.setSnapGuideInfo = function (info) {
        if (this.snapGuideItem) {
            this.snapGuideItem.remove();
            this.snapGuideItem = undefined;
        }
        if (info) {
            this.snapGuideItem = newSnapGuideItem(info, this.cssScaling);
            this.updateChildren();
        }
    };
    PaperLayer.prototype.setSelectionBox = function (box) {
        if (this.selectionBoxItem) {
            this.selectionBoxItem.remove();
            this.selectionBoxItem = undefined;
        }
        if (box) {
            this.selectionBoxItem = newSelectionBoxItem(box.from, box.to);
            this.updateChildren();
        }
    };
    PaperLayer.prototype.updateCanvasColorShape = function () {
        this.canvasColorRect = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"].Rectangle(new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](0, 0), new paper__WEBPACK_IMPORTED_MODULE_5__["Size"](this.vectorLayer.width, this.vectorLayer.height));
        this.canvasColorRect.guide = true;
        this.canvasColorRect.fillColor = parseAndroidColor(this.vectorLayer.canvasColor) || 'white';
        this.updateChildren();
    };
    PaperLayer.prototype.updateVectorLayerItem = function () {
        if (this.vectorLayerItem) {
            this.vectorLayerItem.remove();
        }
        this.vectorLayerItem = newVectorLayerItem(this.vectorLayer);
        this.updateHiddenLayers();
        this.updateChildren();
    };
    PaperLayer.prototype.updateSelectionBoundsItem = function () {
        if (this.selectionBoundsItem) {
            this.selectionBoundsItem.remove();
            this.selectionBoundsItem = undefined;
        }
        if (!this.editPathInfo) {
            var selectedItemBounds = this.getSelectedItemBounds();
            if (selectedItemBounds) {
                this.selectionBoundsItem = newSelectionBoundsItem(selectedItemBounds, this.cssScaling);
            }
        }
        this.updateChildren();
    };
    PaperLayer.prototype.updateRotateItemsPivotItem = function () {
        if (this.rotateItemsPivotItem) {
            this.rotateItemsPivotItem.remove();
            this.rotateItemsPivotItem = undefined;
        }
        var rii = this.rotateItemsInfo;
        if (rii) {
            var selectedItemBounds = this.getSelectedItemBounds();
            if (selectedItemBounds) {
                var vpPivot = rii.pivot ? new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](rii.pivot) : selectedItemBounds.center;
                this.rotateItemsPivotItem = newRotationPivotItem(vpPivot, this.cssScaling);
            }
        }
        this.updateChildren();
    };
    /**
     * Returns the bounds of the currently selected items in project coordinates.
     * Empty groups will be filtered out. Returns undefined if there are no selected
     * items left to compute.
     */
    PaperLayer.prototype.getSelectedItemBounds = function () {
        var _this = this;
        var selectedItems = Array.from(this.selectedLayerIds)
            .map(function (id) { return _this.findItemByLayerId(id); })
            // Filter out any selected empty groups.
            .filter(function (i) { return !(i instanceof paper__WEBPACK_IMPORTED_MODULE_5__["Group"]) || i.children.length; });
        if (selectedItems.length === 0) {
            return undefined;
        }
        return app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_3__["PaperUtil"].transformRectangle(app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_3__["PaperUtil"].computeBounds(selectedItems), this.matrix.inverted());
    };
    PaperLayer.prototype.updateHiddenLayers = function () {
        var hiddenLayerIds = this.hiddenLayerIds;
        (function recurseFn(item) {
            item.visible = !hiddenLayerIds.has(item.data.id);
            if (item.hasChildren()) {
                item.children.forEach(recurseFn);
            }
        })(this.vectorLayerItem);
    };
    PaperLayer.prototype.updateHoverPathItem = function () {
        if (this.hoverPathItem) {
            this.hoverPathItem.remove();
            this.hoverPathItem = undefined;
        }
        if (this.hoveredLayerId) {
            var item = this.findItemByLayerId(this.hoveredLayerId);
            this.hoverPathItem = newHoverPathItem(item);
        }
        this.updateChildren();
    };
    PaperLayer.prototype.updateEditPathItem = function () {
        if (this.editPathItem) {
            this.editPathItem.remove();
            this.editPathItem = undefined;
        }
        var epi = this.editPathInfo;
        var selectedLayerIds = this.selectedLayerIds;
        if (epi && selectedLayerIds.size) {
            // TODO: is it possible for pathData to be undefined?
            var path = this.findItemByLayerId(selectedLayerIds.values().next().value);
            this.editPathItem = newEditPathItem(path, epi, this.cssScaling);
            this.updateChildren();
        }
    };
    PaperLayer.prototype.updatePixelGridItem = function (viewportWidth, viewportHeight) {
        if (this.pixelGridItem) {
            this.pixelGridItem.remove();
            this.pixelGridItem = undefined;
        }
        if (this.cssScaling > 4) {
            this.pixelGridItem = newPixelGridItem(viewportWidth, viewportHeight);
            this.updateChildren();
        }
    };
    PaperLayer.prototype.updateChildren = function () {
        this.children = lodash__WEBPACK_IMPORTED_MODULE_4__["compact"]([
            this.canvasColorRect,
            this.vectorLayerItem,
            this.selectionBoundsItem,
            this.rotateItemsPivotItem,
            this.hoverPathItem,
            this.createPathItem,
            this.splitCurveItem,
            this.editPathItem,
            this.snapGuideItem,
            this.selectionBoxItem,
            this.pixelGridItem,
            this.tooltipItem,
        ]);
    };
    /** Finds the vector layer item with the given layer ID. */
    PaperLayer.prototype.findItemByLayerId = function (layerId) {
        if (!layerId) {
            return undefined;
        }
        if (this.vectorLayerItem.data.id === layerId) {
            return this.vectorLayerItem;
        }
        return lodash__WEBPACK_IMPORTED_MODULE_4__["first"](this.vectorLayerItem.getItems({
            match: function (_a) {
                var id = _a.data.id;
                return layerId === id;
            },
        }));
    };
    /**
     * Finds all vector layer items that overlap with the specified bounds.
     * Note that the bounds must be in viewport coordinates.
     * @param includePartialOverlaps iff true, include items that partially overlap the bounds
     */
    PaperLayer.prototype.findItemsInBounds = function (vpBounds, includePartialOverlaps) {
        return this.vectorLayerItem.getItems({
            // TODO: figure out how to deal with groups and compound paths
            class: paper__WEBPACK_IMPORTED_MODULE_5__["Path"],
            overlapping: includePartialOverlaps ? vpBounds : undefined,
            inside: includePartialOverlaps ? undefined : vpBounds,
        });
    };
    return PaperLayer;
}(paper__WEBPACK_IMPORTED_MODULE_5__["Layer"]));

function parseAndroidColor(androidColor, alpha) {
    if (alpha === void 0) { alpha = 1; }
    var color = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_2__["ColorUtil"].parseAndroidColor(androidColor);
    return color
        ? new paper__WEBPACK_IMPORTED_MODULE_5__["Color"](color.r / 255, color.g / 255, color.b / 255, (color.a / 255) * alpha)
        : undefined;
}
function newVectorLayerItem(vl) {
    var item = new paper__WEBPACK_IMPORTED_MODULE_5__["Group"]();
    if (!vl) {
        return item;
    }
    var fromPathLayerFn = function (layer) {
        var fillColor = layer.fillColor, fillAlpha = layer.fillAlpha, strokeColor = layer.strokeColor, strokeAlpha = layer.strokeAlpha;
        var trimPathStart = layer.trimPathStart, trimPathEnd = layer.trimPathEnd, trimPathOffset = layer.trimPathOffset;
        // TODO: make sure this works with compound paths as well (Android behavior is different)
        var pathLength = layer.pathData ? layer.pathData.getPathLength() : 0;
        var dashArray = pathLength
            ? app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["LayerUtil"].toStrokeDashArray(trimPathStart, trimPathEnd, trimPathOffset, pathLength)
            : undefined;
        var dashOffset = pathLength
            ? app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["LayerUtil"].toStrokeDashOffset(trimPathStart, trimPathEnd, trimPathOffset, pathLength)
            : undefined;
        // TODO: import a compound path instead
        // Only paths with more than one command can be closed.
        var closed = layer.pathData && layer.pathData.isClosed() && layer.pathData.getCommands().length > 1;
        return new paper__WEBPACK_IMPORTED_MODULE_5__["Path"]({
            data: { id: layer.id },
            pathData: layer.pathData ? layer.pathData.getPathString() : '',
            fillColor: parseAndroidColor(fillColor, fillAlpha),
            strokeColor: parseAndroidColor(strokeColor, strokeAlpha),
            strokeWidth: layer.strokeWidth,
            miterLimit: layer.strokeMiterLimit,
            strokeJoin: layer.strokeLinejoin,
            strokeCap: layer.strokeLinecap,
            fillRule: layer.fillType === 'evenOdd' ? 'evenodd' : 'nonzero',
            dashArray: dashArray,
            dashOffset: dashOffset,
            closed: closed,
        });
    };
    var fromClipPathLayerFn = function (layer) {
        var pathData = layer.pathData ? layer.pathData.getPathString() : '';
        // Only paths with more than one command can be closed.
        var closed = layer.pathData && layer.pathData.isClosed() && layer.pathData.getCommands().length > 1;
        return new paper__WEBPACK_IMPORTED_MODULE_5__["Path"]({
            data: { id: layer.id },
            pathData: pathData,
            clipMask: true,
            closed: closed,
        });
    };
    var fromGroupLayerFn = function (layer) {
        var pivotX = layer.pivotX, pivotY = layer.pivotY, scaleX = layer.scaleX, scaleY = layer.scaleY, rotation = layer.rotation, translateX = layer.translateX, translateY = layer.translateY;
        var pivot = new paper__WEBPACK_IMPORTED_MODULE_5__["Matrix"](1, 0, 0, 1, pivotX, pivotY);
        var scale = new paper__WEBPACK_IMPORTED_MODULE_5__["Matrix"](scaleX, 0, 0, scaleY, 0, 0);
        var cosr = Math.cos((rotation * Math.PI) / 180);
        var sinr = Math.sin((rotation * Math.PI) / 180);
        var rotate = new paper__WEBPACK_IMPORTED_MODULE_5__["Matrix"](cosr, sinr, -sinr, cosr, 0, 0);
        var translate = new paper__WEBPACK_IMPORTED_MODULE_5__["Matrix"](1, 0, 0, 1, translateX, translateY);
        var matrix = new paper__WEBPACK_IMPORTED_MODULE_5__["Matrix"]()
            .prepend(pivot.inverted())
            .prepend(scale)
            .prepend(rotate)
            .prepend(translate)
            .prepend(pivot);
        return new paper__WEBPACK_IMPORTED_MODULE_5__["Group"]({ data: { id: layer.id }, matrix: matrix });
    };
    item.data.id = vl.id;
    item.opacity = vl.alpha;
    item.addChildren(vl.children.map(function recurseFn(layer) {
        if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["PathLayer"]) {
            // TODO: return a compound path instead
            return fromPathLayerFn(layer);
        }
        if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["ClipPathLayer"]) {
            // TODO: return a compound path instead
            return fromClipPathLayerFn(layer);
        }
        if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["GroupLayer"]) {
            var groupItem = fromGroupLayerFn(layer);
            groupItem.addChildren(layer.children.map(function (l) { return recurseFn(l); }));
            return groupItem;
        }
        throw new TypeError('Unknown layer type: ' + layer);
    }));
    return item;
}
/** Creates a new hover path for the specified item. */
function newHoverPathItem(item) {
    var hoverPath;
    if (item instanceof paper__WEBPACK_IMPORTED_MODULE_5__["Group"]) {
        hoverPath = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"].Rectangle(item.bounds);
    }
    else if (item instanceof paper__WEBPACK_IMPORTED_MODULE_5__["Path"]) {
        hoverPath = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"](item.segments);
        hoverPath.closed = item.closed;
    }
    if (hoverPath) {
        hoverPath.strokeColor = '#009dec';
        hoverPath.guide = true;
        hoverPath.strokeScaling = false;
        hoverPath.strokeWidth = 2 / paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom;
        // Transform the hover path from local coordinates to viewport coordinates.
        hoverPath.matrix = item.globalMatrix
            .prepended(paper__WEBPACK_IMPORTED_MODULE_5__["project"].activeLayer.matrix.inverted())
            .prepend(item.matrix.inverted());
    }
    return hoverPath;
}
// TODO: reuse this code with SelectionBoundsRaster, etc.
var PIVOT_TYPES = [
    'topLeft',
    'topCenter',
    'topRight',
    'rightCenter',
    'bottomRight',
    'bottomCenter',
    'bottomLeft',
    'leftCenter',
];
/**
 * Creates a new selection bounds item for the specified selected items.
 */
function newSelectionBoundsItem(bounds, cssScaling) {
    var group = new paper__WEBPACK_IMPORTED_MODULE_5__["Group"]();
    // Draw an outline for the bounded box.
    var outlinePath = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"].Rectangle(bounds);
    outlinePath.strokeScaling = false;
    outlinePath.strokeWidth = 2 / paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom;
    outlinePath.strokeColor = '#e8e8e8';
    outlinePath.guide = true;
    group.addChild(outlinePath);
    // Create segments for the bounded box.
    PIVOT_TYPES.forEach(function (pivotType) {
        // TODO: avoid creating rasters in a loop like this
        var center = bounds[pivotType];
        var handle = _SelectionBoundsRaster__WEBPACK_IMPORTED_MODULE_8__["SelectionBoundsRaster"].of(pivotType, center);
        var scaleFactor = getRasterScaleFactor(cssScaling);
        handle.scale(scaleFactor, scaleFactor);
        group.addChild(handle);
    });
    return group;
}
/**
 * Creates a rotation pivot point at the specified position.
 */
function newRotationPivotItem(position, cssScaling) {
    var pivot = _RotateItemsPivotRaster__WEBPACK_IMPORTED_MODULE_7__["RotateItemsPivotRaster"].of(position);
    var scaleFactor = getRasterScaleFactor(cssScaling);
    pivot.scale(scaleFactor, scaleFactor);
    return pivot;
}
/**
 * Creates the overlay decorations for the given edit path.
 */
function newEditPathItem(path, info, cssScaling) {
    var group = new paper__WEBPACK_IMPORTED_MODULE_5__["Group"]();
    var scaleFactor = getRasterScaleFactor(cssScaling);
    var matrix = path.globalMatrix.prepended(new paper__WEBPACK_IMPORTED_MODULE_5__["Matrix"](1 / cssScaling, 0, 0, 1 / cssScaling, 0, 0));
    var addRasterFn = function (raster) {
        raster.scale(scaleFactor, scaleFactor);
        group.addChild(raster);
        return raster;
    };
    var addLineFn = function (from, to) {
        var line = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"].Line(from, to);
        line.guide = true;
        line.strokeColor = '#aaaaaa';
        line.strokeWidth = 1 / paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom;
        line.strokeScaling = false;
        // line.transform(matrix);
        group.addChild(line);
    };
    var selectedSegments = info.selectedSegments, visibleHandleIns = info.visibleHandleIns, selectedHandleIn = info.selectedHandleIn, visibleHandleOuts = info.visibleHandleOuts, selectedHandleOut = info.selectedHandleOut;
    // TODO: avoid creating rasters in a loop like this
    path.segments.forEach(function (_a, segmentIndex) {
        var point = _a.point, handleIn = _a.handleIn, handleOut = _a.handleOut;
        var center = point.transform(matrix);
        if (handleIn && visibleHandleIns.has(segmentIndex)) {
            handleIn = point.add(handleIn).transform(matrix);
            addLineFn(center, handleIn);
            addRasterFn(new _EditPathRaster__WEBPACK_IMPORTED_MODULE_6__["EditPathRaster"]('handle-in', segmentIndex, selectedHandleIn === segmentIndex, handleIn));
        }
        if (handleOut && visibleHandleOuts.has(segmentIndex)) {
            handleOut = point.add(handleOut).transform(matrix);
            addLineFn(center, handleOut);
            addRasterFn(new _EditPathRaster__WEBPACK_IMPORTED_MODULE_6__["EditPathRaster"]('handle-out', segmentIndex, selectedHandleOut === segmentIndex, handleOut));
        }
        addRasterFn(new _EditPathRaster__WEBPACK_IMPORTED_MODULE_6__["EditPathRaster"]('segment', segmentIndex, selectedSegments.has(segmentIndex), center));
    });
    return group;
}
function getRasterScaleFactor(cssScaling) {
    return 1 / (1.8 * cssScaling * paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom);
}
function newCreatePathItem(info) {
    var path = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"](info.pathData);
    path.guide = true;
    path.strokeScaling = false;
    path.strokeWidth = 1 / paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom;
    path.strokeColor = info.strokeColor;
    return path;
}
function newSplitCurveItem(info, cssScaling) {
    var group = new paper__WEBPACK_IMPORTED_MODULE_5__["Group"]();
    group.guide = true;
    var splitPoint = info.splitPoint, segment1 = info.segment1, segment2 = info.segment2;
    var point1 = new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](segment1.point);
    var handleIn1 = new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](segment1.handleIn);
    var handleOut1 = new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](segment1.handleOut);
    var point2 = new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](segment2.point);
    var handleIn2 = new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](segment2.handleIn);
    var handleOut2 = new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](segment2.handleOut);
    var highlightedCurve = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"]([
        new paper__WEBPACK_IMPORTED_MODULE_5__["Segment"](point1, handleIn1, handleOut1),
        new paper__WEBPACK_IMPORTED_MODULE_5__["Segment"](point2, handleIn2, handleOut2),
    ]);
    highlightedCurve.guide = true;
    highlightedCurve.strokeColor = '#3466A9';
    highlightedCurve.strokeScaling = false;
    highlightedCurve.strokeWidth = 2 / paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom;
    group.addChild(highlightedCurve);
    var highlightedPoint = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"].Circle(new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](splitPoint), 4 / paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom / cssScaling);
    highlightedPoint.guide = true;
    highlightedPoint.fillColor = '#3466A9';
    group.addChild(highlightedPoint);
    return group;
}
// TODO: add rounded rect background for tooltip
// TODO: ensure tooltip is justified correctly w/ respect to the active item
// function newTooltipItem(info: TooltipInfo, cssScaling: number) {
//   return new paper.PointText({
//     point: info.point,
//     content: info.label,
//     fillColor: 'red',
//     justification: 'left',
//     // TODO: text doesn't display when using font size of only 12?
//     fontSize: 14 / paper.view.zoom / cssScaling,
//     fontFamily: 'Roboto, Helvetica Neue, sans-serif',
//     guide: true,
//   });
// }
function newSnapGuideItem(info, cssScaling) {
    var group = new paper__WEBPACK_IMPORTED_MODULE_5__["Group"]({ guide: true });
    var newLineFn = function (from, to) {
        var line = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"].Line(from, to);
        line.guide = true;
        line.strokeScaling = false;
        line.strokeWidth = 1 / paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom;
        line.strokeColor = 'red';
        return line;
    };
    info.guides.forEach(function (_a) {
        var from = _a.from, to = _a.to;
        group.addChild(newLineFn(new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](from), new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](to)));
    });
    var addToAngleFn = function (point, angle) {
        point = point.clone();
        point.angle += angle;
        return point;
    };
    var newHandleLineFn = function (endPoint, handle) {
        var from = endPoint.add(addToAngleFn(handle, 90));
        var to = endPoint.add(addToAngleFn(handle, -90));
        return newLineFn(from, to);
    };
    var newRulerLabelFn = function (point, content) {
        // TODO: use a better font (roboto?)
        // TODO: add padding above/to the side of the label
        return new paper__WEBPACK_IMPORTED_MODULE_5__["PointText"]({
            point: point,
            content: content,
            fillColor: 'red',
            // TODO: add justification so it displays to the bottom-left of the current point
            fontSize: 12 / paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom / cssScaling,
            guide: true,
        });
    };
    var handleLengthPixels = 4;
    var matrix = new paper__WEBPACK_IMPORTED_MODULE_5__["Matrix"](cssScaling, 0, 0, cssScaling, 0, 0);
    info.rulers.forEach(function (line) {
        var from = new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](line.from);
        var to = new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](line.to);
        var mid = from.add(to.subtract(from).multiply(0.5));
        var globalFrom = from.transform(matrix);
        var globalTo = to.transform(matrix);
        var rulerHandle = globalTo
            .subtract(globalFrom)
            .normalize()
            .multiply(handleLengthPixels)
            .transform(matrix.inverted());
        // TODO: make sure the rounded vs. actual values are equal!
        // TODO: only display decimals for small viewports
        var pointTextLabel = lodash__WEBPACK_IMPORTED_MODULE_4__["round"](from.getDistance(to), 1).toString();
        group.addChildren([
            newLineFn(from, to),
            newHandleLineFn(from, rulerHandle),
            newHandleLineFn(to, rulerHandle),
            newRulerLabelFn(mid, pointTextLabel),
        ]);
    });
    return group;
}
function newSelectionBoxItem(from, to) {
    var path = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"].Rectangle(new paper__WEBPACK_IMPORTED_MODULE_5__["Rectangle"](from, to));
    path.guide = true;
    path.strokeScaling = false;
    path.strokeWidth = 1 / paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom;
    path.strokeColor = '#aaaaaa';
    path.dashArray = [3 / paper__WEBPACK_IMPORTED_MODULE_5__["view"].zoom];
    return path;
}
function newPixelGridItem(viewportWidth, viewportHeight) {
    var group = new paper__WEBPACK_IMPORTED_MODULE_5__["Group"]({ guide: true });
    var newLineFn = function (from, to) {
        var line = new paper__WEBPACK_IMPORTED_MODULE_5__["Path"].Rectangle(from, to);
        line.strokeColor = '#808080';
        line.opacity = 0.25;
        line.strokeScaling = false;
        line.strokeWidth = 1;
        line.guide = true;
        return line;
    };
    for (var x = 1; x < viewportWidth; x++) {
        group.addChild(newLineFn(new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](x, 0), new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](x, viewportHeight)));
    }
    for (var y = 1; y < viewportHeight; y++) {
        group.addChild(newLineFn(new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](0, y), new paper__WEBPACK_IMPORTED_MODULE_5__["Point"](viewportWidth, y)));
    }
    return group;
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/item/RotateItemsPivotRaster.ts":
/*!*****************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/item/RotateItemsPivotRaster.ts ***!
  \*****************************************************************************/
/*! exports provided: RotateItemsPivotRaster */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RotateItemsPivotRaster", function() { return RotateItemsPivotRaster; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);


var RotateItemsPivotRaster = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](RotateItemsPivotRaster, _super);
    function RotateItemsPivotRaster() {
        return _super.call(this, '/assets/paper/rotate-items-pivot.png') || this;
    }
    RotateItemsPivotRaster.of = function (position) {
        if (!RotateItemsPivotRaster.instance) {
            RotateItemsPivotRaster.instance = new RotateItemsPivotRaster();
        }
        var raster = RotateItemsPivotRaster.instance.clone(false);
        raster.position = position;
        return raster;
    };
    return RotateItemsPivotRaster;
}(paper__WEBPACK_IMPORTED_MODULE_1__["Raster"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/item/SelectionBoundsRaster.ts":
/*!****************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/item/SelectionBoundsRaster.ts ***!
  \****************************************************************************/
/*! exports provided: SelectionBoundsRaster */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionBoundsRaster", function() { return SelectionBoundsRaster; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);


var PIVOT_TYPES = [
    'bottomLeft',
    'leftCenter',
    'topLeft',
    'topCenter',
    'topRight',
    'rightCenter',
    'bottomRight',
    'bottomCenter',
];
var SelectionBoundsRaster = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](SelectionBoundsRaster, _super);
    function SelectionBoundsRaster() {
        return _super.call(this, "/assets/paper/selection-bounds-segment.png") || this;
    }
    SelectionBoundsRaster.of = function (pivotType, center) {
        if (!SelectionBoundsRaster.instance) {
            SelectionBoundsRaster.instance = new SelectionBoundsRaster();
        }
        var raster = SelectionBoundsRaster.instance.clone(false);
        raster.position = center;
        raster.pivotType_ = pivotType;
        raster.oppositePivotType_ = getOppositePivotType(pivotType);
        return raster;
    };
    Object.defineProperty(SelectionBoundsRaster.prototype, "pivotType", {
        get: function () {
            return this.pivotType_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionBoundsRaster.prototype, "oppositePivotType", {
        get: function () {
            return this.oppositePivotType_;
        },
        enumerable: true,
        configurable: true
    });
    return SelectionBoundsRaster;
}(paper__WEBPACK_IMPORTED_MODULE_1__["Raster"]));

var OPPOSITE_PIVOT_TYPES = (function (arr) {
    return arr.map(function (_, i) { return arr[(i + arr.length / 2) % arr.length]; });
})(PIVOT_TYPES);
function getOppositePivotType(pivotType) {
    return OPPOSITE_PIVOT_TYPES[PIVOT_TYPES.indexOf(pivotType)];
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/item/index.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/item/index.ts ***!
  \************************************************************/
/*! exports provided: HitTests, PaperLayer, SelectionBoundsRaster */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _HitTests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HitTests */ "./src/app/modules/editor/scripts/paper/item/HitTests.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "HitTests", function() { return _HitTests__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _PaperLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PaperLayer */ "./src/app/modules/editor/scripts/paper/item/PaperLayer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PaperLayer", function() { return _PaperLayer__WEBPACK_IMPORTED_MODULE_1__["PaperLayer"]; });

/* harmony import */ var _SelectionBoundsRaster__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SelectionBoundsRaster */ "./src/app/modules/editor/scripts/paper/item/SelectionBoundsRaster.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SelectionBoundsRaster", function() { return _SelectionBoundsRaster__WEBPACK_IMPORTED_MODULE_2__["SelectionBoundsRaster"]; });







/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/tool/GestureTool.ts":
/*!******************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/tool/GestureTool.ts ***!
  \******************************************************************/
/*! exports provided: GestureTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GestureTool", function() { return GestureTool; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_detector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/scripts/paper/detector */ "./src/app/modules/editor/scripts/paper/detector/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture_create__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture/create */ "./src/app/modules/editor/scripts/paper/gesture/create/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture_edit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture/edit */ "./src/app/modules/editor/scripts/paper/gesture/edit/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture_hover__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture/hover */ "./src/app/modules/editor/scripts/paper/gesture/hover/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture_rotate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture/rotate */ "./src/app/modules/editor/scripts/paper/gesture/rotate/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture/scale */ "./src/app/modules/editor/scripts/paper/gesture/scale/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture_select__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture/select */ "./src/app/modules/editor/scripts/paper/gesture/select/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_gesture_transform__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/modules/editor/scripts/paper/gesture/transform */ "./src/app/modules/editor/scripts/paper/gesture/transform/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/modules/editor/scripts/paper/item */ "./src/app/modules/editor/scripts/paper/item/index.ts");
/* harmony import */ var app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/modules/editor/scripts/paper/util */ "./src/app/modules/editor/scripts/paper/util/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Tool */ "./src/app/modules/editor/scripts/paper/tool/Tool.ts");














/**
 * A tool that delegates responsibilities to different gestures given the
 * state of the current tool mode and key/mouse events.
 */
var GestureTool = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](GestureTool, _super);
    function GestureTool(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        _this.pl = paper__WEBPACK_IMPORTED_MODULE_12__["project"].activeLayer;
        _this.clickDetector = new app_modules_editor_scripts_paper_detector__WEBPACK_IMPORTED_MODULE_2__["ClickDetector"]();
        _this.currentGesture = new app_modules_editor_scripts_paper_gesture_hover__WEBPACK_IMPORTED_MODULE_5__["HoverGesture"](_this.ps);
        return _this;
    }
    // @Override
    GestureTool.prototype.onToolEvent = function (event) {
        this.clickDetector.onToolEvent(event);
        if (event.type === 'mousedown') {
            this.onMouseDown(event);
        }
        else if (event.type === 'mousedrag') {
            this.currentGesture.onMouseDrag(event);
        }
        else if (event.type === 'mousemove') {
            this.currentGesture.onMouseMove(event);
        }
        else if (event.type === 'mouseup') {
            this.onMouseUp(event);
        }
    };
    GestureTool.prototype.onMouseDown = function (event) {
        var toolMode = this.ps.getToolMode();
        if (toolMode === app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["ToolMode"].Ellipse) {
            this.currentGesture = new app_modules_editor_scripts_paper_gesture_create__WEBPACK_IMPORTED_MODULE_3__["EllipseGesture"](this.ps);
        }
        else if (toolMode === app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["ToolMode"].Rectangle) {
            this.currentGesture = new app_modules_editor_scripts_paper_gesture_create__WEBPACK_IMPORTED_MODULE_3__["RectangleGesture"](this.ps);
        }
        else if (toolMode === app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["ToolMode"].Pencil) {
            this.currentGesture = new app_modules_editor_scripts_paper_gesture_create__WEBPACK_IMPORTED_MODULE_3__["PencilGesture"](this.ps);
        }
        else {
            this.currentGesture = this.createSelectionModeGesture(event);
        }
        this.currentGesture.onMouseDown(event);
    };
    GestureTool.prototype.onMouseUp = function (event) {
        this.currentGesture.onMouseUp(event);
        this.currentGesture = new app_modules_editor_scripts_paper_gesture_hover__WEBPACK_IMPORTED_MODULE_5__["HoverGesture"](this.ps);
    };
    GestureTool.prototype.createSelectionModeGesture = function (event) {
        if (this.ps.getEditPathInfo()) {
            return this.createEditPathModeGesture(event);
        }
        var selectedLayerIds = this.ps.getSelectedLayerIds();
        if (selectedLayerIds.size) {
            // First perform a hit test on the selection bound's segments.
            var selectionBoundSegmentsHitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_10__["HitTests"].selectionModeSegments(event.point);
            var rii = this.ps.getRotateItemsInfo();
            if (selectionBoundSegmentsHitResult) {
                // If the hit item is a selection bound segment, then perform
                // a scale/rotate/transform gesture.
                if (rii) {
                    return new app_modules_editor_scripts_paper_gesture_rotate__WEBPACK_IMPORTED_MODULE_6__["RotateItemsGesture"](this.ps);
                }
                if (this.ps.getTransformPathsInfo()) {
                    return new app_modules_editor_scripts_paper_gesture_transform__WEBPACK_IMPORTED_MODULE_9__["TransformPathsGesture"](this.ps, selectionBoundSegmentsHitResult.item);
                }
                return new app_modules_editor_scripts_paper_gesture_scale__WEBPACK_IMPORTED_MODULE_7__["ScaleItemsGesture"](this.ps, selectionBoundSegmentsHitResult.item);
            }
            if (rii) {
                // Perform a hit test on the rotate items pivot.
                var rotateItemsHitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_10__["HitTests"].rotateItemsPivot(event.point);
                if (rotateItemsHitResult) {
                    return new app_modules_editor_scripts_paper_gesture_rotate__WEBPACK_IMPORTED_MODULE_6__["RotateItemsDragPivotGesture"](this.ps);
                }
            }
        }
        var hitResults = this.pl.hitTestVectorLayer(event.point);
        var selectionMap = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_10__["HitTests"].getSelectedLayerMap(this.ps);
        var hitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_10__["HitTests"].findFirstHitResult(hitResults.children, selectionMap);
        if (!hitResult) {
            // If there is no hit item, then batch select items using a selection box.
            return new app_modules_editor_scripts_paper_gesture_select__WEBPACK_IMPORTED_MODULE_8__["BatchSelectItemsGesture"](this.ps);
        }
        var hitItemId = hitResult.hitItem.data.id;
        if (this.clickDetector.isDoubleClick()) {
            var hitLayer = this.ps.getVectorLayer().findLayerById(hitItemId);
            if (hitLayer.children.length) {
                var newHitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_10__["HitTests"].findFirstHitResult(hitResults.children, selectionMap, new Set([hitLayer.id]));
                if (newHitResult) {
                    return new app_modules_editor_scripts_paper_gesture_select__WEBPACK_IMPORTED_MODULE_8__["SelectDragCloneItemsGesture"](this.ps, newHitResult.hitItem.data.id);
                }
                else {
                    return new app_modules_editor_scripts_paper_gesture_select__WEBPACK_IMPORTED_MODULE_8__["BatchSelectItemsGesture"](this.ps);
                }
            }
            else {
                // If a double click event occurs on top of a hit item w/ no children,
                // then enter edit path mode.
                return new app_modules_editor_scripts_paper_gesture_select__WEBPACK_IMPORTED_MODULE_8__["EditPathGesture"](this.ps, hitItemId);
            }
        }
        if (selectedLayerIds.has(hitItemId) && event.modifiers.shift && selectedLayerIds.size > 1) {
            // If the hit item is selected, shift is pressed, and there is at least
            // one other selected item, then deselect the hit item.
            // TODO: After the item is deselected, it should still be possible
            // to drag/clone any other selected items in subsequent mouse events
            return new app_modules_editor_scripts_paper_gesture_select__WEBPACK_IMPORTED_MODULE_8__["DeselectItemGesture"](this.ps, hitItemId);
        }
        // TODO: The actual behavior in Sketch is a bit more complicated.
        // For example, (1) a cloned item will not be generated until the next
        // onMouseDrag event, (2) on the next onMouseDrag event, the
        // cloned item should be selected and the currently selected item should
        // be deselected, (3) the user can cancel a clone operation mid-drag by
        // pressing/unpressing alt (even if alt wasn't initially pressed in
        // onMouseDown).
        // At this point we know that either (1) the hit item is not selected
        // or (2) the hit item is selected, shift is not being pressed, and
        // there is only one selected item. In both cases the hit item should
        // end up being selected. If alt is being pressed, then we should
        // clone the item as well.
        return new app_modules_editor_scripts_paper_gesture_select__WEBPACK_IMPORTED_MODULE_8__["SelectDragCloneItemsGesture"](this.ps, hitItemId);
    };
    GestureTool.prototype.createEditPathModeGesture = function (event) {
        var selectedLayerIds = this.ps.getSelectedLayerIds();
        var layerId = selectedLayerIds.size ? selectedLayerIds.values().next().value : '';
        var epi = this.ps.getEditPathInfo();
        if (!layerId) {
            // Then the user has created the first segment of a new path, in which
            // case we must create a new dummy path and bring it into focus.
            var newPathLayer = app_modules_editor_scripts_paper_util__WEBPACK_IMPORTED_MODULE_11__["PaperUtil"].addPathToStore(this.ps, '');
            layerId = newPathLayer.id;
            epi = {
                selectedSegments: new Set(),
                visibleHandleIns: new Set(),
                visibleHandleOuts: new Set(),
                selectedHandleIn: undefined,
                selectedHandleOut: undefined,
            };
            this.ps.setSelectedLayerIds(new Set([layerId]));
            this.ps.setEditPathInfo(epi);
        }
        var editPathId = layerId;
        var editPath = this.pl.findItemByLayerId(editPathId);
        // First, do a hit test on the edit path's segments and handles.
        var segmentsAndHandlesHitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_10__["HitTests"].editPathModeSegmentsAndHandles(event.point);
        if (segmentsAndHandlesHitResult) {
            var _a = segmentsAndHandlesHitResult.item, segmentIndex = _a.segmentIndex, type = _a.type;
            if (type === 'handle-in' || type === 'handle-out') {
                // If a mouse down event occurred on top of a handle,
                // then select/drag the handle.
                return new app_modules_editor_scripts_paper_gesture_edit__WEBPACK_IMPORTED_MODULE_4__["SelectDragHandleGesture"](this.ps, editPathId, segmentIndex, type);
            }
            if (this.clickDetector.isDoubleClick()) {
                // If a double click occurred on top of a segment, then toggle the segment's handles.
                return new app_modules_editor_scripts_paper_gesture_edit__WEBPACK_IMPORTED_MODULE_4__["ToggleSegmentHandlesGesture"](this.ps, editPathId, segmentIndex);
            }
            // If a mouse down event occurred on top of a segment,
            // then select/drag the segment.
            return app_modules_editor_scripts_paper_gesture_edit__WEBPACK_IMPORTED_MODULE_4__["SelectDragDrawSegmentsGesture"].hitSegment(this.ps, editPathId, segmentIndex);
        }
        // Second, do a hit test on the edit path itself.
        var hitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_10__["HitTests"].editPathMode(event.point, editPath, {
            fill: true,
            stroke: true,
            curves: true,
        });
        if (hitResult) {
            if (hitResult.type !== 'curve') {
                // TODO: is there a way to avoid a second hit test like this?
                hitResult = app_modules_editor_scripts_paper_item__WEBPACK_IMPORTED_MODULE_10__["HitTests"].editPathMode(event.point, editPath, {
                    curves: true,
                });
            }
            if (hitResult && hitResult.type === 'curve') {
                if (event.modifiers.command) {
                    // If the user is holding down command, then modify the curve
                    // by dragging it.
                    return new app_modules_editor_scripts_paper_gesture_edit__WEBPACK_IMPORTED_MODULE_4__["MouldCurveGesture"](this.ps, editPathId, {
                        curveIndex: hitResult.location.index,
                        time: hitResult.location.time,
                    });
                }
                // Add a segment to the curve.
                return app_modules_editor_scripts_paper_gesture_edit__WEBPACK_IMPORTED_MODULE_4__["SelectDragDrawSegmentsGesture"].hitCurve(this.ps, editPathId, hitResult.location.index, hitResult.location.time);
            }
            // Note that we won't exit edit path mode on the next mouse up event
            // (since the gesture began with a successful hit test).
            return new app_modules_editor_scripts_paper_gesture_edit__WEBPACK_IMPORTED_MODULE_4__["BatchSelectSegmentsGesture"](this.ps, editPathId, false /* clearEditPathOnDraglessClick */);
        }
        if (!editPath.segments.length) {
            // Then we are beginning to build a new path from scratch.
            return app_modules_editor_scripts_paper_gesture_edit__WEBPACK_IMPORTED_MODULE_4__["SelectDragDrawSegmentsGesture"].miss(this.ps, editPathId);
        }
        if (!editPath.closed && epi.selectedSegments.size === 1) {
            var selectedSegmentIndex = epi.selectedSegments.values().next().value;
            if (selectedSegmentIndex === 0 || selectedSegmentIndex === editPath.segments.length - 1) {
                // Then we are extending an existing open path with a single selected end point segment.
                return app_modules_editor_scripts_paper_gesture_edit__WEBPACK_IMPORTED_MODULE_4__["SelectDragDrawSegmentsGesture"].miss(this.ps, editPathId);
            }
        }
        // If there is no hit item and we are in edit path mode, then
        // enter selection box mode for the edit path so we can
        // batch select its segments. If no drag occurs, the gesture will
        // exit edit path mode on the next mouse up event.
        return new app_modules_editor_scripts_paper_gesture_edit__WEBPACK_IMPORTED_MODULE_4__["BatchSelectSegmentsGesture"](this.ps, editPathId, true /* clearEditPathOnDraglessClick */);
    };
    // @Override
    GestureTool.prototype.onKeyEvent = function (event) {
        if (event.type === 'keydown') {
            this.currentGesture.onKeyDown(event);
        }
        else if (event.type === 'keyup') {
            this.currentGesture.onKeyUp(event);
        }
    };
    return GestureTool;
}(_Tool__WEBPACK_IMPORTED_MODULE_13__["Tool"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/tool/MasterToolPicker.ts":
/*!***********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/tool/MasterToolPicker.ts ***!
  \***********************************************************************/
/*! exports provided: MasterToolPicker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MasterToolPicker", function() { return MasterToolPicker; });
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _GestureTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GestureTool */ "./src/app/modules/editor/scripts/paper/tool/GestureTool.ts");
/* harmony import */ var _ZoomPanTool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ZoomPanTool */ "./src/app/modules/editor/scripts/paper/tool/ZoomPanTool.ts");




/**
 * The master tool that is in charge of dispatching mouse, key,
 * and tool mode change events.
 */
var MasterToolPicker = /** @class */ (function () {
    function MasterToolPicker(ps) {
        var _this = this;
        this.ps = ps;
        this.paperTool = new paper__WEBPACK_IMPORTED_MODULE_1__["Tool"]();
        var gestureTool = new _GestureTool__WEBPACK_IMPORTED_MODULE_2__["GestureTool"](ps);
        var zoomPanTool = new _ZoomPanTool__WEBPACK_IMPORTED_MODULE_3__["ZoomPanTool"](ps);
        var currentTool;
        var onEventFn = function (event) {
            var prevTool = currentTool;
            currentTool =
                _this.ps.getToolMode() === app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_0__["ToolMode"].ZoomPan || (event && event.modifiers.space)
                    ? zoomPanTool
                    : gestureTool;
            if (prevTool !== currentTool) {
                if (prevTool) {
                    prevTool.onDeactivate();
                }
                currentTool.onActivate();
            }
            if (event instanceof paper__WEBPACK_IMPORTED_MODULE_1__["ToolEvent"]) {
                currentTool.onToolEvent(event);
            }
            else {
                // TODO: do a better job at clearing focus in the property input component
                // (i.e. clear focus when the user selects something in the canvas or timeline).
                if (document.activeElement.matches('input')) {
                    // Ignore key events when an input element has focus.
                    return;
                }
                if (event.key === 'backspace' || event.key === 'delete') {
                    // In case there's a JS error, never navigate away.
                    event.preventDefault();
                }
                currentTool.onKeyEvent(event);
            }
        };
        this.paperTool.on({
            mousedown: onEventFn,
            mousedrag: onEventFn,
            mousemove: onEventFn,
            mouseup: onEventFn,
            keydown: onEventFn,
            keyup: onEventFn,
        });
    }
    MasterToolPicker.prototype.onToolModeChanged = function () {
        // TODO: better way to set this?
        this.paperTool.fixedDistance = this.ps.getToolMode() === app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_0__["ToolMode"].Pencil ? 4 : undefined;
    };
    return MasterToolPicker;
}());



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/tool/Tool.ts":
/*!***********************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/tool/Tool.ts ***!
  \***********************************************************/
/*! exports provided: Tool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tool", function() { return Tool; });
/** Represents the base class for all tool types. */
var Tool = /** @class */ (function () {
    function Tool() {
    }
    /** Called immediately after this tool has been activated. */
    Tool.prototype.onActivate = function () { };
    /**
     * Called when this tool has received a tool event (i.e. mouse down,
     * mouse drag, mouse move, mouse up).
     */
    Tool.prototype.onToolEvent = function (event) { };
    /** Called when this tool has received a key event (i.e. key down, key up). */
    Tool.prototype.onKeyEvent = function (event) { };
    /** Called immediately after this tool has been deactivated. */
    Tool.prototype.onDeactivate = function () { };
    return Tool;
}());



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/tool/ZoomPanTool.ts":
/*!******************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/tool/ZoomPanTool.ts ***!
  \******************************************************************/
/*! exports provided: ZoomPanTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZoomPanTool", function() { return ZoomPanTool; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Tool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Tool */ "./src/app/modules/editor/scripts/paper/tool/Tool.ts");





/** A tool that enables zooming and panning in the canvas. */
var ZoomPanTool = /** @class */ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"](ZoomPanTool, _super);
    function ZoomPanTool(ps) {
        var _this = _super.call(this) || this;
        _this.ps = ps;
        return _this;
    }
    // @Override
    ZoomPanTool.prototype.onActivate = function () {
        this.viewLastPoint = new paper__WEBPACK_IMPORTED_MODULE_3__["Point"](0, 0);
        this.isDragging = false;
        this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].ZoomIn);
    };
    // @Override
    ZoomPanTool.prototype.onDeactivate = function () {
        // TODO: set the cursor type to whatever it was before onActivate()?
        this.ps.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Default);
    };
    // @Override
    ZoomPanTool.prototype.onToolEvent = function (event) {
        if (event.type === 'mousedown') {
            this.onMouseDown(event);
        }
        else if (event.type === 'mousedrag') {
            this.onMouseDrag(event);
        }
        else if (event.type === 'mouseup') {
            this.onMouseUp(event);
        }
    };
    ZoomPanTool.prototype.onMouseDown = function (event) {
        this.isDragging = false;
        this.updateCursorType(event);
        if (event.modifiers.space) {
            // If space is pressed, then grab/pan the canvas. We store the last known
            // mouse point in view space coordinates (which means the top left corner
            // of the canvas will always be (0, 0), no matter how much we've panned/zoomed
            // so far).
            this.viewLastPoint = paper__WEBPACK_IMPORTED_MODULE_3__["view"].projectToView(event.point);
            return;
        }
        // Zoom out if alt is pressed, and zoom in otherwise.
        var zoom = paper__WEBPACK_IMPORTED_MODULE_3__["view"].zoom * (event.modifiers.alt ? 1 / 2 : 2);
        var _a = paper__WEBPACK_IMPORTED_MODULE_3__["view"].projectToView(event.point).subtract(event.point.multiply(zoom)), x = _a.x, y = _a.y;
        this.setZoomPanInfo(zoom, x, y);
    };
    ZoomPanTool.prototype.onMouseDrag = function (event) {
        this.isDragging = false;
        this.updateCursorType(event);
        if (!event.modifiers.space) {
            return;
        }
        // In order to have coordinate changes not mess up the dragging, we need to
        // convert coordinates to view space, and then back to project space after
        // the view has been scrolled.
        var projPoint = event.point;
        var viewPoint = paper__WEBPACK_IMPORTED_MODULE_3__["view"].projectToView(projPoint);
        var _a = paper__WEBPACK_IMPORTED_MODULE_3__["view"].matrix
            .clone()
            .translate(projPoint.subtract(paper__WEBPACK_IMPORTED_MODULE_3__["view"].viewToProject(this.viewLastPoint))), tx = _a.tx, ty = _a.ty;
        this.setZoomPanInfo(paper__WEBPACK_IMPORTED_MODULE_3__["view"].zoom, tx, ty);
        this.viewLastPoint = viewPoint;
    };
    ZoomPanTool.prototype.onMouseUp = function (event) {
        this.isDragging = false;
        this.updateCursorType(event);
    };
    ZoomPanTool.prototype.setZoomPanInfo = function (zoom, tx, ty) {
        var _a = paper__WEBPACK_IMPORTED_MODULE_3__["view"].viewSize, width = _a.width, height = _a.height;
        zoom = lodash__WEBPACK_IMPORTED_MODULE_2__["clamp"](zoom, 1, 256);
        tx = lodash__WEBPACK_IMPORTED_MODULE_2__["clamp"](tx, -width * (zoom - 1), 0);
        ty = lodash__WEBPACK_IMPORTED_MODULE_2__["clamp"](ty, -height * (zoom - 1), 0);
        this.ps.setZoomPanInfo({ zoom: zoom, translation: { tx: tx, ty: ty } });
    };
    // @Override
    ZoomPanTool.prototype.onKeyEvent = function (event) {
        if (event.key === 'space' || event.key === 'alt') {
            this.updateCursorType(event);
        }
    };
    ZoomPanTool.prototype.updateCursorType = function (event) {
        if (event.modifiers.space) {
            this.ps.setCursorType(this.isDragging ? app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Grabbing : app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Grab);
        }
        else {
            this.ps.setCursorType(event.modifiers.alt ? app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].ZoomOut : app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].ZoomIn);
        }
    };
    return ZoomPanTool;
}(_Tool__WEBPACK_IMPORTED_MODULE_4__["Tool"]));



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/tool/index.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/tool/index.ts ***!
  \************************************************************/
/*! exports provided: MasterToolPicker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MasterToolPicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MasterToolPicker */ "./src/app/modules/editor/scripts/paper/tool/MasterToolPicker.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MasterToolPicker", function() { return _MasterToolPicker__WEBPACK_IMPORTED_MODULE_0__["MasterToolPicker"]; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/util/PaperUtil.ts":
/*!****************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/util/PaperUtil.ts ***!
  \****************************************************************/
/*! exports provided: addPathToStore, getPathFromStore, replacePathInStore, getReplacePathInStoreVectorLayer, selectCurves, transformRectangle, computeBounds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPathToStore", function() { return addPathToStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathFromStore", function() { return getPathFromStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replacePathInStore", function() { return replacePathInStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReplacePathInStoreVectorLayer", function() { return getReplacePathInStoreVectorLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selectCurves", function() { return selectCurves; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformRectangle", function() { return transformRectangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeBounds", function() { return computeBounds; });
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paths */ "./src/app/modules/editor/model/paths/index.ts");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-core.min.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_2__);



/** Adds a new path to the first level of the vector layer tree. */
function addPathToStore(ps, pathData) {
    var vl = ps.getVectorLayer().clone();
    var pl = new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["PathLayer"]({
        name: app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["LayerUtil"].getUniqueLayerName([vl], 'path'),
        children: [],
        pathData: new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"](pathData),
        // TODO: make this customizable
        fillColor: '#D8D8D8',
        strokeColor: '#979797',
        strokeWidth: 0.1,
    });
    vl.children = vl.children.concat([pl]);
    ps.setVectorLayer(vl);
    return pl;
}
/** Returns the path data string for the specified path layer ID. */
function getPathFromStore(ps, layerId) {
    var vl = ps.getVectorLayer();
    var pl = vl.findLayerById(layerId).clone();
    return pl.pathData.getPathString();
}
/** Replaces an existing path in the vector layer tree. */
function replacePathInStore(ps, layerId, pathData) {
    ps.setVectorLayer(getReplacePathInStoreVectorLayer(ps, layerId, pathData));
}
function getReplacePathInStoreVectorLayer(ps, layerId, pathData) {
    var vl = ps.getVectorLayer();
    var pl = vl.findLayerById(layerId).clone();
    pl.pathData = new app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_1__["Path"](pathData);
    return app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_0__["LayerUtil"].replaceLayer(vl, layerId, pl);
}
/** Computes the selected curves associated with the given selected segment indices. */
function selectCurves(path, selectedSegments) {
    var visibleHandleIns = new Set(selectedSegments);
    var visibleHandleOuts = new Set(selectedSegments);
    selectedSegments.forEach(function (segmentIndex) {
        // Also display the out-handle for the previous segment
        // and the in-handle for the next segment.
        var _a = path.segments[segmentIndex], previous = _a.previous, next = _a.next;
        if (previous) {
            visibleHandleOuts.add(previous.index);
        }
        if (next) {
            visibleHandleIns.add(next.index);
        }
    });
    return {
        selectedSegments: selectedSegments,
        visibleHandleIns: visibleHandleIns,
        visibleHandleOuts: visibleHandleOuts,
        selectedHandleIn: undefined,
        selectedHandleOut: undefined,
    };
}
/** Returns a new matrix that has been transformed by the specified matrix m. */
function transformRectangle(rect, m) {
    return new paper__WEBPACK_IMPORTED_MODULE_2__["Rectangle"](rect.topLeft.transform(m), rect.bottomRight.transform(m));
}
/** Computes the bounds for the specified items in global project coordinates. */
function computeBounds(arg) {
    var flattenedItems = [];
    (Array.isArray(arg) ? arg : [arg]).forEach(function recurseFn(i) {
        if (i.hasChildren()) {
            i.children.forEach(function (c) { return recurseFn(c); });
        }
        else {
            flattenedItems.push(i);
        }
    });
    return flattenedItems
        .map(function (item) { return transformRectangle(item.bounds, item.globalMatrix); })
        .reduce(function (p, c) { return p.unite(c); });
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/util/index.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/util/index.ts ***!
  \************************************************************/
/*! exports provided: PaperUtil, SnapUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _PaperUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PaperUtil */ "./src/app/modules/editor/scripts/paper/util/PaperUtil.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "PaperUtil", function() { return _PaperUtil__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _snap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./snap */ "./src/app/modules/editor/scripts/paper/util/snap/index.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SnapUtil", function() { return _snap__WEBPACK_IMPORTED_MODULE_1__["SnapUtil"]; });






/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/util/snap/Constants.ts":
/*!*********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/util/snap/Constants.ts ***!
  \*********************************************************************/
/*! exports provided: DIRECTIONS, CONSTANTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIRECTIONS", function() { return DIRECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CONSTANTS", function() { return CONSTANTS; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

var horiz = { dir: 'horizontal', start: 'left', end: 'right', size: 'width', coord: 'x' };
var vert = { dir: 'vertical', start: 'top', end: 'bottom', size: 'height', coord: 'y' };
var DIRECTIONS = ['horizontal', 'vertical'];
var CONSTANTS = {
    horizontal: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, horiz, { opp: vert }),
    vertical: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, vert, { opp: horiz }),
};


/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/util/snap/SnapBounds.ts":
/*!**********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/util/snap/SnapBounds.ts ***!
  \**********************************************************************/
/*! exports provided: SnapBounds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SnapBounds", function() { return SnapBounds; });
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);


var SnapBounds = /** @class */ (function () {
    function SnapBounds() {
        var snapPoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            snapPoints[_i] = arguments[_i];
        }
        this.snapPoints = snapPoints;
        this.left = lodash__WEBPACK_IMPORTED_MODULE_1__["minBy"](snapPoints, function (p) { return p.x; }).x;
        this.top = lodash__WEBPACK_IMPORTED_MODULE_1__["minBy"](snapPoints, function (p) { return p.y; }).y;
        this.right = lodash__WEBPACK_IMPORTED_MODULE_1__["maxBy"](snapPoints, function (p) { return p.x; }).x;
        this.bottom = lodash__WEBPACK_IMPORTED_MODULE_1__["maxBy"](snapPoints, function (p) { return p.y; }).y;
        this.width = this.right - this.left;
        this.height = this.bottom - this.top;
    }
    /** Computes the minimum distance between two snap bounds. */
    SnapBounds.prototype.distance = function (sb) {
        var _a = this, l1 = _a.left, t1 = _a.top, r1 = _a.right, b1 = _a.bottom;
        var l2 = sb.left, t2 = sb.top, r2 = sb.right, b2 = sb.bottom;
        var left = r2 < l1;
        var top = b1 < t2;
        var right = r1 < l2;
        var bottom = b2 < t1;
        var line;
        if (top && left) {
            line = { from: { x: l1, y: b1 }, to: { x: r2, y: t2 } };
        }
        else if (left && bottom) {
            line = { from: { x: l1, y: t1 }, to: { x: r2, y: b2 } };
        }
        else if (bottom && right) {
            line = { from: { x: r1, y: t1 }, to: { x: l2, y: b2 } };
        }
        else if (right && top) {
            line = { from: { x: r1, y: b1 }, to: { x: l2, y: t2 } };
        }
        else if (left) {
            line = { from: { x: r2, y: t1 }, to: { x: l1, y: t1 } };
        }
        else if (right) {
            line = { from: { x: r1, y: t1 }, to: { x: l2, y: t1 } };
        }
        else if (bottom) {
            line = { from: { x: l1, y: b2 }, to: { x: l1, y: t1 } };
        }
        else if (top) {
            line = { from: { x: l1, y: b1 }, to: { x: l1, y: t2 } };
        }
        else {
            // TODO: handle this case better? (it implies the bounds intersect)
            line = { from: { x: l1, y: t1 }, to: { x: l1, y: t1 } };
        }
        return { line: line, dist: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_0__["MathUtil"].distance(line.from, line.to) };
    };
    return SnapBounds;
}());



/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/util/snap/SnapUtil.ts":
/*!********************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/util/snap/SnapUtil.ts ***!
  \********************************************************************/
/*! exports provided: computeSnapInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeSnapInfo", function() { return computeSnapInfo; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Constants */ "./src/app/modules/editor/scripts/paper/util/snap/Constants.ts");
/* harmony import */ var _SnapBounds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SnapBounds */ "./src/app/modules/editor/scripts/paper/util/snap/SnapBounds.ts");





// TODO: make sure to test things with different stroke width values!
var SNAP_TOLERANCE_PIXELS = 10;
/**
 * A helper function that snaps the given dragged snap points to each of its siblings.
 *
 * TODO: make it possible to create rulers optionally only if a flag is passed
 */
function computeSnapInfo(dragSnapPoints, siblingSnapPointsTable, snapToDimensions) {
    if (snapToDimensions === void 0) { snapToDimensions = false; }
    var dsb = new (_SnapBounds__WEBPACK_IMPORTED_MODULE_4__["SnapBounds"].bind.apply(_SnapBounds__WEBPACK_IMPORTED_MODULE_4__["SnapBounds"], [void 0].concat(dragSnapPoints)))();
    var ssbs = siblingSnapPointsTable.map(function (pts) { return new (_SnapBounds__WEBPACK_IMPORTED_MODULE_4__["SnapBounds"].bind.apply(_SnapBounds__WEBPACK_IMPORTED_MODULE_4__["SnapBounds"], [void 0].concat(pts)))(); });
    var _a = snapToSiblings(dsb, ssbs, snapToDimensions), horizontal = _a.horizontal, vertical = _a.vertical;
    var isHorizontalHit = Math.abs(horizontal.delta) <= SNAP_TOLERANCE_PIXELS;
    var horizontalDelta = isHorizontalHit ? horizontal.delta : Infinity;
    var horizontalValues = isHorizontalHit ? horizontal.values : [];
    var isVerticalHit = Math.abs(vertical.delta) <= SNAP_TOLERANCE_PIXELS;
    var verticalDelta = isVerticalHit ? vertical.delta : Infinity;
    var verticalValues = isVerticalHit ? vertical.values : [];
    var snapInfo = {
        horizontal: { delta: horizontalDelta, values: horizontalValues },
        vertical: { delta: verticalDelta, values: verticalValues },
    };
    var projSnapDelta = {
        x: isFinite(horizontalDelta) ? -horizontalDelta : 0,
        y: isFinite(verticalDelta) ? -verticalDelta : 0,
    };
    return {
        projSnapDelta: projSnapDelta,
        guides: buildGuides(snapInfo),
        rulers: buildRulers(snapInfo),
    };
}
/** Snaps the dragged item to each of its sibling snap items. */
function snapToSiblings(dsb, ssbs, snapToDimensions) {
    // Compute a list of sibling snap results, where each entry represents a snapping
    // between two snap bounds in both directions.
    var ssrs = ssbs.map(function (ssb) {
        // For each direction, return an entry consisting of:
        // - dsb: the drag snap bounds
        // - ssb: the sibling snap bounds
        // - delta: the minimum delta value that would snap the two bounds
        // - values: a list of snap pairs that computed the above delta value
        return {
            horizontal: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({ dsb: dsb, ssb: ssb }, runSnapTest(dsb, ssb, snapToDimensions, 'horizontal')),
            vertical: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({ dsb: dsb, ssb: ssb }, runSnapTest(dsb, ssb, snapToDimensions, 'vertical')),
        };
    });
    return {
        horizontal: filterByMinDelta(ssrs.map(function (r) { return r.horizontal; })),
        vertical: filterByMinDelta(ssrs.map(function (r) { return r.vertical; })),
    };
}
/**
 * Runs a snap test for two snap bounds. The return result consists of (1) the
 * minimum delta value found, and (2) a list of the values that had the specified
 * delta value.
 */
function runSnapTest(dsb, ssb, snapToDimensions, dir) {
    var coord = _Constants__WEBPACK_IMPORTED_MODULE_3__["CONSTANTS"][dir].coord;
    var snapPairResults = [];
    if (snapToDimensions) {
        var getSnapBoundsSize = function (sb) {
            var min = lodash__WEBPACK_IMPORTED_MODULE_2__["minBy"](sb.snapPoints, function (p) { return p[coord]; })[coord];
            var max = lodash__WEBPACK_IMPORTED_MODULE_2__["maxBy"](sb.snapPoints, function (p) { return p[coord]; })[coord];
            return max - min;
        };
        var dsbSize = getSnapBoundsSize(dsb);
        var ssbSize = getSnapBoundsSize(ssb);
        // TODO: improve this snap pair API stuff?
        snapPairResults.push({
            isDimensionSnap: true,
            delta: app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].round(dsbSize - ssbSize),
        });
    }
    else {
        dsb.snapPoints.forEach(function (dragPoint, dragIndex) {
            ssb.snapPoints.forEach(function (siblingPoint, siblingIndex) {
                var delta = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_1__["MathUtil"].round(dragPoint[coord] - siblingPoint[coord]);
                snapPairResults.push({ dragIndex: dragIndex, siblingIndex: siblingIndex, delta: delta });
            });
        });
    }
    return filterByMinDelta(snapPairResults);
}
/**
 * Filters the array of items, keeping the smallest delta values and
 * discarding the rest.
 */
function filterByMinDelta(list) {
    if (!list.length) {
        return undefined;
    }
    var _a = list.reduce(function (prev, curr) {
        var info = {
            min: Math.abs(curr.delta),
            pos: curr.delta >= 0 ? [curr] : [],
            neg: curr.delta >= 0 ? [] : [curr],
        };
        if (prev.min === info.min) {
            return {
                min: prev.min,
                pos: prev.pos.concat(info.pos),
                neg: prev.neg.concat(info.neg),
            };
        }
        return prev.min < info.min ? prev : info;
    }, { min: Infinity, pos: [], neg: [] }), min = _a.min, pos = _a.pos, neg = _a.neg;
    var isDeltaPositive = pos.length >= neg.length;
    return {
        delta: min * (isDeltaPositive ? 1 : -1),
        values: isDeltaPositive ? pos : neg,
    };
}
/**
 * Builds the snap guides to draw given a snap info object.
 * This function assumes the global project coordinate space.
 */
function buildGuides(snapInfo) {
    var guides = [];
    _Constants__WEBPACK_IMPORTED_MODULE_3__["DIRECTIONS"].forEach(function (d) { return guides.push.apply(guides, buildGuidesInDirection(snapInfo, d)); });
    return guides;
}
function buildGuidesInDirection(snapInfo, dir) {
    var guides = [];
    var _a = _Constants__WEBPACK_IMPORTED_MODULE_3__["CONSTANTS"][dir], coord = _a.coord, opp = _a.opp;
    snapInfo[dir].values.forEach(function (_a) {
        var dsb = _a.dsb, ssb = _a.ssb, values = _a.values;
        var firstGuideSnap = lodash__WEBPACK_IMPORTED_MODULE_2__["find"](values, function (_a) {
            var dragIndex = _a.dragIndex, siblingIndex = _a.siblingIndex;
            return dragIndex >= 0 && siblingIndex >= 0;
        });
        if (firstGuideSnap) {
            var startMostBounds = dsb[opp.start] < ssb[opp.start] ? dsb : ssb;
            var endMostBounds = dsb[opp.end] < ssb[opp.end] ? ssb : dsb;
            var startGuide = startMostBounds[opp.start];
            var endGuide = endMostBounds[opp.end];
            var coordGuide = ssb.snapPoints[firstGuideSnap.siblingIndex][coord];
            if (dir === 'horizontal') {
                var from = { x: coordGuide, y: startGuide };
                var to = { x: coordGuide, y: endGuide };
                guides.push({ from: from, to: to });
            }
            else {
                var from = { x: startGuide, y: coordGuide };
                var to = { x: endGuide, y: coordGuide };
                guides.push({ from: from, to: to });
            }
        }
    });
    return guides;
}
/**
 * Builds the snap rulers to draw given a snap info object.
 * This function assumes the global project coordinate space.
 */
function buildRulers(snapInfo, snapToDimensions) {
    if (snapToDimensions === void 0) { snapToDimensions = false; }
    var rulers = [];
    _Constants__WEBPACK_IMPORTED_MODULE_3__["DIRECTIONS"].forEach(function (d) { return rulers.push.apply(rulers, buildRulersInDirection(snapInfo, snapToDimensions, d)); });
    return rulers;
}
// TODO: make sure that only one ruler total is made for the drag bounds!
// TODO: make sure that only one ruler total is made for the drag bounds!
// TODO: make sure that only one ruler total is made for the drag bounds!
// TODO: make sure that only one ruler total is made for the drag bounds!
// TODO: make sure that only one ruler total is made for the drag bounds!
function buildRulersInDirection(snapInfo, snapToDimensions, dir) {
    if (snapToDimensions === void 0) { snapToDimensions = false; }
    var rulers = [];
    snapInfo[dir].values.forEach(function (_a) {
        var dsb = _a.dsb, ssb = _a.ssb, values = _a.values;
        var dimensionSnaps = values.filter(function (_a) {
            var isDimensionSnap = _a.isDimensionSnap;
            return isDimensionSnap;
        });
        if (dimensionSnaps.length) {
            var createRulerFn = function (sb) {
                var from = { x: sb.left, y: sb.top };
                var to = {
                    x: dir === 'horizontal' ? sb.right : sb.left,
                    y: dir === 'horizontal' ? sb.top : sb.bottom,
                };
                return { from: from, to: to };
            };
            rulers.push(createRulerFn(dsb));
            rulers.push(createRulerFn(ssb));
        }
    });
    for (var _i = 0, _a = snapInfo[dir].values; _i < _a.length; _i++) {
        var _b = _a[_i], dsb = _b.dsb, ssb = _b.ssb, values = _b.values;
        var _c = _Constants__WEBPACK_IMPORTED_MODULE_3__["CONSTANTS"][dir], start = _c.start, end = _c.end, opp = _c.opp;
        var oppStartMostBounds = dsb[opp.start] < ssb[opp.start] ? dsb : ssb;
        var oppEndMostBounds = dsb[opp.end] < ssb[opp.end] ? ssb : dsb;
        var nonStartMostBounds = dsb[start] < ssb[start] ? ssb : dsb;
        var nonEndMostBounds = dsb[end] < ssb[end] ? dsb : ssb;
        var guideSnaps = values.filter(function (_a) {
            var isDimensionSnap = _a.isDimensionSnap;
            return !isDimensionSnap;
        });
        if (guideSnaps.length) {
            var oppStartRuler = oppStartMostBounds[opp.end];
            var oppEndRuler = oppEndMostBounds[opp.start];
            var startRuler = nonStartMostBounds[start];
            var endRuler = nonEndMostBounds[end];
            // TODO: handle the horizontal 'rulerLeft === rulerRight' case like sketch does
            // TODO: handle the vertical 'rulerTop === rulerBottom' case like sketch does
            var coordRuler = startRuler + (endRuler - startRuler) * 0.5;
            var from = {
                x: dir === 'horizontal' ? coordRuler : oppStartRuler,
                y: dir === 'horizontal' ? oppStartRuler : coordRuler,
            };
            var to = {
                x: dir === 'horizontal' ? coordRuler : oppEndRuler,
                y: dir === 'horizontal' ? oppEndRuler : coordRuler,
            };
            var guideDelta = to[opp.coord] - from[opp.coord];
            if (guideDelta > SNAP_TOLERANCE_PIXELS) {
                // Don't show a ruler if the items have been snapped (we assume that if
                // the delta values is less than the snap tolerance, then it would have
                // previously been snapped in the canvas such that the delta is now 0).
                rulers.push({ from: from, to: to });
            }
            break;
        }
    }
    var minDistsDragToSibling = [];
    var minDistsSiblingToSibling = [];
    // TODO: make it clear that there should only be one dsb in the snap info object?
    var dsbs = snapInfo[dir].values.map(function (_a) {
        var dsb = _a.dsb;
        return dsb;
    });
    var ssbs = snapInfo[dir].values.map(function (_a) {
        var ssb = _a.ssb;
        return ssb;
    });
    var numValues = snapInfo[dir].values.length;
    for (var i = 0; i < numValues; i++) {
        minDistsDragToSibling.push(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({ sb1: dsbs[i], sb2: ssbs[i] }, dsbs[i].distance(ssbs[i])));
    }
    for (var i = 0; i < numValues - 1; i++) {
        var minSsb = void 0;
        var minLine = void 0;
        var minDist = Infinity;
        for (var j = i + 1; j < numValues; j++) {
            var _d = ssbs[i].distance(ssbs[j]), line = _d.line, dist = _d.dist;
            var absDist = Math.abs(dist);
            if (absDist < minDist) {
                minSsb = ssbs[j];
                minLine = line;
                minDist = absDist;
            }
        }
        minDistsSiblingToSibling.push({ sb1: ssbs[i], sb2: minSsb, line: minLine, dist: minDist });
    }
    var minDistDragToSibling = lodash__WEBPACK_IMPORTED_MODULE_2__["minBy"](minDistsDragToSibling, function (d) { return d.dist; });
    var matchingMinDistsSiblingToSibling = minDistsSiblingToSibling.filter(function (d) {
        return Math.abs(minDistDragToSibling.dist - d.dist) <= SNAP_TOLERANCE_PIXELS;
    });
    if (matchingMinDistsSiblingToSibling.length) {
        rulers.push(minDistDragToSibling.line);
        rulers.push.apply(rulers, matchingMinDistsSiblingToSibling.map(function (d) { return d.line; }));
    }
    return rulers;
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/paper/util/snap/index.ts":
/*!*****************************************************************!*\
  !*** ./src/app/modules/editor/scripts/paper/util/snap/index.ts ***!
  \*****************************************************************/
/*! exports provided: SnapUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SnapUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SnapUtil */ "./src/app/modules/editor/scripts/paper/util/snap/SnapUtil.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "SnapUtil", function() { return _SnapUtil__WEBPACK_IMPORTED_MODULE_0__; });




/***/ }),

/***/ "./src/app/modules/editor/scripts/svgo/index.ts":
/*!******************************************************!*\
  !*** ./src/app/modules/editor/scripts/svgo/index.ts ***!
  \******************************************************/
/*! exports provided: optimizeSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "optimizeSvg", function() { return optimizeSvg; });
/* harmony import */ var svgo_lib_svgo_js2svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svgo/lib/svgo/js2svg */ "./node_modules/svgo/lib/svgo/js2svg.js");
/* harmony import */ var svgo_lib_svgo_js2svg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(svgo_lib_svgo_js2svg__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var svgo_lib_svgo_plugins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svgo/lib/svgo/plugins */ "./node_modules/svgo/lib/svgo/plugins.js");
/* harmony import */ var svgo_lib_svgo_plugins__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(svgo_lib_svgo_plugins__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var svgo_lib_svgo_svg2js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svgo/lib/svgo/svg2js */ "./node_modules/svgo/lib/svgo/svg2js.js");
/* harmony import */ var svgo_lib_svgo_svg2js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(svgo_lib_svgo_svg2js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var svgo_plugins_cleanupAttrs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! svgo/plugins/cleanupAttrs */ "./node_modules/svgo/plugins/cleanupAttrs.js");
/* harmony import */ var svgo_plugins_cleanupAttrs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_cleanupAttrs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var svgo_plugins_cleanupIDs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! svgo/plugins/cleanupIDs */ "./node_modules/svgo/plugins/cleanupIDs.js");
/* harmony import */ var svgo_plugins_cleanupIDs__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_cleanupIDs__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var svgo_plugins_cleanupNumericValues__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! svgo/plugins/cleanupNumericValues */ "./node_modules/svgo/plugins/cleanupNumericValues.js");
/* harmony import */ var svgo_plugins_cleanupNumericValues__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_cleanupNumericValues__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var svgo_plugins_collapseGroups__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! svgo/plugins/collapseGroups */ "./node_modules/svgo/plugins/collapseGroups.js");
/* harmony import */ var svgo_plugins_collapseGroups__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_collapseGroups__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var svgo_plugins_convertPathData__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! svgo/plugins/convertPathData */ "./node_modules/svgo/plugins/convertPathData.js");
/* harmony import */ var svgo_plugins_convertPathData__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_convertPathData__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var svgo_plugins_convertShapeToPath__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! svgo/plugins/convertShapeToPath */ "./node_modules/svgo/plugins/convertShapeToPath.js");
/* harmony import */ var svgo_plugins_convertShapeToPath__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_convertShapeToPath__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var svgo_plugins_convertStyleToAttrs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! svgo/plugins/convertStyleToAttrs */ "./node_modules/svgo/plugins/convertStyleToAttrs.js");
/* harmony import */ var svgo_plugins_convertStyleToAttrs__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_convertStyleToAttrs__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var svgo_plugins_convertTransform__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! svgo/plugins/convertTransform */ "./node_modules/svgo/plugins/convertTransform.js");
/* harmony import */ var svgo_plugins_convertTransform__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_convertTransform__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var svgo_plugins_inlineStyles__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! svgo/plugins/inlineStyles */ "./node_modules/svgo/plugins/inlineStyles.js");
/* harmony import */ var svgo_plugins_inlineStyles__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_inlineStyles__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var svgo_plugins_mergePaths__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! svgo/plugins/mergePaths */ "./node_modules/svgo/plugins/mergePaths.js");
/* harmony import */ var svgo_plugins_mergePaths__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_mergePaths__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var svgo_plugins_minifyStyles__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! svgo/plugins/minifyStyles */ "./node_modules/svgo/plugins/minifyStyles.js");
/* harmony import */ var svgo_plugins_minifyStyles__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_minifyStyles__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var svgo_plugins_moveElemsAttrsToGroup__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! svgo/plugins/moveElemsAttrsToGroup */ "./node_modules/svgo/plugins/moveElemsAttrsToGroup.js");
/* harmony import */ var svgo_plugins_moveElemsAttrsToGroup__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_moveElemsAttrsToGroup__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var svgo_plugins_moveGroupAttrsToElems__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! svgo/plugins/moveGroupAttrsToElems */ "./node_modules/svgo/plugins/moveGroupAttrsToElems.js");
/* harmony import */ var svgo_plugins_moveGroupAttrsToElems__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_moveGroupAttrsToElems__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var svgo_plugins_removeComments__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! svgo/plugins/removeComments */ "./node_modules/svgo/plugins/removeComments.js");
/* harmony import */ var svgo_plugins_removeComments__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeComments__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var svgo_plugins_removeDesc__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! svgo/plugins/removeDesc */ "./node_modules/svgo/plugins/removeDesc.js");
/* harmony import */ var svgo_plugins_removeDesc__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeDesc__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var svgo_plugins_removeDoctype__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! svgo/plugins/removeDoctype */ "./node_modules/svgo/plugins/removeDoctype.js");
/* harmony import */ var svgo_plugins_removeDoctype__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeDoctype__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var svgo_plugins_removeEditorsNSData__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! svgo/plugins/removeEditorsNSData */ "./node_modules/svgo/plugins/removeEditorsNSData.js");
/* harmony import */ var svgo_plugins_removeEditorsNSData__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeEditorsNSData__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var svgo_plugins_removeEmptyAttrs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! svgo/plugins/removeEmptyAttrs */ "./node_modules/svgo/plugins/removeEmptyAttrs.js");
/* harmony import */ var svgo_plugins_removeEmptyAttrs__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeEmptyAttrs__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var svgo_plugins_removeEmptyContainers__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! svgo/plugins/removeEmptyContainers */ "./node_modules/svgo/plugins/removeEmptyContainers.js");
/* harmony import */ var svgo_plugins_removeEmptyContainers__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeEmptyContainers__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var svgo_plugins_removeEmptyText__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! svgo/plugins/removeEmptyText */ "./node_modules/svgo/plugins/removeEmptyText.js");
/* harmony import */ var svgo_plugins_removeEmptyText__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeEmptyText__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var svgo_plugins_removeHiddenElems__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! svgo/plugins/removeHiddenElems */ "./node_modules/svgo/plugins/removeHiddenElems.js");
/* harmony import */ var svgo_plugins_removeHiddenElems__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeHiddenElems__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var svgo_plugins_removeMetadata__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! svgo/plugins/removeMetadata */ "./node_modules/svgo/plugins/removeMetadata.js");
/* harmony import */ var svgo_plugins_removeMetadata__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeMetadata__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var svgo_plugins_removeNonInheritableGroupAttrs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! svgo/plugins/removeNonInheritableGroupAttrs */ "./node_modules/svgo/plugins/removeNonInheritableGroupAttrs.js");
/* harmony import */ var svgo_plugins_removeNonInheritableGroupAttrs__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeNonInheritableGroupAttrs__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var svgo_plugins_removeRasterImages__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! svgo/plugins/removeRasterImages */ "./node_modules/svgo/plugins/removeRasterImages.js");
/* harmony import */ var svgo_plugins_removeRasterImages__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeRasterImages__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var svgo_plugins_removeScriptElement__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! svgo/plugins/removeScriptElement */ "./node_modules/svgo/plugins/removeScriptElement.js");
/* harmony import */ var svgo_plugins_removeScriptElement__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeScriptElement__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var svgo_plugins_removeStyleElement__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! svgo/plugins/removeStyleElement */ "./node_modules/svgo/plugins/removeStyleElement.js");
/* harmony import */ var svgo_plugins_removeStyleElement__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeStyleElement__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var svgo_plugins_removeTitle__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! svgo/plugins/removeTitle */ "./node_modules/svgo/plugins/removeTitle.js");
/* harmony import */ var svgo_plugins_removeTitle__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeTitle__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var svgo_plugins_removeUnknownsAndDefaults__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! svgo/plugins/removeUnknownsAndDefaults */ "./node_modules/svgo/plugins/removeUnknownsAndDefaults.js");
/* harmony import */ var svgo_plugins_removeUnknownsAndDefaults__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeUnknownsAndDefaults__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var svgo_plugins_removeUselessDefs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! svgo/plugins/removeUselessDefs */ "./node_modules/svgo/plugins/removeUselessDefs.js");
/* harmony import */ var svgo_plugins_removeUselessDefs__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeUselessDefs__WEBPACK_IMPORTED_MODULE_31__);
/* harmony import */ var svgo_plugins_removeUselessStrokeAndFill__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! svgo/plugins/removeUselessStrokeAndFill */ "./node_modules/svgo/plugins/removeUselessStrokeAndFill.js");
/* harmony import */ var svgo_plugins_removeUselessStrokeAndFill__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeUselessStrokeAndFill__WEBPACK_IMPORTED_MODULE_32__);
/* harmony import */ var svgo_plugins_removeXMLProcInst__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! svgo/plugins/removeXMLProcInst */ "./node_modules/svgo/plugins/removeXMLProcInst.js");
/* harmony import */ var svgo_plugins_removeXMLProcInst__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(svgo_plugins_removeXMLProcInst__WEBPACK_IMPORTED_MODULE_33__);
/* harmony import */ var _plugins_convertRoundedRectToPath__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./plugins/convertRoundedRectToPath */ "./src/app/modules/editor/scripts/svgo/plugins/convertRoundedRectToPath.ts");
/* harmony import */ var _plugins_replaceUseElems__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./plugins/replaceUseElems */ "./src/app/modules/editor/scripts/svgo/plugins/replaceUseElems.ts");
// TODO: find all differences between the svgo fork and svgo master (and create custom plugins for them?)
// TODO: test indirectly by testing the creation of the vector layer
// TODO: use promises as well for vector layer conversion
// TODO: make sure error handling works properly w/ the new promise architecture
// TODO: re-enable no implicit any and/or no implicit nulls?


































// Custom plugins.


// The complete list is available here: https://github.com/svg/svgo/blob/master/.svgo.yml
var pluginsData = {
    removeDoctype: svgo_plugins_removeDoctype__WEBPACK_IMPORTED_MODULE_18__,
    removeXMLProcInst: svgo_plugins_removeXMLProcInst__WEBPACK_IMPORTED_MODULE_33__,
    removeComments: svgo_plugins_removeComments__WEBPACK_IMPORTED_MODULE_16__,
    removeMetadata: svgo_plugins_removeMetadata__WEBPACK_IMPORTED_MODULE_24__,
    // removeXMLNS,
    removeEditorsNSData: svgo_plugins_removeEditorsNSData__WEBPACK_IMPORTED_MODULE_19__,
    cleanupAttrs: svgo_plugins_cleanupAttrs__WEBPACK_IMPORTED_MODULE_3__,
    inlineStyles: svgo_plugins_inlineStyles__WEBPACK_IMPORTED_MODULE_11__,
    minifyStyles: svgo_plugins_minifyStyles__WEBPACK_IMPORTED_MODULE_13__,
    convertStyleToAttrs: svgo_plugins_convertStyleToAttrs__WEBPACK_IMPORTED_MODULE_9__,
    cleanupIDs: svgo_plugins_cleanupIDs__WEBPACK_IMPORTED_MODULE_4__,
    // prefixIds,
    removeRasterImages: svgo_plugins_removeRasterImages__WEBPACK_IMPORTED_MODULE_26__,
    removeUselessDefs: svgo_plugins_removeUselessDefs__WEBPACK_IMPORTED_MODULE_31__,
    replaceUseElems: _plugins_replaceUseElems__WEBPACK_IMPORTED_MODULE_35__["replaceUseElems"],
    cleanupNumericValues: svgo_plugins_cleanupNumericValues__WEBPACK_IMPORTED_MODULE_5__,
    // cleanupListOfValues,
    // convertColors,
    removeUnknownsAndDefaults: svgo_plugins_removeUnknownsAndDefaults__WEBPACK_IMPORTED_MODULE_30__,
    removeNonInheritableGroupAttrs: svgo_plugins_removeNonInheritableGroupAttrs__WEBPACK_IMPORTED_MODULE_25__,
    removeUselessStrokeAndFill: svgo_plugins_removeUselessStrokeAndFill__WEBPACK_IMPORTED_MODULE_32__,
    // removeViewBox,
    // cleanupEnableBackground,
    removeHiddenElems: svgo_plugins_removeHiddenElems__WEBPACK_IMPORTED_MODULE_23__,
    removeEmptyText: svgo_plugins_removeEmptyText__WEBPACK_IMPORTED_MODULE_22__,
    convertShapeToPath: svgo_plugins_convertShapeToPath__WEBPACK_IMPORTED_MODULE_8__,
    convertRoundedRectToPath: _plugins_convertRoundedRectToPath__WEBPACK_IMPORTED_MODULE_34__["convertRoundedRectToPath"],
    moveElemsAttrsToGroup: svgo_plugins_moveElemsAttrsToGroup__WEBPACK_IMPORTED_MODULE_14__,
    moveGroupAttrsToElems: svgo_plugins_moveGroupAttrsToElems__WEBPACK_IMPORTED_MODULE_15__,
    collapseGroups: svgo_plugins_collapseGroups__WEBPACK_IMPORTED_MODULE_6__,
    convertPathData: svgo_plugins_convertPathData__WEBPACK_IMPORTED_MODULE_7__,
    convertTransform: svgo_plugins_convertTransform__WEBPACK_IMPORTED_MODULE_10__,
    removeEmptyAttrs: svgo_plugins_removeEmptyAttrs__WEBPACK_IMPORTED_MODULE_20__,
    removeEmptyContainers: svgo_plugins_removeEmptyContainers__WEBPACK_IMPORTED_MODULE_21__,
    mergePaths: svgo_plugins_mergePaths__WEBPACK_IMPORTED_MODULE_12__,
    // removeUnusedNS,
    // sortAttrs,
    removeTitle: svgo_plugins_removeTitle__WEBPACK_IMPORTED_MODULE_29__,
    removeDesc: svgo_plugins_removeDesc__WEBPACK_IMPORTED_MODULE_17__,
    // removeDimensions
    // removeAttrs,
    // removeElementsByAttr,
    // addClassesToSVGElement,
    removeStyleElement: svgo_plugins_removeStyleElement__WEBPACK_IMPORTED_MODULE_28__,
    removeScriptElement: svgo_plugins_removeScriptElement__WEBPACK_IMPORTED_MODULE_27__,
};
// Set a global floatPrecision across all the plugins.
var floatPrecision = 6;
for (var _i = 0, _a = Object.values(pluginsData); _i < _a.length; _i++) {
    var plugin = _a[_i];
    if (plugin.params && 'floatPrecision' in plugin.params) {
        plugin.params.floatPrecision = floatPrecision;
    }
}
// Tweak plugin params.
svgo_plugins_cleanupIDs__WEBPACK_IMPORTED_MODULE_4__["params"].minify = false;
svgo_plugins_convertPathData__WEBPACK_IMPORTED_MODULE_7__["params"].makeArcs = undefined;
svgo_plugins_convertPathData__WEBPACK_IMPORTED_MODULE_7__["params"].transformPrecision = floatPrecision;
svgo_plugins_convertShapeToPath__WEBPACK_IMPORTED_MODULE_8__["params"].convertArcs = true;
svgo_plugins_convertTransform__WEBPACK_IMPORTED_MODULE_10__["params"].transformPrecision = floatPrecision;
svgo_plugins_inlineStyles__WEBPACK_IMPORTED_MODULE_11__["params"].onlyMatchedOnce = false;
svgo_plugins_removeUselessStrokeAndFill__WEBPACK_IMPORTED_MODULE_32__["params"].removeNone = true;
var optimizedPluginsData = (function () {
    return Object.values(pluginsData)
        .map(function (item) { return [item]; })
        .reduce(function (arr, item) {
        var last = arr[arr.length - 1];
        if (last && item[0].type === last[0].type) {
            last.push(item[0]);
        }
        else {
            arr.push(item);
        }
        return arr;
    }, []);
})();
function optimizeSvg(svgText, pretty) {
    if (pretty === void 0) { pretty = true; }
    return new Promise(function (resolve, reject) {
        var callbackFn = function (svgjs) {
            if (svgjs.error) {
                reject(svgjs.error);
                return;
            }
            resolve(svgjs.data);
        };
        svgo_lib_svgo_svg2js__WEBPACK_IMPORTED_MODULE_2__(svgText, function (svgjs) {
            if (svgjs.error) {
                callbackFn(svgjs);
                return;
            }
            svgjs = svgo_lib_svgo_plugins__WEBPACK_IMPORTED_MODULE_1__(svgjs, { input: 'string' }, optimizedPluginsData);
            callbackFn(svgo_lib_svgo_js2svg__WEBPACK_IMPORTED_MODULE_0__(svgjs, {
                indent: '  ',
                pretty: pretty,
            }));
        });
    });
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/svgo/plugins/convertRoundedRectToPath.ts":
/*!*********************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/svgo/plugins/convertRoundedRectToPath.ts ***!
  \*********************************************************************************/
/*! exports provided: convertRoundedRectToPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertRoundedRectToPath", function() { return convertRoundedRectToPath; });
var convertRoundedRectToPath = {
    active: true,
    type: 'perItem',
    fn: convertRoundedRectToPathFn,
    params: undefined,
};
var none = { value: 0 };
/**
 * Converts a rounded rect to a more compact path.
 * It also allows further optimizations like
 * combining paths with similar attributes.
 *
 * @see http://www.w3.org/TR/SVG/shapes.html
 *
 * @param {Object} item current iteration item
 * @param {Object} params plugin params
 * @return {Boolean} if false, item will be filtered out
 */
function convertRoundedRectToPathFn(item, params) {
    if (!item.isElem('rect') ||
        !item.hasAttr('width') ||
        !item.hasAttr('height') ||
        !(item.hasAttr('rx') || item.hasAttr('ry'))) {
        return undefined;
    }
    var x = +(item.attr('x') || none).value;
    var y = +(item.attr('y') || none).value;
    var width = +item.attr('width').value;
    var height = +item.attr('height').value;
    var hasRx = item.hasAttr('rx') && isValidCornerRadius(+item.attr('rx').value);
    var hasRy = item.hasAttr('ry') && isValidCornerRadius(+item.attr('ry').value);
    var rx = +(item.attr('rx') || none).value;
    var ry = +(item.attr('ry') || none).value;
    if (!hasRx && !hasRy) {
        // If neither 'rx' nor 'ry' are properly specified, then set both rx and ry to 0.
        rx = ry = 0;
    }
    else if (hasRx && !hasRy) {
        // Otherwise, if a properly specified value is provided for 'rx', but not for 'ry',
        // then set both rx and ry to the value of 'rx'.
        ry = rx;
    }
    else if (!hasRx && hasRy) {
        // Otherwise, if a properly specified value is provided for 'ry', but not for 'rx',
        // then set both rx and ry to the value of 'ry'.
        rx = ry;
    }
    else {
        // If rx is greater than half of 'width', then set rx to half of 'width'.
        if (rx > width / 2) {
            rx = width / 2;
        }
        // If ry is greater than half of 'height', then set ry to half of 'height'.
        if (ry > height / 2) {
            ry = height / 2;
        }
    }
    // Values like '100%' compute to NaN, thus running after
    // cleanupNumericValues when 'px' units has already been removed.
    // TODO: Calculate sizes from % and non-px units if possible.
    if (isNaN(x - y + width - height + rx - ry)) {
        return undefined;
    }
    var pathData;
    if (!rx && !ry) {
        pathData = "M " + x + " " + y + " H " + (x + width) + " V " + (y + height) + " H " + x + " Z";
    }
    else {
        pathData =
            "M " + (x + rx) + " " + y + " " +
                ("H " + (x + width - rx) + " ") +
                ("A " + rx + " " + ry + " 0 0 1 " + (x + width) + " " + (y + ry) + " ") +
                ("V " + (y + height - ry) + " ") +
                ("A " + rx + " " + ry + " 0 0 1 " + (x + width - rx) + " " + (y + height) + " ") +
                ("H " + (x + rx) + " ") +
                ("A " + rx + " " + ry + " 0 0 1 " + x + " " + (y + height - ry) + " ") +
                ("V " + (y + ry) + " ") +
                ("A " + rx + " " + ry + " 0 0 1 " + (x + rx) + " " + y);
    }
    item.addAttr({ name: 'd', value: pathData, prefix: '', local: 'd' });
    item.renameElem('path').removeAttr(['x', 'y', 'width', 'height', 'rx', 'ry']);
}
function isValidCornerRadius(val) {
    return !(typeof val !== 'number' || val === Infinity || val < 0);
}


/***/ }),

/***/ "./src/app/modules/editor/scripts/svgo/plugins/replaceUseElems.ts":
/*!************************************************************************!*\
  !*** ./src/app/modules/editor/scripts/svgo/plugins/replaceUseElems.ts ***!
  \************************************************************************/
/*! exports provided: replaceUseElems */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceUseElems", function() { return replaceUseElems; });
/* harmony import */ var svgo_lib_svgo_css_class_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svgo/lib/svgo/css-class-list */ "./node_modules/svgo/lib/svgo/css-class-list.js");
/* harmony import */ var svgo_lib_svgo_css_class_list__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(svgo_lib_svgo_css_class_list__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var svgo_lib_svgo_css_style_declaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svgo/lib/svgo/css-style-declaration */ "./node_modules/svgo/lib/svgo/css-style-declaration.js");
/* harmony import */ var svgo_lib_svgo_css_style_declaration__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(svgo_lib_svgo_css_style_declaration__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var svgo_lib_svgo_jsAPI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svgo/lib/svgo/jsAPI */ "./node_modules/svgo/lib/svgo/jsAPI.js");
/* harmony import */ var svgo_lib_svgo_jsAPI__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(svgo_lib_svgo_jsAPI__WEBPACK_IMPORTED_MODULE_2__);



var replaceUseElems = {
    active: true,
    type: 'full',
    fn: replaceUseElemsFn,
    params: undefined,
};
/**
 * Replace <use> elems with their referenced content.
 *
 * @param {Object} document the root document
 * @param {Object} params plugin params
 */
function replaceUseElemsFn(document, params) {
    var defsElems = document.querySelectorAll('defs') || [];
    var queryReferencedElementFn = function (selector) {
        for (var _i = 0, defsElems_1 = defsElems; _i < defsElems_1.length; _i++) {
            var defs = defsElems_1[_i];
            var referencedElem = defs.querySelector(selector);
            if (referencedElem) {
                return cloneParsedSvg(referencedElem);
            }
        }
        return undefined;
    };
    // TODO: handle the case where a 'use' element references another 'use'
    // TODO: handle the circular dependency that could potentially result as well
    var useElems = document.querySelectorAll('use') || [];
    for (var _i = 0, useElems_1 = useElems; _i < useElems_1.length; _i++) {
        var use = useElems_1[_i];
        if (!use.hasAttr('xlink:href')) {
            continue;
        }
        var refElem = queryReferencedElementFn(use.attr('xlink:href').value);
        if (!refElem) {
            continue;
        }
        use.removeAttr('xlink:href');
        if (refElem.isElem('symbol')) {
            // TODO: determine whether we should support 'symbol' elements as well
            continue;
        }
        var addAttrFn = function (elem, attrName, attrValue) {
            elem.addAttr({
                name: attrName,
                value: attrValue,
                prefix: '',
                local: attrName,
            });
        };
        if (refElem.isElem('svg')) {
            // TODO: test this
            var svg = refElem;
            if (use.hasAttr('width')) {
                addAttrFn(svg, 'width', use.attr('width').value);
                use.removeAttr('width');
            }
            if (use.hasAttr('height')) {
                addAttrFn(svg, 'height', use.attr('height').value);
                use.removeAttr('height');
            }
        }
        // TODO: handle the NAN cases?
        var x = 0;
        var y = 0;
        if (use.hasAttr('x')) {
            x = +use.attr('x').value;
            use.removeAttr('x');
        }
        if (use.hasAttr('y')) {
            y = +use.attr('y').value;
            use.removeAttr('y');
        }
        if (x || y) {
            var transform = "translate(" + x + " " + y + ")";
            if (use.hasAttr('transform')) {
                transform = use.attr('transform').value + ' ' + transform;
            }
            addAttrFn(use, 'transform', transform);
        }
        use.content = [refElem];
        refElem.parentNode = use;
        use.renameElem('g');
    }
    return document;
}
// Clone is currently broken. Hack it:
function cloneParsedSvg(svg) {
    var clones = new Map();
    function cloneKeys(target, obj) {
        for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
            var key = _a[_i];
            target[key] = clone(obj[key]);
        }
        return target;
    }
    function clone(obj) {
        if (typeof obj !== 'object' || obj === null) {
            return obj;
        }
        if (clones.has(obj)) {
            return clones.get(obj);
        }
        var objClone;
        if (obj.constructor === svgo_lib_svgo_jsAPI__WEBPACK_IMPORTED_MODULE_2__) {
            objClone = new svgo_lib_svgo_jsAPI__WEBPACK_IMPORTED_MODULE_2__({}, obj.parentNode);
            clones.set(obj, objClone);
            if (obj.parentNode) {
                objClone.parentNode = clone(obj.parentNode);
            }
            cloneKeys(objClone, obj);
        }
        else if (obj.constructor === svgo_lib_svgo_css_class_list__WEBPACK_IMPORTED_MODULE_0__ ||
            obj.constructor === svgo_lib_svgo_css_style_declaration__WEBPACK_IMPORTED_MODULE_1__ ||
            obj.constructor === Object ||
            obj.constructor === Array) {
            objClone = new obj.constructor();
            clones.set(obj, objClone);
            cloneKeys(objClone, obj);
        }
        else if (obj.constructor === Map) {
            objClone = new Map();
            clones.set(obj, objClone);
            for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {
                var _a = obj_1[_i], key = _a[0], val = _a[1];
                objClone.set(clone(key), clone(val));
            }
        }
        else if (obj.constructor === Set) {
            objClone = new Set();
            clones.set(obj, objClone);
            for (var _b = 0, obj_2 = obj; _b < obj_2.length; _b++) {
                var val = obj_2[_b];
                objClone.add(clone(val));
            }
        }
        else {
            throw Error('unexpected type');
        }
        return objClone;
    }
    return clone(svg);
}


/***/ }),

/***/ "./src/app/modules/editor/services/StoreUtil.ts":
/*!******************************************************!*\
  !*** ./src/app/modules/editor/services/StoreUtil.ts ***!
  \******************************************************/
/*! exports provided: getEnterDefaultModeActions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnterDefaultModeActions", function() { return getEnterDefaultModeActions; });
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/store/paper/actions */ "./src/app/modules/editor/store/paper/actions.ts");


// TODO: expand on this class... possibly a better redesigned version?
function getEnterDefaultModeActions() {
    return [
        new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_1__["SetToolMode"](app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_0__["ToolMode"].Default),
        new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_1__["SetEditPathInfo"](undefined),
        new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_1__["SetRotateItemsInfo"](undefined),
        new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_1__["SetTransformPathsInfo"](undefined),
    ];
}


/***/ }),

/***/ "./src/app/modules/editor/services/actionmode.service.ts":
/*!***************************************************************!*\
  !*** ./src/app/modules/editor/services/actionmode.service.ts ***!
  \***************************************************************/
/*! exports provided: ActionModeService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionModeService", function() { return ActionModeService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/model/paths */ "./src/app/modules/editor/model/paths/index.ts");
/* harmony import */ var app_modules_editor_scripts_algorithms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/algorithms */ "./src/app/modules/editor/scripts/algorithms/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store/actionmode/actions */ "./src/app/modules/editor/store/actionmode/actions.ts");
/* harmony import */ var app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store/actionmode/selectors */ "./src/app/modules/editor/store/actionmode/selectors.ts");
/* harmony import */ var app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/modules/editor/store/batch/actions */ "./src/app/modules/editor/store/batch/actions.ts");
/* harmony import */ var app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/modules/editor/store/timeline/actions */ "./src/app/modules/editor/store/timeline/actions.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _layertimeline_service__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./layertimeline.service */ "./src/app/modules/editor/services/layertimeline.service.ts");













/**
 * A simple service that provides an interface for making action mode changes.
 */
var ActionModeService = /** @class */ (function () {
    function ActionModeService(store, layerTimelineService) {
        this.store = store;
        this.layerTimelineService = layerTimelineService;
    }
    // Action mode.
    ActionModeService.prototype.isActionMode = function () {
        return this.getActionMode() !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].None;
    };
    ActionModeService.prototype.getActionMode = function () {
        return this.queryStore(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_7__["getActionMode"]);
    };
    ActionModeService.prototype.setActionMode = function (mode) {
        this.store.dispatch(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionMode"](mode));
    };
    ActionModeService.prototype.toggleSplitCommandsMode = function () {
        this.toggleActionMode(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitCommands);
    };
    ActionModeService.prototype.toggleSplitSubPathsMode = function () {
        this.toggleActionMode(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].SplitSubPaths);
    };
    ActionModeService.prototype.togglePairSubPathsMode = function () {
        this.toggleActionMode(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].PairSubPaths);
    };
    ActionModeService.prototype.toggleActionMode = function (modeToToggle) {
        var currentMode = this.getActionMode();
        if (currentMode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].None) {
            return;
        }
        this.setActionMode(currentMode === modeToToggle ? app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection : modeToToggle);
    };
    ActionModeService.prototype.isShowingSubPathActionMode = function () {
        return this.isShowingActionModeType(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].SubPath);
    };
    ActionModeService.prototype.isShowingSegmentActionMode = function () {
        return this.isShowingActionModeType(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Segment);
    };
    ActionModeService.prototype.isShowingPointActionMode = function () {
        return this.isShowingActionModeType(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Point);
    };
    ActionModeService.prototype.isShowingActionModeType = function (type) {
        var mode = this.getActionMode();
        return (mode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].None &&
            (mode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection || this.getSelections().filter(function (s) { return s.type === type; }).length));
    };
    ActionModeService.prototype.closeActionMode = function () {
        var mode = this.getActionMode();
        if (mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].None) {
            return;
        }
        if (mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection) {
            if (this.queryStore(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_7__["getActionModeSelections"]).length) {
                // TODO: move this logic out into a component (it's confusing)
                this.store.dispatch(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeSelections"]([]));
            }
            else {
                this.store.dispatch(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionMode"](app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].None));
            }
        }
        else {
            this.store.dispatch(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionMode"](app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection));
        }
    };
    // Selections.
    ActionModeService.prototype.setSelections = function (selections) {
        this.store.dispatch(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeSelections"](selections));
    };
    ActionModeService.prototype.getSelections = function () {
        return this.queryStore(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_7__["getActionModeSelections"]);
    };
    ActionModeService.prototype.toggleSubPathSelection = function (source, subIdx) {
        var selections = this.getSelections().slice();
        lodash__WEBPACK_IMPORTED_MODULE_10__["remove"](selections, function (s) { return s.type !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].SubPath || s.source !== source; });
        var type = app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].SubPath;
        var toggledSelections = this.toggleSelections(selections, [{ type: type, source: source, subIdx: subIdx }]);
        this.store.dispatch(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeSelections"](toggledSelections));
    };
    ActionModeService.prototype.toggleSegmentSelections = function (source, segments) {
        var selections = this.getSelections().slice();
        lodash__WEBPACK_IMPORTED_MODULE_10__["remove"](selections, function (s) { return s.type !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Segment || s.source !== source; });
        var type = app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Segment;
        var toggledSelections = this.toggleSelections(selections, segments.map(function (_a) {
            var subIdx = _a.subIdx, cmdIdx = _a.cmdIdx;
            return ({ type: type, source: source, subIdx: subIdx, cmdIdx: cmdIdx });
        }));
        this.store.dispatch(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeSelections"](toggledSelections));
    };
    ActionModeService.prototype.togglePointSelection = function (source, subIdx, cmdIdx, isShiftOrMetaPressed) {
        var selections = this.getSelections().slice();
        lodash__WEBPACK_IMPORTED_MODULE_10__["remove"](selections, function (s) { return s.type !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Point || s.source !== source; });
        var type = app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Point;
        var toggledSelections = this.toggleSelections(selections, [{ type: type, source: source, subIdx: subIdx, cmdIdx: cmdIdx }], isShiftOrMetaPressed);
        this.store.dispatch(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeSelections"](toggledSelections));
    };
    /**
     * Toggles the specified shape shifter selections. If a selection exists, all selections
     * will be removed from the list. Otherwise, they will be added to the list of selections.
     * By default, all other selections from the list will be cleared.
     */
    ActionModeService.prototype.toggleSelections = function (currentSelections, newSelections, appendToList) {
        if (appendToList === void 0) { appendToList = false; }
        var matchingSelections = lodash__WEBPACK_IMPORTED_MODULE_10__["remove"](currentSelections, function (currSel) {
            // Remove any selections that are equal to a new selection.
            return newSelections.some(function (s) { return lodash__WEBPACK_IMPORTED_MODULE_10__["isEqual"](s, currSel); });
        });
        if (!matchingSelections.length) {
            // If no selections were removed, then add all of the selections to the list.
            currentSelections.push.apply(currentSelections, newSelections);
        }
        if (!appendToList) {
            // If we aren't appending multiple selections at a time, then clear
            // any previous selections from the list.
            lodash__WEBPACK_IMPORTED_MODULE_10__["remove"](currentSelections, function (currSel) {
                return newSelections.every(function (newSel) { return !lodash__WEBPACK_IMPORTED_MODULE_10__["isEqual"](currSel, newSel); });
            });
        }
        return currentSelections;
    };
    // Hovers.
    ActionModeService.prototype.setHover = function (newHover) {
        var currHover = this.queryStore(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_7__["getActionModeHover"]);
        if (!lodash__WEBPACK_IMPORTED_MODULE_10__["isEqual"](newHover, currHover)) {
            this.store.dispatch(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeHover"](newHover));
        }
    };
    ActionModeService.prototype.splitInHalfHover = function () {
        var pointSelections = this.getSelections().filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Point; });
        if (pointSelections.length) {
            var _a = pointSelections[0], source = _a.source, subIdx = _a.subIdx, cmdIdx = _a.cmdIdx;
            this.setHover({ type: app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["HoverType"].Split, source: source, subIdx: subIdx, cmdIdx: cmdIdx });
        }
    };
    ActionModeService.prototype.clearHover = function () {
        this.setHover(undefined);
    };
    // Mutate subpaths.
    ActionModeService.prototype.reverseSelectedSubPaths = function () {
        this.mutateSelectedSubPaths(function (pm, subIdx) { return pm.reverseSubPath(subIdx); });
    };
    ActionModeService.prototype.shiftBackSelectedSubPaths = function () {
        this.mutateSelectedSubPaths(function (pm, subIdx) { return pm.shiftSubPathBack(subIdx); });
    };
    ActionModeService.prototype.shiftForwardSelectedSubPaths = function () {
        this.mutateSelectedSubPaths(function (pm, subIdx) { return pm.shiftSubPathForward(subIdx); });
    };
    ActionModeService.prototype.mutateSelectedSubPaths = function (mutatorFn) {
        var selections = this.getSelections().filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].SubPath; });
        var source = selections[0].source;
        var pm = this.getActivePathBlockValue(source).mutate();
        for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {
            var subIdx = selections_1[_i].subIdx;
            mutatorFn(pm, subIdx);
        }
        this.store.dispatch(new app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_8__["BatchAction"](this.buildUpdatedActivePathBlockAnimationAction(source, pm.build()), new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeHover"](undefined)));
    };
    // Mutate points.
    ActionModeService.prototype.shiftPointToFront = function () {
        var selections = this.getSelections().filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Point; });
        var _a = selections[0], source = _a.source, subIdx = _a.subIdx, cmdIdx = _a.cmdIdx;
        var activePath = this.getActivePathBlockValue(source);
        var pm = activePath.mutate();
        pm.shiftSubPathForward(subIdx, cmdIdx);
        this.store.dispatch(this.buildUpdatedActivePathBlockAnimationAction(source, pm.build()));
    };
    ActionModeService.prototype.splitSelectedPointInHalf = function () {
        var selections = this.getSelections().filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Point; });
        var _a = selections[0], source = _a.source, subIdx = _a.subIdx, cmdIdx = _a.cmdIdx;
        var activePath = this.getActivePathBlockValue(source);
        var pm = activePath.mutate();
        pm.splitCommandInHalf(subIdx, cmdIdx);
        this.store.dispatch(new app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_8__["BatchAction"](this.buildUpdatedActivePathBlockAnimationAction(source, pm.build()), new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeSelections"]([]), new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeHover"](undefined)));
    };
    // Pair/unpair subpaths.
    ActionModeService.prototype.pairSubPath = function (subIdx, actionSource) {
        var currUnpair = this.getUnpairedSubPath();
        var actions = [];
        if (currUnpair && actionSource !== currUnpair.source) {
            var fromSource_1 = currUnpair.source, fromSubIdx_1 = currUnpair.subIdx;
            var toSource_1 = actionSource;
            var toSubIdx_1 = subIdx;
            actions.push(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetUnpairedSubPath"](undefined));
            var fromSelections = this.getSelections().filter(function (s) { return s.source === fromSource_1; });
            var toSelections = this.getSelections().filter(function (s) { return s.source === toSource_1; });
            if (fromSelections.length) {
                actions.push(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeSelections"](fromSelections.map(function (s) {
                    var sIdx = s.subIdx, cmdIdx = s.cmdIdx, source = s.source, type = s.type;
                    return {
                        subIdx: sIdx === fromSubIdx_1 ? 0 : sIdx,
                        cmdIdx: cmdIdx,
                        source: source,
                        type: type,
                    };
                })));
            }
            else if (toSelections.length) {
                actions.push(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeSelections"](toSelections.map(function (s) {
                    var sIdx = s.subIdx, cmdIdx = s.cmdIdx, source = s.source, type = s.type;
                    return {
                        subIdx: sIdx === toSubIdx_1 ? 0 : sIdx,
                        cmdIdx: cmdIdx,
                        source: source,
                        type: type,
                    };
                })));
            }
            var pairedSubPaths_1 = new Set();
            this.getPairedSubPaths().forEach(function (p) { return pairedSubPaths_1.add(p); });
            if (pairedSubPaths_1.has(fromSubIdx_1)) {
                pairedSubPaths_1.delete(fromSubIdx_1);
            }
            if (pairedSubPaths_1.has(toSubIdx_1)) {
                pairedSubPaths_1.delete(toSubIdx_1);
            }
            pairedSubPaths_1.add(pairedSubPaths_1.size);
            actions.push(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetPairedSubPaths"](pairedSubPaths_1));
            actions.push(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeHover"](undefined));
            var updatedAnimation = this.buildUpdatedActivePathBlockAnimation(fromSource_1, this.getActivePathBlockValue(fromSource_1)
                .mutate()
                .moveSubPath(fromSubIdx_1, 0)
                .build());
            updatedAnimation = this.buildUpdatedActivePathBlockAnimation(toSource_1, this.getActivePathBlockValue(toSource_1)
                .mutate()
                .moveSubPath(toSubIdx_1, 0)
                .build(), updatedAnimation);
            actions.push(new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_9__["SetAnimation"](updatedAnimation));
        }
        else {
            actions.push(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetUnpairedSubPath"]({ source: actionSource, subIdx: subIdx }));
        }
        this.store.dispatch(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_8__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_8__["BatchAction"], [void 0].concat(actions)))());
    };
    ActionModeService.prototype.getPairedSubPaths = function () {
        return this.queryStore(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_7__["getPairedSubPaths"]);
    };
    ActionModeService.prototype.setUnpairedSubPath = function (unpair) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_10__["isEqual"](this.getUnpairedSubPath(), unpair)) {
            this.store.dispatch(new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetUnpairedSubPath"](unpair));
        }
    };
    ActionModeService.prototype.getUnpairedSubPath = function () {
        return this.queryStore(app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_7__["getUnpairedSubPath"]);
    };
    // Autofix.
    ActionModeService.prototype.autoFix = function () {
        var _a = app_modules_editor_scripts_algorithms__WEBPACK_IMPORTED_MODULE_4__["AutoAwesome"].autoFix(this.getActivePathBlockValue(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From), this.getActivePathBlockValue(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].To)), from = _a[0], to = _a[1];
        var animation = this.buildUpdatedActivePathBlockAnimation(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From, from);
        animation = this.buildUpdatedActivePathBlockAnimation(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].To, to, animation);
        this.store.dispatch(new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_9__["SetAnimation"](animation));
    };
    // Delete selected action mode models.
    ActionModeService.prototype.deleteSelectedActionModeModels = function () {
        if (this.getActionMode() !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionMode"].Selection) {
            return;
        }
        var selections = this.getSelections();
        if (!selections.length) {
            return;
        }
        var subPathSelections = selections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].SubPath; });
        var segmentSelections = selections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Segment; });
        var pointSelections = selections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["SelectionType"].Point; });
        var updatePathAction;
        if (subPathSelections.length) {
            var _a = subPathSelections[0], source = _a.source, subIdx = _a.subIdx;
            var path = this.getActivePathBlockValue(source);
            if (path.getSubPath(subIdx).isSplit()) {
                var pm = path.mutate();
                var layer = this.getActivePathBlockLayer();
                if (layer.isFilled()) {
                    pm.deleteFilledSubPath(subIdx);
                }
                else if (layer.isStroked()) {
                    pm.deleteStrokedSubPath(subIdx);
                }
                updatePathAction = this.buildUpdatedActivePathBlockAnimationAction(source, pm.build());
            }
        }
        else if (segmentSelections.length) {
            var _b = segmentSelections[0], source = _b.source, subIdx = _b.subIdx, cmdIdx = _b.cmdIdx;
            var path = this.getActivePathBlockValue(source);
            if (path.getCommand(subIdx, cmdIdx).isSplitSegment()) {
                updatePathAction = this.buildUpdatedActivePathBlockAnimationAction(source, path
                    .mutate()
                    .deleteFilledSubPathSegment(subIdx, cmdIdx)
                    .build());
            }
        }
        else if (pointSelections.length) {
            var source = pointSelections[0].source;
            var path = this.getActivePathBlockValue(source);
            var unsplitOpsMap = new Map();
            for (var _i = 0, pointSelections_1 = pointSelections; _i < pointSelections_1.length; _i++) {
                var _c = pointSelections_1[_i], subIdx = _c.subIdx, cmdIdx = _c.cmdIdx;
                if (!path.getCommand(subIdx, cmdIdx).isSplitPoint()) {
                    continue;
                }
                var subIdxOps = unsplitOpsMap.get(subIdx);
                if (!subIdxOps) {
                    subIdxOps = [];
                }
                subIdxOps.push({ subIdx: subIdx, cmdIdx: cmdIdx });
                unsplitOpsMap.set(subIdx, subIdxOps);
            }
            if (unsplitOpsMap.size) {
                var pm_1 = path.mutate();
                unsplitOpsMap.forEach(function (ops, idx) {
                    app_modules_editor_model_paths__WEBPACK_IMPORTED_MODULE_3__["PathUtil"].sortPathOps(ops);
                    ops.forEach(function (op) { return pm_1.unsplitCommand(op.subIdx, op.cmdIdx); });
                });
                updatePathAction = this.buildUpdatedActivePathBlockAnimationAction(source, pm_1.build());
            }
        }
        if (updatePathAction) {
            this.store.dispatch(new app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_8__["BatchAction"](updatePathAction, new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeSelections"]([]), new app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_6__["SetActionModeHover"](undefined)));
        }
    };
    // Update active path block.
    ActionModeService.prototype.updateActivePathBlock = function (source, path) {
        this.store.dispatch(this.buildUpdatedActivePathBlockAnimationAction(source, path));
    };
    ActionModeService.prototype.buildUpdatedActivePathBlockAnimationAction = function (source, path, animation) {
        if (animation === void 0) { animation = this.layerTimelineService.getAnimation(); }
        return new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_9__["SetAnimation"](this.buildUpdatedActivePathBlockAnimation(source, path, animation));
    };
    ActionModeService.prototype.buildUpdatedActivePathBlockAnimation = function (source, path, animation) {
        if (animation === void 0) { animation = this.layerTimelineService.getAnimation(); }
        var _a, _b;
        var blockId = this.getActivePathBlock().id;
        var blockIndex = lodash__WEBPACK_IMPORTED_MODULE_10__["findIndex"](animation.blocks, function (b) { return b.id === blockId; });
        var block = animation.blocks[blockIndex];
        // Remove any existing conversions and collapsing sub paths from the path.
        var oppSource = source === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From ? app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].To : app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From;
        var oppPath = oppSource === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From ? block.fromValue : block.toValue;
        _a = app_modules_editor_scripts_algorithms__WEBPACK_IMPORTED_MODULE_4__["AutoAwesome"].autoAddCollapsingSubPaths(path, oppPath), path = _a[0], oppPath = _a[1];
        _b = app_modules_editor_scripts_algorithms__WEBPACK_IMPORTED_MODULE_4__["AutoAwesome"].autoConvert(path, oppPath), path = _b[0], oppPath = _b[1];
        var setBlockValueFn = function (b, t, p) {
            if (t === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From) {
                b.fromValue = p;
            }
            else {
                b.toValue = p;
            }
        };
        var newBlock = block.clone();
        setBlockValueFn(newBlock, source, path);
        setBlockValueFn(newBlock, oppSource, oppPath);
        var newBlocks = animation.blocks.map(function (b, i) { return (i === blockIndex ? newBlock : b); });
        animation = animation.clone();
        animation.blocks = newBlocks;
        return animation;
    };
    ActionModeService.prototype.getActivePathBlock = function () {
        return this.layerTimelineService.getSelectedBlocks()[0];
    };
    ActionModeService.prototype.getActivePathBlockValue = function (source) {
        var activeBlock = this.getActivePathBlock();
        return source === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_2__["ActionSource"].From ? activeBlock.fromValue : activeBlock.toValue;
    };
    ActionModeService.prototype.getActivePathBlockLayer = function () {
        var vl = this.layerTimelineService.getVectorLayer();
        return vl.findLayerById(this.getActivePathBlock().layerId);
    };
    ActionModeService.prototype.queryStore = function (selector) {
        var obj;
        this.store
            .select(selector)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["first"])())
            .subscribe(function (o) { return (obj = o); });
        return obj;
    };
    ActionModeService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_5__["Store"],
            _layertimeline_service__WEBPACK_IMPORTED_MODULE_12__["LayerTimelineService"]])
    ], ActionModeService);
    return ActionModeService;
}());



/***/ }),

/***/ "./src/app/modules/editor/services/clipboard.service.ts":
/*!**************************************************************!*\
  !*** ./src/app/modules/editor/services/clipboard.service.ts ***!
  \**************************************************************/
/*! exports provided: ClipboardService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClipboardService", function() { return ClipboardService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/timeline */ "./src/app/modules/editor/model/timeline/index.ts");
/* harmony import */ var app_modules_editor_scripts_bugsnag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/bugsnag */ "./src/app/modules/editor/scripts/bugsnag/index.ts");
/* harmony import */ var app_modules_editor_scripts_import__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/import */ "./src/app/modules/editor/scripts/import/index.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _actionmode_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./actionmode.service */ "./src/app/modules/editor/services/actionmode.service.ts");
/* harmony import */ var _layertimeline_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./layertimeline.service */ "./src/app/modules/editor/services/layertimeline.service.ts");
/* harmony import */ var _playback_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./playback.service */ "./src/app/modules/editor/services/playback.service.ts");









//BHAARATA: end of my code
var ClipboardService = /** @class */ (function () {
    function ClipboardService(layerTimelineService, playbackService, actionModeService) {
        this.layerTimelineService = layerTimelineService;
        this.playbackService = playbackService;
        this.actionModeService = actionModeService;
    }
    ClipboardService.prototype.init = function () {
        var _this = this;
        var cutCopyHandlerFn = function (event, shouldCut) {
            if (document.activeElement.matches('input')) {
                return true;
            }
            var blocks = _this.layerTimelineService.getSelectedBlocks().map(function (b) { return b.toJSON(); });
            if (!blocks.length) {
                return false;
            }
            //const clipboardData = (event.originalEvent as ClipboardEvent).clipboardData;
            var clipboardData = event.originalEvent.clipboardData; //BHAARATA: my code
            clipboardData.setData('text/plain', JSON.stringify({ blocks: blocks }, undefined, 2));
            if (shouldCut) {
                _this.layerTimelineService.deleteSelectedModels();
            }
            return false;
        };
        var pasteHandlerFn = function (event) {
            if (_this.actionModeService.isActionMode()) {
                // TODO: make action mode automatically exit when layers/blocks are added in other parts of the app
                app_modules_editor_scripts_bugsnag__WEBPACK_IMPORTED_MODULE_3__["bugsnagClient"].notify('Attempt to import files while in action mode', {
                    severity: 'warning',
                });
                return false;
            }
            if (document.activeElement.matches('input')) {
                return true;
            }
            //const clipboardData = (event.originalEvent as ClipboardEvent).clipboardData;
            var clipboardData = event.originalEvent.clipboardData; //BHAARATA: my code
            var str = clipboardData.getData('text');
            var existingVl = _this.layerTimelineService.getVectorLayer();
            if (str.match(/<\/svg>\s*$/)) {
                // Paste SVG.
                ga('send', 'event', 'paste', 'svg');
                app_modules_editor_scripts_import__WEBPACK_IMPORTED_MODULE_4__["SvgLoader"].loadVectorLayerFromSvgString(str, function (name) { return !!existingVl.findLayerByName(name); })
                    .then(function (vl) { return _this.layerTimelineService.importLayers([vl]); })
                    .catch(function () { return console.warn('failed to import SVG'); });
            }
            else if (str.match(/<\/vector>\s*$/)) {
                // Paste VD.
                ga('send', 'event', 'paste', 'vd');
                var importedVl = app_modules_editor_scripts_import__WEBPACK_IMPORTED_MODULE_4__["VectorDrawableLoader"].loadVectorLayerFromXmlString(str, function (name) { return !!existingVl.findLayerByName(name); });
                if (importedVl) {
                    _this.layerTimelineService.importLayers([importedVl]);
                }
            }
            else if (str.match(/\}\s*$/)) {
                var parsed = void 0;
                try {
                    parsed = JSON.parse(str);
                }
                catch (e) {
                    console.error("Couldn't parse JSON: " + str);
                    return false;
                }
                if (parsed.blocks) {
                    ga('send', 'event', 'paste', 'json.blocks');
                    _this.layerTimelineService.addBlocks(parsed.blocks.map(function (b) {
                        var block = app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_2__["AnimationBlock"].from(b);
                        var layerId = block.layerId, propertyName = block.propertyName, fromValue = block.fromValue, toValue = block.toValue, interpolator = block.interpolator, startTime = block.startTime, endTime = block.endTime;
                        var duration = endTime - startTime;
                        return {
                            layerId: layerId,
                            propertyName: propertyName,
                            fromValue: fromValue,
                            toValue: toValue,
                            currentTime: _this.playbackService.getCurrentTime(),
                            duration: duration,
                            interpolator: interpolator,
                        };
                    }), false);
                }
                else {
                    ga('send', 'event', 'paste', 'json.unknown');
                }
                return false;
            }
            return false;
        };
        var cutHandler = function (event) { return cutCopyHandlerFn(event, true); };
        var copyHandler = function (event) { return cutCopyHandlerFn(event, false); };
        var pasteHandler = pasteHandlerFn;
        jquery__WEBPACK_IMPORTED_MODULE_5__(window)
            .on('cut', cutHandler)
            .on('copy', copyHandler)
            .on('paste', pasteHandler);
    };
    ClipboardService.prototype.destroy = function () {
        jquery__WEBPACK_IMPORTED_MODULE_5__(window)
            .unbind('cut')
            .unbind('copy')
            .unbind('paste');
    };
    ClipboardService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_layertimeline_service__WEBPACK_IMPORTED_MODULE_7__["LayerTimelineService"],
            _playback_service__WEBPACK_IMPORTED_MODULE_8__["PlaybackService"],
            _actionmode_service__WEBPACK_IMPORTED_MODULE_6__["ActionModeService"]])
    ], ClipboardService);
    return ClipboardService;
}());



/***/ }),

/***/ "./src/app/modules/editor/services/fileexport.service.ts":
/*!***************************************************************!*\
  !*** ./src/app/modules/editor/services/fileexport.service.ts ***!
  \***************************************************************/
/*! exports provided: FileExportService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileExportService", function() { return FileExportService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/model/timeline */ "./src/app/modules/editor/model/timeline/index.ts");
/* harmony import */ var app_modules_editor_scripts_export__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/export */ "./src/app/modules/editor/scripts/export/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store/timeline/selectors */ "./src/app/modules/editor/store/timeline/selectors.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jszip */ "./node_modules/jszip/dist/jszip.min.js");
/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");












// Store a version number just in case we ever change the export format...
var IMPORT_EXPORT_VERSION = 1;
var EXPORTED_FPS = [30, 60];
/**
 * A simple service that exports vectors and animations.
 */
var FileExportService = /** @class */ (function () {
    function FileExportService(store) {
        this.store = store;
    }
    FileExportService.fromJSON = function (jsonObj) {
        var layers = jsonObj.layers, timeline = jsonObj.timeline;
        var vectorLayer = new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["VectorLayer"](layers.vectorLayer);
        var hiddenLayerIds = new Set(layers.hiddenLayerIds);
        var animation = new app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_3__["Animation"](timeline.animation);
        return { vectorLayer: vectorLayer, hiddenLayerIds: hiddenLayerIds, animation: animation };
    };
    FileExportService.prototype.exportJSON = function () {
        var vl = this.getVectorLayer();
        var anim = this.getAnimation();
        var jsonStr = JSON.stringify({
            version: IMPORT_EXPORT_VERSION,
            layers: {
                vectorLayer: vl.toJSON(),
                hiddenLayerIds: Array.from(this.getHiddenLayerIds()),
            },
            timeline: {
                animation: anim.toJSON(),
            },
        }, undefined, 2);
        downloadFile(jsonStr, vl.name + ".shapeshifter");
    };
    FileExportService.prototype.exportSvg = function () {
        // Export standalone SVG frames.
        var vl = this.getVectorLayerWithoutHiddenLayers();
        var anim = this.getAnimationWithoutHiddenBlocks();
        if (!anim.blocks.length) {
            // Just export an SVG if there are no animation blocks defined.
            var svg = app_modules_editor_scripts_export__WEBPACK_IMPORTED_MODULE_4__["SvgSerializer"].toSvgString(vl);
            downloadFile(svg, vl.name + ".svg");
            return;
        }
        // TODO: figure out how to add better jszip typings
        var zip = new jszip__WEBPACK_IMPORTED_MODULE_9__();
        EXPORTED_FPS.forEach(function (fps) {
            var numSteps = Math.ceil((anim.duration / 1000) * fps);
            var svgs = app_modules_editor_scripts_export__WEBPACK_IMPORTED_MODULE_4__["SpriteSerializer"].createSvgFrames(vl, anim, numSteps);
            var length = (numSteps - 1).toString().length;
            var fpsFolder = zip.folder(fps + "fps");
            svgs.forEach(function (s, i) {
                fpsFolder.file("frame" + lodash__WEBPACK_IMPORTED_MODULE_10__["padStart"](i.toString(), length, '0') + ".svg", s);
            });
        });
        zip.generateAsync({ type: 'blob' }).then(function (content) {
            downloadFile(content, "frames_" + vl.name + ".zip");
        });
    };
    // TODO: should we or should we not export hidden layers?
    FileExportService.prototype.exportVectorDrawable = function () {
        var vl = this.getVectorLayerWithoutHiddenLayers();
        var vd = app_modules_editor_scripts_export__WEBPACK_IMPORTED_MODULE_4__["AvdSerializer"].toVectorDrawableXmlString(vl);
        var fileName = "vd_" + vl.name + ".xml";
        downloadFile(vd, fileName);
    };
    FileExportService.prototype.exportAnimatedVectorDrawable = function () {
        var vl = this.getVectorLayerWithoutHiddenLayers();
        var anim = this.getAnimationWithoutHiddenBlocks();
        var avd = app_modules_editor_scripts_export__WEBPACK_IMPORTED_MODULE_4__["AvdSerializer"].toAnimatedVectorDrawableXmlString(vl, anim);
        var fileName = "avd_" + anim.name + ".xml";
        downloadFile(avd, fileName);
    };
    FileExportService.prototype.exportSvgSpritesheet = function () {
        var _this = this;
        // Create an svg sprite animation.
        var vl = this.getVectorLayerWithoutHiddenLayers();
        var anim = this.getAnimationWithoutHiddenBlocks();
        // TODO: figure out how to add better jszip typings
        var zip = new jszip__WEBPACK_IMPORTED_MODULE_9__();
        (function () { return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](_this, void 0, void 0, function () {
            var _this = this;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, asyncForEach(EXPORTED_FPS, function (fps) { return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](_this, void 0, void 0, function () {
                            var numSteps, svgSprite, cssSprite, fileName, htmlSprite, spriteFolder;
                            return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        numSteps = Math.ceil((anim.duration / 1000) * fps);
                                        return [4 /*yield*/, app_modules_editor_scripts_export__WEBPACK_IMPORTED_MODULE_4__["SpriteSerializer"].createSvgSprite(vl, anim, numSteps)];
                                    case 1:
                                        svgSprite = _a.sent();
                                        cssSprite = app_modules_editor_scripts_export__WEBPACK_IMPORTED_MODULE_4__["SpriteSerializer"].createCss(vl.width, vl.height, anim.duration, numSteps);
                                        fileName = "sprite_" + fps + "fps";
                                        htmlSprite = app_modules_editor_scripts_export__WEBPACK_IMPORTED_MODULE_4__["SpriteSerializer"].createHtml(fileName + ".svg", fileName + ".css");
                                        spriteFolder = zip.folder(fps + "fps");
                                        spriteFolder.file(fileName + ".html", htmlSprite);
                                        spriteFolder.file(fileName + ".css", cssSprite);
                                        spriteFolder.file(fileName + ".svg", svgSprite);
                                        return [2 /*return*/];
                                }
                            });
                        }); })];
                    case 1:
                        _a.sent();
                        zip.generateAsync({ type: 'blob' }).then(function (content) {
                            downloadFile(content, "spritesheet_" + vl.name + ".zip");
                        });
                        return [2 /*return*/];
                }
            });
        }); })();
    };
    FileExportService.prototype.exportCssKeyframes = function () {
        // TODO: implement this
    };
    FileExportService.prototype.getVectorLayer = function () {
        var vectorLayer;
        this.store
            .select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_6__["getVectorLayer"])
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["first"])())
            .subscribe(function (vl) { return (vectorLayer = vl); });
        return vectorLayer;
    };
    FileExportService.prototype.getAnimation = function () {
        var animation;
        this.store
            .select(app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_7__["getAnimation"])
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["first"])())
            .subscribe(function (anim) { return (animation = anim); });
        return animation;
    };
    FileExportService.prototype.getHiddenLayerIds = function () {
        var hiddenLayerIds;
        this.store
            .select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_6__["getHiddenLayerIds"])
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__["first"])())
            .subscribe(function (ids) { return (hiddenLayerIds = ids); });
        return hiddenLayerIds;
    };
    FileExportService.prototype.getVectorLayerWithoutHiddenLayers = function () {
        return app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["LayerUtil"].removeLayers.apply(app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["LayerUtil"], [this.getVectorLayer()].concat(Array.from(this.getHiddenLayerIds())));
    };
    FileExportService.prototype.getAnimationWithoutHiddenBlocks = function () {
        var anim = this.getAnimation().clone();
        var hiddenLayerIds = this.getHiddenLayerIds();
        anim.blocks = anim.blocks.filter(function (b) { return !hiddenLayerIds.has(b.layerId); });
        return anim;
    };
    FileExportService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_5__["Store"]])
    ], FileExportService);
    return FileExportService;
}());

function downloadFile(content, fileName) {
    var anchor = jquery__WEBPACK_IMPORTED_MODULE_8__('<a>')
        .hide()
        .appendTo(document.body);
    var blob = content instanceof Blob ? content : new Blob([content], { type: 'octet/stream' });
    var url = window.URL.createObjectURL(blob);
    anchor.attr({ href: url, download: fileName });
    anchor.get(0).click();
    window.URL.revokeObjectURL(url);
}
function asyncForEach(array, callback) {
    return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](this, void 0, void 0, function () {
        var index;
        return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
            switch (_a.label) {
                case 0:
                    index = 0;
                    _a.label = 1;
                case 1:
                    if (!(index < array.length)) return [3 /*break*/, 4];
                    return [4 /*yield*/, callback(array[index], index, array)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    index++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    });
}


/***/ }),

/***/ "./src/app/modules/editor/services/fileimport.service.ts":
/*!***************************************************************!*\
  !*** ./src/app/modules/editor/services/fileimport.service.ts ***!
  \***************************************************************/
/*! exports provided: FileImportService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileImportService", function() { return FileImportService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_scripts_import__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/import */ "./src/app/modules/editor/scripts/import/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_reset_actions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store/reset/actions */ "./src/app/modules/editor/store/reset/actions.ts");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _fileexport_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./fileexport.service */ "./src/app/modules/editor/services/fileexport.service.ts");
/* harmony import */ var _layertimeline_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./layertimeline.service */ "./src/app/modules/editor/services/layertimeline.service.ts");
/* harmony import */ var _snackbar_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./snackbar.service */ "./src/app/modules/editor/services/snackbar.service.ts");












var ImportType;
(function (ImportType) {
    ImportType[ImportType["Svg"] = 1] = "Svg";
    ImportType[ImportType["VectorDrawable"] = 2] = "VectorDrawable";
    ImportType[ImportType["Json"] = 3] = "Json";
})(ImportType || (ImportType = {}));
/**
 * A simple service that imports vector layers from files.
 */
var FileImportService = /** @class */ (function () {
    function FileImportService(store, snackBarService, layerTimelineService) {
        this.store = store;
        this.snackBarService = snackBarService;
        this.layerTimelineService = layerTimelineService;
    }
    Object.defineProperty(FileImportService.prototype, "vectorLayer", {
        get: function () {
            var vectorLayer;
            this.store
                .select(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_6__["getVectorLayer"])
                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["first"])())
                .subscribe(function (vl) { return (vectorLayer = vl); });
            return vectorLayer;
        },
        enumerable: true,
        configurable: true
    });
    FileImportService.prototype.import = function (fileList, resetWorkspace) {
        var _this = this;
        if (resetWorkspace === void 0) { resetWorkspace = false; }
        if (!fileList || !fileList.length) {
            return;
        }
        var files = [];
        // tslint:disable-next-line: prefer-for-of
        for (var i = 0; i < fileList.length; i++) {
            files.push(fileList[i]);
        }
        var numCallbacks = 0;
        var numErrors = 0;
        var addedVls = [];
        var importType;
        var maybeAddVectorLayersFn = function () {
            numCallbacks++;
            if (numErrors === files.length) {
                _this.onFailure();
            }
            else if (numCallbacks === files.length) {
                _this.onSuccess(importType, resetWorkspace, addedVls);
            }
        };
        var existingVl = this.vectorLayer;
        var _loop_1 = function (file) {
            var fileReader = new FileReader();
            fileReader.onload = function (event) {
                var text = event.target.result;
                var callbackFn = function (vectorLayer) {
                    if (!vectorLayer) {
                        numErrors++;
                        maybeAddVectorLayersFn();
                        return;
                    }
                    addedVls.push(vectorLayer);
                    maybeAddVectorLayersFn();
                };
                var doesNameExistFn = function (name) {
                    return !!app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["LayerUtil"].findLayerByName([existingVl].concat(addedVls), name);
                };
                if (file.type.includes('svg')) {
                    importType = ImportType.Svg;
                    app_modules_editor_scripts_import__WEBPACK_IMPORTED_MODULE_4__["SvgLoader"].loadVectorLayerFromSvgString(text, doesNameExistFn)
                        .then(function (vl) { return callbackFn(vl); })
                        .catch(function () {
                        console.warn('failed to import SVG');
                        callbackFn(undefined);
                    });
                }
                else if (file.type.includes('xml')) {
                    importType = ImportType.VectorDrawable;
                    var vl = void 0;
                    try {
                        vl = app_modules_editor_scripts_import__WEBPACK_IMPORTED_MODULE_4__["VectorDrawableLoader"].loadVectorLayerFromXmlString(text, doesNameExistFn);
                        callbackFn(vl);
                    }
                    catch (e) {
                        console.warn('Failed to parse the file', e);
                        callbackFn(undefined);
                    }
                }
                else if (file.type === 'application/json' || file.name.match(/\.shapeshifter$/)) {
                    importType = ImportType.Json;
                    var vl = void 0;
                    var animation = void 0;
                    var hiddenLayerIds = void 0;
                    try {
                        var jsonObj = JSON.parse(text);
                        var parsedObj = _fileexport_service__WEBPACK_IMPORTED_MODULE_9__["FileExportService"].fromJSON(jsonObj);
                        vl = parsedObj.vectorLayer;
                        animation = parsedObj.animation;
                        hiddenLayerIds = parsedObj.hiddenLayerIds;
                        var regeneratedModels = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_3__["ModelUtil"].regenerateModelIds(vl, animation, hiddenLayerIds);
                        vl = regeneratedModels.vectorLayer;
                        animation = regeneratedModels.animation;
                        hiddenLayerIds = regeneratedModels.hiddenLayerIds;
                    }
                    catch (e) {
                        console.warn('Failed to parse the file', e);
                        _this.onFailure();
                    }
                    _this.onSuccess(importType, resetWorkspace, [vl], animation, hiddenLayerIds);
                }
            };
            fileReader.onerror = function (event) {
                var target = event.target;
                switch (target.error.code) {
                    case target.error.NOT_FOUND_ERR:
                        alert('File not found');
                        break;
                    case target.error.NOT_READABLE_ERR:
                        alert('File is not readable');
                        break;
                    case target.error.ABORT_ERR:
                        break;
                    default:
                        alert('An error occurred reading this file');
                        break;
                }
                numErrors++;
                maybeAddVectorLayersFn();
            };
            fileReader.onabort = function (event) {
                alert('File read cancelled');
            };
            fileReader.readAsText(file);
        };
        for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
            var file = files_1[_i];
            _loop_1(file);
        }
    };
    FileImportService.prototype.onSuccess = function (importType, resetWorkspace, vls, animation, hiddenLayerIds) {
        if (importType === ImportType.Json) {
            ga('send', 'event', 'Import', 'JSON');
            this.store.dispatch(new app_modules_editor_store_reset_actions__WEBPACK_IMPORTED_MODULE_7__["ResetWorkspace"](vls[0], animation, hiddenLayerIds));
        }
        else {
            if (importType === ImportType.Svg) {
                ga('send', 'event', 'Import', 'SVG');
            }
            else if (importType === ImportType.VectorDrawable) {
                ga('send', 'event', 'Import', 'Vector Drawable');
            }
            if (resetWorkspace) {
                this.store.dispatch(new app_modules_editor_store_reset_actions__WEBPACK_IMPORTED_MODULE_7__["ResetWorkspace"]());
            }
            this.layerTimelineService.importLayers(vls);
            // TODO: count number of individual layers?
            this.snackBarService.show("Imported " + vls.length + " layer" + (vls.length === 1 ? '' : 's'), 'Dismiss', _snackbar_service__WEBPACK_IMPORTED_MODULE_11__["Duration"].Short);
        }
    };
    FileImportService.prototype.onFailure = function () {
        this.snackBarService.show("Couldn't import layers from file", 'Dismiss', _snackbar_service__WEBPACK_IMPORTED_MODULE_11__["Duration"].Long);
    };
    FileImportService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_5__["Store"],
            _snackbar_service__WEBPACK_IMPORTED_MODULE_11__["SnackBarService"],
            _layertimeline_service__WEBPACK_IMPORTED_MODULE_10__["LayerTimelineService"]])
    ], FileImportService);
    return FileImportService;
}());



/***/ }),

/***/ "./src/app/modules/editor/services/index.ts":
/*!**************************************************!*\
  !*** ./src/app/modules/editor/services/index.ts ***!
  \**************************************************/
/*! exports provided: ActionModeService, ClipboardService, FileExportService, FileImportService, LayerTimelineService, PlaybackService, SnackBarService, ShortcutService, ThemeService, PaperService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _actionmode_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actionmode.service */ "./src/app/modules/editor/services/actionmode.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ActionModeService", function() { return _actionmode_service__WEBPACK_IMPORTED_MODULE_0__["ActionModeService"]; });

/* harmony import */ var _clipboard_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clipboard.service */ "./src/app/modules/editor/services/clipboard.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClipboardService", function() { return _clipboard_service__WEBPACK_IMPORTED_MODULE_1__["ClipboardService"]; });

/* harmony import */ var _fileexport_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fileexport.service */ "./src/app/modules/editor/services/fileexport.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FileExportService", function() { return _fileexport_service__WEBPACK_IMPORTED_MODULE_2__["FileExportService"]; });

/* harmony import */ var _fileimport_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fileimport.service */ "./src/app/modules/editor/services/fileimport.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FileImportService", function() { return _fileimport_service__WEBPACK_IMPORTED_MODULE_3__["FileImportService"]; });

/* harmony import */ var _layertimeline_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layertimeline.service */ "./src/app/modules/editor/services/layertimeline.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayerTimelineService", function() { return _layertimeline_service__WEBPACK_IMPORTED_MODULE_4__["LayerTimelineService"]; });

/* harmony import */ var _playback_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./playback.service */ "./src/app/modules/editor/services/playback.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlaybackService", function() { return _playback_service__WEBPACK_IMPORTED_MODULE_5__["PlaybackService"]; });

/* harmony import */ var _snackbar_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./snackbar.service */ "./src/app/modules/editor/services/snackbar.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SnackBarService", function() { return _snackbar_service__WEBPACK_IMPORTED_MODULE_6__["SnackBarService"]; });

/* harmony import */ var _shortcut_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shortcut.service */ "./src/app/modules/editor/services/shortcut.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShortcutService", function() { return _shortcut_service__WEBPACK_IMPORTED_MODULE_7__["ShortcutService"]; });

/* harmony import */ var _theme_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./theme.service */ "./src/app/modules/editor/services/theme.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ThemeService", function() { return _theme_service__WEBPACK_IMPORTED_MODULE_8__["ThemeService"]; });

/* harmony import */ var _paper_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./paper.service */ "./src/app/modules/editor/services/paper.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PaperService", function() { return _paper_service__WEBPACK_IMPORTED_MODULE_9__["PaperService"]; });













/***/ }),

/***/ "./src/app/modules/editor/services/layertimeline.service.ts":
/*!******************************************************************!*\
  !*** ./src/app/modules/editor/services/layertimeline.service.ts ***!
  \******************************************************************/
/*! exports provided: LayerTimelineService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerTimelineService", function() { return LayerTimelineService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_interpolators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/interpolators */ "./src/app/modules/editor/model/interpolators/index.ts");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/model/timeline */ "./src/app/modules/editor/model/timeline/index.ts");
/* harmony import */ var app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/scripts/common */ "./src/app/modules/editor/scripts/common/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store/batch/actions */ "./src/app/modules/editor/store/batch/actions.ts");
/* harmony import */ var app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/modules/editor/store/layers/actions */ "./src/app/modules/editor/store/layers/actions.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/modules/editor/store/timeline/actions */ "./src/app/modules/editor/store/timeline/actions.ts");
/* harmony import */ var app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/modules/editor/store/timeline/selectors */ "./src/app/modules/editor/store/timeline/selectors.ts");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _StoreUtil__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./StoreUtil */ "./src/app/modules/editor/services/StoreUtil.ts");
















/**
 * A simple service that provides an interface for making layer/timeline changes.
 */
var LayerTimelineService = /** @class */ (function () {
    function LayerTimelineService(store) {
        this.store = store;
    }
    /**
     * Selects or deselects the animation.
     */
    LayerTimelineService.prototype.selectAnimation = function (isSelected) {
        this.updateSelections(isSelected, new Set(), new Set());
    };
    /**
     * Selects or deselects the specified block ID.
     */
    LayerTimelineService.prototype.selectBlock = function (blockId, clearExisting) {
        var selectedBlockIds = this.getSelectedBlockIds();
        if (clearExisting) {
            selectedBlockIds.forEach(function (id) {
                if (id !== blockId) {
                    selectedBlockIds.delete(id);
                }
            });
        }
        if (!clearExisting && selectedBlockIds.has(blockId)) {
            selectedBlockIds.delete(blockId);
        }
        else {
            selectedBlockIds.add(blockId);
        }
        this.updateSelections(false, selectedBlockIds, new Set());
    };
    /**
     * Selects or deselects the specified layer ID.
     */
    LayerTimelineService.prototype.selectLayer = function (layerId, clearExisting) {
        var selectedLayerIds = this.getSelectedLayerIds();
        if (clearExisting) {
            selectedLayerIds.forEach(function (id) {
                if (id !== layerId) {
                    selectedLayerIds.delete(id);
                }
            });
        }
        if (!clearExisting && selectedLayerIds.has(layerId)) {
            selectedLayerIds.delete(layerId);
        }
        else {
            selectedLayerIds.add(layerId);
        }
        this.updateSelections(false, new Set(), selectedLayerIds);
    };
    LayerTimelineService.prototype.setSelectedLayers = function (layerIds) {
        this.updateSelections(false, new Set(), new Set(layerIds));
    };
    /**
     * Clears all animation/block/layer selections.
     */
    LayerTimelineService.prototype.clearSelections = function () {
        var actions = this.getClearSelectionsActions();
        if (actions.length) {
            this.store.dispatch(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"], [void 0].concat(actions)))());
        }
    };
    LayerTimelineService.prototype.getClearSelectionsActions = function () {
        return this.getUpdateSelectionsActions(false, new Set(), new Set());
    };
    LayerTimelineService.prototype.updateSelections = function (isAnimSelected, selectedBlockIds, selectedLayerIds) {
        var actions = this.getUpdateSelectionsActions(isAnimSelected, selectedBlockIds, selectedLayerIds);
        if (actions.length) {
            this.store.dispatch(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"], [void 0].concat(actions)))());
        }
    };
    LayerTimelineService.prototype.getUpdateSelectionsActions = function (isAnimSelected, selectedBlockIds, selectedLayerIds) {
        var actions = [];
        if (this.isAnimationSelected() !== isAnimSelected) {
            actions.push(new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SelectAnimation"](isAnimSelected));
        }
        if (!lodash__WEBPACK_IMPORTED_MODULE_13__["isEqual"](this.getSelectedBlockIds(), selectedBlockIds)) {
            actions.push(new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SetSelectedBlocks"](selectedBlockIds));
        }
        if (!lodash__WEBPACK_IMPORTED_MODULE_13__["isEqual"](this.getSelectedLayerIds(), selectedLayerIds)) {
            actions.push(new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetSelectedLayers"](selectedLayerIds));
            // TODO: improve this design somehow (probably best not to have this service depend on paper ops?)
            // TODO: figure out which selection-changed cases should force you into default mode
            // TODO: i.e. should selecting a new layer in edit path mode trigger edit path mode for the new layer?
            if (environments_environment__WEBPACK_IMPORTED_MODULE_12__["environment"].beta) {
                actions.push.apply(actions, _StoreUtil__WEBPACK_IMPORTED_MODULE_15__["getEnterDefaultModeActions"]());
            }
        }
        return actions;
    };
    /**
     * Toggles the specified layer's expanded state.
     */
    LayerTimelineService.prototype.toggleExpandedLayer = function (layerId, recursive) {
        var layerIds = new Set([layerId]);
        if (recursive) {
            var layer = this.getVectorLayer().findLayerById(layerId);
            if (layer) {
                layer.walk(function (l) { return layerIds.add(l.id); });
            }
        }
        var collapsedLayerIds = this.getCollapsedLayerIds();
        if (collapsedLayerIds.has(layerId)) {
            layerIds.forEach(function (id) { return collapsedLayerIds.delete(id); });
        }
        else {
            layerIds.forEach(function (id) { return collapsedLayerIds.add(id); });
        }
        this.store.dispatch(new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetCollapsedLayers"](collapsedLayerIds));
    };
    /**
     * Toggles the specified layer's visibility.
     */
    LayerTimelineService.prototype.toggleVisibleLayer = function (layerId) {
        var layerIds = this.getHiddenLayerIds();
        if (layerIds.has(layerId)) {
            layerIds.delete(layerId);
        }
        else {
            layerIds.add(layerId);
        }
        this.store.dispatch(new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetHiddenLayers"](layerIds));
    };
    /**
     * Imports a list of vector layers into the workspace.
     */
    LayerTimelineService.prototype.importLayers = function (vls) {
        if (!vls.length) {
            return;
        }
        var importedVls = vls.slice();
        var vectorLayer = this.getVectorLayer();
        var vectorLayers = [vectorLayer];
        if (!vectorLayer.children.length) {
            // Simply replace the empty vector layer rather than merging with it.
            var vl = importedVls[0].clone();
            vl.name = vectorLayer.name;
            importedVls[0] = vl;
            vectorLayers = [];
        }
        var newVectorLayers = vectorLayers.concat(importedVls);
        var newVl = newVectorLayers.length === 1
            ? newVectorLayers[0]
            : newVectorLayers.reduce(app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].mergeVectorLayers);
        this.store.dispatch(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"], [void 0].concat(this.getClearSelectionsActions(), [new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetVectorLayer"](newVl)])))());
    };
    /**
     * Adds a layer to the vector tree.
     */
    LayerTimelineService.prototype.addLayer = function (layer) {
        var vl = this.getVectorLayer();
        var selectedLayers = this.getSelectedLayers();
        if (selectedLayers.length === 1) {
            var selectedLayer = selectedLayers[0];
            if (!(selectedLayer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["VectorLayer"])) {
                // Add the new layer as a sibling to the currently selected layer.
                var parent_1 = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].findParent(vl, selectedLayer.id).clone();
                parent_1.children = parent_1.children.concat([layer]);
                this.updateLayer(parent_1);
                return;
            }
        }
        var vectorLayer = vl.clone();
        vectorLayer.children = vectorLayer.children.concat([layer]);
        this.updateLayer(vectorLayer);
    };
    /**
     * Sets the current vector layer.
     */
    LayerTimelineService.prototype.setVectorLayer = function (vl) {
        this.store.dispatch(new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetVectorLayer"](vl));
    };
    /**
     * Updates an existing layer in the tree.
     */
    LayerTimelineService.prototype.updateLayer = function (layer) {
        this.store.dispatch(new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetVectorLayer"](app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].updateLayer(this.getVectorLayer(), layer)));
    };
    /**
     * Replaces an existing layer in the tree with a new layer. Note that
     * this method assumes that both layers still have the same children layers.
     */
    LayerTimelineService.prototype.swapLayers = function (layerId, newLayer) {
        if (layerId === newLayer.id) {
            this.updateLayer(newLayer);
            return;
        }
        var vl = this.getVectorLayer();
        var parent = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].findParent(vl, layerId).clone();
        var layerIndex = lodash__WEBPACK_IMPORTED_MODULE_13__["findIndex"](parent.children, function (l) { return l.id === layerId; });
        var children = parent.children.slice();
        children.splice(layerIndex, 1, newLayer);
        parent.children = children;
        var actions = [
            new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetVectorLayer"](app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].updateLayer(vl, parent))
        ].concat(this.buildCleanupLayerIdActions(layerId));
        var animation = this.getAnimation();
        var oldLayerBlocks = animation.blocks.filter(function (b) { return b.layerId === layerId; });
        var newAnimatableProperties = new Set(newLayer.animatableProperties.keys());
        // Preserve any blocks that are still animatable with the new layer.
        var newLayerBlocks = oldLayerBlocks
            .filter(function (b) { return newAnimatableProperties.has(b.propertyName); })
            .map(function (b) {
            b = b.clone();
            b.layerId = newLayer.id;
            return b;
        });
        var newAnimation = animation.clone();
        newAnimation.blocks = animation.blocks.filter(function (b) { return b.layerId !== layerId; }).concat(newLayerBlocks);
        actions.push(new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SetAnimation"](newAnimation));
        this.store.dispatch(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"], [void 0].concat(actions)))());
    };
    /**
     * Merges the specified group layer into its children layers.
     * TODO: make it possible to merge groups that contain animation blocks?
     */
    LayerTimelineService.prototype.flattenGroupLayer = function (layerId) {
        var vl = this.getVectorLayer();
        var layer = vl.findLayerById(layerId);
        if (!layer.children.length) {
            return;
        }
        var layerTransform = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_5__["Matrix"].flatten(app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformsForGroupLayer(layer));
        var layerChildren = layer.children.map(function (l) {
            if (l instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["GroupLayer"]) {
                var flattenedTransform = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_5__["Matrix"].flatten([
                    layerTransform
                ].concat(app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getCanvasTransformsForGroupLayer(l)));
                var _a = flattenedTransform.getScaling(), sx = _a.sx, sy = _a.sy;
                var degrees = flattenedTransform.getRotation();
                var _b = flattenedTransform.getTranslation(), tx = _b.tx, ty = _b.ty;
                l = l.clone();
                l.pivotX = 0;
                l.pivotY = 0;
                l.translateX = tx;
                l.translateY = ty;
                l.rotation = degrees;
                l.scaleX = sx;
                l.scaleY = sy;
                return l;
            }
            l = l.clone();
            if (l instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["PathLayer"] && l.strokeWidth) {
                var scaleFactor = layerTransform.getScaleFactor();
                var newStrokeWidth = l.strokeWidth * scaleFactor ? 1 / scaleFactor : 0;
                l.strokeWidth = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_5__["MathUtil"].round(newStrokeWidth);
            }
            var path = l.pathData;
            if (!path || !l.pathData.getPathString()) {
                return l;
            }
            l.pathData = path
                .mutate()
                .transform(layerTransform)
                .build();
            return l;
        });
        var layerChildrenIds = new Set(layerChildren.map(function (l) { return l.id; }));
        var parent = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].findParent(vl, layerId).clone();
        var children = parent.children.slice();
        children.splice.apply(children, [lodash__WEBPACK_IMPORTED_MODULE_13__["findIndex"](parent.children, function (l) { return l.id === layerId; }), 1].concat(layerChildren));
        parent.children = children;
        var actions = [
            new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetVectorLayer"](app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].updateLayer(vl, parent))
        ].concat(this.buildCleanupLayerIdActions(layerId));
        var newAnimation = this.getAnimation().clone();
        // TODO: show a dialog if the user is about to unknowingly delete any blocks?
        newAnimation.blocks = newAnimation.blocks.filter(function (b) { return b.layerId !== layerId; });
        // TODO: also attempt to merge children group animation blocks?
        newAnimation.blocks = newAnimation.blocks.map(function (b) {
            if (!(b instanceof app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_4__["PathAnimationBlock"]) || !layerChildrenIds.has(b.layerId)) {
                return b;
            }
            var block = b.clone();
            if (block.fromValue) {
                block.fromValue = block.fromValue
                    .mutate()
                    .transform(layerTransform)
                    .build();
            }
            if (block.toValue) {
                block.toValue = block.toValue
                    .mutate()
                    .transform(layerTransform)
                    .build();
            }
            return block;
        });
        actions.push(new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SetAnimation"](newAnimation));
        this.store.dispatch(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"], [void 0].concat(actions)))());
    };
    LayerTimelineService.prototype.buildCleanupLayerIdActions = function () {
        var deletedLayerIds = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            deletedLayerIds[_i] = arguments[_i];
        }
        var collapsedLayerIds = this.getCollapsedLayerIds();
        var hiddenLayerIds = this.getHiddenLayerIds();
        var selectedLayerIds = this.getSelectedLayerIds();
        var differenceFn = function (s, a) {
            return new Set(lodash__WEBPACK_IMPORTED_MODULE_13__["difference"](Array.from(s), a));
        };
        var actions = [];
        if (deletedLayerIds.some(function (id) { return collapsedLayerIds.has(id); })) {
            actions.push(new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetCollapsedLayers"](differenceFn(collapsedLayerIds, deletedLayerIds)));
        }
        if (deletedLayerIds.some(function (id) { return hiddenLayerIds.has(id); })) {
            actions.push(new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetHiddenLayers"](differenceFn(hiddenLayerIds, deletedLayerIds)));
        }
        if (deletedLayerIds.some(function (id) { return selectedLayerIds.has(id); })) {
            actions.push(new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetSelectedLayers"](differenceFn(selectedLayerIds, deletedLayerIds)));
        }
        return actions;
    };
    /**
     * Groups or ungroups the selected layers.
     */
    LayerTimelineService.prototype.groupOrUngroupSelectedLayers = function (shouldGroup) {
        var selectedLayerIds = this.getSelectedLayerIds();
        if (!selectedLayerIds.size) {
            return;
        }
        var vl = this.getVectorLayer();
        // Sort selected layers by order they appear in tree.
        var tempSelLayers = Array.from(selectedLayerIds).map(function (id) { return vl.findLayerById(id); });
        var selLayerOrdersMap = {};
        var n = 0;
        vl.walk(function (layer) {
            if (lodash__WEBPACK_IMPORTED_MODULE_13__["find"](tempSelLayers, function (l) { return l.id === layer.id; })) {
                selLayerOrdersMap[layer.id] = n;
                n++;
            }
        });
        tempSelLayers.sort(function (a, b) { return selLayerOrdersMap[a.id] - selLayerOrdersMap[b.id]; });
        if (shouldGroup) {
            // Remove any layers that are descendants of other selected layers,
            // and remove the vectorLayer itself if selected.
            tempSelLayers = tempSelLayers.filter(function (layer) {
                if (layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["VectorLayer"]) {
                    return false;
                }
                var p = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].findParent(vl, layer.id);
                while (p) {
                    if (lodash__WEBPACK_IMPORTED_MODULE_13__["find"](tempSelLayers, function (l) { return l.id === p.id; })) {
                        return false;
                    }
                    p = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].findParent(vl, p.id);
                }
                return true;
            });
            if (!tempSelLayers.length) {
                return;
            }
            // Find destination parent and insertion point.
            var firstSelectedLayerParent = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].findParent(vl, tempSelLayers[0].id).clone();
            var firstSelectedLayerIndexInParent = lodash__WEBPACK_IMPORTED_MODULE_13__["findIndex"](firstSelectedLayerParent.children, function (l) { return l.id === tempSelLayers[0].id; });
            // Remove all selected items from their parents and move them into a new parent.
            var newGroup = new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["GroupLayer"]({
                name: app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].getUniqueLayerName([vl], 'group'),
                children: tempSelLayers,
            });
            var parentChildren = firstSelectedLayerParent.children.slice();
            parentChildren.splice(firstSelectedLayerIndexInParent, 0, newGroup);
            lodash__WEBPACK_IMPORTED_MODULE_13__["remove"](parentChildren, function (child) {
                return lodash__WEBPACK_IMPORTED_MODULE_13__["find"](tempSelLayers, function (selectedLayer) { return selectedLayer.id === child.id; });
            });
            firstSelectedLayerParent.children = parentChildren;
            vl = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].updateLayer(vl, firstSelectedLayerParent);
            selectedLayerIds = new Set([newGroup.id]);
        }
        else {
            // Ungroup selected groups layers.
            var newSelectedLayers_1 = [];
            tempSelLayers.filter(function (layer) { return layer instanceof app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["GroupLayer"]; }).forEach(function (groupLayer) {
                // Move children into parent.
                var parent = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].findParent(vl, groupLayer.id).clone();
                var indexInParent = Math.max(0, lodash__WEBPACK_IMPORTED_MODULE_13__["findIndex"](parent.children, function (l) { return l.id === groupLayer.id; }));
                var newChildren = parent.children.slice();
                newChildren.splice.apply(newChildren, [indexInParent, 0].concat(groupLayer.children));
                parent.children = newChildren;
                vl = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].updateLayer(vl, parent);
                newSelectedLayers_1.splice.apply(newSelectedLayers_1, [0, 0].concat(groupLayer.children));
                // Delete the parent.
                vl = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].removeLayers(vl, groupLayer.id);
            });
            selectedLayerIds = new Set(newSelectedLayers_1.map(function (l) { return l.id; }));
        }
        this.store.dispatch(new app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"](new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetVectorLayer"](vl), new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetSelectedLayers"](selectedLayerIds)));
    };
    LayerTimelineService.prototype.deleteSelectedModels = function () {
        return this.store.dispatch(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"], [void 0].concat(this.getDeleteSelectedModelsActions())))());
    };
    LayerTimelineService.prototype.getDeleteSelectedModelsActions = function () {
        var collapsedLayerIds = this.getCollapsedLayerIds();
        var hiddenLayerIds = this.getHiddenLayerIds();
        var selectedLayerIds = this.getSelectedLayerIds();
        var vl = this.getVectorLayer();
        if (selectedLayerIds.has(vl.id)) {
            vl = new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["VectorLayer"]();
            collapsedLayerIds.clear();
            hiddenLayerIds.clear();
        }
        else {
            selectedLayerIds.forEach(function (layerId) {
                vl = app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_3__["LayerUtil"].removeLayers(vl, layerId);
                collapsedLayerIds.delete(layerId);
                hiddenLayerIds.delete(layerId);
            });
        }
        var animation = this.getAnimation();
        if (this.isAnimationSelected()) {
            animation = new app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_4__["Animation"]();
        }
        var selectedBlockIds = this.getSelectedBlockIds();
        if (selectedBlockIds.size) {
            animation = animation.clone();
            animation.blocks = animation.blocks.filter(function (b) { return !selectedBlockIds.has(b.id); });
        }
        // Remove any blocks corresponding to deleted layers.
        var filteredBlocks = animation.blocks.filter(function (b) { return !!vl.findLayerById(b.layerId); });
        if (filteredBlocks.length !== animation.blocks.length) {
            animation = animation.clone();
            animation.blocks = filteredBlocks;
        }
        return [
            new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetVectorLayer"](vl),
            new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetCollapsedLayers"](collapsedLayerIds),
            new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetHiddenLayers"](hiddenLayerIds),
            new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetSelectedLayers"](new Set()),
            new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SelectAnimation"](false),
            new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SetAnimation"](animation),
            new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SetSelectedBlocks"](new Set()),
        ];
    };
    LayerTimelineService.prototype.updateBlocks = function (blocks) {
        if (!blocks.length) {
            return;
        }
        var animation = this.getAnimation().clone();
        animation.blocks = animation.blocks.map(function (block) {
            var newBlock = lodash__WEBPACK_IMPORTED_MODULE_13__["find"](blocks, function (b) { return block.id === b.id; });
            return newBlock ? newBlock : block;
        });
        this.store.dispatch(new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SetAnimation"](animation));
    };
    LayerTimelineService.prototype.addBlocks = function (blocks, autoSelectBlocks) {
        if (autoSelectBlocks === void 0) { autoSelectBlocks = true; }
        blocks.forEach(function (b) {
            if (!b.id) {
                b.id = lodash__WEBPACK_IMPORTED_MODULE_13__["uniqueId"]();
            }
        });
        var animation = this.getAnimation();
        var addedBlocks = [];
        for (var _i = 0, blocks_1 = blocks; _i < blocks_1.length; _i++) {
            var block = blocks_1[_i];
            var anim = this.addBlockToAnimation(animation, block);
            if (animation !== anim) {
                animation = anim;
                addedBlocks.push(block);
            }
        }
        this.store.dispatch(new app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_7__["BatchAction"](new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SetAnimation"](animation), new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SelectAnimation"](false), new app_modules_editor_store_timeline_actions__WEBPACK_IMPORTED_MODULE_10__["SetSelectedBlocks"](new Set(addedBlocks.map(function (b) { return b.id; }))), new app_modules_editor_store_layers_actions__WEBPACK_IMPORTED_MODULE_8__["SetSelectedLayers"](new Set())));
    };
    LayerTimelineService.prototype.addBlockToAnimation = function (animation, block) {
        var layer = this.getVectorLayer().findLayerById(block.layerId);
        if (!layer) {
            return animation;
        }
        var newBlockDuration = block.duration || 100;
        var interpolator = block.interpolator || app_modules_editor_model_interpolators__WEBPACK_IMPORTED_MODULE_2__["INTERPOLATORS"][0].value;
        var propertyName = block.propertyName;
        var currentTime = block.currentTime;
        // Find the right start time for the block, which should be a gap between
        // neighboring blocks closest to the active time cursor, of a minimum size.
        var blocksByLayerId = app_modules_editor_scripts_common__WEBPACK_IMPORTED_MODULE_5__["ModelUtil"].getOrderedBlocksByPropertyByLayer(animation);
        var blockNeighbors = (blocksByLayerId[layer.id] || {})[propertyName] || [];
        var gaps = [];
        for (var i = 0; i < blockNeighbors.length; i++) {
            gaps.push({
                start: i === 0 ? 0 : blockNeighbors[i - 1].endTime,
                end: blockNeighbors[i].startTime,
            });
        }
        gaps.push({
            start: blockNeighbors.length ? blockNeighbors[blockNeighbors.length - 1].endTime : 0,
            end: animation.duration,
        });
        gaps = gaps
            .filter(function (gap) { return gap.end - gap.start >= newBlockDuration; })
            .map(function (gap) {
            var dist = Math.min(Math.abs(gap.end - currentTime), Math.abs(gap.start - currentTime));
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, gap, { dist: dist });
        })
            .sort(function (a, b) { return a.dist - b.dist; });
        if (!gaps.length) {
            // No available gaps, cancel.
            // TODO: show a disabled button to prevent this case?
            console.warn('Ignoring failed attempt to add animation block');
            return animation;
        }
        var startTime = Math.max(currentTime, gaps[0].start);
        var endTime = Math.min(startTime + newBlockDuration, gaps[0].end);
        if (endTime - startTime < newBlockDuration) {
            startTime = endTime - newBlockDuration;
        }
        // Generate the new block.
        var property = layer.animatableProperties.get(propertyName);
        var type;
        if (property.getTypeName() === 'PathProperty') {
            type = 'path';
        }
        else if (property.getTypeName() === 'ColorProperty') {
            type = 'color';
        }
        else {
            type = 'number';
        }
        // TODO: clone the current rendered property value and set the from/to values appropriately
        // const valueAtCurrentTime =
        //   this.studioState_.animationRenderer
        //     .getLayerPropertyValue(layer.id, propertyName);
        var newBlock = app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_4__["AnimationBlock"].from({
            id: block.id ? block.id : undefined,
            layerId: layer.id,
            propertyName: propertyName,
            startTime: startTime,
            endTime: endTime,
            fromValue: block.fromValue,
            toValue: block.toValue,
            interpolator: interpolator,
            type: type,
        });
        animation = animation.clone();
        animation.blocks = animation.blocks.concat([newBlock]);
        return animation;
    };
    LayerTimelineService.prototype.getVectorLayer = function () {
        return this.queryStore(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_9__["getVectorLayer"]);
    };
    LayerTimelineService.prototype.getSelectedLayerIds = function () {
        return new Set(this.queryStore(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_9__["getSelectedLayerIds"]));
    };
    LayerTimelineService.prototype.getSelectedLayers = function () {
        var vl = this.getVectorLayer();
        return Array.from(this.getSelectedLayerIds()).map(function (id) { return vl.findLayerById(id); });
    };
    LayerTimelineService.prototype.getHiddenLayerIds = function () {
        return new Set(this.queryStore(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_9__["getHiddenLayerIds"]));
    };
    LayerTimelineService.prototype.getCollapsedLayerIds = function () {
        return new Set(this.queryStore(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_9__["getCollapsedLayerIds"]));
    };
    LayerTimelineService.prototype.getSelectedBlockIds = function () {
        return new Set(this.queryStore(app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_11__["getSelectedBlockIds"]));
    };
    LayerTimelineService.prototype.getSelectedBlocks = function () {
        var anim = this.getAnimation();
        var blockIds = this.getSelectedBlockIds();
        return Array.from(blockIds).map(function (id) { return lodash__WEBPACK_IMPORTED_MODULE_13__["find"](anim.blocks, function (b) { return b.id === id; }); });
    };
    LayerTimelineService.prototype.getAnimation = function () {
        return this.queryStore(app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_11__["getAnimation"]);
    };
    LayerTimelineService.prototype.isAnimationSelected = function () {
        return this.queryStore(app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_11__["isAnimationSelected"]);
    };
    LayerTimelineService.prototype.queryStore = function (selector) {
        var obj;
        this.store
            .select(selector)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["first"])())
            .subscribe(function (o) { return (obj = o); });
        return obj;
    };
    LayerTimelineService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_6__["Store"]])
    ], LayerTimelineService);
    return LayerTimelineService;
}());



/***/ }),

/***/ "./src/app/modules/editor/services/paper.service.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/services/paper.service.ts ***!
  \**********************************************************/
/*! exports provided: PaperService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PaperService", function() { return PaperService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/store/batch/actions */ "./src/app/modules/editor/store/batch/actions.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store/paper/actions */ "./src/app/modules/editor/store/paper/actions.ts");
/* harmony import */ var app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store/paper/selectors */ "./src/app/modules/editor/store/paper/selectors.ts");
/* harmony import */ var app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/modules/editor/store/playback/selectors */ "./src/app/modules/editor/store/playback/selectors.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _layertimeline_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./layertimeline.service */ "./src/app/modules/editor/services/layertimeline.service.ts");












/** A simple service that provides an interface for making paper.js changes to the store. */
var PaperService = /** @class */ (function () {
    function PaperService(layerTimelineService, store, 
    // TODO: figure out if this is the most efficient use of NgZone...
    // TODO: can we get away with only executing in NgZone for certain dispatch store ops?
    ngZone) {
        this.layerTimelineService = layerTimelineService;
        this.store = store;
        this.ngZone = ngZone;
    }
    PaperService.prototype.observeToolPanelState = function () {
        return this.store.select(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getToolPanelState"]);
    };
    PaperService.prototype.enterDefaultMode = function () {
        this.setToolMode(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].Default);
        this.setEditPathInfo(undefined);
        this.setRotateItemsInfo(undefined);
        this.setTransformPathsInfo(undefined);
    };
    PaperService.prototype.enterEditPathMode = function () {
        this.setToolMode(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].Default);
        this.setEditPathInfo({
            selectedSegments: new Set(),
            visibleHandleIns: new Set(),
            visibleHandleOuts: new Set(),
            selectedHandleIn: undefined,
            selectedHandleOut: undefined,
        });
        this.setRotateItemsInfo(undefined);
        this.setTransformPathsInfo(undefined);
        this.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["CursorType"].PenAdd);
    };
    /** Exits edit path mode. */
    PaperService.prototype.exitEditPathMode = function () {
        this.dispatchStore(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_4__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_4__["BatchAction"], [void 0].concat(this.getExitEditPathModeActions())))());
    };
    /** Returns a list of actions that will exit edit path mode. */
    PaperService.prototype.getExitEditPathModeActions = function () {
        return [new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetEditPathInfo"](undefined)].concat(this.getClearEditPathModeStateActions());
    };
    /** Returns a list of actions that will clear any state associated with edit path mode. */
    PaperService.prototype.getClearEditPathModeStateActions = function () {
        return [
            new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetCreatePathInfo"](undefined),
            new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetSplitCurveInfo"](undefined),
            new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetSnapGuideInfo"](undefined),
            new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetCursorType"](app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["CursorType"].Default),
        ];
    };
    PaperService.prototype.enterRotateItemsMode = function () {
        this.setToolMode(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].Default);
        this.setEditPathInfo(undefined);
        this.setRotateItemsInfo({});
        this.setTransformPathsInfo(undefined);
    };
    PaperService.prototype.enterTransformPathsMode = function () {
        this.setToolMode(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].Default);
        this.setEditPathInfo(undefined);
        this.setRotateItemsInfo(undefined);
        this.setTransformPathsInfo({});
    };
    PaperService.prototype.enterPencilMode = function () {
        this.setToolMode(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].Pencil);
        this.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["CursorType"].Pencil);
    };
    PaperService.prototype.enterCreateRectangleMode = function () {
        this.setToolMode(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].Rectangle);
        this.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["CursorType"].Crosshair);
    };
    PaperService.prototype.enterCreateEllipseMode = function () {
        this.setToolMode(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["ToolMode"].Ellipse);
        this.setCursorType(app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_2__["CursorType"].Crosshair);
    };
    PaperService.prototype.setVectorLayer = function (vl) {
        var _this = this;
        // TODO: avoid running in angular zone whenever possible?
        this.ngZone.run(function () { return _this.layerTimelineService.setVectorLayer(vl); });
    };
    PaperService.prototype.getVectorLayer = function () {
        // TODO: return the non-animated vector layer here (using layer timeline service) instead?
        return this.queryStore(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_8__["getAnimatedVectorLayer"]).vl;
    };
    PaperService.prototype.setSelectedLayerIds = function (layerIds) {
        var _this = this;
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_5__["getSelectedLayerIds"]), layerIds)) {
            this.ngZone.run(function () { return _this.layerTimelineService.setSelectedLayers(layerIds); });
        }
    };
    PaperService.prototype.getSelectedLayerIds = function () {
        return this.queryStore(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_5__["getSelectedLayerIds"]);
    };
    PaperService.prototype.setHoveredLayerId = function (layerId) {
        var _this = this;
        if (this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getHoveredLayerId"]) !== layerId) {
            this.ngZone.run(function () { return _this.store.dispatch(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetHoveredLayerId"](layerId)); });
        }
    };
    PaperService.prototype.getHoveredLayerId = function () {
        return this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getHoveredLayerId"]);
    };
    PaperService.prototype.getHiddenLayerIds = function () {
        return this.queryStore(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_5__["getHiddenLayerIds"]);
    };
    PaperService.prototype.setSelectionBox = function (box) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getSelectionBox"]), box)) {
            // TODO: run this outside angular zone instead?
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetSelectionBox"](box));
        }
    };
    PaperService.prototype.getSelectionBox = function () {
        return this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getSelectionBox"]);
    };
    PaperService.prototype.setCreatePathInfo = function (info) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getCreatePathInfo"]), info)) {
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetCreatePathInfo"](info));
        }
    };
    PaperService.prototype.getCreatePathInfo = function () {
        return this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getCreatePathInfo"]);
    };
    PaperService.prototype.setSplitCurveInfo = function (info) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getSplitCurveInfo"]), info)) {
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetSplitCurveInfo"](info));
        }
    };
    PaperService.prototype.setToolMode = function (toolMode) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getToolMode"]), toolMode)) {
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetToolMode"](toolMode));
        }
    };
    PaperService.prototype.getToolMode = function () {
        return this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getToolMode"]);
    };
    PaperService.prototype.setEditPathInfo = function (info) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getEditPathInfo"]), info)) {
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetEditPathInfo"](info));
        }
    };
    PaperService.prototype.getEditPathInfo = function () {
        return this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getEditPathInfo"]);
    };
    PaperService.prototype.setRotateItemsInfo = function (info) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getRotateItemsInfo"]), info)) {
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetRotateItemsInfo"](info));
        }
    };
    PaperService.prototype.getRotateItemsInfo = function () {
        return this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getRotateItemsInfo"]);
    };
    PaperService.prototype.setTransformPathsInfo = function (info) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getTransformPathsInfo"]), info)) {
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetTransformPathsInfo"](info));
        }
    };
    PaperService.prototype.getTransformPathsInfo = function () {
        return this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getTransformPathsInfo"]);
    };
    PaperService.prototype.setCursorType = function (cursorType) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getCursorType"]), cursorType)) {
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetCursorType"](cursorType));
        }
    };
    PaperService.prototype.setSnapGuideInfo = function (info) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getSnapGuideInfo"]), info)) {
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetSnapGuideInfo"](info));
        }
    };
    PaperService.prototype.setZoomPanInfo = function (info) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getZoomPanInfo"]), info)) {
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetZoomPanInfo"](info));
        }
    };
    PaperService.prototype.setTooltipInfo = function (info) {
        if (!lodash__WEBPACK_IMPORTED_MODULE_9__["isEqual"](this.queryStore(app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_7__["getTooltipInfo"]), info)) {
            this.dispatchStore(new app_modules_editor_store_paper_actions__WEBPACK_IMPORTED_MODULE_6__["SetTooltipInfo"](info));
        }
    };
    PaperService.prototype.deleteSelectedModels = function () {
        if (this.getRotateItemsInfo() || this.getTransformPathsInfo()) {
            // Do not delete layers when in rotate items or transform paths mode.
            return;
        }
        this.layerTimelineService.deleteSelectedModels();
    };
    PaperService.prototype.getDeleteSelectedModelsActions = function () {
        return this.layerTimelineService.getDeleteSelectedModelsActions();
    };
    PaperService.prototype.dispatchStore = function (action) {
        var _this = this;
        if (_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"].isInAngularZone()) {
            this.store.dispatch(action);
        }
        else {
            // PaperService methods are usually executed outside of the Angular zone
            // (since they originate from event handlers registered by paper.js). In
            // order to ensure change detection works properly, we need to force
            // state changes to be executed inside the Angular zone.
            this.ngZone.run(function () { return _this.store.dispatch(action); });
        }
    };
    PaperService.prototype.queryStore = function (selector) {
        var obj;
        this.store
            .select(selector)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["first"])())
            .subscribe(function (o) { return (obj = o); });
        return obj;
    };
    PaperService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_layertimeline_service__WEBPACK_IMPORTED_MODULE_11__["LayerTimelineService"],
            app_modules_editor_store__WEBPACK_IMPORTED_MODULE_3__["Store"],
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
    ], PaperService);
    return PaperService;
}());



/***/ }),

/***/ "./src/app/modules/editor/services/playback.service.ts":
/*!*************************************************************!*\
  !*** ./src/app/modules/editor/services/playback.service.ts ***!
  \*************************************************************/
/*! exports provided: PlaybackService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaybackService", function() { return PlaybackService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/store/batch/actions */ "./src/app/modules/editor/store/batch/actions.ts");
/* harmony import */ var app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/store/playback/actions */ "./src/app/modules/editor/store/playback/actions.ts");
/* harmony import */ var app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/store/playback/selectors */ "./src/app/modules/editor/store/playback/selectors.ts");
/* harmony import */ var app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store/timeline/selectors */ "./src/app/modules/editor/store/timeline/selectors.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");









/** A simple service that provides an interface for making playback changes. */
var PlaybackService = /** @class */ (function () {
    // TODO: set current time to 0 when animation/vector layer changes (like before)?
    // TODO: reset time (or any other special handling) during workspace resets?
    function PlaybackService(store, ngZone) {
        var _this = this;
        this.store = store;
        this.animator = new Animator(ngZone, {
            onAnimationStart: function () {
                _this.setIsPlaying(true);
            },
            onAnimationUpdate: function (currentTime) {
                currentTime = Math.round(currentTime);
                _this.store.dispatch(new app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_4__["SetCurrentTime"](currentTime));
            },
            onAnimationEnd: function () {
                _this.setIsPlaying(false);
            },
        });
        this.store.select(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getIsPlaying"]).subscribe(function (isPlaying) {
            if (isPlaying) {
                var duration = _this.queryStore(app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_6__["getAnimation"]).duration;
                var currentTime = _this.getCurrentTime();
                var startTime = duration === _this.getCurrentTime() ? 0 : currentTime;
                _this.animator.play(duration, startTime);
            }
            else {
                _this.animator.pause();
            }
        });
        this.store.select(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getIsSlowMotion"]).subscribe(function (isSlowMotion) {
            _this.animator.setIsSlowMotion(isSlowMotion);
        });
        this.store.select(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getIsRepeating"]).subscribe(function (isRepeating) {
            _this.animator.setIsRepeating(isRepeating);
        });
    }
    PlaybackService.prototype.asObservable = function () {
        return this.store.select(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getAnimatedVectorLayer"]);
    };
    PlaybackService.prototype.getCurrentTime = function () {
        return this.queryStore(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getCurrentTime"]);
    };
    PlaybackService.prototype.setCurrentTime = function (currentTime) {
        currentTime = Math.round(currentTime);
        if (this.queryStore(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getCurrentTime"]) !== currentTime) {
            this.store.dispatch(new app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_4__["SetCurrentTime"](currentTime));
        }
    };
    // TODO: make it so rewind navigates to the start of the currently active block?
    PlaybackService.prototype.rewind = function () {
        var actions = [];
        if (this.getCurrentTime() !== 0) {
            actions.push(new app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_4__["SetCurrentTime"](0));
        }
        if (this.queryStore(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getIsPlaying"])) {
            actions.push(new app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_4__["SetIsPlaying"](false));
        }
        if (actions.length) {
            this.store.dispatch(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_3__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_3__["BatchAction"], [void 0].concat(actions)))());
        }
    };
    // TODO: make it so fast forward navigates to the end of the currently active block?
    PlaybackService.prototype.fastForward = function () {
        var actions = [];
        var duration = this.queryStore(app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_6__["getAnimation"]).duration;
        if (this.getCurrentTime() !== duration) {
            actions.push(new app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_4__["SetCurrentTime"](duration));
        }
        if (this.queryStore(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getIsPlaying"])) {
            actions.push(new app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_4__["SetIsPlaying"](false));
        }
        if (actions.length) {
            this.store.dispatch(new (app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_3__["BatchAction"].bind.apply(app_modules_editor_store_batch_actions__WEBPACK_IMPORTED_MODULE_3__["BatchAction"], [void 0].concat(actions)))());
        }
    };
    PlaybackService.prototype.toggleIsSlowMotion = function () {
        this.store.dispatch(new app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_4__["SetIsSlowMotion"](!this.queryStore(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getIsSlowMotion"])));
    };
    PlaybackService.prototype.toggleIsRepeating = function () {
        this.store.dispatch(new app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_4__["SetIsRepeating"](!this.queryStore(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getIsRepeating"])));
    };
    PlaybackService.prototype.toggleIsPlaying = function () {
        this.setIsPlaying(!this.queryStore(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getIsPlaying"]));
    };
    PlaybackService.prototype.setIsPlaying = function (isPlaying) {
        if (isPlaying !== this.queryStore(app_modules_editor_store_playback_selectors__WEBPACK_IMPORTED_MODULE_5__["getIsPlaying"])) {
            this.store.dispatch(new app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_4__["SetIsPlaying"](isPlaying));
        }
    };
    PlaybackService.prototype.queryStore = function (selector) {
        var obj;
        this.store
            .select(selector)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["first"])())
            .subscribe(function (o) { return (obj = o); });
        return obj;
    };
    PlaybackService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_2__["Store"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
    ], PlaybackService);
    return PlaybackService;
}());

var REPEAT_DELAY = 750;
var DEFAULT_PLAYBACK_SPEED = 1;
var SLOW_MOTION_PLAYBACK_SPEED = 5;
/** A simple class that simulates an animation loop. */
var Animator = /** @class */ (function () {
    function Animator(ngZone, callback) {
        this.ngZone = ngZone;
        this.callback = callback;
        this.playbackSpeed = DEFAULT_PLAYBACK_SPEED;
        this.isRepeating = false;
    }
    Animator.prototype.setIsRepeating = function (isRepeating) {
        this.isRepeating = isRepeating;
    };
    Animator.prototype.setIsSlowMotion = function (isSlowMotion) {
        // TODO: make it possible to change this mid-animation?
        this.playbackSpeed = isSlowMotion ? SLOW_MOTION_PLAYBACK_SPEED : DEFAULT_PLAYBACK_SPEED;
    };
    Animator.prototype.play = function (duration, startTime) {
        var _this = this;
        this.runOutsideAngular(function () { return _this.startAnimation(duration, startTime); });
        this.runInsideAngular(function () { return _this.callback.onAnimationStart(); });
    };
    Animator.prototype.startAnimation = function (duration, startTime) {
        var _this = this;
        var startTimestamp;
        var playbackSpeed = this.playbackSpeed;
        var onAnimationFrameFn = function (timestamp) {
            if (!startTimestamp) {
                startTimestamp = timestamp;
            }
            var progress = timestamp - startTimestamp + startTime;
            if (progress < duration * playbackSpeed) {
                _this.animationFrameId = window.requestAnimationFrame(onAnimationFrameFn);
            }
            else if (_this.isRepeating) {
                _this.timeoutId = window.setTimeout(function () { return _this.startAnimation(duration, startTime); }, REPEAT_DELAY);
            }
            else {
                _this.pause(true);
            }
            var fraction = lodash__WEBPACK_IMPORTED_MODULE_7__["clamp"](progress / (duration * playbackSpeed), 0, 1);
            var executeFn = function () { return _this.callback.onAnimationUpdate(fraction * duration); };
            if (fraction === 0 || fraction === 1) {
                _this.runInsideAngular(executeFn);
            }
            else {
                executeFn();
            }
        };
        this.animationFrameId = window.requestAnimationFrame(onAnimationFrameFn);
    };
    Animator.prototype.pause = function (shouldNotify) {
        var _this = this;
        if (shouldNotify === void 0) { shouldNotify = false; }
        if (this.timeoutId) {
            window.clearTimeout(this.timeoutId);
            this.timeoutId = undefined;
        }
        if (this.animationFrameId) {
            window.cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = undefined;
        }
        if (shouldNotify) {
            this.runInsideAngular(function () { return _this.callback.onAnimationEnd(); });
        }
    };
    Animator.prototype.rewind = function () {
        this.pause();
    };
    Animator.prototype.fastForward = function () {
        this.pause();
    };
    Animator.prototype.runInsideAngular = function (fn) {
        if (_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"].isInAngularZone()) {
            fn();
        }
        else {
            this.ngZone.run(fn);
        }
    };
    Animator.prototype.runOutsideAngular = function (fn) {
        if (_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"].isInAngularZone()) {
            this.ngZone.runOutsideAngular(fn);
        }
        else {
            fn();
        }
    };
    return Animator;
}());


/***/ }),

/***/ "./src/app/modules/editor/services/shortcut.service.ts":
/*!*************************************************************!*\
  !*** ./src/app/modules/editor/services/shortcut.service.ts ***!
  \*************************************************************/
/*! exports provided: Shortcut, ShortcutService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shortcut", function() { return Shortcut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortcutService", function() { return ShortcutService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var redux_undo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! redux-undo */ "./node_modules/redux-undo/lib/index.js");
/* harmony import */ var redux_undo__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(redux_undo__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var _actionmode_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./actionmode.service */ "./src/app/modules/editor/services/actionmode.service.ts");
/* harmony import */ var _layertimeline_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./layertimeline.service */ "./src/app/modules/editor/services/layertimeline.service.ts");
/* harmony import */ var _playback_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./playback.service */ "./src/app/modules/editor/services/playback.service.ts");










var Shortcut;
(function (Shortcut) {
    Shortcut[Shortcut["ZoomToFit"] = 1] = "ZoomToFit";
})(Shortcut || (Shortcut = {}));
var ShortcutService = /** @class */ (function () {
    function ShortcutService(store, actionModeService, playbackService, layerTimelineService) {
        this.store = store;
        this.actionModeService = actionModeService;
        this.playbackService = playbackService;
        this.layerTimelineService = layerTimelineService;
        this.isInit = false;
        this.shortcutSubject = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
    }
    ShortcutService_1 = ShortcutService;
    /** Returns true if the event is a modifier key (meta for Macs, ctrl for others). */
    ShortcutService.isOsDependentModifierKey = function (event) {
        return !!(ShortcutService_1.isMac() ? !!event.metaKey : !!event.ctrlKey);
    };
    ShortcutService.isMac = function () {
        return navigator.appVersion.includes('Mac');
    };
    ShortcutService.prototype.asObservable = function () {
        return this.shortcutSubject.asObservable();
    };
    ShortcutService.prototype.init = function () {
        var _this = this;
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        jquery__WEBPACK_IMPORTED_MODULE_4__(window).on('keydown', function (event) {
            if (ShortcutService_1.isOsDependentModifierKey(event)) {
                if (event.keyCode === 'Z'.charCodeAt(0)) {
                    _this.store.dispatch(event.shiftKey ? redux_undo__WEBPACK_IMPORTED_MODULE_5__["ActionCreators"].redo() : redux_undo__WEBPACK_IMPORTED_MODULE_5__["ActionCreators"].undo());
                    return false;
                }
                if (event.keyCode === 'G'.charCodeAt(0)) {
                    _this.layerTimelineService.groupOrUngroupSelectedLayers(!event.shiftKey);
                    return false;
                }
                if (event.keyCode === 'O'.charCodeAt(0)) {
                    _this.shortcutSubject.next(Shortcut.ZoomToFit);
                    return false;
                }
            }
            if (event.ctrlKey || event.metaKey) {
                // Do nothing if the ctrl or meta keys are pressed.
                return undefined;
            }
            if (document.activeElement.matches('input')) {
                // Ignore shortcuts when an input element has focus.
                return true;
            }
            if (event.keyCode === 8 || event.keyCode === 46) {
                // Backspace or delete.
                var isActionMode = _this.actionModeService.isActionMode();
                // If we aren't in beta or it is action mode, handle the backspace/delete
                // event here. Otherwise we will handle it in the gesture tool (which is
                // where we will likely want to move all of the shortcut logic in the future).
                if (!environments_environment__WEBPACK_IMPORTED_MODULE_3__["environment"].beta || isActionMode) {
                    // In case there's a JS error, never navigate away.
                    event.preventDefault();
                    if (isActionMode) {
                        _this.actionModeService.deleteSelectedActionModeModels();
                    }
                    else {
                        _this.layerTimelineService.deleteSelectedModels();
                    }
                    return false;
                }
            }
            if (event.keyCode === 27) {
                // Escape.
                _this.actionModeService.closeActionMode();
                return false;
            }
            // TODO: figure out how to re-enable this keyboard shortcut in beta
            if (!environments_environment__WEBPACK_IMPORTED_MODULE_3__["environment"].beta && event.keyCode === 32) {
                // Spacebar.
                _this.playbackService.toggleIsPlaying();
                return false;
            }
            if (event.keyCode === 37) {
                // Left arrow.
                _this.playbackService.rewind();
                return false;
            }
            if (event.keyCode === 39) {
                // Right arrow.
                _this.playbackService.fastForward();
                return false;
            }
            if (event.keyCode === 'R'.charCodeAt(0)) {
                if (_this.actionModeService.isShowingSubPathActionMode()) {
                    _this.actionModeService.reverseSelectedSubPaths();
                }
                else {
                    _this.playbackService.toggleIsRepeating();
                }
                return false;
            }
            if (event.keyCode === 'S'.charCodeAt(0)) {
                if (_this.actionModeService.isShowingSubPathActionMode() ||
                    _this.actionModeService.isShowingSegmentActionMode()) {
                    _this.actionModeService.toggleSplitSubPathsMode();
                }
                else {
                    _this.playbackService.toggleIsSlowMotion();
                }
                return false;
            }
            if (event.keyCode === 'A'.charCodeAt(0)) {
                if (_this.actionModeService.isShowingSubPathActionMode() ||
                    _this.actionModeService.isShowingSegmentActionMode()) {
                    _this.actionModeService.toggleSplitCommandsMode();
                }
                else if (_this.actionModeService.isShowingPointActionMode()) {
                    _this.actionModeService.splitSelectedPointInHalf();
                }
                return false;
            }
            if (event.keyCode === 'D'.charCodeAt(0)) {
                if (_this.actionModeService.isShowingSubPathActionMode() ||
                    _this.actionModeService.isShowingSegmentActionMode()) {
                    _this.actionModeService.togglePairSubPathsMode();
                }
                return false;
            }
            if (event.keyCode === 'B'.charCodeAt(0)) {
                if (_this.actionModeService.isShowingSubPathActionMode()) {
                    _this.actionModeService.shiftBackSelectedSubPaths();
                }
                return false;
            }
            if (event.keyCode === 'F'.charCodeAt(0)) {
                if (_this.actionModeService.isShowingSubPathActionMode()) {
                    _this.actionModeService.shiftForwardSelectedSubPaths();
                }
                else if (_this.actionModeService.isShowingPointActionMode()) {
                    _this.actionModeService.shiftPointToFront();
                }
                return false;
            }
            return undefined;
        });
    };
    ShortcutService.prototype.destroy = function () {
        if (!this.isInit) {
            return;
        }
        this.isInit = false;
        jquery__WEBPACK_IMPORTED_MODULE_4__(window).unbind('keydown');
    };
    ShortcutService.prototype.getZoomToFitText = function () {
        return this.getCmdOrCtrlText() + " + O";
    };
    ShortcutService.prototype.getCmdOrCtrlText = function () {
        return ShortcutService_1.isMac() ? 'Cmd' : 'Ctrl';
    };
    var ShortcutService_1;
    ShortcutService = ShortcutService_1 = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_2__["Store"],
            _actionmode_service__WEBPACK_IMPORTED_MODULE_7__["ActionModeService"],
            _playback_service__WEBPACK_IMPORTED_MODULE_9__["PlaybackService"],
            _layertimeline_service__WEBPACK_IMPORTED_MODULE_8__["LayerTimelineService"]])
    ], ShortcutService);
    return ShortcutService;
}());



/***/ }),

/***/ "./src/app/modules/editor/services/snackbar.service.ts":
/*!*************************************************************!*\
  !*** ./src/app/modules/editor/services/snackbar.service.ts ***!
  \*************************************************************/
/*! exports provided: Duration, SnackBarService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Duration", function() { return Duration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SnackBarService", function() { return SnackBarService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");



var Duration;
(function (Duration) {
    Duration[Duration["Short"] = 2750] = "Short";
    Duration[Duration["Long"] = 5000] = "Long";
})(Duration || (Duration = {}));
var SnackBarService = /** @class */ (function () {
    function SnackBarService(snackBar) {
        this.snackBar = snackBar;
    }
    SnackBarService.prototype.show = function (message, action, duration) {
        if (action === void 0) { action = ''; }
        if (duration === void 0) { duration = Duration.Short; }
        this.snackBar.open(message, action.toUpperCase(), { duration: duration });
    };
    SnackBarService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_material__WEBPACK_IMPORTED_MODULE_2__["MatSnackBar"]])
    ], SnackBarService);
    return SnackBarService;
}());



/***/ }),

/***/ "./src/app/modules/editor/services/theme.service.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/services/theme.service.ts ***!
  \**********************************************************/
/*! exports provided: ThemeService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemeService", function() { return ThemeService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var app_modules_editor_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/store */ "./src/app/modules/editor/store/index.ts");
/* harmony import */ var app_modules_editor_store_theme_actions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/store/theme/actions */ "./src/app/modules/editor/store/theme/actions.ts");
/* harmony import */ var app_modules_editor_store_theme_selectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/store/theme/selectors */ "./src/app/modules/editor/store/theme/selectors.ts");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");






// TODO: change the animation block green color
var LIGHT_PRIMARY_TEXT = 'rgba(0, 0, 0, 0.87)';
var DARK_PRIMARY_TEXT = 'rgba(255, 255, 255, 1)';
var LIGHT_SECONDARY_TEXT = 'rgba(0, 0, 0, 0.54)';
var DARK_SECONDARY_TEXT = 'rgba(255, 255, 255, 0.7)';
var LIGHT_DISABLED_TEXT = 'rgba(0, 0, 0, 0.26)';
var DARK_DISABLED_TEXT = 'rgba(255, 255, 255, 0.3)';
var LIGHT_DIVIDER_TEXT = 'rgba(0, 0, 0, 0.12)';
var DARK_DIVIDER_TEXT = 'rgba(255, 255, 255, 0.12)';
/**
 * A simple service that provides an interface for making theme changes.
 */
var ThemeService = /** @class */ (function () {
    function ThemeService(store) {
        this.store = store;
    }
    ThemeService.prototype.setTheme = function (themeType) {
        this.store.dispatch(new app_modules_editor_store_theme_actions__WEBPACK_IMPORTED_MODULE_3__["SetTheme"](themeType));
    };
    ThemeService.prototype.toggleTheme = function () {
        this.setTheme(this.getThemeType().themeType === 'dark' ? 'light' : 'dark');
    };
    ThemeService.prototype.getThemeType = function () {
        var result;
        this.asObservable()
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])())
            .subscribe(function (res) { return (result = res); });
        return result;
    };
    ThemeService.prototype.asObservable = function () {
        return this.store.select(app_modules_editor_store_theme_selectors__WEBPACK_IMPORTED_MODULE_4__["getThemeType"]);
    };
    ThemeService.prototype.getPrimaryTextColor = function () {
        return this.getThemeType().themeType === 'dark' ? DARK_PRIMARY_TEXT : LIGHT_PRIMARY_TEXT;
    };
    ThemeService.prototype.getSecondaryTextColor = function () {
        return this.getThemeType().themeType === 'dark' ? DARK_SECONDARY_TEXT : LIGHT_SECONDARY_TEXT;
    };
    ThemeService.prototype.getDisabledTextColor = function () {
        return this.getThemeType().themeType === 'dark' ? DARK_DISABLED_TEXT : LIGHT_DISABLED_TEXT;
    };
    ThemeService.prototype.getDividerTextColor = function () {
        return this.getThemeType().themeType === 'dark' ? DARK_DIVIDER_TEXT : LIGHT_DIVIDER_TEXT;
    };
    ThemeService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [app_modules_editor_store__WEBPACK_IMPORTED_MODULE_2__["Store"]])
    ], ThemeService);
    return ThemeService;
}());



/***/ }),

/***/ "./src/app/modules/editor/store/actionmode/actions.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/store/actionmode/actions.ts ***!
  \************************************************************/
/*! exports provided: ActionModeActionTypes, SetActionMode, SetActionModeHover, SetActionModeSelections, SetPairedSubPaths, SetUnpairedSubPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActionModeActionTypes", function() { return ActionModeActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetActionMode", function() { return SetActionMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetActionModeHover", function() { return SetActionModeHover; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetActionModeSelections", function() { return SetActionModeSelections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetPairedSubPaths", function() { return SetPairedSubPaths; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetUnpairedSubPath", function() { return SetUnpairedSubPath; });
var ActionModeActionTypes;
(function (ActionModeActionTypes) {
    ActionModeActionTypes["SetActionMode"] = "__actionmode__SET_ACTION_MODE";
    ActionModeActionTypes["SetActionModeHover"] = "__actionmode__SET_ACTION_MODE_HOVER";
    ActionModeActionTypes["SetActionModeSelections"] = "__actionmode__SET_ACTION_MODE_SELECTIONS";
    ActionModeActionTypes["SetPairedSubPaths"] = "__actionmode__SET_PAIRED_SUBPATHS";
    ActionModeActionTypes["SetUnpairedSubPath"] = "__actionmode__SET_UNPAIRED_SUBPATH";
})(ActionModeActionTypes || (ActionModeActionTypes = {}));
var SetActionMode = /** @class */ (function () {
    function SetActionMode(mode) {
        this.type = ActionModeActionTypes.SetActionMode;
        this.payload = { mode: mode };
    }
    return SetActionMode;
}());

var SetActionModeHover = /** @class */ (function () {
    function SetActionModeHover(hover) {
        this.type = ActionModeActionTypes.SetActionModeHover;
        this.payload = { hover: hover };
    }
    return SetActionModeHover;
}());

var SetActionModeSelections = /** @class */ (function () {
    function SetActionModeSelections(selections) {
        this.type = ActionModeActionTypes.SetActionModeSelections;
        this.payload = { selections: selections };
    }
    return SetActionModeSelections;
}());

var SetPairedSubPaths = /** @class */ (function () {
    function SetPairedSubPaths(pairedSubPaths) {
        this.type = ActionModeActionTypes.SetPairedSubPaths;
        this.payload = { pairedSubPaths: pairedSubPaths };
    }
    return SetPairedSubPaths;
}());

var SetUnpairedSubPath = /** @class */ (function () {
    function SetUnpairedSubPath(unpairedSubPath) {
        this.type = ActionModeActionTypes.SetUnpairedSubPath;
        this.payload = { unpairedSubPath: unpairedSubPath };
    }
    return SetUnpairedSubPath;
}());



/***/ }),

/***/ "./src/app/modules/editor/store/actionmode/reducer.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/store/actionmode/reducer.ts ***!
  \************************************************************/
/*! exports provided: buildInitialState, reducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildInitialState", function() { return buildInitialState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reducer", function() { return reducer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions */ "./src/app/modules/editor/store/actionmode/actions.ts");



function buildInitialState() {
    return {
        mode: app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["ActionMode"].None,
        hover: undefined,
        selections: [],
        pairedSubPaths: new Set(),
        unpairedSubPath: undefined,
    };
}
// TODO: move as much logic as possible from here into action mode service
function reducer(state, action) {
    if (state === void 0) { state = buildInitialState(); }
    switch (action.type) {
        // Set the app mode during action mode.
        case _actions__WEBPACK_IMPORTED_MODULE_2__["ActionModeActionTypes"].SetActionMode: {
            var mode = action.payload.mode;
            if (mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["ActionMode"].None) {
                return buildInitialState();
            }
            var selections = state.selections, pairedSubPaths = state.pairedSubPaths, unpairedSubPath = state.unpairedSubPath;
            if (state.mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["ActionMode"].PairSubPaths && mode !== state.mode) {
                // Reset the paired subpath state when leaving pair subpath mode.
                pairedSubPaths = new Set();
                unpairedSubPath = undefined;
            }
            if (mode === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["ActionMode"].Selection && mode !== state.mode) {
                // Clear selections when switching back to selection mode.
                selections = [];
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { mode: mode, selections: selections, pairedSubPaths: pairedSubPaths, unpairedSubPath: unpairedSubPath });
        }
        // Set the hover mode during action mode.
        case _actions__WEBPACK_IMPORTED_MODULE_2__["ActionModeActionTypes"].SetActionModeHover: {
            var hover = action.payload.hover;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { hover: hover });
        }
        // Set the path selections during action mode.
        case _actions__WEBPACK_IMPORTED_MODULE_2__["ActionModeActionTypes"].SetActionModeSelections: {
            var selections = action.payload.selections;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { selections: selections });
        }
        // Set the currently paired subpaths.
        case _actions__WEBPACK_IMPORTED_MODULE_2__["ActionModeActionTypes"].SetPairedSubPaths: {
            var pairedSubPaths = new Set(action.payload.pairedSubPaths);
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { pairedSubPaths: pairedSubPaths });
        }
        // Set the currently unpaired subpath in pair subpaths mode.
        case _actions__WEBPACK_IMPORTED_MODULE_2__["ActionModeActionTypes"].SetUnpairedSubPath: {
            var unpairedSubPath = action.payload.unpairedSubPath;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { unpairedSubPath: unpairedSubPath });
        }
    }
    return state;
}


/***/ }),

/***/ "./src/app/modules/editor/store/actionmode/selectors.ts":
/*!**************************************************************!*\
  !*** ./src/app/modules/editor/store/actionmode/selectors.ts ***!
  \**************************************************************/
/*! exports provided: getActionMode, isActionMode, getActionModeHover, getActionModeSelections, getActionModeSubPathSelections, getActionModeSegmentSelections, getActionModePointSelections, getPairedSubPaths, getUnpairedSubPath, getActionModeStartState, getActionModeEndState, getToolbarState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActionMode", function() { return getActionMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isActionMode", function() { return isActionMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActionModeHover", function() { return getActionModeHover; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActionModeSelections", function() { return getActionModeSelections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActionModeSubPathSelections", function() { return getActionModeSubPathSelections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActionModeSegmentSelections", function() { return getActionModeSegmentSelections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActionModePointSelections", function() { return getActionModePointSelections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPairedSubPaths", function() { return getPairedSubPaths; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUnpairedSubPath", function() { return getUnpairedSubPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActionModeStartState", function() { return getActionModeStartState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActionModeEndState", function() { return getActionModeEndState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getToolbarState", function() { return getToolbarState; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/actionmode */ "./src/app/modules/editor/model/actionmode/index.ts");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var app_modules_editor_scripts_actionmode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/scripts/actionmode */ "./src/app/modules/editor/scripts/actionmode/index.ts");
/* harmony import */ var app_modules_editor_scripts_animator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/scripts/animator */ "./src/app/modules/editor/scripts/animator/index.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/modules/editor/store/selectors */ "./src/app/modules/editor/store/selectors.ts");
/* harmony import */ var app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/modules/editor/store/timeline/selectors */ "./src/app/modules/editor/store/timeline/selectors.ts");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! reselect */ "./node_modules/reselect/lib/index.js");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(reselect__WEBPACK_IMPORTED_MODULE_8__);









var getActionModeState = Object(reselect__WEBPACK_IMPORTED_MODULE_8__["createSelector"])(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_6__["getEditorState"], function (s) { return s.actionmode; });
var getActionMode = Object(reselect__WEBPACK_IMPORTED_MODULE_8__["createSelector"])(getActionModeState, function (s) { return s.mode; });
var isActionMode = Object(reselect__WEBPACK_IMPORTED_MODULE_8__["createSelector"])(getActionMode, function (mode) { return mode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["ActionMode"].None; });
var getActionModeHover = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_6__["createDeepEqualSelector"])(getActionModeState, function (s) { return s.hover; });
var getActionModeSelections = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_6__["createDeepEqualSelector"])(getActionModeState, function (s) { return s.selections; });
var getActionModeSubPathSelections = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_6__["createDeepEqualSelector"])(getActionModeSelections, function (selections) { return selections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["SelectionType"].SubPath; }); });
var getActionModeSegmentSelections = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_6__["createDeepEqualSelector"])(getActionModeSelections, function (selections) { return selections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["SelectionType"].Segment; }); });
var getActionModePointSelections = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_6__["createDeepEqualSelector"])(getActionModeSelections, function (selections) { return selections.filter(function (s) { return s.type === app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["SelectionType"].Point; }); });
var getPairedSubPaths = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_6__["createDeepEqualSelector"])(getActionModeState, function (state) { return state.pairedSubPaths; });
var getUnpairedSubPath = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_6__["createDeepEqualSelector"])(getActionModeState, function (state) { return state.unpairedSubPath; });
function getVectorLayerValue(getTimeFn) {
    return Object(reselect__WEBPACK_IMPORTED_MODULE_8__["createSelector"])([app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_5__["getVectorLayer"], app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_7__["getAnimation"], app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_7__["getSingleSelectedPathBlock"]], function (vl, anim, block) {
        if (!block) {
            return undefined;
        }
        // Note this is a bit dangerous because the renderer interpolates paths
        // and that causes all mutated path state to be lost if we aren't careful.
        // There are currently checks in PathProperty.ts to avoid this by returning
        // the start and end path when the interpolated fraction is 0 and 1 respectively.
        var renderer = new app_modules_editor_scripts_animator__WEBPACK_IMPORTED_MODULE_4__["AnimationRenderer"](vl, anim);
        var timeMillis = getTimeFn(block);
        // First interpolate the entire vector layer.
        var renderedVl = renderer.setCurrentTime(timeMillis);
        // TODO: this is hacky! the real solution is to not clear path state after interpolations
        // Replace the interpolated value with the block's to/from value.
        var layer = vl.findLayerById(block.layerId).clone();
        layer.pathData = timeMillis === block.startTime ? block.fromValue : block.toValue;
        return app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_2__["LayerUtil"].updateLayer(renderedVl, layer);
    });
}
var getVectorLayerFromValue = getVectorLayerValue(function (block) { return block.startTime; });
var getVectorLayerToValue = getVectorLayerValue(function (block) { return block.endTime; });
function getMorphableLayerValue(selector) {
    return Object(reselect__WEBPACK_IMPORTED_MODULE_8__["createSelector"])([selector, app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_7__["getSingleSelectedBlockLayerId"]], function (vl, blockLayerId) {
        if (!vl || !blockLayerId) {
            return undefined;
        }
        return vl.findLayerById(blockLayerId);
    });
}
var getMorphableLayerFromValue = getMorphableLayerValue(getVectorLayerFromValue);
var getMorphableLayerToValue = getMorphableLayerValue(getVectorLayerToValue);
var getPathsCompatibleResult = Object(reselect__WEBPACK_IMPORTED_MODULE_8__["createSelector"])(app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_7__["getSingleSelectedPathBlock"], function (block) { return (block ? app_modules_editor_scripts_actionmode__WEBPACK_IMPORTED_MODULE_3__["ActionModeUtil"].checkPathsCompatible(block) : undefined); });
function getHighlightedSubIdxWithError(actionSource) {
    return Object(reselect__WEBPACK_IMPORTED_MODULE_8__["createSelector"])([getActionMode, getActionModeSelections, getPathsCompatibleResult], function (mode, selections, result) {
        if (!result) {
            // Then there is no path animation block currently selected.
            return undefined;
        }
        var areCompatible = result.areCompatible, errorPath = result.errorPath, errorSubIdx = result.errorSubIdx;
        if (mode !== app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["ActionMode"].Selection || selections.length) {
            // Don't show any highlights if we're not in selection mode, or
            // if there are any existing selections.
            return undefined;
        }
        if (areCompatible || errorPath !== actionSource || errorSubIdx === undefined) {
            return undefined;
        }
        return errorSubIdx;
    });
}
var actionModeBaseSelectors = {
    blockLayerId: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_7__["getSingleSelectedBlockLayerId"],
    isActionMode: isActionMode,
    hover: getActionModeHover,
    selections: getActionModeSelections,
    pairedSubPaths: getPairedSubPaths,
    unpairedSubPath: getUnpairedSubPath,
    hiddenLayerIds: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_5__["getHiddenLayerIds"],
    selectedLayerIds: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_5__["getSelectedLayerIds"],
};
var getActionModeStartState = Object(reselect__WEBPACK_IMPORTED_MODULE_8__["createStructuredSelector"])(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, actionModeBaseSelectors, { vectorLayer: getVectorLayerFromValue, subIdxWithError: getHighlightedSubIdxWithError(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["ActionSource"].From) }));
var getActionModeEndState = Object(reselect__WEBPACK_IMPORTED_MODULE_8__["createStructuredSelector"])(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, actionModeBaseSelectors, { vectorLayer: getVectorLayerToValue, subIdxWithError: getHighlightedSubIdxWithError(app_modules_editor_model_actionmode__WEBPACK_IMPORTED_MODULE_1__["ActionSource"].To) }));
var getToolbarState = Object(reselect__WEBPACK_IMPORTED_MODULE_8__["createStructuredSelector"])({
    mode: getActionMode,
    fromMl: getMorphableLayerFromValue,
    toMl: getMorphableLayerToValue,
    selections: getActionModeSelections,
    unpairedSubPath: getUnpairedSubPath,
    block: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_7__["getSingleSelectedPathBlock"],
});


/***/ }),

/***/ "./src/app/modules/editor/store/batch/actions.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/store/batch/actions.ts ***!
  \*******************************************************/
/*! exports provided: BatchActionTypes, BatchAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BatchActionTypes", function() { return BatchActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BatchAction", function() { return BatchAction; });
var BatchActionTypes;
(function (BatchActionTypes) {
    BatchActionTypes["BatchAction"] = "__batch__BATCH";
})(BatchActionTypes || (BatchActionTypes = {}));
var BatchAction = /** @class */ (function () {
    function BatchAction() {
        var actions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            actions[_i] = arguments[_i];
        }
        this.type = BatchActionTypes.BatchAction;
        this.payload = actions;
    }
    return BatchAction;
}());



/***/ }),

/***/ "./src/app/modules/editor/store/batch/metareducer.ts":
/*!***********************************************************!*\
  !*** ./src/app/modules/editor/store/batch/metareducer.ts ***!
  \***********************************************************/
/*! exports provided: metaReducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metaReducer", function() { return metaReducer; });
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions */ "./src/app/modules/editor/store/batch/actions.ts");

function metaReducer(reducer) {
    return function (state, action) {
        var isBatchAction = action.type === _actions__WEBPACK_IMPORTED_MODULE_0__["BatchActionTypes"].BatchAction;
        return (isBatchAction ? action.payload : [action]).reduce(reducer, state);
    };
}


/***/ }),

/***/ "./src/app/modules/editor/store/common/selectors.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/store/common/selectors.ts ***!
  \**********************************************************/
/*! exports provided: getCanvasOverlayState, getPropertyInputState, getLayerListTreeState, getTimelineAnimationRowState, getLayerTimelineState, isWorkspaceDirty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCanvasOverlayState", function() { return getCanvasOverlayState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPropertyInputState", function() { return getPropertyInputState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayerListTreeState", function() { return getLayerListTreeState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTimelineAnimationRowState", function() { return getTimelineAnimationRowState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLayerTimelineState", function() { return getLayerTimelineState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWorkspaceDirty", function() { return isWorkspaceDirty; });
/* harmony import */ var app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/store/actionmode/selectors */ "./src/app/modules/editor/store/actionmode/selectors.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/store/paper/selectors */ "./src/app/modules/editor/store/paper/selectors.ts");
/* harmony import */ var app_modules_editor_store_reset_selectors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/store/reset/selectors */ "./src/app/modules/editor/store/reset/selectors.ts");
/* harmony import */ var app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/modules/editor/store/timeline/selectors */ "./src/app/modules/editor/store/timeline/selectors.ts");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! reselect */ "./node_modules/reselect/lib/index.js");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(reselect__WEBPACK_IMPORTED_MODULE_5__);






var getCanvasOverlayState = Object(reselect__WEBPACK_IMPORTED_MODULE_5__["createStructuredSelector"])({
    hiddenLayerIds: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getHiddenLayerIds"],
    selectedLayerIds: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getSelectedLayerIds"],
    selectedBlockLayerIds: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["getSelectedBlockLayerIds"],
    isActionMode: app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_0__["isActionMode"],
});
var getPropertyInputState = Object(reselect__WEBPACK_IMPORTED_MODULE_5__["createStructuredSelector"])({
    animation: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["getAnimation"],
    isAnimationSelected: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["isAnimationSelected"],
    selectedBlockIds: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["getSelectedBlockIds"],
    vectorLayer: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getVectorLayer"],
    selectedLayerIds: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getSelectedLayerIds"],
});
var getLayerListTreeState = Object(reselect__WEBPACK_IMPORTED_MODULE_5__["createStructuredSelector"])({
    animation: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["getAnimation"],
    selectedLayerIds: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getSelectedLayerIds"],
    collapsedLayerIds: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getCollapsedLayerIds"],
    hiddenLayerIds: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getHiddenLayerIds"],
    hoveredLayerId: app_modules_editor_store_paper_selectors__WEBPACK_IMPORTED_MODULE_2__["getHoveredLayerId"],
    isActionMode: app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_0__["isActionMode"],
});
var getTimelineAnimationRowState = Object(reselect__WEBPACK_IMPORTED_MODULE_5__["createStructuredSelector"])({
    animation: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["getAnimation"],
    collapsedLayerIds: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getCollapsedLayerIds"],
    selectedBlockIds: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["getSelectedBlockIds"],
    isActionMode: app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_0__["isActionMode"],
});
var getLayerTimelineState = Object(reselect__WEBPACK_IMPORTED_MODULE_5__["createStructuredSelector"])({
    animation: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["getAnimation"],
    vectorLayer: app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getVectorLayer"],
    isAnimationSelected: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["isAnimationSelected"],
    selectedBlockIds: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["getSelectedBlockIds"],
    isBeingReset: app_modules_editor_store_reset_selectors__WEBPACK_IMPORTED_MODULE_3__["isBeingReset"],
    isActionMode: app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_0__["isActionMode"],
    actionMode: app_modules_editor_store_actionmode_selectors__WEBPACK_IMPORTED_MODULE_0__["getActionMode"],
    singleSelectedPathBlock: app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["getSingleSelectedPathBlock"],
});
var isWorkspaceDirty = Object(reselect__WEBPACK_IMPORTED_MODULE_5__["createSelector"])([app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getVectorLayer"], app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_4__["getAnimation"]], function (vl, anim) { return vl.children.length > 0 || anim.blocks.length > 0; });


/***/ }),

/***/ "./src/app/modules/editor/store/index.ts":
/*!***********************************************!*\
  !*** ./src/app/modules/editor/store/index.ts ***!
  \***********************************************/
/*! exports provided: StoreModule, Store, reducers, metaReducers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ngrx_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ngrx/store */ "./node_modules/@ngrx/store/fesm5/store.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StoreModule", function() { return _ngrx_store__WEBPACK_IMPORTED_MODULE_0__["StoreModule"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Store", function() { return _ngrx_store__WEBPACK_IMPORTED_MODULE_0__["Store"]; });

/* harmony import */ var _reducer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reducer */ "./src/app/modules/editor/store/reducer.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reducers", function() { return _reducer__WEBPACK_IMPORTED_MODULE_1__["reducers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "metaReducers", function() { return _reducer__WEBPACK_IMPORTED_MODULE_1__["metaReducers"]; });





/***/ }),

/***/ "./src/app/modules/editor/store/layers/actions.ts":
/*!********************************************************!*\
  !*** ./src/app/modules/editor/store/layers/actions.ts ***!
  \********************************************************/
/*! exports provided: LayerActionTypes, SetVectorLayer, SetSelectedLayers, SetHiddenLayers, SetCollapsedLayers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerActionTypes", function() { return LayerActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetVectorLayer", function() { return SetVectorLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetSelectedLayers", function() { return SetSelectedLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetHiddenLayers", function() { return SetHiddenLayers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetCollapsedLayers", function() { return SetCollapsedLayers; });
var LayerActionTypes;
(function (LayerActionTypes) {
    LayerActionTypes["SetVectorLayer"] = "__layers__SET_VECTOR_LAYER";
    LayerActionTypes["SetSelectedLayers"] = "__layers__SET_SELECTED_LAYERS";
    LayerActionTypes["SetHiddenLayers"] = "__layers__SET_HIDDEN_LAYERS";
    LayerActionTypes["SetCollapsedLayers"] = "__layers__SET_COLLAPSED_LAYERS";
})(LayerActionTypes || (LayerActionTypes = {}));
var SetVectorLayer = /** @class */ (function () {
    function SetVectorLayer(vectorLayer) {
        this.type = LayerActionTypes.SetVectorLayer;
        this.payload = { vectorLayer: vectorLayer };
    }
    return SetVectorLayer;
}());

var SetSelectedLayers = /** @class */ (function () {
    function SetSelectedLayers(layerIds) {
        this.type = LayerActionTypes.SetSelectedLayers;
        this.payload = { layerIds: layerIds };
    }
    return SetSelectedLayers;
}());

var SetHiddenLayers = /** @class */ (function () {
    function SetHiddenLayers(layerIds) {
        this.type = LayerActionTypes.SetHiddenLayers;
        this.payload = { layerIds: layerIds };
    }
    return SetHiddenLayers;
}());

var SetCollapsedLayers = /** @class */ (function () {
    function SetCollapsedLayers(layerIds) {
        this.type = LayerActionTypes.SetCollapsedLayers;
        this.payload = { layerIds: layerIds };
    }
    return SetCollapsedLayers;
}());



/***/ }),

/***/ "./src/app/modules/editor/store/layers/reducer.ts":
/*!********************************************************!*\
  !*** ./src/app/modules/editor/store/layers/reducer.ts ***!
  \********************************************************/
/*! exports provided: buildInitialState, reducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildInitialState", function() { return buildInitialState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reducer", function() { return reducer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/layers */ "./src/app/modules/editor/model/layers/index.ts");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions */ "./src/app/modules/editor/store/layers/actions.ts");



function buildInitialState() {
    return {
        vectorLayer: new app_modules_editor_model_layers__WEBPACK_IMPORTED_MODULE_1__["VectorLayer"](),
        selectedLayerIds: new Set(),
        collapsedLayerIds: new Set(),
        hiddenLayerIds: new Set(),
    };
}
function reducer(state, action) {
    if (state === void 0) { state = buildInitialState(); }
    switch (action.type) {
        case _actions__WEBPACK_IMPORTED_MODULE_2__["LayerActionTypes"].SetVectorLayer:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { vectorLayer: action.payload.vectorLayer });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["LayerActionTypes"].SetSelectedLayers:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { selectedLayerIds: new Set(action.payload.layerIds) });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["LayerActionTypes"].SetHiddenLayers:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { hiddenLayerIds: new Set(action.payload.layerIds) });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["LayerActionTypes"].SetCollapsedLayers:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { collapsedLayerIds: new Set(action.payload.layerIds) });
    }
    return state;
}


/***/ }),

/***/ "./src/app/modules/editor/store/layers/selectors.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/store/layers/selectors.ts ***!
  \**********************************************************/
/*! exports provided: getVectorLayer, getSelectedLayerIds, getCollapsedLayerIds, getHiddenLayerIds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVectorLayer", function() { return getVectorLayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedLayerIds", function() { return getSelectedLayerIds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCollapsedLayerIds", function() { return getCollapsedLayerIds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHiddenLayerIds", function() { return getHiddenLayerIds; });
/* harmony import */ var app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/store/selectors */ "./src/app/modules/editor/store/selectors.ts");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ "./node_modules/reselect/lib/index.js");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(reselect__WEBPACK_IMPORTED_MODULE_1__);


var getLayerState = Object(reselect__WEBPACK_IMPORTED_MODULE_1__["createSelector"])(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_0__["getEditorState"], function (s) { return s.layers; });
var getVectorLayer = Object(reselect__WEBPACK_IMPORTED_MODULE_1__["createSelector"])(getLayerState, function (l) { return l.vectorLayer; });
var getSelectedLayerIds = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_0__["createDeepEqualSelector"])(getLayerState, function (l) { return l.selectedLayerIds; });
var getCollapsedLayerIds = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_0__["createDeepEqualSelector"])(getLayerState, function (l) { return l.collapsedLayerIds; });
var getHiddenLayerIds = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_0__["createDeepEqualSelector"])(getLayerState, function (l) { return l.hiddenLayerIds; });


/***/ }),

/***/ "./src/app/modules/editor/store/paper/actions.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/store/paper/actions.ts ***!
  \*******************************************************/
/*! exports provided: PaperActionTypes, SetToolMode, SetSelectionBox, SetCreatePathInfo, SetSplitCurveInfo, SetEditPathInfo, SetRotateItemsInfo, SetTransformPathsInfo, SetCursorType, SetSnapGuideInfo, SetZoomPanInfo, SetTooltipInfo, SetHoveredLayerId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PaperActionTypes", function() { return PaperActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetToolMode", function() { return SetToolMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetSelectionBox", function() { return SetSelectionBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetCreatePathInfo", function() { return SetCreatePathInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetSplitCurveInfo", function() { return SetSplitCurveInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetEditPathInfo", function() { return SetEditPathInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetRotateItemsInfo", function() { return SetRotateItemsInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetTransformPathsInfo", function() { return SetTransformPathsInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetCursorType", function() { return SetCursorType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetSnapGuideInfo", function() { return SetSnapGuideInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetZoomPanInfo", function() { return SetZoomPanInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetTooltipInfo", function() { return SetTooltipInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetHoveredLayerId", function() { return SetHoveredLayerId; });
var PaperActionTypes;
(function (PaperActionTypes) {
    PaperActionTypes["SetToolMode"] = "__paper__SET_TOOL_MODE";
    PaperActionTypes["SetSelectionBox"] = "__paper__SET_SELECTION_BOX";
    PaperActionTypes["SetCreatePathInfo"] = "__paper__SET_CREATE_PATH_INFO";
    PaperActionTypes["SetSplitCurveInfo"] = "__paper__SET_SPLIT_CURVE_INFO";
    PaperActionTypes["SetEditPathInfo"] = "__paper__SET_EDIT_PATH_INFO";
    PaperActionTypes["SetRotateItemsInfo"] = "__paper__SET_ROTATE_ITEMS_INFO";
    PaperActionTypes["SetTransformPathInfo"] = "__paper__SET_TRANSFORM_PATHS_INFO";
    PaperActionTypes["SetCursorType"] = "__paper__SET_CANVAS_CURSOR";
    PaperActionTypes["SetSnapGuideInfo"] = "__paper__SET_SNAP_GUIDE_INFO";
    PaperActionTypes["SetZoomPanInfo"] = "__paper__SET_ZOOM_PAN_INFO";
    PaperActionTypes["SetTooltipInfo"] = "__paper__SET_TOOLTIP_INFO";
    PaperActionTypes["SetHoveredLayerId"] = "__paper__SET_HOVERED_LAYER_ID";
})(PaperActionTypes || (PaperActionTypes = {}));
var SetToolMode = /** @class */ (function () {
    function SetToolMode(toolMode) {
        this.toolMode = toolMode;
        this.type = PaperActionTypes.SetToolMode;
    }
    return SetToolMode;
}());

var SetSelectionBox = /** @class */ (function () {
    function SetSelectionBox(selectionBox) {
        this.selectionBox = selectionBox;
        this.type = PaperActionTypes.SetSelectionBox;
    }
    return SetSelectionBox;
}());

var SetCreatePathInfo = /** @class */ (function () {
    function SetCreatePathInfo(createPathInfo) {
        this.createPathInfo = createPathInfo;
        this.type = PaperActionTypes.SetCreatePathInfo;
    }
    return SetCreatePathInfo;
}());

var SetSplitCurveInfo = /** @class */ (function () {
    function SetSplitCurveInfo(splitCurveInfo) {
        this.splitCurveInfo = splitCurveInfo;
        this.type = PaperActionTypes.SetSplitCurveInfo;
    }
    return SetSplitCurveInfo;
}());

var SetEditPathInfo = /** @class */ (function () {
    function SetEditPathInfo(editPathInfo) {
        this.editPathInfo = editPathInfo;
        this.type = PaperActionTypes.SetEditPathInfo;
    }
    return SetEditPathInfo;
}());

var SetRotateItemsInfo = /** @class */ (function () {
    function SetRotateItemsInfo(rotateItemsInfo) {
        this.rotateItemsInfo = rotateItemsInfo;
        this.type = PaperActionTypes.SetRotateItemsInfo;
    }
    return SetRotateItemsInfo;
}());

var SetTransformPathsInfo = /** @class */ (function () {
    function SetTransformPathsInfo(transformPathsInfo) {
        this.transformPathsInfo = transformPathsInfo;
        this.type = PaperActionTypes.SetTransformPathInfo;
    }
    return SetTransformPathsInfo;
}());

var SetCursorType = /** @class */ (function () {
    function SetCursorType(cursorType) {
        this.cursorType = cursorType;
        this.type = PaperActionTypes.SetCursorType;
    }
    return SetCursorType;
}());

var SetSnapGuideInfo = /** @class */ (function () {
    function SetSnapGuideInfo(snapGuideInfo) {
        this.snapGuideInfo = snapGuideInfo;
        this.type = PaperActionTypes.SetSnapGuideInfo;
    }
    return SetSnapGuideInfo;
}());

var SetZoomPanInfo = /** @class */ (function () {
    function SetZoomPanInfo(zoomPanInfo) {
        this.zoomPanInfo = zoomPanInfo;
        this.type = PaperActionTypes.SetZoomPanInfo;
    }
    return SetZoomPanInfo;
}());

var SetTooltipInfo = /** @class */ (function () {
    function SetTooltipInfo(tooltipInfo) {
        this.tooltipInfo = tooltipInfo;
        this.type = PaperActionTypes.SetTooltipInfo;
    }
    return SetTooltipInfo;
}());

var SetHoveredLayerId = /** @class */ (function () {
    function SetHoveredLayerId(hoveredLayerId) {
        this.hoveredLayerId = hoveredLayerId;
        this.type = PaperActionTypes.SetHoveredLayerId;
    }
    return SetHoveredLayerId;
}());



/***/ }),

/***/ "./src/app/modules/editor/store/paper/reducer.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/store/paper/reducer.ts ***!
  \*******************************************************/
/*! exports provided: buildInitialState, reducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildInitialState", function() { return buildInitialState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reducer", function() { return reducer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions */ "./src/app/modules/editor/store/paper/actions.ts");



function buildInitialState() {
    return {
        zoomPanInfo: { zoom: 1, translation: { tx: 0, ty: 0 } },
        toolModeInfo: { toolMode: app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["ToolMode"].Default },
        cursorType: app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_1__["CursorType"].Default,
    };
}
function reducer(state, action) {
    if (state === void 0) { state = buildInitialState(); }
    var toolModeInfo = state.toolModeInfo;
    switch (action.type) {
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetZoomPanInfo:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { zoomPanInfo: action.zoomPanInfo });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetToolMode:
            // TODO: don't wipe out all of the other tool mode info here...
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { toolModeInfo: { toolMode: action.toolMode } });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetSelectionBox:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { toolModeInfo: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, toolModeInfo, { selectionBox: action.selectionBox }) });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetCreatePathInfo:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { toolModeInfo: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, toolModeInfo, { createPathInfo: action.createPathInfo }) });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetSplitCurveInfo:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { toolModeInfo: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, toolModeInfo, { splitCurveInfo: action.splitCurveInfo }) });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetEditPathInfo:
            var editPathInfo = action.editPathInfo;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { toolModeInfo: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, toolModeInfo, { editPathInfo: editPathInfo }) });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetRotateItemsInfo:
            var rotateItemsInfo = action.rotateItemsInfo;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { toolModeInfo: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, toolModeInfo, { rotateItemsInfo: rotateItemsInfo }) });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetTransformPathInfo:
            var transformPathsInfo = action.transformPathsInfo;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { toolModeInfo: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, toolModeInfo, { transformPathsInfo: transformPathsInfo }) });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetSnapGuideInfo:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { toolModeInfo: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, toolModeInfo, { snapGuideInfo: action.snapGuideInfo }) });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetTooltipInfo:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { toolModeInfo: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, toolModeInfo, { tooltipInfo: action.tooltipInfo }) });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetCursorType:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { cursorType: action.cursorType });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["PaperActionTypes"].SetHoveredLayerId:
            var hoveredLayerId = action.hoveredLayerId;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { toolModeInfo: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, toolModeInfo, { hoveredLayerId: hoveredLayerId }) });
    }
    return state;
}


/***/ }),

/***/ "./src/app/modules/editor/store/paper/selectors.ts":
/*!*********************************************************!*\
  !*** ./src/app/modules/editor/store/paper/selectors.ts ***!
  \*********************************************************/
/*! exports provided: getZoomPanInfo, getToolMode, getSelectionBox, getCreatePathInfo, getSplitCurveInfo, getEditPathInfo, getRotateItemsInfo, getTransformPathsInfo, getSnapGuideInfo, getTooltipInfo, getCursorType, getHoveredLayerId, getToolPanelState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getZoomPanInfo", function() { return getZoomPanInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getToolMode", function() { return getToolMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectionBox", function() { return getSelectionBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCreatePathInfo", function() { return getCreatePathInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSplitCurveInfo", function() { return getSplitCurveInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEditPathInfo", function() { return getEditPathInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotateItemsInfo", function() { return getRotateItemsInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransformPathsInfo", function() { return getTransformPathsInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSnapGuideInfo", function() { return getSnapGuideInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTooltipInfo", function() { return getTooltipInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCursorType", function() { return getCursorType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHoveredLayerId", function() { return getHoveredLayerId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getToolPanelState", function() { return getToolPanelState; });
/* harmony import */ var app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/paper */ "./src/app/modules/editor/model/paper/index.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/store/selectors */ "./src/app/modules/editor/store/selectors.ts");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reselect */ "./node_modules/reselect/lib/index.js");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(reselect__WEBPACK_IMPORTED_MODULE_3__);




var getPaperState = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["getEditorState"], function (s) { return s.paper; });
var getZoomPanInfo = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getPaperState, function (p) { return p.zoomPanInfo; });
var getToolModeInfo = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(getPaperState, function (p) { return p.toolModeInfo; });
var getToolMode = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getToolModeInfo, function (p) { return p.toolMode; });
var getSelectionBox = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getToolModeInfo, function (p) { return p.selectionBox; });
var getCreatePathInfo = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getToolModeInfo, function (p) { return p.createPathInfo; });
var getSplitCurveInfo = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getToolModeInfo, function (p) { return p.splitCurveInfo; });
var getEditPathInfo = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getToolModeInfo, function (p) { return p.editPathInfo; });
var getRotateItemsInfo = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getToolModeInfo, function (p) { return p.rotateItemsInfo; });
var getTransformPathsInfo = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getToolModeInfo, function (p) { return p.transformPathsInfo; });
var getSnapGuideInfo = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getToolModeInfo, function (p) { return p.snapGuideInfo; });
var getTooltipInfo = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getToolModeInfo, function (p) { return p.tooltipInfo; });
var getCursorType = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getPaperState, function (p) { return p.cursorType; });
var getHoveredLayerId = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["createDeepEqualSelector"])(getToolModeInfo, function (p) { return p.hoveredLayerId; });
var getSingleSelectedChildlessLayer = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])([app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getVectorLayer"], app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getSelectedLayerIds"]], function (vl, layerIds) {
    if (layerIds.size !== 1) {
        return undefined;
    }
    var layerId = layerIds.values().next().value;
    var layer = vl.findLayerById(layerId);
    // TODO: consolidate this logic in a single place (the layer.children.length check is used in gestures too)
    return layer.children.length ? undefined : layer;
});
var isEditPathChecked = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(getEditPathInfo, function (epi) { return !!epi; });
// TODO: exclude empty groups for rotate items?
var isRotateItemsEnabled = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getSelectedLayerIds"], function (layerIds) { return layerIds.size > 0; });
var isRotateItemsChecked = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(getRotateItemsInfo, function (rii) { return !!rii; });
var isTransformPathsEnabled = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(getSingleSelectedChildlessLayer, function (layer) { return !!layer; });
var isTransformPathsChecked = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(getTransformPathsInfo, function (tpi) { return !!tpi; });
var isDefaultChecked = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])([getToolMode, isEditPathChecked, isRotateItemsChecked, isTransformPathsChecked], function (toolMode, editPathChecked, rotateItemsChecked, transformPathChecked) {
    return (toolMode === app_modules_editor_model_paper__WEBPACK_IMPORTED_MODULE_0__["ToolMode"].Default &&
        !editPathChecked &&
        !rotateItemsChecked &&
        !transformPathChecked);
});
var getToolPanelState = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createStructuredSelector"])({
    toolMode: getToolMode,
    isDefaultChecked: isDefaultChecked,
    isEditPathChecked: isEditPathChecked,
    isRotateItemsEnabled: isRotateItemsEnabled,
    isRotateItemsChecked: isRotateItemsChecked,
    isTransformPathsEnabled: isTransformPathsEnabled,
    isTransformPathsChecked: isTransformPathsChecked,
});


/***/ }),

/***/ "./src/app/modules/editor/store/playback/actions.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/store/playback/actions.ts ***!
  \**********************************************************/
/*! exports provided: PlaybackActionTypes, SetIsSlowMotion, SetIsPlaying, SetIsRepeating, SetCurrentTime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaybackActionTypes", function() { return PlaybackActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetIsSlowMotion", function() { return SetIsSlowMotion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetIsPlaying", function() { return SetIsPlaying; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetIsRepeating", function() { return SetIsRepeating; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetCurrentTime", function() { return SetCurrentTime; });
var PlaybackActionTypes;
(function (PlaybackActionTypes) {
    PlaybackActionTypes["SetIsSlowMotion"] = "__playback__SET_IS_SLOW_MOTION";
    PlaybackActionTypes["SetIsPlaying"] = "__playback__SET_IS_PLAYING";
    PlaybackActionTypes["SetIsRepeating"] = "__playback__SET_IS_REPEATING";
    PlaybackActionTypes["SetCurrentTime"] = "__playback__SET_CURRENT_TIME";
})(PlaybackActionTypes || (PlaybackActionTypes = {}));
var SetIsSlowMotion = /** @class */ (function () {
    function SetIsSlowMotion(isSlowMotion) {
        this.type = PlaybackActionTypes.SetIsSlowMotion;
        this.payload = { isSlowMotion: isSlowMotion };
    }
    return SetIsSlowMotion;
}());

var SetIsPlaying = /** @class */ (function () {
    function SetIsPlaying(isPlaying) {
        this.type = PlaybackActionTypes.SetIsPlaying;
        this.payload = { isPlaying: isPlaying };
    }
    return SetIsPlaying;
}());

var SetIsRepeating = /** @class */ (function () {
    function SetIsRepeating(isRepeating) {
        this.type = PlaybackActionTypes.SetIsRepeating;
        this.payload = { isRepeating: isRepeating };
    }
    return SetIsRepeating;
}());

var SetCurrentTime = /** @class */ (function () {
    function SetCurrentTime(currentTime) {
        this.type = PlaybackActionTypes.SetCurrentTime;
        this.payload = { currentTime: currentTime };
    }
    return SetCurrentTime;
}());



/***/ }),

/***/ "./src/app/modules/editor/store/playback/reducer.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/store/playback/reducer.ts ***!
  \**********************************************************/
/*! exports provided: buildInitialState, reducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildInitialState", function() { return buildInitialState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reducer", function() { return reducer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actions */ "./src/app/modules/editor/store/playback/actions.ts");


function buildInitialState() {
    return {
        isSlowMotion: false,
        isPlaying: false,
        isRepeating: false,
        currentTime: 0,
    };
}
function reducer(state, action) {
    if (state === void 0) { state = buildInitialState(); }
    switch (action.type) {
        case _actions__WEBPACK_IMPORTED_MODULE_1__["PlaybackActionTypes"].SetIsSlowMotion:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { isSlowMotion: action.payload.isSlowMotion });
        case _actions__WEBPACK_IMPORTED_MODULE_1__["PlaybackActionTypes"].SetIsPlaying:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { isPlaying: action.payload.isPlaying });
        case _actions__WEBPACK_IMPORTED_MODULE_1__["PlaybackActionTypes"].SetIsRepeating:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { isRepeating: action.payload.isRepeating });
        case _actions__WEBPACK_IMPORTED_MODULE_1__["PlaybackActionTypes"].SetCurrentTime:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { currentTime: action.payload.currentTime });
    }
    return state;
}


/***/ }),

/***/ "./src/app/modules/editor/store/playback/selectors.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/store/playback/selectors.ts ***!
  \************************************************************/
/*! exports provided: getPlaybackState, getIsSlowMotion, getIsPlaying, getIsRepeating, getCurrentTime, getAnimatedVectorLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlaybackState", function() { return getPlaybackState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIsSlowMotion", function() { return getIsSlowMotion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIsPlaying", function() { return getIsPlaying; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIsRepeating", function() { return getIsRepeating; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentTime", function() { return getCurrentTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAnimatedVectorLayer", function() { return getAnimatedVectorLayer; });
/* harmony import */ var app_modules_editor_scripts_animator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/scripts/animator */ "./src/app/modules/editor/scripts/animator/index.ts");
/* harmony import */ var app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/store/layers/selectors */ "./src/app/modules/editor/store/layers/selectors.ts");
/* harmony import */ var app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/store/selectors */ "./src/app/modules/editor/store/selectors.ts");
/* harmony import */ var app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/store/timeline/selectors */ "./src/app/modules/editor/store/timeline/selectors.ts");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reselect */ "./node_modules/reselect/lib/index.js");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(reselect__WEBPACK_IMPORTED_MODULE_4__);





var getPlaybackState = Object(reselect__WEBPACK_IMPORTED_MODULE_4__["createSelector"])(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_2__["getEditorState"], function (s) { return s.playback; });
var getIsSlowMotion = Object(reselect__WEBPACK_IMPORTED_MODULE_4__["createSelector"])(getPlaybackState, function (p) { return p.isSlowMotion; });
var getIsPlaying = Object(reselect__WEBPACK_IMPORTED_MODULE_4__["createSelector"])(getPlaybackState, function (p) { return p.isPlaying; });
var getIsRepeating = Object(reselect__WEBPACK_IMPORTED_MODULE_4__["createSelector"])(getPlaybackState, function (p) { return p.isRepeating; });
var getCurrentTime = Object(reselect__WEBPACK_IMPORTED_MODULE_4__["createSelector"])(getPlaybackState, function (p) { return p.currentTime; });
var getAnimationRenderer = Object(reselect__WEBPACK_IMPORTED_MODULE_4__["createSelector"])([app_modules_editor_store_layers_selectors__WEBPACK_IMPORTED_MODULE_1__["getVectorLayer"], app_modules_editor_store_timeline_selectors__WEBPACK_IMPORTED_MODULE_3__["getAnimation"]], function (vl, anim) { return new app_modules_editor_scripts_animator__WEBPACK_IMPORTED_MODULE_0__["AnimationRenderer"](vl, anim); });
var getAnimatedVectorLayer = Object(reselect__WEBPACK_IMPORTED_MODULE_4__["createSelector"])([getAnimationRenderer, getCurrentTime], function (animationRenderer, currentTime) {
    var vl = animationRenderer.setCurrentTime(currentTime);
    return { vl: vl, currentTime: currentTime };
});


/***/ }),

/***/ "./src/app/modules/editor/store/reducer.ts":
/*!*************************************************!*\
  !*** ./src/app/modules/editor/store/reducer.ts ***!
  \*************************************************/
/*! exports provided: reducers, metaReducers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reducers", function() { return reducers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metaReducers", function() { return metaReducers; });
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");
/* harmony import */ var ngrx_store_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ngrx-store-logger */ "./node_modules/ngrx-store-logger/dist/index.js");
/* harmony import */ var ngrx_store_logger__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ngrx_store_logger__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _actionmode_reducer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actionmode/reducer */ "./src/app/modules/editor/store/actionmode/reducer.ts");
/* harmony import */ var _batch_metareducer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./batch/metareducer */ "./src/app/modules/editor/store/batch/metareducer.ts");
/* harmony import */ var _layers_reducer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./layers/reducer */ "./src/app/modules/editor/store/layers/reducer.ts");
/* harmony import */ var _paper_reducer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./paper/reducer */ "./src/app/modules/editor/store/paper/reducer.ts");
/* harmony import */ var _playback_reducer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./playback/reducer */ "./src/app/modules/editor/store/playback/reducer.ts");
/* harmony import */ var _reset_metareducer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./reset/metareducer */ "./src/app/modules/editor/store/reset/metareducer.ts");
/* harmony import */ var _reset_reducer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./reset/reducer */ "./src/app/modules/editor/store/reset/reducer.ts");
/* harmony import */ var _storefreeze_metareducer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./storefreeze/metareducer */ "./src/app/modules/editor/store/storefreeze/metareducer.ts");
/* harmony import */ var _theme_reducer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./theme/reducer */ "./src/app/modules/editor/store/theme/reducer.ts");
/* harmony import */ var _timeline_reducer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./timeline/reducer */ "./src/app/modules/editor/store/timeline/reducer.ts");
/* harmony import */ var _undoredo_metareducer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./undoredo/metareducer */ "./src/app/modules/editor/store/undoredo/metareducer.ts");













var reducers = {
    layers: _layers_reducer__WEBPACK_IMPORTED_MODULE_4__["reducer"],
    timeline: _timeline_reducer__WEBPACK_IMPORTED_MODULE_11__["reducer"],
    playback: _playback_reducer__WEBPACK_IMPORTED_MODULE_6__["reducer"],
    actionmode: _actionmode_reducer__WEBPACK_IMPORTED_MODULE_2__["reducer"],
    reset: _reset_reducer__WEBPACK_IMPORTED_MODULE_8__["reducer"],
    theme: _theme_reducer__WEBPACK_IMPORTED_MODULE_10__["reducer"],
    paper: _paper_reducer__WEBPACK_IMPORTED_MODULE_5__["reducer"],
};
var prodMetaReducers = [
    // Meta-reducer that records past/present/future state.
    _undoredo_metareducer__WEBPACK_IMPORTED_MODULE_12__["metaReducer"],
    // Meta-reducer that adds the ability to dispatch multiple actions at a time.
    _batch_metareducer__WEBPACK_IMPORTED_MODULE_3__["metaReducer"],
    // Meta-reducer that adds the ability to reset the entire state tree.
    _reset_metareducer__WEBPACK_IMPORTED_MODULE_7__["metaReducer"],
];
var devMetaReducers = [
    // Meta reducer that logs the before/after state of the store
    // as actions are performed in dev builds.
    Object(ngrx_store_logger__WEBPACK_IMPORTED_MODULE_1__["storeLogger"])({ collapsed: true }),
    // Meta reducer that freezes the state tree to ensure that
    // accidental mutations fail fast in dev builds.
    _storefreeze_metareducer__WEBPACK_IMPORTED_MODULE_9__["metaReducer"],
];
var metaReducers = environments_environment__WEBPACK_IMPORTED_MODULE_0__["environment"].production
    ? prodMetaReducers
    : devMetaReducers.concat(prodMetaReducers);


/***/ }),

/***/ "./src/app/modules/editor/store/reset/actions.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/store/reset/actions.ts ***!
  \*******************************************************/
/*! exports provided: ResetActionTypes, ResetWorkspace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResetActionTypes", function() { return ResetActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResetWorkspace", function() { return ResetWorkspace; });
var ResetActionTypes;
(function (ResetActionTypes) {
    ResetActionTypes["ResetWorkspace"] = "__reset__RESET_WORKSPACE";
})(ResetActionTypes || (ResetActionTypes = {}));
var ResetWorkspace = /** @class */ (function () {
    function ResetWorkspace(vectorLayer, animation, hiddenLayerIds) {
        this.type = ResetActionTypes.ResetWorkspace;
        this.payload = { vectorLayer: vectorLayer, animation: animation, hiddenLayerIds: hiddenLayerIds };
    }
    return ResetWorkspace;
}());



/***/ }),

/***/ "./src/app/modules/editor/store/reset/metareducer.ts":
/*!***********************************************************!*\
  !*** ./src/app/modules/editor/store/reset/metareducer.ts ***!
  \***********************************************************/
/*! exports provided: metaReducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metaReducer", function() { return metaReducer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actions */ "./src/app/modules/editor/store/reset/actions.ts");


function metaReducer(reducer) {
    return function (state, action) {
        if (action.type === _actions__WEBPACK_IMPORTED_MODULE_1__["ResetActionTypes"].ResetWorkspace) {
            state = undefined;
        }
        state = reducer(state, action);
        if (action.type === _actions__WEBPACK_IMPORTED_MODULE_1__["ResetActionTypes"].ResetWorkspace) {
            var _a = action.payload, vectorLayer = _a.vectorLayer, animation = _a.animation, hiddenLayerIds = _a.hiddenLayerIds;
            if (vectorLayer) {
                var layers = state.layers;
                state = tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { layers: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, layers, { vectorLayer: vectorLayer,
                        hiddenLayerIds: hiddenLayerIds }) });
            }
            if (animation) {
                var timeline = state.timeline;
                state = tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { timeline: tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, timeline, { animation: animation }) });
            }
        }
        return state;
    };
}


/***/ }),

/***/ "./src/app/modules/editor/store/reset/reducer.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/store/reset/reducer.ts ***!
  \*******************************************************/
/*! exports provided: buildInitialState, reducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildInitialState", function() { return buildInitialState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reducer", function() { return reducer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actions */ "./src/app/modules/editor/store/reset/actions.ts");


function buildInitialState() {
    return {
        isBeingReset: false,
    };
}
function reducer(state, action) {
    if (state === void 0) { state = buildInitialState(); }
    if (action.type === _actions__WEBPACK_IMPORTED_MODULE_1__["ResetActionTypes"].ResetWorkspace) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { isBeingReset: true });
    }
    var isBeingReset = state.isBeingReset;
    if (isBeingReset) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { isBeingReset: false });
    }
    return state;
}


/***/ }),

/***/ "./src/app/modules/editor/store/reset/selectors.ts":
/*!*********************************************************!*\
  !*** ./src/app/modules/editor/store/reset/selectors.ts ***!
  \*********************************************************/
/*! exports provided: isBeingReset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBeingReset", function() { return isBeingReset; });
/* harmony import */ var app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/store/selectors */ "./src/app/modules/editor/store/selectors.ts");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ "./node_modules/reselect/lib/index.js");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(reselect__WEBPACK_IMPORTED_MODULE_1__);


var getResetState = Object(reselect__WEBPACK_IMPORTED_MODULE_1__["createSelector"])(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_0__["getEditorState"], function (s) { return s.reset; });
var isBeingReset = Object(reselect__WEBPACK_IMPORTED_MODULE_1__["createSelector"])(getResetState, function (r) { return r.isBeingReset; });


/***/ }),

/***/ "./src/app/modules/editor/store/selectors.ts":
/*!***************************************************!*\
  !*** ./src/app/modules/editor/store/selectors.ts ***!
  \***************************************************/
/*! exports provided: getEditorState, createDeepEqualSelector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEditorState", function() { return getEditorState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDeepEqualSelector", function() { return createDeepEqualSelector; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ "./node_modules/reselect/lib/index.js");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(reselect__WEBPACK_IMPORTED_MODULE_1__);


var getState = function (state) { return state; };
var getEditorState = Object(reselect__WEBPACK_IMPORTED_MODULE_1__["createSelector"])(getState, function (s) { return s.present; });
var createDeepEqualSelector = Object(reselect__WEBPACK_IMPORTED_MODULE_1__["createSelectorCreator"])(reselect__WEBPACK_IMPORTED_MODULE_1__["defaultMemoize"], lodash__WEBPACK_IMPORTED_MODULE_0__["isEqual"]);


/***/ }),

/***/ "./src/app/modules/editor/store/storefreeze/metareducer.ts":
/*!*****************************************************************!*\
  !*** ./src/app/modules/editor/store/storefreeze/metareducer.ts ***!
  \*****************************************************************/
/*! exports provided: metaReducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metaReducer", function() { return metaReducer; });
/* harmony import */ var deep_freeze_strict__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deep-freeze-strict */ "./node_modules/deep-freeze-strict/index.js");
/* harmony import */ var deep_freeze_strict__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deep_freeze_strict__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Meta reducer that prevents state from being mutated anywhere in the app.
 */
function metaReducer(reducer) {
    return function (state, action) {
        if (state) {
            deep_freeze_strict__WEBPACK_IMPORTED_MODULE_0__(state);
        }
        var nextState = reducer(state, action);
        if (nextState) {
            deep_freeze_strict__WEBPACK_IMPORTED_MODULE_0__(nextState);
        }
        return nextState;
    };
}


/***/ }),

/***/ "./src/app/modules/editor/store/theme/actions.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/store/theme/actions.ts ***!
  \*******************************************************/
/*! exports provided: ThemeActionTypes, SetTheme */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThemeActionTypes", function() { return ThemeActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetTheme", function() { return SetTheme; });
var ThemeActionTypes;
(function (ThemeActionTypes) {
    ThemeActionTypes["SetTheme"] = "__theme__SET_THEME";
})(ThemeActionTypes || (ThemeActionTypes = {}));
var SetTheme = /** @class */ (function () {
    function SetTheme(themeType) {
        this.type = ThemeActionTypes.SetTheme;
        this.payload = { themeType: themeType };
    }
    return SetTheme;
}());



/***/ }),

/***/ "./src/app/modules/editor/store/theme/reducer.ts":
/*!*******************************************************!*\
  !*** ./src/app/modules/editor/store/theme/reducer.ts ***!
  \*******************************************************/
/*! exports provided: buildInitialState, reducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildInitialState", function() { return buildInitialState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reducer", function() { return reducer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actions */ "./src/app/modules/editor/store/theme/actions.ts");


var STORAGE_KEY_THEME_TYPE = 'storage_key_theme_type';
function buildInitialState() {
    return {
        themeType: window.localStorage.getItem(STORAGE_KEY_THEME_TYPE) || 'light',
        isInitialPageLoad: true,
    };
}
function reducer(state, action) {
    if (state === void 0) { state = buildInitialState(); }
    if (action.type === _actions__WEBPACK_IMPORTED_MODULE_1__["ThemeActionTypes"].SetTheme) {
        var themeType = action.payload.themeType;
        window.localStorage.setItem(STORAGE_KEY_THEME_TYPE, themeType);
        if (themeType === state.themeType) {
            return state;
        }
        return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { themeType: themeType, isInitialPageLoad: false });
    }
    return state;
}


/***/ }),

/***/ "./src/app/modules/editor/store/theme/selectors.ts":
/*!*********************************************************!*\
  !*** ./src/app/modules/editor/store/theme/selectors.ts ***!
  \*********************************************************/
/*! exports provided: getThemeType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getThemeType", function() { return getThemeType; });
/* harmony import */ var app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/store/selectors */ "./src/app/modules/editor/store/selectors.ts");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ "./node_modules/reselect/lib/index.js");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(reselect__WEBPACK_IMPORTED_MODULE_1__);


var getThemeState = Object(reselect__WEBPACK_IMPORTED_MODULE_1__["createSelector"])(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_0__["getEditorState"], function (s) { return s.theme; });
var getThemeType = Object(reselect__WEBPACK_IMPORTED_MODULE_1__["createStructuredSelector"])({
    themeType: Object(reselect__WEBPACK_IMPORTED_MODULE_1__["createSelector"])(getThemeState, function (t) { return t.themeType; }),
    isInitialPageLoad: Object(reselect__WEBPACK_IMPORTED_MODULE_1__["createSelector"])(getThemeState, function (t) { return t.isInitialPageLoad; }),
});


/***/ }),

/***/ "./src/app/modules/editor/store/timeline/actions.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/store/timeline/actions.ts ***!
  \**********************************************************/
/*! exports provided: TimelineActionTypes, SetAnimation, SelectAnimation, SetSelectedBlocks */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineActionTypes", function() { return TimelineActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetAnimation", function() { return SetAnimation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectAnimation", function() { return SelectAnimation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetSelectedBlocks", function() { return SetSelectedBlocks; });
var TimelineActionTypes;
(function (TimelineActionTypes) {
    TimelineActionTypes["SetAnimation"] = "__timeline__SET_ANIMATION";
    TimelineActionTypes["SelectAnimation"] = "__timeline__SELECT_ANIMATION";
    TimelineActionTypes["SetSelectedBlocks"] = "__timeline__SET_SELECTED_BLOCKS";
})(TimelineActionTypes || (TimelineActionTypes = {}));
var SetAnimation = /** @class */ (function () {
    function SetAnimation(animation) {
        this.type = TimelineActionTypes.SetAnimation;
        this.payload = { animation: animation };
    }
    return SetAnimation;
}());

var SelectAnimation = /** @class */ (function () {
    function SelectAnimation(isAnimationSelected) {
        this.type = TimelineActionTypes.SelectAnimation;
        this.payload = { isAnimationSelected: isAnimationSelected };
    }
    return SelectAnimation;
}());

var SetSelectedBlocks = /** @class */ (function () {
    function SetSelectedBlocks(blockIds) {
        this.type = TimelineActionTypes.SetSelectedBlocks;
        this.payload = { blockIds: blockIds };
    }
    return SetSelectedBlocks;
}());



/***/ }),

/***/ "./src/app/modules/editor/store/timeline/reducer.ts":
/*!**********************************************************!*\
  !*** ./src/app/modules/editor/store/timeline/reducer.ts ***!
  \**********************************************************/
/*! exports provided: buildInitialState, reducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildInitialState", function() { return buildInitialState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reducer", function() { return reducer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/model/timeline */ "./src/app/modules/editor/model/timeline/index.ts");
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions */ "./src/app/modules/editor/store/timeline/actions.ts");



function buildInitialState() {
    return {
        animation: new app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_1__["Animation"](),
        isAnimationSelected: false,
        selectedBlockIds: new Set(),
    };
}
function reducer(state, action) {
    if (state === void 0) { state = buildInitialState(); }
    switch (action.type) {
        case _actions__WEBPACK_IMPORTED_MODULE_2__["TimelineActionTypes"].SetAnimation:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { animation: action.payload.animation });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["TimelineActionTypes"].SelectAnimation:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { isAnimationSelected: action.payload.isAnimationSelected });
        case _actions__WEBPACK_IMPORTED_MODULE_2__["TimelineActionTypes"].SetSelectedBlocks:
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, state, { selectedBlockIds: new Set(action.payload.blockIds) });
    }
    return state;
}


/***/ }),

/***/ "./src/app/modules/editor/store/timeline/selectors.ts":
/*!************************************************************!*\
  !*** ./src/app/modules/editor/store/timeline/selectors.ts ***!
  \************************************************************/
/*! exports provided: getAnimation, isAnimationSelected, getSelectedBlockIds, getSingleSelectedBlockId, getSingleSelectedPathBlock, getSelectedBlockLayerIds, getSingleSelectedBlockLayerId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAnimation", function() { return getAnimation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAnimationSelected", function() { return isAnimationSelected; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedBlockIds", function() { return getSelectedBlockIds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSingleSelectedBlockId", function() { return getSingleSelectedBlockId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSingleSelectedPathBlock", function() { return getSingleSelectedPathBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedBlockLayerIds", function() { return getSelectedBlockLayerIds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSingleSelectedBlockLayerId", function() { return getSingleSelectedBlockLayerId; });
/* harmony import */ var app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/modules/editor/model/timeline */ "./src/app/modules/editor/model/timeline/index.ts");
/* harmony import */ var app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/store/selectors */ "./src/app/modules/editor/store/selectors.ts");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reselect */ "./node_modules/reselect/lib/index.js");
/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(reselect__WEBPACK_IMPORTED_MODULE_3__);




var getTimelineState = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_1__["getEditorState"], function (s) { return s.timeline; });
var getAnimation = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(getTimelineState, function (t) { return t.animation; });
var isAnimationSelected = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(getTimelineState, function (t) { return t.isAnimationSelected; });
var getSelectedBlockIds = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_1__["createDeepEqualSelector"])(getTimelineState, function (t) { return t.selectedBlockIds; });
var getSingleSelectedBlockId = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(getSelectedBlockIds, function (blockIds) { return (blockIds.size === 1 ? blockIds.values().next().value : undefined); });
var getSingleSelectedPathBlock = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])([getAnimation, getSingleSelectedBlockId], function (anim, blockId) {
    if (!blockId) {
        return undefined;
    }
    return lodash__WEBPACK_IMPORTED_MODULE_2__["find"](anim.blocks, function (b) { return b.id === blockId && b instanceof app_modules_editor_model_timeline__WEBPACK_IMPORTED_MODULE_0__["PathAnimationBlock"]; });
});
var getSelectedBlockLayerIds = Object(app_modules_editor_store_selectors__WEBPACK_IMPORTED_MODULE_1__["createDeepEqualSelector"])([getAnimation, getSelectedBlockIds], function (anim, blockIds) {
    return new Set(Array.from(blockIds).map(function (id) { return lodash__WEBPACK_IMPORTED_MODULE_2__["find"](anim.blocks, function (b) { return b.id === id; }).layerId; }));
});
var getSingleSelectedBlockLayerId = Object(reselect__WEBPACK_IMPORTED_MODULE_3__["createSelector"])(getSelectedBlockLayerIds, function (blockLayerIds) { return (blockLayerIds.size === 1 ? blockLayerIds.values().next().value : undefined); });


/***/ }),

/***/ "./src/app/modules/editor/store/undoredo/metareducer.ts":
/*!**************************************************************!*\
  !*** ./src/app/modules/editor/store/undoredo/metareducer.ts ***!
  \**************************************************************/
/*! exports provided: metaReducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metaReducer", function() { return metaReducer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/modules/editor/store/actionmode/actions */ "./src/app/modules/editor/store/actionmode/actions.ts");
/* harmony import */ var app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/modules/editor/store/playback/actions */ "./src/app/modules/editor/store/playback/actions.ts");
/* harmony import */ var redux_undo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-undo */ "./node_modules/redux-undo/lib/index.js");
/* harmony import */ var redux_undo__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(redux_undo__WEBPACK_IMPORTED_MODULE_3__);




var UNDO_HISTORY_SIZE = 30;
var UNDO_DEBOUNCE_MILLIS = 1000;
var UNDO_EXCLUDED_ACTIONS = [
    app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_2__["PlaybackActionTypes"].SetIsSlowMotion,
    app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_2__["PlaybackActionTypes"].SetIsPlaying,
    app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_2__["PlaybackActionTypes"].SetIsRepeating,
    app_modules_editor_store_playback_actions__WEBPACK_IMPORTED_MODULE_2__["PlaybackActionTypes"].SetCurrentTime,
    app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_1__["ActionModeActionTypes"].SetActionMode,
    app_modules_editor_store_actionmode_actions__WEBPACK_IMPORTED_MODULE_1__["ActionModeActionTypes"].SetActionModeHover,
];
var groupCounter = 1;
function metaReducer(reducer) {
    var undoableReducer = redux_undo__WEBPACK_IMPORTED_MODULE_3___default()(reducer, {
        limit: UNDO_HISTORY_SIZE,
        filter: Object(redux_undo__WEBPACK_IMPORTED_MODULE_3__["excludeAction"])(UNDO_EXCLUDED_ACTIONS),
        groupBy: function (action, currState, prevState) {
            if (Date.now() - prevState.timestamp < UNDO_DEBOUNCE_MILLIS) {
                return groupCounter;
            }
            groupCounter++;
            return undefined;
        },
    });
    return function (state, action) {
        return tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, undoableReducer(state, action), { timestamp: Date.now() });
    };
}


/***/ }),

/***/ "./src/environments/environment.ts":
/*!*****************************************!*\
  !*** ./src/environments/environment.ts ***!
  \*****************************************/
/*! exports provided: environment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return environment; });
var environment = {
    production: false,
    beta: true,
    analyticsTrackingId: 'UA-92075411-2',
};


/***/ }),

/***/ "./src/environments/version.ts":
/*!*************************************!*\
  !*** ./src/environments/version.ts ***!
  \*************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./environment */ "./src/environments/environment.ts");

var version = __webpack_require__(/*! ../../package.json */ "./package.json").version + "-" + (_environment__WEBPACK_IMPORTED_MODULE_0__["environment"].beta ? 'beta' : 'stable');


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hammerjs */ "./node_modules/hammerjs/hammer.js");
/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_platform_browser_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/platform-browser-dynamic */ "./node_modules/@angular/platform-browser-dynamic/fesm5/platform-browser-dynamic.js");
/* harmony import */ var app_modules_editor_editor_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/modules/editor/editor.module */ "./src/app/modules/editor/editor.module.ts");
/* harmony import */ var environments_environment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! environments/environment */ "./src/environments/environment.ts");





var script = document.createElement('script');
script.innerHTML = "\n(function (i, s, o, g, r, a, m) {\n  i['GoogleAnalyticsObject'] = r;\n  i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments) }, i[r].l = 1 * new Date();\n  a = s.createElement(o), m = s.getElementsByTagName(o)[0];\n  a.async = 1;\n  a.src = g;\n  m.parentNode.insertBefore(a, m)\n})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');\nga('create', '" + environments_environment__WEBPACK_IMPORTED_MODULE_4__["environment"].analyticsTrackingId + "', 'auto');\nga('send', 'pageview');\n";
document.head.appendChild(script);
if (environments_environment__WEBPACK_IMPORTED_MODULE_4__["environment"].production) {
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["enableProdMode"])();
}
Object(_angular_platform_browser_dynamic__WEBPACK_IMPORTED_MODULE_2__["platformBrowserDynamic"])().bootstrapModule(app_modules_editor_editor_module__WEBPACK_IMPORTED_MODULE_3__["EditorModule"]);


/***/ }),

/***/ 0:
/*!***************************!*\
  !*** multi ./src/main.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/ubuntu/ShapeShifter/src/main.ts */"./src/main.ts");


/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!********************************!*\
  !*** ./node/self.js (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 4:
/*!**********************************!*\
  !*** ./node/extend.js (ignored) ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

},[[0,"runtime","vendor"]]]);
//# sourceMappingURL=main.js.map